{"pr_number": 4867, "pr_title": "Issue 4677: Offset/Version Table Entry Iteration", "pr_createdAt": "2020-06-11T18:24:03Z", "pr_url": "https://github.com/pravega/pravega/pull/4867", "timeline": [{"oid": "08601afd11463bf700a6d0af3f33dcb53f935e09", "url": "https://github.com/pravega/pravega/commit/08601afd11463bf700a6d0af3f33dcb53f935e09", "message": "Update K8 client APIs to use their 5.0.0 counterparts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-02-21T00:13:24Z", "type": "commit"}, {"oid": "25a165d0293c34ee8703fff764e55cf8fda413dd", "url": "https://github.com/pravega/pravega/commit/25a165d0293c34ee8703fff764e55cf8fda413dd", "message": "Merge pull request #1 from co-jo/issue-4464-update-kubernetes-client-version\n\nIssue 4464 update kubernetes client version", "committedDate": "2020-02-21T18:42:03Z", "type": "commit"}, {"oid": "8cc2dd2be26feed2953258ff055c1657aeb57019", "url": "https://github.com/pravega/pravega/commit/8cc2dd2be26feed2953258ff055c1657aeb57019", "message": "Run system tests using alternative flag value.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-02-23T04:43:09Z", "type": "commit"}, {"oid": "c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "url": "https://github.com/pravega/pravega/commit/c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-03-10T22:21:32Z", "type": "commit"}, {"oid": "f5f808cc42831892aeb8e7824c22d499a1f9fa03", "url": "https://github.com/pravega/pravega/commit/f5f808cc42831892aeb8e7824c22d499a1f9fa03", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-03-18T18:44:10Z", "type": "commit"}, {"oid": "7901435dc1127bed1c46845bbaf8024477e2078f", "url": "https://github.com/pravega/pravega/commit/7901435dc1127bed1c46845bbaf8024477e2078f", "message": "Merge branch 'master' of https://github.com/pravega/pravega\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-04-02T18:49:59Z", "type": "commit"}, {"oid": "d59b3e33f6d5bd90264753caadcea7ed7bbfe06c", "url": "https://github.com/pravega/pravega/commit/d59b3e33f6d5bd90264753caadcea7ed7bbfe06c", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-04-16T20:22:05Z", "type": "commit"}, {"oid": "aa090cad1d88812f2a88e9debacdb04df585adbf", "url": "https://github.com/pravega/pravega/commit/aa090cad1d88812f2a88e9debacdb04df585adbf", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-04-18T20:15:50Z", "type": "commit"}, {"oid": "e328bcb38239fdc32f866980ee1103c93dff522d", "url": "https://github.com/pravega/pravega/commit/e328bcb38239fdc32f866980ee1103c93dff522d", "message": "Merge branch 'master' of https://github.com/co-jo/pravega", "committedDate": "2020-05-11T22:25:21Z", "type": "commit"}, {"oid": "cd02180986f49a42002c7fd2ef28885d1f701af9", "url": "https://github.com/pravega/pravega/commit/cd02180986f49a42002c7fd2ef28885d1f701af9", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-05-11T22:25:27Z", "type": "commit"}, {"oid": "df6ddaa58fded6128bad5fc35ddcd1ec817a29d5", "url": "https://github.com/pravega/pravega/commit/df6ddaa58fded6128bad5fc35ddcd1ec817a29d5", "message": "Initial API proposal on offset based TableSegment reads.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-05-12T18:17:19Z", "type": "commit"}, {"oid": "1e4e548363b9d4b5fd627e402fdef73d32a6693e", "url": "https://github.com/pravega/pravega/commit/1e4e548363b9d4b5fd627e402fdef73d32a6693e", "message": "Fix misordered writes.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-05-12T20:54:44Z", "type": "commit"}, {"oid": "f5f07d793d7b2c9ed6986cdcdd8260553f335d02", "url": "https://github.com/pravega/pravega/commit/f5f07d793d7b2c9ed6986cdcdd8260553f335d02", "message": "Add basic unit tests for new WireCommands.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-05-12T21:33:15Z", "type": "commit"}, {"oid": "672a07692f3a654dd6d4615c914df412ccbe2d38", "url": "https://github.com/pravega/pravega/commit/672a07692f3a654dd6d4615c914df412ccbe2d38", "message": "Add checks if a tableSegmentOffset was provided.\nCreates a constant value signifying no offset was provided.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-05-14T19:34:49Z", "type": "commit"}, {"oid": "85d2ba3d13d42ef345f72ee84d169b87f3d9b8b0", "url": "https://github.com/pravega/pravega/commit/85d2ba3d13d42ef345f72ee84d169b87f3d9b8b0", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-05-18T14:31:13Z", "type": "commit"}, {"oid": "ac2a2d330241f403ff5961115779847f580a9f29", "url": "https://github.com/pravega/pravega/commit/ac2a2d330241f403ff5961115779847f580a9f29", "message": "Add meaningful default value to the UpdateTableEntries calls in PravegaRequestProcessorTest.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-05-18T19:30:16Z", "type": "commit"}, {"oid": "3f52d0b1fc19a195c692889f3b1542176a082e0e", "url": "https://github.com/pravega/pravega/commit/3f52d0b1fc19a195c692889f3b1542176a082e0e", "message": "Merge branch 'issue-4677-offset-table-reads' of https://github.com/co-jo/pravega into issue-4677-offset-table-reads", "committedDate": "2020-05-18T20:42:17Z", "type": "commit"}, {"oid": "1408d7527ec73f1645418df04aea4aa1120b39e7", "url": "https://github.com/pravega/pravega/commit/1408d7527ec73f1645418df04aea4aa1120b39e7", "message": "Merge branch 'master' of https://github.com/co-jo/pravega", "committedDate": "2020-05-18T20:48:16Z", "type": "commit"}, {"oid": "e2719517850f39bce3e5f2c92f04c8c24122a520", "url": "https://github.com/pravega/pravega/commit/e2719517850f39bce3e5f2c92f04c8c24122a520", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-05-20T18:59:36Z", "type": "commit"}, {"oid": "92dbe1a241144b155a2885f4ea30a7b52aa46ed7", "url": "https://github.com/pravega/pravega/commit/92dbe1a241144b155a2885f4ea30a7b52aa46ed7", "message": "* Implement offset/version based TableEntry iteration.\n* Add new API to appropriate classes implementing TableStore and Request/ReplyProcessor interfaces.\n* New Iterator/IteratorState classes to support non-bucket based iteration of TableSegments.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-10T02:19:30Z", "type": "commit"}, {"oid": "ad83fc68fe8f2cc64b5a3ce5008f002183b80197", "url": "https://github.com/pravega/pravega/commit/ad83fc68fe8f2cc64b5a3ce5008f002183b80197", "message": "* Update files with missing copyright statements.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-10T04:20:14Z", "type": "commit"}, {"oid": "7cbca9e3c1f51e158ac7d04bd4b2e244be2fcca7", "url": "https://github.com/pravega/pravega/commit/7cbca9e3c1f51e158ac7d04bd4b2e244be2fcca7", "message": "* Make overloaded 'newIterator' methods adjacent.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-10T07:35:38Z", "type": "commit"}, {"oid": "d8adc68accb9ac6b12895478033734bfe3cd01fe", "url": "https://github.com/pravega/pravega/commit/d8adc68accb9ac6b12895478033734bfe3cd01fe", "message": "* Adhere to proper checkstyle guidelines.c\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-10T18:42:23Z", "type": "commit"}, {"oid": "d722048e0449da0ba24822ef5cb0f47da146ef1a", "url": "https://github.com/pravega/pravega/commit/d722048e0449da0ba24822ef5cb0f47da146ef1a", "message": "* Update API parameter name.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-11T18:33:23Z", "type": "commit"}, {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "url": "https://github.com/pravega/pravega/commit/686552bf45b447f07c9670d16d7c2ec2f044dd77", "message": "* Fix checkstyle issues.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-11T19:58:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NDc5Mw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439464793", "bodyText": "Iterator -> {@link AsyncIterator}", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:48:04Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NTkzMA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439465930", "bodyText": "I know we discussed this offline, but let's be consistent now. In the description you said \"offset\", but here you say fromPosition and then \"offset/version\".\nLet's keep everything as \"position\", at least in the contracts and associated Javadoc.", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:49:56Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjI5Mw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439466293", "bodyText": "Is this what this method is returning?", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:50:26Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.\n+     * @param fetchTimeout      Timeout for each invocation to {@link AsyncIterator#getNext()}.\n+     * @return A CompletableFuture that, when completed, will return a {@link List} of {@link TableEntry}, occuring after", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2OTA5NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439469094", "bodyText": "Just a heads up that we'll need to rework this after #4842 is merged in. It improved a number of things, mostly around in how this class reads data from the Table Segment.\n(No need to worry or do anything right now, just be a on the lookout on when that PR is merged in as your subsequent merge from master will need to resolve a number of conflicts.)", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:54:17Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -838,6 +840,77 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                   }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        final AtomicInteger msgSize = new AtomicInteger(0);\n+        final Map<ArrayView, TableEntry> entries = new HashMap<>();\n+        final AtomicReference<EntryIteratorState> lastState = new AtomicReference<>();\n+        val timer = new Timer();\n+        tableStore.entryIterator(segment, fromPosition, TIMEOUT)", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2OTI3Nw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439469277", "bodyText": "Nice one.", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:54:37Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/DirectSegmentAccess.java", "diffHunk": "@@ -22,7 +22,7 @@\n /**\n  * Defines an API that can be used to get direct access to a Segment. This can be used instead of the SegmentContainer API\n  * for short periods of time if a rapid sequence of operations is desired (since it caches the locations of the Segment and\n- * it does not need to all the usual SegmentContainer and StreamSegment lookups on every invocation).\n+ * it does not need to call the usual SegmentContainer and StreamSegment lookups on every invocation).", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MDY2Ng==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439470666", "bodyText": "I would really name this something different since it has different semantics than entryIterator. entryIterator will iterate through all the entries that are still present in the index, while this method will give you the latest state from a given offset, which may include deletions.\nConsider naming this entryDeltaIterator  (or deltaEntryIterator) - the term \"delta\" is key here.", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:56:51Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.\n+     * @param fetchTimeout      Timeout for each invocation to {@link AsyncIterator#getNext()}.\n+     * @return A CompletableFuture that, when completed, will return a {@link List} of {@link TableEntry}, occuring after\n+     * the given . If the operation failed, the Future will be failed with the\n+     * causing exception. Notable exceptions:\n+     * <ul>\n+     * <li>{@link StreamSegmentNotExistsException} If the Table Segment does not exist.\n+     * <li>{@link BadSegmentTypeException} If segmentName refers to a non-Table Segment.\n+     * </ul>\n+     * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n+     */\n+    CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, long fromPosition, Duration fetchTimeout);", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MDk3OA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439470978", "bodyText": "Same here about \"delta\".", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:57:22Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -315,9 +322,40 @@ protected int getMaxCompactionSize() {\n         return segment.append(new ByteArraySegment(s), null, timeout);\n     }\n \n-    private <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, byte[] serializedState,\n-                                                                              @NonNull Duration fetchTimeout,\n-                                                                              @NonNull GetBucketReader<T> createBucketReader) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, long fromPosition, @NonNull Duration fetchTimeout) {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MTE0MQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439471141", "bodyText": "I can't tell from the diff. Why is this needed?", "author": "andreipaduroiu", "createdAt": "2020-06-12T14:57:37Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -315,9 +322,40 @@ protected int getMaxCompactionSize() {\n         return segment.append(new ByteArraySegment(s), null, timeout);\n     }\n \n-    private <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, byte[] serializedState,\n-                                                                              @NonNull Duration fetchTimeout,\n-                                                                              @NonNull GetBucketReader<T> createBucketReader) {\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYxMDMwNw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439610307", "bodyText": "The cast in the lambda expression on line 342.", "author": "co-jo", "createdAt": "2020-06-12T19:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MTE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MzAwNQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439473005", "bodyText": "Is there really no way to unify this with IteratorItemImpl?", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:00:49Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -466,6 +504,29 @@ public String toString() {\n         }\n     }\n \n+    // endregion\n+\n+    // region EntryIteratorItemImpl\n+\n+    @RequiredArgsConstructor\n+    private class EntryIteratorItemImpl<T> implements IteratorItem<T> {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3Mzg2Ng==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439473866", "bodyText": "Tip: If all you need toString for is for debugging (watching), consider using Lombok's @ToString annotation which will auto-generate this for you (you can even pick the fields you want to include).", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:02:15Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NDQ1NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439474454", "bodyText": "You don't need to specify these fields in here. The @Builder annotation will take care of this for you. The only reason we need to declare this class is because we want it to implement ObjectBuilder<>.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:03:15Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Position = %s Reached End = %s Should Clear = %s\", this.position, this.reachedEnd, this.shouldClear);\n+    }\n+\n+    //region Serialization\n+\n+    /**\n+     * Creates a new instance of the IteratorState class from the given array.\n+     *\n+     * @param data A byte array containing the serialization of an IteratorState. This must have been generated using\n+     *             {@link #serialize()}.\n+     * @return As new instance of the IteratorState class.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public static EntryIteratorState deserialize(byte[] data) {\n+        return SERIALIZER.deserialize(data);\n+    }\n+\n+    /**\n+     * Serializes this IteratorState instance into an {@link ArrayView}.\n+     *\n+     * @return The {@link ArrayView} that was used for serialization.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public ArrayView serialize() {\n+        return SERIALIZER.serialize(this);\n+    }\n+\n+    private static class IteratorStateBuilder implements ObjectBuilder<EntryIteratorState> {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NTY4NQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439475685", "bodyText": "Just a heads up that CompactLong can only serialize up to 2^62 (and no negatives). This sounds OK for now, since we do not expect negative offsets and 2^62 is still a huge number.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:05:21Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Position = %s Reached End = %s Should Clear = %s\", this.position, this.reachedEnd, this.shouldClear);\n+    }\n+\n+    //region Serialization\n+\n+    /**\n+     * Creates a new instance of the IteratorState class from the given array.\n+     *\n+     * @param data A byte array containing the serialization of an IteratorState. This must have been generated using\n+     *             {@link #serialize()}.\n+     * @return As new instance of the IteratorState class.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public static EntryIteratorState deserialize(byte[] data) {\n+        return SERIALIZER.deserialize(data);\n+    }\n+\n+    /**\n+     * Serializes this IteratorState instance into an {@link ArrayView}.\n+     *\n+     * @return The {@link ArrayView} that was used for serialization.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public ArrayView serialize() {\n+        return SERIALIZER.serialize(this);\n+    }\n+\n+    private static class IteratorStateBuilder implements ObjectBuilder<EntryIteratorState> {\n+        private long position;\n+        private boolean reachedEnd;\n+        private boolean shouldClear;\n+        private boolean deletionRecord;\n+\n+        @Override\n+        public EntryIteratorState build() {\n+            return new EntryIteratorState(position, reachedEnd, shouldClear, deletionRecord);\n+        }\n+    }\n+\n+    private static class Serializer extends VersionedSerializer.WithBuilder<EntryIteratorState, IteratorStateBuilder> {\n+        @Override\n+        protected IteratorStateBuilder newBuilder() {\n+            return new IteratorStateBuilder();\n+        }\n+\n+        @Override\n+        protected byte getWriteVersion() {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void declareVersions() {\n+            version(0).revision(0, this::write00, this::read00);\n+        }\n+\n+        private void read00(RevisionDataInput revisionDataInput, IteratorStateBuilder builder) throws IOException {\n+            builder.position = revisionDataInput.readCompactLong();", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NjAwNw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439476007", "bodyText": "TableEntryDeltaIterator", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:05:56Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NzQxMA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439477410", "bodyText": "Nit: either use this. for all private fields or for none. Try to be consistent.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:08:26Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3Nzc4Mg==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439477782", "bodyText": "this.currentBatchOffset is Guarded By this but you don't use a synchronized block here.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NzQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODI3NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439478274", "bodyText": "Tip: use val to avoid having to write long type names (i.e val next = this.currentEntry.next())", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:09:57Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3OTYxMQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439479611", "bodyText": "Tip: if you declare a variable that you do not expect (or want) to change throughout your method, add the final modifier or declare it with val (which makes it final). This way the compiler will catch any attempt you make to modify it, which can, in turn, prevent bugs from developing.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:12:19Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<EntryIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<EntryIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long maxOffset = startOffset + readLength;", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MTI3MQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439481271", "bodyText": "You don't need to declare this class. Adding @Builder will do it for you.\nThe reason I did it \"manually\" in TableIterator was because build() had to do a significant amount of custom work, so the @Builder annotation wouldn't have helped.\nIn your case, however, this is plain boilerplate code so that annotation will save you from having to do that.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:15:15Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<EntryIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<EntryIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long maxOffset = startOffset + readLength;\n+        long currentOffset = startOffset;\n+\n+        InputStream input = data.getReader();\n+        List<Map.Entry<EntryIteratorState, TableEntry>> entries = new ArrayList<>();\n+        try {\n+            while (currentOffset < maxOffset) {\n+                val entry = AsyncTableEntryReader.readEntryComponents(input, currentOffset, this.entrySerializer);\n+                boolean reachedEnd = currentOffset + entry.getHeader().getTotalLength() >= maxLength + startOffset;\n+                // We must preserve deletions to accurately construct a delta.\n+                byte[] value = entry.getValue() == null ? new byte[0] : entry.getValue();\n+                entries.add(new AbstractMap.SimpleEntry<>(\n+                        new EntryIteratorState(currentOffset, reachedEnd, shouldClear, entry.getHeader().isDeletion()),\n+                        TableEntry.versioned(new ByteArraySegment(entry.getKey()), new ByteArraySegment(value), entry.getVersion())));\n+                currentOffset += entry.getHeader().getTotalLength();\n+            }\n+\n+        } catch (EOFException ex) {\n+            input.close();\n+        }\n+        this.currentBatchOffset = currentOffset;\n+\n+        return entries;\n+    }\n+\n+    /**\n+     * Creates a new {@link TableIterator} that contains no elements.\n+     *\n+     * @param <T> Type of elements returned at each iteration.\n+     * @return A new instance of the {@link TableIterator.Builder} class.\n+     */\n+    static <T> TableEntryIterator<T> empty() {\n+        return new TableEntryIterator<>(\n+                null,\n+                0L,\n+                0,\n+                false,\n+                Duration.ofMillis(0),\n+                new EntrySerializer(),\n+                ignored -> CompletableFuture.completedFuture(null),\n+                ForkJoinPool.commonPool());\n+    }\n+\n+    //endregion\n+\n+    //region Builder\n+\n+    /**\n+     * Creates a new {@link TableIterator.Builder} that can be used to construct {@link TableIterator} instances.\n+     *\n+     * @param <T> Type of the elements returned at each iteration.\n+     * @return A new instance of the {@link TableIterator.Builder} class.\n+     */\n+    static <T> Builder<T> builder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Builder for the {@link TableIterator} class.\n+     */\n+    static class Builder<T> {\n+\n+        private int maxLength = MAX_READ_SIZE;", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MjM3MA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439482370", "bodyText": "Please add a quick Javadoc on this class explaining its purpose. I know it's in the test package, but since you took it out of the class it was originally in, we need to explain what it should be used for.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:17:13Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/TableContext.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.containers.StreamSegmentMetadata;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import lombok.val;\n+\n+public class TableContext implements AutoCloseable {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MjgxNQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439482815", "bodyText": "Is there a reason why this mock class got taken out of the TableContext class?", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:18:02Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerMock.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.util.concurrent.Service;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.MergeStreamSegmentResult;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import org.junit.Assert;\n+\n+public class ContainerMock implements SegmentContainer {", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODg3NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439698874", "bodyText": "It doesn't add much value with respect to this PR, however I thought it could sufficiently stand alone and might come in handy for some other work down the line. Will revert it.", "author": "co-jo", "createdAt": "2020-06-13T01:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MjgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MzQyNQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439483425", "bodyText": "I think you can remove this TODO now.", "author": "andreipaduroiu", "createdAt": "2020-06-12T15:19:10Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2182,6 +2190,79 @@ public boolean isFailure() {\n         }\n     }\n \n+    @Data\n+    public static final class ReadTableEntriesDelta implements Request, WireCommand {\n+        final WireCommandType type = WireCommandType.READ_TABLE_ENTRIES_DELTA;\n+        final long requestId;\n+        final String segment;\n+        @ToString.Exclude\n+        final String delegationToken;\n+        final long fromPosition;\n+        final int suggestedEntryCount;\n+\n+        @Override\n+        public void process(RequestProcessor cp) {\n+            cp.readTableEntriesDelta(this);\n+        }\n+\n+        @Override\n+        public void writeFields(DataOutput out) throws IOException {\n+            out.writeLong(requestId);\n+            out.writeUTF(segment);\n+            out.writeUTF(delegationToken == null ? \"\" : delegationToken);\n+            out.writeLong(fromPosition);\n+            out.writeInt(suggestedEntryCount);\n+        }\n+\n+        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+            long requestId = in.readLong();\n+            String segment = in.readUTF();\n+            String delegationToken = in.readUTF();\n+            long fromPosition = in.readLong();\n+            int suggestedEntryCount = in.readInt();\n+\n+            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromPosition, suggestedEntryCount);\n+        }\n+    }\n+\n+    @Data\n+    public static final class TableEntriesDeltaRead implements Reply, WireCommand {\n+        final WireCommandType type = WireCommandType.TABLE_ENTRIES_DELTA_READ;\n+        final long requestId;\n+        final String segment;\n+        final TableEntries tableEntries;\n+        final boolean shouldClear;\n+        final boolean reachedEnd;\n+        final long lastPosition;\n+\n+        // TODO: Will be implemented as apart of: https://github.com/pravega/pravega/issues/4677", "originalCommit": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63586e44866c0b7c2a2e6604418b2c2110894a48", "url": "https://github.com/pravega/pravega/commit/63586e44866c0b7c2a2e6604418b2c2110894a48", "message": "* Initial test for the PravegaRequestProcessor.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-12T18:29:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDU4NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439580584", "bodyText": "Note: processor.readTableEntriesDelta does not wait to the call to finish. This test is copied verbatim from testGetTableEntires, with the exception of readTableEntriesDelta being called instead of readTableEntries.", "author": "co-jo", "createdAt": "2020-06-12T18:30:48Z", "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java", "diffHunk": "@@ -985,6 +986,115 @@ public void testGetTableEntries() throws Exception {\n         assertTrue(keyVersions.containsAll(getTableEntriesIteratorsResp.getEntries().getEntries().stream().map(e -> e.getKey().getKeyVersion()).collect(Collectors.toList())));\n     }\n \n+    @Test\n+    public void testReadTableEntriesDelta() throws Exception {\n+        // Set up PravegaRequestProcessor instance to execute requests against\n+        val rnd = new Random(0);\n+        String tableSegmentName = \"testReadTableEntriesDelta\";\n+\n+        @Cleanup\n+        ServiceBuilder serviceBuilder = newInlineExecutionInMemoryBuilder(getBuilderConfig());\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();\n+        TableStore tableStore = serviceBuilder.createTableStoreService();\n+        ServerConnection connection = mock(ServerConnection.class);\n+        InOrder order = inOrder(connection);\n+        val recorderMock = mock(TableSegmentStatsRecorder.class);\n+        PravegaRequestProcessor processor = new PravegaRequestProcessor(store, tableStore, connection, SegmentStatsRecorder.noOp(),\n+                recorderMock, new PassingTokenVerifier(), false);\n+\n+        // Generate keys.\n+        ArrayList<HashedArray> keys = generateKeys(3, rnd);\n+        HashedArray testValue = generateValue(rnd);\n+        TableEntry e1 = TableEntry.unversioned(keys.get(0), testValue);\n+        TableEntry e2 = TableEntry.unversioned(keys.get(1), testValue);\n+        TableEntry e3 = TableEntry.unversioned(keys.get(2), testValue);\n+\n+        // Create a table segment and add data.\n+        processor.createTableSegment(new WireCommands.CreateTableSegment(1, tableSegmentName, \"\"));\n+        order.verify(connection).send(new WireCommands.SegmentCreated(1, tableSegmentName));\n+        verify(recorderMock).createTableSegment(eq(tableSegmentName), any());\n+        processor.updateTableEntries(new WireCommands.UpdateTableEntries(2, tableSegmentName, \"\",\n+                getTableEntries(asList(e1, e2, e3)), WireCommands.NULL_TABLE_SEGMENT_OFFSET));\n+        verify(recorderMock).updateEntries(eq(tableSegmentName), eq(3), eq(false), any());\n+\n+        // 1. Now read the table entries where suggestedEntryCount is equal to number of entries in the Table Store.\n+        processor.readTableEntriesDelta(new WireCommands.ReadTableEntriesDelta(3, tableSegmentName, \"\", 0, 3));\n+        // Does not work without some delay.\n+        TimeUnit.SECONDS.sleep(1);", "originalCommit": "63586e44866c0b7c2a2e6604418b2c2110894a48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0MzQ1OA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r440243458", "bodyText": "This is a classic example of some async operation that hasn't completed yet. Most likely even your 1s delay may not help in some cases if wherever you are running this is too slow.\nWhat happens here is that somewhere inside the execution of readTableEntriesDelta we execute some async operation without waiting for it to finish. However since that's how PravegaRequestProcessor works internally, there is little we can do there to help us in this case. To solve this problem we've created this InlineExecutor which is a single-thread executor that executes every task \"inline\" (i.e., awaits its completion before moving on). This is why all the other tests in this class work consistently well.\nThis means that somewhere in your code (test code or not), you are not using this executor or are doing some other \"funny business\" (pretty vague term, but it's mostly a \"catch-all\" scenario). Let's focus on the first case instead (not using InlineExecutor).\nIf we look at the CompletableFuture doc (and implementation) we learn the following things:\n\nAny continuation callback method (thenXYZ) that does not have the Async suffix will be executed on the same thread where the previous task completed (and implicitly on the same thread pool).\nAny continuation callback method that has the Async method will execute as follows :\n\nIf you pass an Executor as the last argument to that method, the callback code will be transferred to that Executor.\nIf you do not pass an Executor, then the ForkJoinPool.commonPool() will be used instead.\n\n\n\nIn case 1.2. above, if you have such a callback, your execution will jump out of InlineExecutor to a regular thread pool, thus the runtime will not await its execution to complete so this test will likely not work.\nI did a quick check on the code path that this is executing (and compared it to the regular iterator) and found that you do not pass this.executor to this method: https://github.com/pravega/pravega/pull/4867/files#diff-3dfd10edcdb2751b3655ff97953c1612R330\nThere may be others downstream, but I'm willing to bet this is the cause of your issues.", "author": "andreipaduroiu", "createdAt": "2020-06-15T15:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDU4NA=="}], "type": "inlineReview"}, {"oid": "24159ad4fcf95473821f9c657c643ab323e27122", "url": "https://github.com/pravega/pravega/commit/24159ad4fcf95473821f9c657c643ab323e27122", "message": "* Addresses most feedback from draft PR.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-13T02:34:10Z", "type": "commit"}, {"oid": "4d2ef90af7c18f98e9d183bc9d8c352463b361bd", "url": "https://github.com/pravega/pravega/commit/4d2ef90af7c18f98e9d183bc9d8c352463b361bd", "message": "* Refactor 'ContainerMock' back into 'TableContext'.\n* Fix @Builder annotation on TableEntryDeltaIterator.\n* Address other feedback.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-15T03:19:58Z", "type": "commit"}, {"oid": "6e75c0a03dbeb6c27857257da292f1ab09d5c94c", "url": "https://github.com/pravega/pravega/commit/6e75c0a03dbeb6c27857257da292f1ab09d5c94c", "message": "* Properly pass down the ExecutorService (this fixes our testing issue in PravegaRequestProcessorTest).\n* Change the position field of the DeltaIteratorState class.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-15T18:13:46Z", "type": "commit"}, {"oid": "b1d3648dd2c28a161dab520a48bf4bf657f9d14d", "url": "https://github.com/pravega/pravega/commit/b1d3648dd2c28a161dab520a48bf4bf657f9d14d", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-06-15T18:43:02Z", "type": "commit"}, {"oid": "78ff6324b40431e17d655d738a4174b2b634ecba", "url": "https://github.com/pravega/pravega/commit/78ff6324b40431e17d655d738a4174b2b634ecba", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-06-17T18:04:56Z", "type": "commit"}, {"oid": "d68b68b60ad46a154cfa9e8b07c5160494ef9216", "url": "https://github.com/pravega/pravega/commit/d68b68b60ad46a154cfa9e8b07c5160494ef9216", "message": "Merge branch 'master' into issue-4677-offset-table-reads\n\n# Conflicts:\n#\tsegmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\n#\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java\n#\tshared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "committedDate": "2020-06-17T18:13:06Z", "type": "commit"}, {"oid": "1baa07c38f3f293e786ecc3689700ffa1241473e", "url": "https://github.com/pravega/pravega/commit/1baa07c38f3f293e786ecc3689700ffa1241473e", "message": "* Fix error in testing code.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-17T20:21:31Z", "type": "commit"}, {"oid": "16d3331ab414a75619214f3ad9c6402f1998385d", "url": "https://github.com/pravega/pravega/commit/16d3331ab414a75619214f3ad9c6402f1998385d", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-06-22T19:03:02Z", "type": "commit"}, {"oid": "d18e63f214a2ed82b45ab637ac276e42e4d91dac", "url": "https://github.com/pravega/pravega/commit/d18e63f214a2ed82b45ab637ac276e42e4d91dac", "message": "* Merge with master.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-23T21:15:18Z", "type": "commit"}, {"oid": "fb74ccf264c78ba725759061acf9d4395f56cca6", "url": "https://github.com/pravega/pravega/commit/fb74ccf264c78ba725759061acf9d4395f56cca6", "message": "Merge missed file.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-23T21:23:40Z", "type": "commit"}, {"oid": "4e43a8e00d250a3ca3464f6a66836f0a55ccda43", "url": "https://github.com/pravega/pravega/commit/4e43a8e00d250a3ca3464f6a66836f0a55ccda43", "message": "* Use proper key.\n* Fix deletion condition.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-23T22:51:10Z", "type": "commit"}, {"oid": "93aeef87fc7da5a29708027bc1a5835343e75390", "url": "https://github.com/pravega/pravega/commit/93aeef87fc7da5a29708027bc1a5835343e75390", "message": "* Remove setSizeBytes method.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-23T23:21:36Z", "type": "commit"}, {"oid": "5f6b8c19ed217af47a72270bce387ba0dc904b3e", "url": "https://github.com/pravega/pravega/commit/5f6b8c19ed217af47a72270bce387ba0dc904b3e", "message": "* Fix checkstyle errors.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-24T00:57:28Z", "type": "commit"}, {"oid": "b73de22a5a35634a204e6ddbbb71cc9f5fbe0aa8", "url": "https://github.com/pravega/pravega/commit/b73de22a5a35634a204e6ddbbb71cc9f5fbe0aa8", "message": "* Add check to make sure iteration done by both 'entryIterator' and 'entryDeltaIterator' are equivalent.\n* When building the diff in PravegaRequestProcessor, add only the entry with the newer (greater) version.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-24T21:27:10Z", "type": "commit"}, {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b", "url": "https://github.com/pravega/pravega/commit/b551e1c40dc2a059f80bb5d7361498952356457b", "message": "* Add coverage for both branches of the delta entry set.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-25T02:14:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNjU2NA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446236564", "bodyText": "No need for public here.\nAlso please add a Javadoc to this method.", "author": "andreipaduroiu", "createdAt": "2020-06-26T14:58:24Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts.tables;\n+\n+import io.pravega.common.util.ArrayView;\n+\n+/**\n+ * {@link IteratorState} encapsulates classes that will need to capture and pass state during iteration of a TableSegment.\n+ */\n+public interface IteratorState {\n+\n+    public ArrayView serialize();", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNzM3NQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446237375", "bodyText": "offset -> position.", "author": "andreipaduroiu", "createdAt": "2020-06-26T14:59:44Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, BufferView serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new {@link AsyncIterator} over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzODQ0Mw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446238443", "bodyText": "Can we add a log.debug here (just like the other iterator methods) to indicate that we are sending something back. Feel free to follow the message pattern used for the other iterators.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:01:34Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -815,6 +821,62 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                 }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        val timer = new Timer();\n+        val result = new DeltaIteratorResult<BufferView, Map.Entry<WireCommands.TableKey, WireCommands.TableValue>, DeltaIteratorState>(\n+                segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        tableStore.entryDeltaIterator(segment, fromPosition, TIMEOUT)\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (result.getItemCount() >= suggestedEntryCount || result.getSizeBytes() >= MAX_READ_SIZE) {\n+                                return  false;\n+                            }\n+                            TableEntry entry = e.getEntries().iterator().next();\n+                            DeltaIteratorState state = DeltaIteratorState.deserialize(e.getState().array());\n+                            // Store all TableEntries.\n+                            val k = new WireCommands.TableKey(toByteBuf(entry.getKey().getKey()), entry.getKey().getVersion());\n+                            val v = new WireCommands.TableValue(toByteBuf(entry.getValue()));\n+                            if (state.isDeletionRecord()) {\n+                                result.remove(entry.getKey().getKey(), k.size() + v.size());\n+                            } else {\n+                                Map.Entry<WireCommands.TableKey, WireCommands.TableValue> old = result.getItem(entry.getKey().getKey());\n+                                if (old != null && old.getKey().getKeyVersion() < entry.getKey().getVersion()) {\n+                                    int sizeBytes = (k.size() + v.size()) - (old.getKey().size() + old.getValue().size());\n+                                    result.add(entry.getKey().getKey(), new AbstractMap.SimpleImmutableEntry<>(k, v), sizeBytes);\n+                                } else {\n+                                    result.add(entry.getKey().getKey(), new AbstractMap.SimpleImmutableEntry<>(k, v), k.size() + v.size());\n+                                }\n+                            }\n+                            result.setState(state);\n+                            // Update total read data.\n+                            return true;\n+                        }))\n+                .thenAccept(v -> {\n+                    connection.send(new WireCommands.TableEntriesDeltaRead(", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTM2NQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446239365", "bodyText": "This complex calculation could be simplified in the following way:\n\nJust invoke .add on the DeltaIteratorState.\nInside DeltaIteratorState.add, when you invoke put on the map, that method will actually return the existing (replaced) value, or null if no such value existed. If you get such a value, then subtract its size from the size tracker.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:03:05Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -815,6 +821,62 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                 }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        val timer = new Timer();\n+        val result = new DeltaIteratorResult<BufferView, Map.Entry<WireCommands.TableKey, WireCommands.TableValue>, DeltaIteratorState>(\n+                segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        tableStore.entryDeltaIterator(segment, fromPosition, TIMEOUT)\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (result.getItemCount() >= suggestedEntryCount || result.getSizeBytes() >= MAX_READ_SIZE) {\n+                                return  false;\n+                            }\n+                            TableEntry entry = e.getEntries().iterator().next();\n+                            DeltaIteratorState state = DeltaIteratorState.deserialize(e.getState().array());\n+                            // Store all TableEntries.\n+                            val k = new WireCommands.TableKey(toByteBuf(entry.getKey().getKey()), entry.getKey().getVersion());\n+                            val v = new WireCommands.TableValue(toByteBuf(entry.getValue()));\n+                            if (state.isDeletionRecord()) {\n+                                result.remove(entry.getKey().getKey(), k.size() + v.size());\n+                            } else {\n+                                Map.Entry<WireCommands.TableKey, WireCommands.TableValue> old = result.getItem(entry.getKey().getKey());", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1ODg3MQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447158871", "bodyText": "Do you mean DeltaIteratorResult? From my understanding it is not guaranteed that entries are read monotonically, i.e we could receive some value later on in the iteration, with an earlier version. Assuming that is true, we'd have to check these conditions prior to the put.  Certainly I can place that logic within the add call, if losing the generic functionality is acceptable.", "author": "co-jo", "createdAt": "2020-06-29T18:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3MzU2MQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r448473561", "bodyText": "I am talking about the HashMap internal to DeltaIteratorResult. That method is synchronized so you don't have to worry about concurrency. Actually you don't need to worry about concurrency at all in this case; we only need synchronized because we pass this between threads (in sequence).\nIf you use the HashMap.put while synchronized you are guaranteed to get the previous value assigned to that key. It will make your code simpler and (slightly) faster.", "author": "andreipaduroiu", "createdAt": "2020-07-01T16:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwMjYwOA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r448602608", "bodyText": "Ok, nevermind. I completely missed the second part of the if condition, where you are comparing the versions. Then what you are doing is good.", "author": "andreipaduroiu", "createdAt": "2020-07-01T20:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTYwMA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446239600", "bodyText": "entryDeltaIterator", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:03:32Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -292,6 +294,12 @@ public void close() {\n         return newIterator(segmentName, serializedState, fetchTimeout, TableBucketReader::entry);\n     }\n \n+    @Override\n+    public CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryDeltaIterator(String segmentName, long fromPosition, Duration fetchTimeout) {\n+        logRequest(\"entryIterator\", segmentName);", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MDI5MA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446240290", "bodyText": "\"resumable delta iterator\"\nLet's differentiate between IteratorState and DeltaIteratorState. The Javadoc should explain what is different about this one.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:04:51Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/DeltaIteratorState.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import io.pravega.segmentstore.contracts.tables.IteratorState;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+import lombok.ToString;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MTAzMw==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446241033", "bodyText": "DeltaIteratorState", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:06:11Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/DeltaIteratorState.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import io.pravega.segmentstore.contracts.tables.IteratorState;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+import lombok.ToString;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+@ToString\n+@Builder\n+public class DeltaIteratorState implements IteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+    private static final int BOOLEAN_BYTES = 1;\n+    @Getter\n+    private final long fromPosition;\n+    @Getter\n+    private final boolean reachedEnd;\n+    @Getter\n+    private final boolean shouldClear;\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MjE0Ng==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446242146", "bodyText": "extra space after implements", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:08:14Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/IteratorStateImpl.java", "diffHunk": "@@ -25,7 +26,7 @@\n /**\n  * Represents the state of a resumable iterator.\n  */\n-class IteratorState {\n+class IteratorStateImpl implements  IteratorState {", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MzUyNQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446243525", "bodyText": "You are assigning currentEntry outside of declared guards. This is not thread safe.\nDoesn't Intellij highlight this as a warning? It should be enabled by default.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:10:38Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public synchronized boolean endOfSegment() {\n+        return this.currentBatchOffset >= (this.startOffset + this.maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<DeltaIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<DeltaIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            val next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MDM5Mg==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447170392", "bodyText": "Nope, no warnings. Will look to enable it.", "author": "co-jo", "createdAt": "2020-06-29T18:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0NDcxNQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446244715", "bodyText": "I believe I know why you are silently ignoring this exception, but please add a comment explaining why.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:12:38Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public synchronized boolean endOfSegment() {\n+        return this.currentBatchOffset >= (this.startOffset + this.maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<DeltaIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<DeltaIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            val next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<DeltaIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<DeltaIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long currentOffset = startOffset;\n+        final long maxOffset = startOffset + readLength;\n+\n+        BufferView.Reader input = data.getBufferViewReader();\n+        List<Map.Entry<DeltaIteratorState, TableEntry>> entries = new ArrayList<>();\n+        try {\n+            while (currentOffset < maxOffset) {\n+                val entry = AsyncTableEntryReader.readEntryComponents(input, currentOffset, this.entrySerializer);\n+                boolean reachedEnd = currentOffset + entry.getHeader().getTotalLength() >= this.maxLength + startOffset;\n+                // We must preserve deletions to accurately construct a delta.\n+                BufferView value = entry.getValue() == null ? BufferView.empty() : entry.getValue();\n+                currentOffset += entry.getHeader().getTotalLength();\n+                entries.add(new AbstractMap.SimpleEntry<>(\n+                        new DeltaIteratorState(currentOffset, reachedEnd, this.shouldClear, entry.getHeader().isDeletion()),\n+                        TableEntry.versioned(entry.getKey(), value, entry.getVersion())));\n+            }\n+\n+        } catch (BufferView.Reader.OutOfBoundsException ex) {", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0NDk5OA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446244998", "bodyText": "get -> entryDeltaIterator", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:13:01Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableService.java", "diffHunk": "@@ -109,6 +109,13 @@ public TableService(SegmentContainerRegistry segmentContainerRegistry, SegmentTo\n                 \"get\", segmentName, serializedState != null, fetchTimeout);\n     }\n \n+    @Override\n+    public CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryDeltaIterator(String segmentName, long fromPosition, Duration fetchTimeout) {\n+        return invokeExtension(segmentName,\n+                e -> e.entryDeltaIterator(segmentName, fromPosition, fetchTimeout),\n+                \"get\", segmentName, fromPosition, fetchTimeout);", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0ODExOQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446248119", "bodyText": "you need to add .requireRelease() before returning this object. See the changes that were made to TableEntriesRead ,for example.", "author": "andreipaduroiu", "createdAt": "2020-06-26T15:18:32Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2238,31 +2238,31 @@ public boolean isFailure() {\n         final String segment;\n         @ToString.Exclude\n         final String delegationToken;\n-        final long fromVersion;\n+        final long fromPosition;\n         final int suggestedEntryCount;\n \n         @Override\n         public void process(RequestProcessor cp) {\n-\n+            cp.readTableEntriesDelta(this);\n         }\n \n         @Override\n         public void writeFields(DataOutput out) throws IOException {\n             out.writeLong(requestId);\n             out.writeUTF(segment);\n             out.writeUTF(delegationToken == null ? \"\" : delegationToken);\n-            out.writeLong(fromVersion);\n+            out.writeLong(fromPosition);\n             out.writeInt(suggestedEntryCount);\n         }\n \n         public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             String delegationToken = in.readUTF();\n-            long fromVersion = in.readLong();\n+            long fromPosition = in.readLong();\n             int suggestedEntryCount = in.readInt();\n \n-            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromVersion, suggestedEntryCount);\n+            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromPosition, suggestedEntryCount);", "originalCommit": "b551e1c40dc2a059f80bb5d7361498952356457b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4ODY2Ng==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447188666", "bodyText": "Which resources need releasing? I extended TableEntriesReadDelta to release its entries but it didn't seem like ReadTableEntriesDelta required it.", "author": "co-jo", "createdAt": "2020-06-29T19:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0ODExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI5NjE3OA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447296178", "bodyText": "My bad. This comment relates to line 2303. See below.", "author": "andreipaduroiu", "createdAt": "2020-06-29T22:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0ODExOQ=="}], "type": "inlineReview"}, {"oid": "720cefe147a5a013d42eecad357c969c5480de86", "url": "https://github.com/pravega/pravega/commit/720cefe147a5a013d42eecad357c969c5480de86", "message": "* Addresses feedback from PR.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-29T19:41:18Z", "type": "commit"}, {"oid": "6615136824e0c79e4c2c7b0ca8e7cf99c4f4f7d8", "url": "https://github.com/pravega/pravega/commit/6615136824e0c79e4c2c7b0ca8e7cf99c4f4f7d8", "message": "* Add debug logs to readTableEntriesDelta.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-29T20:34:54Z", "type": "commit"}, {"oid": "8dd70593b07d84f5914acaab5009faea8b420fb7", "url": "https://github.com/pravega/pravega/commit/8dd70593b07d84f5914acaab5009faea8b420fb7", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-06-29T22:31:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI5OTEwOQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447299109", "bodyText": "This is where you need to add it. See other cases in this class for examples how to do it.\nIf you want to know what, then follow through the .release call at line 2308 and see which ByteBufs get released. Without invoking that (and requiring it), those buffers will stick around for a long time and lead to memory leaks).", "author": "andreipaduroiu", "createdAt": "2020-06-29T22:37:44Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2299,14 +2298,14 @@ public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) th\n             TableEntries entries = TableEntries.readFrom(in, in.available());\n             boolean shouldClear = in.readBoolean();\n             boolean reachedEnd = in.readBoolean();\n-            long lastVersion = in.readLong();\n+            long lastPosition = in.readLong();\n \n-            return new TableEntriesDeltaRead(requestId, segment, entries, shouldClear, reachedEnd, lastVersion);\n+            return new TableEntriesDeltaRead(requestId, segment, entries, shouldClear, reachedEnd, lastPosition);", "originalCommit": "8dd70593b07d84f5914acaab5009faea8b420fb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75fde4ba492edc0ad20688475a01dec477386994", "url": "https://github.com/pravega/pravega/commit/75fde4ba492edc0ad20688475a01dec477386994", "message": "* Add release requirement to TableEntriesDelta read command.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-06-30T21:13:26Z", "type": "commit"}, {"oid": "14187411742aeae7d394f99030f8770c658cbb7c", "url": "https://github.com/pravega/pravega/commit/14187411742aeae7d394f99030f8770c658cbb7c", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads", "committedDate": "2020-06-30T21:14:07Z", "type": "commit"}, {"oid": "9d7a68def78ac1aa93994b120190a31729550096", "url": "https://github.com/pravega/pravega/commit/9d7a68def78ac1aa93994b120190a31729550096", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-01T16:13:54Z", "type": "commit"}, {"oid": "964d971e4feb8c4addb1d77ffae75bdfc906b8fa", "url": "https://github.com/pravega/pravega/commit/964d971e4feb8c4addb1d77ffae75bdfc906b8fa", "message": "* Remove redundant extension.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-01T20:37:49Z", "type": "commit"}, {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740", "url": "https://github.com/pravega/pravega/commit/29725a2a49fc498254d2ea213c86d6a539fb0740", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads", "committedDate": "2020-07-01T20:38:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NDQyNg==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451054426", "bodyText": "This needs to be explained in more depth.", "author": "tkaitchuck", "createdAt": "2020-07-07T18:14:27Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, BufferView serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new {@link AsyncIterator} over all the {@link TableEntry} instances in the given Table Segment starting from a given position.", "originalCommit": "29725a2a49fc498254d2ea213c86d6a539fb0740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzI0OQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451057249", "bodyText": "I don't see this being sent back in the return value. Is it actually used for anything?", "author": "tkaitchuck", "createdAt": "2020-07-07T18:19:42Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -1001,5 +1067,45 @@ synchronized BufferView getContinuationToken() {\n         }\n     }\n \n+    private static class DeltaIteratorResult<K, V, S> {\n+        @Getter\n+        @Setter\n+        @GuardedBy(\"this\")\n+        private S state;\n+        @GuardedBy(\"this\")\n+        private final Map<K, V> items = new HashMap<>();\n+        @Getter\n+        @GuardedBy(\"this\")\n+        private int sizeBytes;", "originalCommit": "29725a2a49fc498254d2ea213c86d6a539fb0740", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNzYxOQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r452407619", "bodyText": "I'm not sure I understand the question. Its being used to bound the aggregate size of entries that can be returned.", "author": "co-jo", "createdAt": "2020-07-09T18:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NDQ4MA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451154480", "bodyText": "It says this is thread safe, but I am not clear on the semantics of this method being called in parallel.\nIn particular getNextEntry could have two calls to getNextEntryFromBatch in parallel both get null and hence end up calling fetchNextTableEntriesBatch twice. When if those calls had been ordered it would have only resulted to one call to fetchNextTableEntriesBatch", "author": "tkaitchuck", "createdAt": "2020-07-07T21:29:24Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through a {@link DirectSegmentAccess}, deserializing {@link TableEntry} from a {@link BufferView} in linear fashion.\n+ *\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    // The offset to being iteration at.\n+    private final long startOffset;\n+    // Maximum length of the TableSegment we want to read until.\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {", "originalCommit": "29725a2a49fc498254d2ea213c86d6a539fb0740", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxOTYwOQ==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r452419609", "bodyText": "I see, good catch. It would seem the only conflict that can occur is that multiple calls to getNextEntry can return null, but otherwise concurrent calls won't point to the same non-null currentEntry. So I see two solutions: call if (this.currentEntry != null) return CompletableFuture.completedFuture(null); from within fetchNextTableEntriesBatch or make getNextEntry synchronized. I'm not sure the former provides any substantial improvement.", "author": "co-jo", "createdAt": "2020-07-09T18:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NDQ4MA=="}], "type": "inlineReview"}, {"oid": "57c266dbf42f093e1df6ea262c460f21b38efcf4", "url": "https://github.com/pravega/pravega/commit/57c266dbf42f093e1df6ea262c460f21b38efcf4", "message": "* Fix possible race condition.\n* Improve documentation for TableStore.entryDeltaIterator.\n* Rename tests class.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-09T18:20:08Z", "type": "commit"}, {"oid": "0391c923f5f22c47767cfa6e363bb598b2a65fe8", "url": "https://github.com/pravega/pravega/commit/0391c923f5f22c47767cfa6e363bb598b2a65fe8", "message": "* Change solution for potential race condition.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-09T18:47:06Z", "type": "commit"}, {"oid": "f3437025a1696ebf736fbecc5d947c0a8856d7b5", "url": "https://github.com/pravega/pravega/commit/f3437025a1696ebf736fbecc5d947c0a8856d7b5", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4677-offset-table-reads\n\n\u0001 Conflicts:\n\u0001\tsegmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java\n\u0001\tsegmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java\n\u0001\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java\n\u0001\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/TableServiceTests.java", "committedDate": "2020-07-09T18:57:28Z", "type": "commit"}, {"oid": "6e217c0fcb7297626e4c161005708e61fc38bc62", "url": "https://github.com/pravega/pravega/commit/6e217c0fcb7297626e4c161005708e61fc38bc62", "message": "* Fix merge conflicts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-09T19:24:25Z", "type": "commit"}, {"oid": "c163927faf73d41fbcb20ed660cde5ab054223b0", "url": "https://github.com/pravega/pravega/commit/c163927faf73d41fbcb20ed660cde5ab054223b0", "message": "* Fix merge issue.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-09T19:30:27Z", "type": "commit"}, {"oid": "575c090be7ecb83217b7a5fa4f5b54b1e8dc2f7f", "url": "https://github.com/pravega/pravega/commit/575c090be7ecb83217b7a5fa4f5b54b1e8dc2f7f", "message": "* Fix invalid method call.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-09T23:33:11Z", "type": "commit"}, {"oid": "20237d641268a4b416046c49d54d74db18c5317d", "url": "https://github.com/pravega/pravega/commit/20237d641268a4b416046c49d54d74db18c5317d", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-14T10:20:10Z", "type": "commit"}, {"oid": "e9be2b6820ef674f1fa86793e2741531735f28d2", "url": "https://github.com/pravega/pravega/commit/e9be2b6820ef674f1fa86793e2741531735f28d2", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-14T17:41:57Z", "type": "commit"}, {"oid": "3eb88f730ad9e4b848064112f5410b9d068214f0", "url": "https://github.com/pravega/pravega/commit/3eb88f730ad9e4b848064112f5410b9d068214f0", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-16T00:18:43Z", "type": "commit"}, {"oid": "535ec5786f0aab9e8c137877ef0c93708af13619", "url": "https://github.com/pravega/pravega/commit/535ec5786f0aab9e8c137877ef0c93708af13619", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-16T19:20:10Z", "type": "commit"}, {"oid": "fd4811be8d1079b6b7e5205101ba840e8f9c60e3", "url": "https://github.com/pravega/pravega/commit/fd4811be8d1079b6b7e5205101ba840e8f9c60e3", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4677-offset-table-reads\n\n\u0001 Conflicts:\n\u0001\tsegmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\n\u0001\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java", "committedDate": "2020-07-16T20:34:13Z", "type": "commit"}, {"oid": "8127f135018b7585ce498754c46416bf00674d6a", "url": "https://github.com/pravega/pravega/commit/8127f135018b7585ce498754c46416bf00674d6a", "message": "* Merge conflicts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-16T21:10:42Z", "type": "commit"}, {"oid": "74ea516eaf44c8e0b0c589d13721c097045117dc", "url": "https://github.com/pravega/pravega/commit/74ea516eaf44c8e0b0c589d13721c097045117dc", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads", "committedDate": "2020-07-16T21:14:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE1NDUyMA==", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r456154520", "bodyText": "It just occurred to me that this will not work on sorted table segments. It does not have to.\nLet's add a check here (it's an attribute stored in the SegmentProperties) whether this is a sorted table segment. If it is, we should be throwing/returning an UnsupportedOperationException explaining why.", "author": "andreipaduroiu", "createdAt": "2020-07-17T00:40:02Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -457,13 +463,48 @@ protected int getMaxCompactionSize() {\n                 });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newDeltaIterator(@NonNull String segmentName, long fromPosition, @NonNull Duration fetchTimeout) {\n+        return this.segmentContainer\n+                .forSegment(segmentName, fetchTimeout)\n+                .thenComposeAsync(segment -> {\n+                    SegmentProperties properties = segment.getInfo();\n+                    long compactionOffset = properties.getAttributes().getOrDefault(TableAttributes.COMPACTION_OFFSET, 0L);", "originalCommit": "74ea516eaf44c8e0b0c589d13721c097045117dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e75cfbf24f2bb93089acf6cae0c58c48d399c95", "url": "https://github.com/pravega/pravega/commit/5e75cfbf24f2bb93089acf6cae0c58c48d399c95", "message": "* Add guards to prevent a delta iterator being used on a sorted TableSegment.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-07-17T22:15:13Z", "type": "commit"}, {"oid": "bc56ebfc4bef1b09be771924cfc9aea7fe9879b1", "url": "https://github.com/pravega/pravega/commit/bc56ebfc4bef1b09be771924cfc9aea7fe9879b1", "message": "Merge branch 'master' into issue-4677-offset-table-reads", "committedDate": "2020-07-17T23:43:26Z", "type": "commit"}]}