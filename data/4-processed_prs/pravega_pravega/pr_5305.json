{"pr_number": 5305, "pr_title": "Issue 5296: Using Java 11 Intrinsic Serializers for Shorts, Ints and Longs.", "pr_createdAt": "2020-11-05T23:20:01Z", "pr_url": "https://github.com/pravega/pravega/pull/5305", "timeline": [{"oid": "62ad2aa76d808e02038875b812acb32b0e69bb42", "url": "https://github.com/pravega/pravega/commit/62ad2aa76d808e02038875b812acb32b0e69bb42", "message": "BufferViewSink -> DirectDataOutput\nAdded writeShort, writeInt and writeLong to DirectDataOutput.\nDataFrameOutputStream, DataFrame and CompositeArrayView/CompositeByteArraySegment: added support for writing direct ints, longs and shorts using (if available) intrinsic methods.\nAdded some unit tests. More to follow.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-04T00:37:06Z", "type": "commit"}, {"oid": "aa35d331166623f599b6b3a2b411f6567adeacfa", "url": "https://github.com/pravega/pravega/commit/aa35d331166623f599b6b3a2b411f6567adeacfa", "message": "StructuredReadableBuffer and StructuredWritableBuffer. Made ByteArraySegment and CompositeArrayView implement these (as needed). Not yet wired into other upstream classes.\nByteArraySegment uses a ByteBuf underneath.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-04T19:00:31Z", "type": "commit"}, {"oid": "e32d8198f21c8312a502d510175415ab166358ac", "url": "https://github.com/pravega/pravega/commit/e32d8198f21c8312a502d510175415ab166358ac", "message": "Removing usages of BitConverter obsolete methods.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-05T00:19:21Z", "type": "commit"}, {"oid": "66f1f108130f46a100aa1b5cc9136b6bbedc5dd8", "url": "https://github.com/pravega/pravega/commit/66f1f108130f46a100aa1b5cc9136b6bbedc5dd8", "message": "Bugfix.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-05T00:38:45Z", "type": "commit"}, {"oid": "c7c90a2e7269e221c0178a13c5af807f632209ee", "url": "https://github.com/pravega/pravega/commit/c7c90a2e7269e221c0178a13c5af807f632209ee", "message": "Retired FixedByteArrayOutputStream. Retired EnhancedByteArrayOutputStream.\nCreated ByteBufferOutputStream that will replace both of them. Updated callsites as necessary.\nImproving RevisionDataOutputStream to make use of DirectDataOutput for more situations.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-05T20:59:21Z", "type": "commit"}, {"oid": "03c1bfe94714eac59be8e8a711f5c400916b4bd9", "url": "https://github.com/pravega/pravega/commit/03c1bfe94714eac59be8e8a711f5c400916b4bd9", "message": "BitConverter unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-05T22:10:57Z", "type": "commit"}, {"oid": "4a1806fdaa3fb7caa68fddc855fe6a890f8b39f8", "url": "https://github.com/pravega/pravega/commit/4a1806fdaa3fb7caa68fddc855fe6a890f8b39f8", "message": "RevisionDataOutputStream unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-05T23:18:02Z", "type": "commit"}, {"oid": "46e30269eb377b7af82ba2ef2bec1a1da8d00de3", "url": "https://github.com/pravega/pravega/commit/46e30269eb377b7af82ba2ef2bec1a1da8d00de3", "message": "Merge remote-tracking branch 'origin/master' into issue-5296-fast-serializers", "committedDate": "2020-11-05T23:18:27Z", "type": "commit"}, {"oid": "0ddad3c52e8b7532b0098d9fcb6ec4897640672a", "url": "https://github.com/pravega/pravega/commit/0ddad3c52e8b7532b0098d9fcb6ec4897640672a", "message": "Spotbugs.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-06T00:45:26Z", "type": "commit"}, {"oid": "e54ac4cb2504e55be9c77c2d00a9541ffd07db74", "url": "https://github.com/pravega/pravega/commit/e54ac4cb2504e55be9c77c2d00a9541ffd07db74", "message": "Optimizing code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-06T17:55:22Z", "type": "commit"}, {"oid": "51c1800ddced2a4fe0e7f63acef67bf55809e875", "url": "https://github.com/pravega/pravega/commit/51c1800ddced2a4fe0e7f63acef67bf55809e875", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-07T02:48:11Z", "type": "commit"}, {"oid": "fd00cc24c7cda2505594e0c07be27930114d207d", "url": "https://github.com/pravega/pravega/commit/fd00cc24c7cda2505594e0c07be27930114d207d", "message": "Improving tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-09T23:45:41Z", "type": "commit"}, {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196", "url": "https://github.com/pravega/pravega/commit/77f68de9e4cde3d2870447d48e3a845d5aee2196", "message": "Merge remote-tracking branch 'ap/issue-5296-fast-serializers' into issue-5296-fast-serializers", "committedDate": "2020-11-09T23:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODAzNQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520608035", "bodyText": "Have you thought about releasing the ByteBuffer with the cleaner ?", "author": "eolivelli", "createdAt": "2020-11-10T14:34:03Z", "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {\n+        this.buf.put(streamPosition, (byte) byteValue);\n+    }\n+\n+    @Override\n+    public void write(byte[] array) {\n+        write(array, 0, array.length);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int length) {\n+        ensureExtraCapacity(length);\n+        this.buf.put(b, offset, length);\n+    }\n+\n+    @Override\n+    public void write(byte[] array, int arrayOffset, int length, int streamPosition) {\n+        if (arrayOffset < 0 || length < 0 || (length > 0 && arrayOffset + length > array.length)) {\n+            throw new ArrayIndexOutOfBoundsException(\"bufferOffset and length must refer to a range within buffer.\");\n+        }\n+\n+        final int extra = streamPosition + length - this.buf.position();\n+        if (extra > 0) {\n+            ensureExtraCapacity(extra);\n+        }\n+\n+        final int originalPos = this.buf.position();\n+        this.buf.position(streamPosition);\n+        this.buf.put(array, arrayOffset, length);\n+        this.buf.position(Math.max(originalPos, streamPosition + length));\n+    }\n+\n+\n+    @Override\n+    public int size() {\n+        return this.buf.position();\n+    }\n+\n+    @Override\n+    public void flush() {\n+        // This method intentionally left blank.\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This method intentionally left blank.", "originalCommit": "77f68de9e4cde3d2870447d48e3a845d5aee2196", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYxODQ4NA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520618484", "bodyText": "Java NIO ByteBuffer does not have a release mechanism. Plus this is dealing exclusively with heap byte buffers which are recycled by the GC. Are you thinking of Netty ByteBuf?", "author": "andreipaduroiu", "createdAt": "2020-11-10T14:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYyNjc4MQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520626781", "bodyText": "Probably I need a coffe :-)\nI thought you were using a direct memory buffer.\nSorry for the noise.\nbtw, are you using an heap buffer because the instances of this class won't be used directly for I/O ?", "author": "eolivelli", "createdAt": "2020-11-10T14:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg3Mzk5NQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r527873995", "bodyText": "This class is an equivalent of ByteArrayOutputStream but using ByteBuffer. I don't need it to be heap or direct, but heap is easier to deal with, is faster (to allocate) and I can always fetch a slice of the underlying array if needed (which is what the point of this class is anyway).\nI don't use it for IO directly, rather than as a way to conveniently serialize a set of objects.", "author": "andreipaduroiu", "createdAt": "2020-11-20T17:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODQ1MA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520608450", "bodyText": "Have you thought about releasing the old ByteBuffer with the cleaner ?", "author": "eolivelli", "createdAt": "2020-11-10T14:34:33Z", "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {\n+        this.buf.put(streamPosition, (byte) byteValue);\n+    }\n+\n+    @Override\n+    public void write(byte[] array) {\n+        write(array, 0, array.length);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int length) {\n+        ensureExtraCapacity(length);\n+        this.buf.put(b, offset, length);\n+    }\n+\n+    @Override\n+    public void write(byte[] array, int arrayOffset, int length, int streamPosition) {\n+        if (arrayOffset < 0 || length < 0 || (length > 0 && arrayOffset + length > array.length)) {\n+            throw new ArrayIndexOutOfBoundsException(\"bufferOffset and length must refer to a range within buffer.\");\n+        }\n+\n+        final int extra = streamPosition + length - this.buf.position();\n+        if (extra > 0) {\n+            ensureExtraCapacity(extra);\n+        }\n+\n+        final int originalPos = this.buf.position();\n+        this.buf.position(streamPosition);\n+        this.buf.put(array, arrayOffset, length);\n+        this.buf.position(Math.max(originalPos, streamPosition + length));\n+    }\n+\n+\n+    @Override\n+    public int size() {\n+        return this.buf.position();\n+    }\n+\n+    @Override\n+    public void flush() {\n+        // This method intentionally left blank.\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This method intentionally left blank.\n+    }\n+\n+    //endregion\n+\n+    //region RandomAccessOutputStream and DirectDataOutput Implementation\n+\n+    @Override\n+    public void writeBuffer(BufferView buffer) {\n+        ensureExtraCapacity(buffer.getLength());\n+        int bytesCopied = buffer.copyTo(this.buf);\n+        assert bytesCopied == buffer.getLength();\n+    }\n+\n+    @Override\n+    public void writeShort(int shortValue) {\n+        ensureExtraCapacity(Short.BYTES);\n+        this.buf.putShort((short) shortValue);\n+    }\n+\n+    @Override\n+    public void writeInt(int intValue) {\n+        ensureExtraCapacity(Integer.BYTES);\n+        this.buf.putInt(intValue);\n+    }\n+\n+    @Override\n+    public void writeInt(int intValue, int streamPosition) {\n+        this.buf.putInt(streamPosition, intValue);\n+    }\n+\n+    @Override\n+    public void writeLong(long longValue) {\n+        ensureExtraCapacity(Long.BYTES);\n+        this.buf.putLong(longValue);\n+    }\n+\n+    @Override\n+    public ByteArraySegment getData() {\n+        return new ByteArraySegment(this.buf.array(), this.buf.arrayOffset(), size());\n+    }\n+\n+    //endregion\n+\n+    //region Helpers\n+\n+    private void ensureExtraCapacity(int count) {\n+        // This method is borrowed from ByteArrayOutputStream and adapted for use with ByteBuffers.\n+        final int minCapacity = this.buf.position() + count;\n+        if (minCapacity <= this.buf.limit()) {\n+            return;\n+        }\n+\n+        final int oldCapacity = this.buf.limit();\n+        int newCapacity = oldCapacity << 1;\n+        if (newCapacity - minCapacity < 0) {\n+            newCapacity = minCapacity;\n+        }\n+\n+        if (newCapacity - MAX_ARRAY_SIZE > 0) {\n+            if (minCapacity < 0) {\n+                throw new OutOfMemoryError();\n+            } else {\n+                newCapacity = minCapacity > MAX_ARRAY_SIZE ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;\n+            }\n+        }\n+\n+        final int oldPosition = this.buf.position();\n+        this.buf.position(0);", "originalCommit": "77f68de9e4cde3d2870447d48e3a845d5aee2196", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYxODYwMw==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520618603", "bodyText": "See above", "author": "andreipaduroiu", "createdAt": "2020-11-10T14:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODQ1MA=="}], "type": "inlineReview"}, {"oid": "a727d464855ef748aaefcd4de189ea8f30bc979e", "url": "https://github.com/pravega/pravega/commit/a727d464855ef748aaefcd4de189ea8f30bc979e", "message": "BufferView.Reader.readBytes now targets a ByteBuffer (instead of ByteArraySegment).\nOptimizing code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-10T20:51:29Z", "type": "commit"}, {"oid": "a6c0ee7b0da6f43eba2edb6c51ed2a81e548eee7", "url": "https://github.com/pravega/pravega/commit/a6c0ee7b0da6f43eba2edb6c51ed2a81e548eee7", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-16T16:22:38Z", "type": "commit"}, {"oid": "e8336ba47708989475488d3680d8da222b53a74e", "url": "https://github.com/pravega/pravega/commit/e8336ba47708989475488d3680d8da222b53a74e", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-19T15:34:42Z", "type": "commit"}, {"oid": "0d7a0cc711eb753c84b1fd10107a49662cc1c2b1", "url": "https://github.com/pravega/pravega/commit/0d7a0cc711eb753c84b1fd10107a49662cc1c2b1", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-20T10:20:42Z", "type": "commit"}, {"oid": "8960fc7fa010db18de3f8c1325302b71bbfc8200", "url": "https://github.com/pravega/pravega/commit/8960fc7fa010db18de3f8c1325302b71bbfc8200", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-20T15:56:19Z", "type": "commit"}, {"oid": "7af6eae7f9063141c91b5642e8cf0b68c728aa25", "url": "https://github.com/pravega/pravega/commit/7af6eae7f9063141c91b5642e8cf0b68c728aa25", "message": "Fixed a bug in CompositeByteArraySegment where it would incorrectly read more than needed when reading into the last ByteBuffer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-20T22:41:54Z", "type": "commit"}, {"oid": "a9a3872951bab154cd13d8d6b9d2b07c1f7ba8cd", "url": "https://github.com/pravega/pravega/commit/a9a3872951bab154cd13d8d6b9d2b07c1f7ba8cd", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-22T20:52:19Z", "type": "commit"}, {"oid": "5ef147c70e62361c9b8a97f2f83af60fca1c1b18", "url": "https://github.com/pravega/pravega/commit/5ef147c70e62361c9b8a97f2f83af60fca1c1b18", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-23T15:33:57Z", "type": "commit"}, {"oid": "fb60bdfd4fb0d26ba17bce354b49849285cd9473", "url": "https://github.com/pravega/pravega/commit/fb60bdfd4fb0d26ba17bce354b49849285cd9473", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-24T01:40:00Z", "type": "commit"}, {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "url": "https://github.com/pravega/pravega/commit/b4c518306198cc9e8090fac9f90587bd6d948dc1", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-24T13:47:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MDk4Mg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529890982", "bodyText": "Take a look at how I handled this here:\nhttps://github.com/pravega/pravega/pull/5249/files#diff-281329b3593c7cd026ac5e38d7d89ecdabb4d4ebff070c50268ce53f328798aeR214\nI think rather than this random access pattern which has the problem of passing offsets that have not yet been allocated. (IE ensureExtraCapacity is not called here) it's better to return a slice that can be written to to write to. This allows a caller to delay writing to a particular location until later and have an object which represents the location that they can jump back to.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:31:48Z", "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2MTUxOA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530461518", "bodyText": "The contract for RandomAccessOutputStream (where this method is defined) explicitly states that streamPosition must be within bounds, otherwise an IndexOutOfBoundsException will be thrown back.\nThe consuming code (of that interface) takes advantage of this, for example, in serialization, when it needs to \"go back\" and back-fill the length field after the serialization is over. If this had not been possible/allowed, its only choice would have been to precompute that length before the serialization, a potentially unnecessary step. By allowing this back-fill, all that the serializer needs to do is count the number of bytes written (as they are written) and then fill that position upon close.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MDk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3ODMxNQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r532978315", "bodyText": "I understood what the code was doing. I was pointing out there is a better way to handle this usecase, and I already wrote the code for it. Take a look at that pattern.", "author": "tkaitchuck", "createdAt": "2020-11-30T23:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MDk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MjY4OQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529892689", "bodyText": "Is there a reason this is prefered to DataOutput with is a built in interface for more or less the same thing?", "author": "tkaitchuck", "createdAt": "2020-11-24T21:35:25Z", "path": "common/src/main/java/io/pravega/common/io/DirectDataOutput.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.util.BufferView;\n+import java.io.IOException;\n+\n+/**\n+ * Defines an object meant for serializing data (usually an {@link java.io.OutputStream}) that can write various inputs\n+ * more efficiently than otherwise (i.e., byte-by-byte copy).\n+ */\n+public interface DirectDataOutput {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NDMwMA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530464300", "bodyText": "Several reasons:\n\nIt has writeBuffer(BufferView).\nI do not have to reimplement all DataOutput methods; I only need to do the ones for which I have proper optimizations in place. Plus, every other data type can be reduced to one of these here.\nDataOutputStream, which is the sole class implementing DataOutput, made all of its implementation methods final so I cannot subclass that method to provide more efficient implementations for them.\n\nI could see that in a future iteration, we can clean this up and provide a uniform implementation, but for now I did not want to force every class implementing this (ByteBufferOutputStream, DataFrameOutputStream) to subclass DataOutputStream (for reason #3 above) or to have to independently reimplement the methods in DataOutputStream.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MjY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3ODY0NA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r532978644", "bodyText": "DataOutput and DataOutputStream are different.", "author": "tkaitchuck", "createdAt": "2020-11-30T23:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MjY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0NjUzMA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r533746530", "bodyText": "Yes. I did not want to implement all methods defined on DataOutput. I only care about a select few. I brought up DataOutputStream because it is the encoding format that we want to follow. My only choice would be to reimplement that everywhere I implement this interface, which is not my intention.", "author": "andreipaduroiu", "createdAt": "2020-12-01T21:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MjY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDk0Nw==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529894947", "bodyText": "You can use slicing to eliminate the need for this member.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:39:58Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -21,17 +20,18 @@\n import java.util.Iterator;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n+import lombok.Getter;\n \n /**\n  * Allows segmenting a byte array and operating only on that segment.\n  */\n public class ByteArraySegment extends AbstractBufferView implements ArrayView {\n     //region Members\n \n-    private final byte[] array;\n-    private final int startOffset;\n+    private final ByteBuffer buffer;\n+    private final int bufferPosition;", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDM4MQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530474381", "bodyText": "I didn't use slicing; yet I set buffer.position(...) in the constructor.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NTg2OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529895868", "bodyText": "This method name does not imply a copy will be performed. The prefix \"as\" would lead me to believe that one will not.\nWe should either rename the method, or make it avoid the copy.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:41:42Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -123,24 +114,30 @@ public Reader getBufferViewReader() {\n \n     @Override\n     public InputStream getReader() {\n-        return new ByteArrayInputStream(this.array, this.startOffset, this.length);\n+        return new ByteArrayInputStream(array(), arrayOffset(), this.length);\n     }\n \n     @Override\n     public InputStream getReader(int offset, int length) {\n         Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n-        return new ByteArrayInputStream(this.array, this.startOffset + offset, length);\n+        return new ByteArrayInputStream(array(), arrayOffset() + offset, length);\n     }\n \n     @Override\n     public ByteArraySegment slice(int offset, int length) {\n-        return subSegment(offset, length, this.readOnly);\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        return new ByteArraySegment(array(), arrayOffset() + offset, length);\n+    }\n+\n+    @Override\n+    public ByteBuffer asByteBuffer() {\n+        return this.buffer.duplicate(); // Duplicate to prevent anyone external from messing with our buffer.", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDk2OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530470968", "bodyText": "ByteBuffer.duplicate does not make a copy of the data itself. It returns a new ByteBuffer instance pointing to the same backing buffer. The user may access the buffer's array (same with invoking .array()) but the point of invoking .duplicate() is for them not to mess with position, limit, etc.\nThis is the code in HeapByteBuffer.java:\n   public ByteBuffer duplicate() {\n        return new HeapByteBuffer(this.hb, this.markValue(), this.position(), this.limit(), this.capacity(), this.offset);\n    }", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NjgwMg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529896802", "bodyText": ".array() is not guaranteed to exist. It is OK to rely on if this class is the one creating the buffer but in this case it is not. So if the provided buffer came from a socket then this method could throw.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:43:31Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -68,7 +55,7 @@ public ByteArraySegment(byte[] array, int startOffset, int length) {\n      * @throws UnsupportedOperationException  If buff is not backed by an array.\n      */\n     public ByteArraySegment(ByteBuffer buff) {\n-        this(buff.array(), buff.arrayOffset() + buff.position(), buff.remaining(), false);\n+        this(buff.array(), buff.arrayOffset() + buff.position(), buff.remaining());", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NTg4MQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530475881", "bodyText": "True. This class is named ByteArraySegment so it implies that it deals with arrays. It has been like that before and even in the client (which is the only place which invokes this ByteBuffer constructor) passes in a HeapByteBuffer.\nI could see that in the future we either create a new class ByteBufferWrapper (to replace ByteBufWrapper once we eliminate Netty) or adjust this class to accommodate multiple types of ByteBuffer instances.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NjgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzE4Mw==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897183", "bodyText": "See above. (Also I think byteBuffer already has a method for this)", "author": "tkaitchuck", "createdAt": "2020-11-24T21:44:10Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -149,13 +146,13 @@ public void copyTo(byte[] target, int targetOffset, int length) {\n         Preconditions.checkElementIndex(length, this.length + 1, \"length\");\n         Exceptions.checkArrayRange(targetOffset, length, target.length, \"index\", \"values.length\");\n \n-        System.arraycopy(this.array, this.startOffset, target, targetOffset, length);\n+        System.arraycopy(array(), arrayOffset(), target, targetOffset, length);\n     }\n \n     @Override\n     public int copyTo(ByteBuffer target) {\n         int length = Math.min(this.length, target.remaining());\n-        target.put(this.array, this.startOffset, length);\n+        target.put(array(), arrayOffset(), length);", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NzY2Mg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530477662", "bodyText": "Well, I am using that method: ByteBuffer.put(byte[], int, int).\nThere is another method that allows a ByteBuffer to be copied to another ByteBuffer. It is very clunky to use (requires proper setting and then resetting of positions and limits), so we wrote our own in ByteBufferUtils but it is far too complex for this task - that one is great if we have a generic ByteBuffer, but if we already have an array, this one is the fastest way to achieve the copy.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzMwNQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897305", "bodyText": "See above. (Also I think byteBuffer already has a method for this)", "author": "tkaitchuck", "createdAt": "2020-11-24T21:44:24Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -168,16 +165,16 @@ public int copyTo(ByteBuffer target) {\n      */\n     @Override\n     public void copyTo(OutputStream stream) throws IOException {\n-        stream.write(this.array, this.startOffset, this.length);\n+        stream.write(array(), arrayOffset(), this.length);", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3ODMyMA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530478320", "bodyText": "ByteBuffer does not have any methods that work on OutputStream", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5Nzk4OQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897989", "bodyText": "Here is an example of where the \"asByteBuffer\" performing a copy is unexpected. Before there was no copy here and now there is.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:45:37Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3OTIwNg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530479206", "bodyText": "It's not making a copy. See my answer above.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5Nzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODA2Mg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898062", "bodyText": "same here", "author": "tkaitchuck", "createdAt": "2020-11-24T21:45:45Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDAzOA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530480038", "bodyText": "See above.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODE2OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898168", "bodyText": "See above.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:46:00Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());\n     }\n \n-    //endregion\n+    @Override\n+    public void set(int index, byte value) {\n+        this.buffer.put(this.bufferPosition + index, value);\n+    }\n \n-    //region Operations\n+    @Override\n+    public void setShort(int index, short value) {\n+        this.buffer.putShort(this.bufferPosition + index, value);\n+    }\n \n-    /**\n-     * Sets the value at the specified index.\n-     *\n-     * @param index The index to set the value at.\n-     * @param value The value to set.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n-     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n-     */\n-    public void set(int index, byte value) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Preconditions.checkElementIndex(index, this.length, \"index\");\n-        this.array[index + this.startOffset] = value;\n+    @Override\n+    public void setInt(int index, int value) {\n+        this.buffer.putInt(this.bufferPosition + index, value);\n     }\n \n-    /**\n-     * Gets a value indicating whether the ByteArraySegment is read-only.\n-     *\n-     * @return The value.\n-     */\n-    public boolean isReadOnly() {\n-        return this.readOnly;\n+    @Override\n+    public void setLong(int index, long value) {\n+        this.buffer.putLong(this.bufferPosition + index, value);\n     }\n \n+    //endregion\n+\n+    //region Other Operations\n+\n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n+    public void copyFrom(ArrayView source, int targetOffset, int length) {\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset, this.array, targetOffset + this.startOffset, length);\n+        System.arraycopy(source.array(), source.arrayOffset(), this.array(), this.bufferPosition + targetOffset, length);", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDUzMA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530480530", "bodyText": "See above. The ByteBuffer code resolves to this same call, so no point in doing extra invocations to achieve the same outcome.", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODIzMA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898230", "bodyText": "See above.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:46:08Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());\n     }\n \n-    //endregion\n+    @Override\n+    public void set(int index, byte value) {\n+        this.buffer.put(this.bufferPosition + index, value);\n+    }\n \n-    //region Operations\n+    @Override\n+    public void setShort(int index, short value) {\n+        this.buffer.putShort(this.bufferPosition + index, value);\n+    }\n \n-    /**\n-     * Sets the value at the specified index.\n-     *\n-     * @param index The index to set the value at.\n-     * @param value The value to set.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n-     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n-     */\n-    public void set(int index, byte value) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Preconditions.checkElementIndex(index, this.length, \"index\");\n-        this.array[index + this.startOffset] = value;\n+    @Override\n+    public void setInt(int index, int value) {\n+        this.buffer.putInt(this.bufferPosition + index, value);\n     }\n \n-    /**\n-     * Gets a value indicating whether the ByteArraySegment is read-only.\n-     *\n-     * @return The value.\n-     */\n-    public boolean isReadOnly() {\n-        return this.readOnly;\n+    @Override\n+    public void setLong(int index, long value) {\n+        this.buffer.putLong(this.bufferPosition + index, value);\n     }\n \n+    //endregion\n+\n+    //region Other Operations\n+\n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n+    public void copyFrom(ArrayView source, int targetOffset, int length) {\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset, this.array, targetOffset + this.startOffset, length);\n+        System.arraycopy(source.array(), source.arrayOffset(), this.array(), this.bufferPosition + targetOffset, length);\n     }\n \n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param sourceOffset The offset within source to start copying from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int sourceOffset, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Exceptions.checkArrayRange(sourceOffset, length, source.length, \"index\", \"values.length\");\n+    public void copyFrom(ArrayView source, int sourceOffset, int targetOffset, int length) {\n+        Exceptions.checkArrayRange(sourceOffset, length, source.getLength(), \"index\", \"values.length\");\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset + sourceOffset, this.array, this.startOffset + targetOffset, length);\n-    }\n-\n-    /**\n-     * Creates an OutputStream that can be used to write contents to this ByteArraySegment. The OutputStream returned\n-     * is a FixedByteArrayOutputStream (ByteArrayOutputStream that cannot expand) that spans the entire ByteArraySegment.\n-     *\n-     * @return The OutputStream.\n-     * @throws IllegalStateException If the ByteArraySegment is readonly.\n-     */\n-    public OutputStream getWriter() {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        return new FixedByteArrayOutputStream(this.array, this.startOffset, this.length);\n-    }\n-\n-    /**\n-     * Returns a new ByteArraySegment that is a sub-segment of this ByteArraySegment. The new ByteArraySegment wraps\n-     * the same underlying byte array that this ByteArraySegment does.\n-     *\n-     * @param offset   The offset within this ByteArraySegment where the new ByteArraySegment starts.\n-     * @param length   The length of the new ByteArraySegment.\n-     * @param readOnly Whether the resulting sub-segment should be read-only.\n-     *                 Note: if this ByteArraySegment is already read-only, this argument is ignored and the resulting\n-     *                 segment is read-only\n-     * @return The new ByteArraySegment.\n-     * @throws ArrayIndexOutOfBoundsException If offset or length are invalid.\n-     */\n-    public ByteArraySegment subSegment(int offset, int length, boolean readOnly) {\n-        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n-        return new ByteArraySegment(this.array, this.startOffset + offset, length, readOnly || this.readOnly);\n+        System.arraycopy(source.array(), source.arrayOffset() + sourceOffset, this.array(), this.bufferPosition + targetOffset, length);", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDU4OQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530480589", "bodyText": "Same", "author": "andreipaduroiu", "createdAt": "2020-11-25T15:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODkyOQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898929", "bodyText": "This is bad from. Please do a conditional.", "author": "tkaitchuck", "createdAt": "2020-11-24T21:47:27Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjQ0OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530482448", "bodyText": "Benchmarking has shown that conditional performs 10-15% worse than this. If did a conditional, I would have had to calculate the remaining length every time I invoke this method, which translates to extra CPU cycles.\nI am aware this is not super clean code, but it is optimized for the case where the value does fit - as that is by far the most common case.\nIMO, it is ok to be slightly sloppy here. This is extremely low-level code that is invoked very frequenty; any optimization here can speed up upstream code. And viceversa: any slowdown here has bad ramifications upstream.", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk4NTIxNg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r532985216", "bodyText": "It may be faster in the happy case, but this case it far from impossible and will be tens of thousands of times more costly in the unhappy case. It needs to be a very low probably for a 15% benefit to pay off on average. I see no evidence that this is the case here.", "author": "tkaitchuck", "createdAt": "2020-12-01T00:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0NzgyOQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r533747829", "bodyText": "I have reworked this class in the following way:\n\nI'm requiring that all component buffer lengths be a power of 2. This enables me to use bitwise operations to get buffer ids and buffer offsets (instead of expensive divisions and modulos).\nI created a BufferLayout, which in my case, is instantiated once and reused with every CompositeByteArrayInstance. This class precalculates the last offsets at which I can write longs, ints and shorts, so all I need to do is compare the offset with those values. That is less expensive than having do do a subtraction for every write.", "author": "andreipaduroiu", "createdAt": "2020-12-01T21:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTQzNA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529899434", "bodyText": "Same here", "author": "tkaitchuck", "createdAt": "2020-11-24T21:48:24Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjUwMw==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530482503", "bodyText": "See above.", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTY1MQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529899651", "bodyText": "Same here", "author": "tkaitchuck", "createdAt": "2020-11-24T21:48:49Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 3) {\n+            // We can only fit 3 bytes. Write as 1 short + 2 bytes.\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            bb.array()[bufferOffset + Short.BYTES] = (byte) (value >>> 8);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) value;\n+        } else if (diff == 2) {\n+            // We can only fit 2 bytes. Write as 2 shorts\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            getBuffer(bufferId + 1, true).putShort(0, (short) value);\n+        } else {\n+            // We can only fit 1 byte. Write as 2 bytes + 1 short.\n+            bb.array()[bufferOffset] = (byte) (value >>> 24);\n+            bb = getBuffer(bufferId + 1, true);\n+            bb.array()[0] = (byte) (value >>> 16);\n+            bb.putShort(1, (short) value);\n+        }\n+    }\n+\n+    @Override\n+    public void setLong(int offset, long value) {\n+        Exceptions.checkArrayRange(offset, Long.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putLong(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjU1Mg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530482552", "bodyText": "See above.", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMDA4Ng==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529900086", "bodyText": "At this point it might be easier to just have a for loop", "author": "tkaitchuck", "createdAt": "2020-11-24T21:49:12Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 3) {\n+            // We can only fit 3 bytes. Write as 1 short + 2 bytes.\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            bb.array()[bufferOffset + Short.BYTES] = (byte) (value >>> 8);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) value;\n+        } else if (diff == 2) {\n+            // We can only fit 2 bytes. Write as 2 shorts\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            getBuffer(bufferId + 1, true).putShort(0, (short) value);\n+        } else {\n+            // We can only fit 1 byte. Write as 2 bytes + 1 short.\n+            bb.array()[bufferOffset] = (byte) (value >>> 24);\n+            bb = getBuffer(bufferId + 1, true);\n+            bb.array()[0] = (byte) (value >>> 16);\n+            bb.putShort(1, (short) value);\n+        }\n+    }\n+\n+    @Override\n+    public void setLong(int offset, long value) {\n+        Exceptions.checkArrayRange(offset, Long.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putLong(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 7) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4Mzc2Ng==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530483766", "bodyText": "for loops take extra CPU cycles. See my explanation above. Plus I want to break down the long into as \"big\" components as I can so I can write them like that - bigger components may take advantage of intrinsic operations inside these serializers.\nSee how Unsafe.putLongUnaligned works. It follows exactly the same pattern and for the same reason: it's a very low-level API call which needs to be as optimized as possible.", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMDA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk4NjM0OQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r532986349", "bodyText": "If it is \"clear\" to the compiler that the loop is of small constant size, it can unroll it and make a computed jump. That would be more efficient than even this, and would look nice too.", "author": "tkaitchuck", "createdAt": "2020-12-01T00:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMDA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3MjY5OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r533772698", "bodyText": "Ok, I did not notice any difference when I ran this in a tight loop, but given that the code looks nicer, I have made the change anyway.", "author": "andreipaduroiu", "createdAt": "2020-12-01T22:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMDA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNDkzMg==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530024932", "bodyText": "It's very odd that this is called \"unsigned long\" because, as I understand it, the point of this method is so that negative numbers are sorted below positive ones when sorting by bytes. So it's not only relevant when dealing with exclusively positive numbers, if that were the case the method wouldn't be needed in the first place.\nI would term this \"sortable\" rather than unsigned, and I wouldn't make it part of this interface but a wrapper that implements all these same getInt getShort etc, so that it works with all of them.", "author": "tkaitchuck", "createdAt": "2020-11-25T00:11:15Z", "path": "common/src/main/java/io/pravega/common/util/StructuredReadableBuffer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+/**\n+ * {@link BufferView} whose contents can be interpreted as structured data.\n+ * See {@link StructuredWritableBuffer} for reading such data.\n+ */\n+public interface StructuredReadableBuffer extends BufferView {\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The byte at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n+     */\n+    byte get(int index);\n+\n+    /**\n+     * Gets the 16 bit Short value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Short at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    short getShort(int index);\n+\n+    /**\n+     * Gets the 32 bit Int value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Integer at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    int getInt(int index);\n+\n+    /**\n+     * Gets the 64 bit Long value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Long at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    long getLong(int index);\n+\n+    /**\n+     * Gets a 64 bit Unsigned Long from the specified index. This value must have been serialized using\n+     * {@link StructuredWritableBuffer#setUnsignedLong} for proper results. This method is not interoperable with\n+     * {@link StructuredWritableBuffer#setLong}.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Long at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    default long getUnsignedLong(int index) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTY4OQ==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530485689", "bodyText": "I moved this method from BitConverter while preserving the name.\nWe can consider renaming it in a subsequent change.", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNTE1OA==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530025158", "bodyText": "See my comment above.", "author": "tkaitchuck", "createdAt": "2020-11-25T00:11:54Z", "path": "common/src/main/java/io/pravega/common/util/StructuredWritableBuffer.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+/**\n+ * Modifiable {@link BufferView} whose contents can be interpreted as structured data.\n+ * See {@link StructuredReadableBuffer} for reading such data.\n+ */\n+public interface StructuredWritableBuffer extends BufferView {\n+    /**\n+     * Sets the value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Byte value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n+     */\n+    void set(int index, byte value);\n+\n+    /**\n+     * Sets a Short value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Short value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setShort(int index, short value);\n+\n+    /**\n+     * Sets a 32 bit Integer value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Integer value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setInt(int index, int value);\n+\n+    /**\n+     * Sets a 64 bit Long value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Long value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setLong(int index, long value);\n+\n+    /**\n+     * Sets a 64 bit Unsigned Long at the specified index. This value can then be deserialized using\n+     * {@link StructuredReadableBuffer#getUnsignedLong(int)}. This method is not interoperable with\n+     * {@link StructuredReadableBuffer#getLong}.\n+     *\n+     * The advantage of serializing as Unsigned Long (vs. a normal Signed Long) is that the serialization will have the\n+     * same natural order as the input value type (i.e., if compared using a lexicographic bitwise comparator such as\n+     * BufferViewComparator, it will have the same ordering as the typical Long type).\n+     *\n+     * @param index The index to set the value at.\n+     * @param value  The (signed) value to write. The value will be converted into the range [0, 2^64-1] before\n+     *               serialization by flipping the high order bit (so positive values will begin with 1 and negative values\n+     *               will begin with 0).\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    default void setUnsignedLong(int index, long value) {", "originalCommit": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTc1Ng==", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530485756", "bodyText": "Same", "author": "andreipaduroiu", "createdAt": "2020-11-25T16:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNTE1OA=="}], "type": "inlineReview"}, {"oid": "aaf68c051ed9142e56da2bf46f4c2e4e0b390eef", "url": "https://github.com/pravega/pravega/commit/aaf68c051ed9142e56da2bf46f4c2e4e0b390eef", "message": "Using ByteBuffer.position.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-25T16:07:04Z", "type": "commit"}, {"oid": "c9f6758daef34cb2049eeeb82e948dbb79e9b2be", "url": "https://github.com/pravega/pravega/commit/c9f6758daef34cb2049eeeb82e948dbb79e9b2be", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-27T14:02:25Z", "type": "commit"}, {"oid": "11def26ad28d1fe2912771853ff06ba2bc93dd05", "url": "https://github.com/pravega/pravega/commit/11def26ad28d1fe2912771853ff06ba2bc93dd05", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-30T15:34:54Z", "type": "commit"}, {"oid": "7368f916535edddff0fe63a1b7c68c6b480c58b7", "url": "https://github.com/pravega/pravega/commit/7368f916535edddff0fe63a1b7c68c6b480c58b7", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-11-30T21:34:26Z", "type": "commit"}, {"oid": "63e93a8581ba43ef22832f50ad34ba53b32a9f55", "url": "https://github.com/pravega/pravega/commit/63e93a8581ba43ef22832f50ad34ba53b32a9f55", "message": "Optimizing CompositeByteArraySegment\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-01T22:45:39Z", "type": "commit"}, {"oid": "80432df46bcbe62310113cb0e3e735562d3874cc", "url": "https://github.com/pravega/pravega/commit/80432df46bcbe62310113cb0e3e735562d3874cc", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-12-01T22:46:09Z", "type": "commit"}, {"oid": "97805e9136065741c9f04c3cbbd1908129d3a781", "url": "https://github.com/pravega/pravega/commit/97805e9136065741c9f04c3cbbd1908129d3a781", "message": "do-while -> while\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-02T04:27:27Z", "type": "commit"}, {"oid": "46d136f620bd951062d0b13ad8708d3005ec87e6", "url": "https://github.com/pravega/pravega/commit/46d136f620bd951062d0b13ad8708d3005ec87e6", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-12-02T16:00:43Z", "type": "commit"}, {"oid": "fa4a234cb7ae56f25f5d3d189f768fe2f486be5f", "url": "https://github.com/pravega/pravega/commit/fa4a234cb7ae56f25f5d3d189f768fe2f486be5f", "message": "Merge branch 'master' into issue-5296-fast-serializers", "committedDate": "2020-12-02T20:49:25Z", "type": "commit"}]}