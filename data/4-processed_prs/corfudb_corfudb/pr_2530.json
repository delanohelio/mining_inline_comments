{"pr_number": 2530, "pr_title": "CorfuStore: Lightweight Streaming Layer", "pr_createdAt": "2020-05-04T07:39:23Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2530", "timeline": [{"oid": "4f035c6214110a2fff37ec4046e83420ff9e6d2f", "url": "https://github.com/CorfuDB/CorfuDB/commit/4f035c6214110a2fff37ec4046e83420ff9e6d2f", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-05T22:14:12Z", "type": "forcePushed"}, {"oid": "ec70e58c4f78279c1df4af1ee70b06e5678d3565", "url": "https://github.com/CorfuDB/CorfuDB/commit/ec70e58c4f78279c1df4af1ee70b06e5678d3565", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-06T18:17:26Z", "type": "forcePushed"}, {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "url": "https://github.com/CorfuDB/CorfuDB/commit/59476c21f4a0e204c15446fdd71f8429cfb3a770", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-20T18:51:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428830810", "bodyText": "Since you implement pub-sub, it would be great if you could use https://www.reactive-streams.org/ instead of self-written protocols.\nreactive-streams is a part of Java 9, so when we migrate to newer versions of java it can be used natively", "author": "xnull", "createdAt": "2020-05-21T18:21:04Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODk4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428858989", "bodyText": "sure - we would be asked to move to Java 11 shortly anyway, but as of Java 8 this functionality is not available. Also this gives us fine grained control over how the streams should behave.", "author": "hisundar", "createdAt": "2020-05-21T19:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNTk1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428905959", "bodyText": "you can add a dependency when we migrate to the new version of java we just get rid of that dependency.\nAlso, you write a lot of code which makes migration to reactive streams more and more complicated over time, we would end up with our custom version, now is the best time to migrate, it's cheap and safe and takes a couple of hours of work", "author": "xnull", "createdAt": "2020-05-21T20:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNzU1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428917556", "bodyText": "Well this implementation is 600 lines of lesser code compared to previous (existing). It's just one file, so can't think of an easier way to migrate to RxJava if we should decide to use it in the future.\nAlso its not just dependency, RxJava internally uses a thread pool based on a publisher subscriber model. The use of separate publisher + subscriber is the root cause of the very bug which prompted this change, so we have to be careful about adding back a publisher-subscriber based model. For now, it makes sense to have something that works and more importantly does not break anything.", "author": "hisundar", "createdAt": "2020-05-21T21:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTE4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428919188", "bodyText": "I'm not talking about RxJva, only reactive-streams, it's much smaller", "author": "xnull", "createdAt": "2020-05-21T21:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MDgzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429450836", "bodyText": "reactive-streams is also based on a publisher-subscriber model with functionality for backpressure both of which are anti-patterns given the current use case where we have JVMs with low heap space needing to selectively poll. In the current form where we still have a big global TRANSACTION_STREAM anything other than simple threads processing one mutation at a time will hit issues.\nNow that is not to say reactive-streams should not be used. We need the stream tagging feature first. That will allow us to be selective in streaming at which point we would be able to have better control over the subscriptions and we can avoid OOMs. Until then we do need fine grained control over how stream listeners work. Using direct threads achieves just that in probably the simplest way possible.", "author": "hisundar", "createdAt": "2020-05-22T21:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMzQ5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428833493", "bodyText": "Creating a new thread could be an expensive operation, probably reactive-streams already solved this problem internally in an efficient way", "author": "xnull", "createdAt": "2020-05-21T18:26:02Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODQ1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428858452", "bodyText": "Threads are not going to be created and destroyed often, it should be just once per lifecycle of the process.", "author": "hisundar", "createdAt": "2020-05-21T19:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDA2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428834069", "bodyText": "it should be static in the other case make it non-caps", "author": "xnull", "createdAt": "2020-05-21T18:27:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTIxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428859217", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T19:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDk0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428834940", "bodyText": "could be race condition here, please use ConcurrentHashMap", "author": "xnull", "createdAt": "2020-05-21T18:28:41Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNTY5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428835691", "bodyText": "Oh I see, you use synchronized. But what's the point for that if we can use ConcurrentHashMap? Also I suspect all these things already implemented and tested in reactive-streams", "author": "xnull", "createdAt": "2020-05-21T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDY5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428864694", "bodyText": "subscribe() unsubscribe() where the synchronized is used are lifecycle methods, they won't be called often. It's more like once per lifecycle of the process so concurrency is not required, the goal of these concurrency primitives is just correctness.", "author": "hisundar", "createdAt": "2020-05-21T19:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjAyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428836023", "bodyText": "log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener);", "author": "xnull", "createdAt": "2020-05-21T18:30:40Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1Njk4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856987", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T19:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjk1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428836957", "bodyText": "I'm concerned, probably we gonna create too many threads", "author": "xnull", "createdAt": "2020-05-21T18:32:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjgzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856839", "bodyText": "We have a cap on it at MAX_SUBSCRIBERS currently set to an arbitrary value of 12.", "author": "hisundar", "createdAt": "2020-05-21T19:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjAzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428866035", "bodyText": "Also we are talking about 1 thread per business vertical so number of threads is currently just one. However one can argue that even if there are multiple threads since they correspond to actual business verticals they should be fully justified.", "author": "hisundar", "createdAt": "2020-05-21T19:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzQzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428837433", "bodyText": "Should be AtomicBoolean", "author": "xnull", "createdAt": "2020-05-21T18:33:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjIwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856203", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T19:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzY4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428837689", "bodyText": "NIT: When concating the strings I think its better to have spaces around +", "author": "PavelZaytsev", "createdAt": "2020-05-21T18:34:01Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjEzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856131", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T19:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMzM0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428923342", "bodyText": "I would vote for log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener);\nAt least it won't create an additional instance of a String, and appears prettier", "author": "xnull", "createdAt": "2020-05-21T21:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428852235", "bodyText": "The exception name makes sense for the second case, but seems confusing for the first case.", "author": "WenbinZhu", "createdAt": "2020-05-21T19:01:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTUxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428859513", "bodyText": "also, typo in 'subscriber'", "author": "pankti-m", "createdAt": "2020-05-21T19:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2OTkwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428869905", "bodyText": "yes, just wanted to prevent adding another exception since each exception raises more questions that need explanation and answering. Thought the message in the exception makes the difference right?", "author": "hisundar", "createdAt": "2020-05-21T19:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3NTUxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428875516", "bodyText": "What I meant was changing the name of exception to a more genral one and the messages in it can be different.", "author": "WenbinZhu", "createdAt": "2020-05-21T19:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODc4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428908784", "bodyText": "understood, sure will do that. thanks", "author": "hisundar", "createdAt": "2020-05-21T20:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428855064", "bodyText": "I think it's cleaner to put the try catch block outside the while loop, because once it hits exception, it is stopped. And preferrably also combine the the first try catch block for txnStream.seek(), they seem to be the same.", "author": "WenbinZhu", "createdAt": "2020-05-21T19:07:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MTM5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428871398", "bodyText": "I will put the try catch outside the while, but can't combine it with the first.\nThe first exception is distinctly different. It happens when a subscriber is trying to start from a trimmed address which is different from a subscriber hitting a trimmed exception during normal operation.", "author": "hisundar", "createdAt": "2020-05-21T19:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3NjA2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428876065", "bodyText": "Actually seek() should not raise any exception as it just moves the pointer, but it's ok to be defensive.", "author": "WenbinZhu", "createdAt": "2020-05-21T19:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjA0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856049", "bodyText": "This should be trace right?", "author": "WenbinZhu", "createdAt": "2020-05-21T19:09:07Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {\n+                    while (!txnStream.hasNext()) {\n+                        log.debug(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MDQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428870481", "bodyText": "done. I put it in debug because it was helpful for debugging this on a live setup.", "author": "hisundar", "createdAt": "2020-05-21T19:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTA3NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428859074", "bodyText": "nit - space after + signs", "author": "pankti-m", "createdAt": "2020-05-21T19:15:34Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MzExOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428873119", "bodyText": "fixed, thanks", "author": "hisundar", "createdAt": "2020-05-21T19:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzkwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428863905", "bodyText": "nit: spaces around '+'", "author": "pankti-m", "createdAt": "2020-05-21T19:24:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {\n+                    while (!txnStream.hasNext()) {\n+                        log.debug(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                            // Only extract the list of updates per stream as a list\n+                            multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                    CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                    epoch,\n+                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                            ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        log.debug(\"{}::onNext took {} ms\", listener.toString(),\n+                                TimeUnit.NANOSECONDS.toMillis(onNextEnd - onNextStart));\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(\"CorfuSubscriber: \"+namespace+\":\"+listener.toString());", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDYzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428864638", "bodyText": "also isnt it more clear this way? \"corfusubscriber: listener.toString() + namesapace\"?", "author": "pankti-m", "createdAt": "2020-05-21T19:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3NDE5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428874199", "bodyText": "yes it is, fixed, thanks", "author": "hisundar", "createdAt": "2020-05-21T19:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjgwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428866801", "bodyText": "is the client expected to know the start address of the stream of interest?  Is it possible for the client to have this info in a clean way?", "author": "pankti-m", "createdAt": "2020-05-21T19:30:37Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -173,7 +170,7 @@ public Query query(@Nonnull final String namespace) {\n     void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n                    @Nonnull List<TableSchema> tablesOfInterest,\n                    @Nullable Timestamp timestamp) {\n-        txnStreamingManager.subscribe(streamListener, namespace, tablesOfInterest,\n+        streamManager.subscribe(streamListener, namespace, tablesOfInterest,\n                 (timestamp == null) ? getTimestamp().getSequence() : timestamp.getSequence());", "originalCommit": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3NjQ0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428876442", "bodyText": "CorfuStore exposes an api called getTimestamp() which abstracts the internal start address of the stream. Please check out Timestamp in CorfuStoreMetadata.", "author": "hisundar", "createdAt": "2020-05-21T19:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjgwMQ=="}], "type": "inlineReview"}, {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "url": "https://github.com/CorfuDB/CorfuDB/commit/152eeb47f631be762a96d16b94601cf8b4cff2a6", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-21T20:02:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNzM0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428907347", "bodyText": "please rename the variable, it is not a constant", "author": "xnull", "createdAt": "2020-05-21T20:51:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;", "originalCommit": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMzU4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428913588", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T21:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNzM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0ODQ1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428948455", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T22:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNzM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDY2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428910665", "bodyText": "looks like there is a problem here, you do not handle InterruptedException it means there could be problems when other threads will try to stop this thread. Intellij IDEA should makes this line yellow with the warning/explanation.\nP.S. I know you execute interrupt() in unsubscribe method. I can't require you or claim but the way how this while cycle is written seems fragile to me", "author": "xnull", "createdAt": "2020-05-21T20:57:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {", "originalCommit": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMDE5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428920194", "bodyText": "StreamingIT.java has a test case that covers unsubscribe() and validate that it does not receive any future updates. That test seems to be working as expected.\nBut if you have an alternate better way please suggest. For now I am just relying on the fact that InterruptedException is also a type of Throwable\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/InterruptedException.html", "author": "hisundar", "createdAt": "2020-05-21T21:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTAxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428911011", "bodyText": "no need for return", "author": "xnull", "createdAt": "2020-05-21T20:58:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;", "originalCommit": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMzgxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428913816", "bodyText": "removed, thanks", "author": "hisundar", "createdAt": "2020-05-21T21:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTIyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428911221", "bodyText": "please use String.format", "author": "xnull", "createdAt": "2020-05-21T20:59:01Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(\"CorfuSubscriber: \" + listener.toString() + \":\" + namespace);", "originalCommit": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNDY3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428914671", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T21:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTIyMQ=="}], "type": "inlineReview"}, {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14", "url": "https://github.com/CorfuDB/CorfuDB/commit/0199b7b79e73c28e6916bde8835567a3a916da14", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-21T21:22:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODExMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428928112", "bodyText": "It would be great if you fix all yellows in the code, some of them could indicate about fragility in the code some bout bugs, thanks", "author": "xnull", "createdAt": "2020-05-21T21:33:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>", "originalCommit": "0199b7b79e73c28e6916bde8835567a3a916da14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODU5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428928599", "bodyText": "looks like you forgot to add K,V,T into TableSchema signature", "author": "xnull", "createdAt": "2020-05-21T21:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1MTM1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428951357", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T22:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMzI3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428933278", "bodyText": "Sorry my bad, the format has to be\nsuper(String.format(\"CorfuSubscriber: %s:%s\", listener, namespace));", "author": "xnull", "createdAt": "2020-05-21T21:44:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(String.format(\"CorfuSubscriber: {}:{}\", listener.toString(), namespace));", "originalCommit": "0199b7b79e73c28e6916bde8835567a3a916da14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NzA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428947064", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-05-21T22:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428945983", "bodyText": "If I understand it properly what you are trying to do is to have scheduler which will run your task periodically.\nYou can use java scheduler and it simplifies code. You will not need to check shutdown variable, no need for thread.sleep, catching exceptions to stop the thread, and so on.\nPlease take a look simplifyStreaming...simplifyStreaming-scheduler", "author": "xnull", "createdAt": "2020-05-21T22:17:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {", "originalCommit": "0199b7b79e73c28e6916bde8835567a3a916da14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NjM5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428946394", "bodyText": "Also you can have as many threads as you need (scheduler threadfctory)", "author": "xnull", "createdAt": "2020-05-21T22:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0OTczOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428949738", "bodyText": "Your implementation seems to be creating one thread factory in every thread. Why?", "author": "hisundar", "createdAt": "2020-05-21T22:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1MDk1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428950950", "bodyText": "Please see https://stackoverflow.com/a/50077162/4513389 for why this is an overkill for this use case.", "author": "hisundar", "createdAt": "2020-05-21T22:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1MzIxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428953215", "bodyText": "It's just a dirty example, you can put scheduler and factory into places where the should be", "author": "xnull", "createdAt": "2020-05-21T22:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTAxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428959014", "bodyText": "Please see https://stackoverflow.com/a/50077162/4513389\n\nA very weird explanation, not sure what that guy tried to say :)", "author": "xnull", "createdAt": "2020-05-21T22:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0MjExOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429042118", "bodyText": "scheduler type model with a thread pool is exactly what we have currently (please check out the code that was removed by this PR) - the problem is when you have varying rates of consumption we have multiple tasks executing in the same thread and the heap (from thread local data) grows too quickly for JVMs with low heap space to handle. This is the very bug which prompted this simplification in the first place.\nAdding back a scheduler and factory model where multiple tasks are going to execute on the same thread will simply bring back the very problem we are trying to fix.", "author": "hisundar", "createdAt": "2020-05-22T04:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NDUwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429044502", "bodyText": "I don't believe that scheduler could be a problem in this case. I don't see how it could be possible in java when \"the heap (from thread local data) grows too quickly\" it sounds a bit odd, also if you just replace scheduler by threads I'm pretty sure it doesn't improve anything just by definition it can't improve performance/resource utilization/consumption.\nSo, it's up to you, but replacing scheduler by threads not a good idea imo (usually threads gett replaced by scheduler)", "author": "xnull", "createdAt": "2020-05-22T05:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MzQxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429343413", "bodyText": "It's not a problem with scheduler, but a problem with having multiple tasks executing on the same thread pulling different set of log data objects from stream layer.\nSo to avoid that we really need only have one task running on one thread. Given this requirement a scheduler is really pointless which is what the stackoverflow link above is trying to explain. Once we move to stream tagged selective streaming we will now be able to selectively pull items, at which point it might make sense to consider multiple tasks on a thread or thread factory or pools or even the reactive-streams framework if it makes sense. Technologies have to be applied to serve use cases not the other way around right?", "author": "hisundar", "createdAt": "2020-05-22T16:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxNzk2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429417961", "bodyText": "Let's clarify.\nInvariants:\n\na thread can execute one task at a time, it's not possible to execute many tasks by one thread at a time\nyour task must not keep any state in the thread, you shouldn't use ThreadLocal variables if you want to use a common pool of threads.\n\nIf I understand it properly, we have some ThreadLocal variables which bring side effects?\nIf that true, then it's poor design/implementation in Corfu and we are trying to hack it here and make it work.\nIf I'm wrong then ok, but I don't see how using a scheduler can be in any way worse than using threads. I would prefer to fix a problem in the design than replace a better solution by a more complex and fragile solution", "author": "xnull", "createdAt": "2020-05-22T19:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NzcyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429447720", "bodyText": "Here is a simpler question - why do you need a thread scheduler/factory if a thread only needs to ever execute one task?", "author": "hisundar", "createdAt": "2020-05-22T20:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw=="}], "type": "inlineReview"}, {"oid": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "url": "https://github.com/CorfuDB/CorfuDB/commit/cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-05-21T22:20:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1ODc2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429358767", "bodyText": "Here we call remaining(). that could cause the high memory usage. Instead of call remaining(), we can call remainUpto(offset + 40).\nWe can do something like this:\npollTxStream() {\nn = 0;\nwhile {\nn = polltxstream(upto);\n} do (n > 0)", "author": "xiaoqin2012", "createdAt": "2020-05-22T17:02:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TransactionPoller.java", "diffHunk": "@@ -1,111 +0,0 @@\n-package org.corfudb.runtime.collections;\n-\n-import lombok.Getter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.List;\n-import java.util.LinkedList;\n-import java.util.Comparator;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nonnull;\n-\n-import org.corfudb.protocols.wireprotocol.ILogData;\n-import org.corfudb.runtime.CorfuRuntime;\n-import org.corfudb.runtime.view.ObjectsView;\n-import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n-\n-/**\n- *\n- * Created by sneginhal on 10/22/2019.\n- */\n-@Slf4j\n-public class TransactionPoller implements Runnable {\n-\n-    /**\n-     * Corfu Runtime.\n-     */\n-    private final CorfuRuntime runtime;\n-\n-    /**\n-     * List of StreamingSubscriptionContexts to process.\n-     *\n-     * This is the list of StreamingSubscriptionContexts sorted by the last read addresses.\n-     */\n-    private final List<StreamingSubscriptionContext> streamContexts;\n-\n-    /**\n-     * A reference to the transaction stream\n-     */\n-    @Getter\n-    private final IStreamView txnStream;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param streams The list of StreamingSubscriptionContexts to process.\n-     */\n-    public TransactionPoller(@Nonnull CorfuRuntime runtime,\n-                             @Nonnull List<StreamingSubscriptionContext> streams) {\n-        this.runtime = runtime;\n-        this.streamContexts = streams.stream()\n-                .sorted(Comparator.comparingLong(sc -> sc.getLastReadAddress()))\n-                .collect(Collectors.toList());\n-\n-        StreamOptions options = StreamOptions.builder()\n-                .cacheEntries(false)\n-                .build();\n-\n-        txnStream = runtime.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n-    }\n-\n-    /**\n-     *\n-     */\n-    @Override\n-    public void run() {\n-        try {\n-            pollTxStream();\n-        } catch (Throwable t) {\n-            // We don't want the thread running the poller to be terminated due to\n-            // some unexpected exception, so catch all here.\n-            log.error(\"Encountered an exception while polling the txn stream: {}\", t);\n-\n-            streamContexts.forEach(sc -> sc.setPollerException(t));\n-        } finally {\n-            streamContexts.forEach(sc -> sc.release());\n-        }\n-    }\n-\n-    private void pollTxStream() {\n- \n-        long lastReadAddress = streamContexts.get(0).getLastReadAddress();\n-\n-        log.trace(\"Seeking txStream to {}\", lastReadAddress + 1);\n-        txnStream.seek(lastReadAddress + 1);\n-        log.trace(\"txStream current global position after seeking {}, hasNext {}\",\n-                txnStream.getCurrentGlobalPosition(), txnStream.hasNext());\n-\n-        List<ILogData> updates = txnStream.remaining();", "originalCommit": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2MTgzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429361831", "bodyText": "remainingUpto() was the first thing I tried when trying to fix the OOM issue before trying this rewrite.\nThe problem is when you have a publisher subscriber model even if you poll 40 items ahead of current cursor and if only one of those 40 is needed while 39 are not, that whole batch cannot be garbage collected. Since we have one big TRANSACTION_STREAM to which the whole world tags transactions any attempt at batching hits this problem. Which is why to avoid the issue we just go one at a time so we are sure that nothing is held back.", "author": "hisundar", "createdAt": "2020-05-22T17:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1ODc2Nw=="}], "type": "inlineReview"}, {"oid": "660f74198726a97e9e83d729cad1dfff687877fd", "url": "https://github.com/CorfuDB/CorfuDB/commit/660f74198726a97e9e83d729cad1dfff687877fd", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability.", "committedDate": "2020-06-17T17:54:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjk0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452606945", "bodyText": "I think its cleaner to pass a config type that has this as a default.", "author": "Maithem", "createdAt": "2020-07-10T03:46:17Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExOTA4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453119082", "bodyText": "a RuntimeParameter?\nok will do that.", "author": "hisundar", "createdAt": "2020-07-10T23:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2NTI3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453165273", "bodyText": "Maybe just pass it through the constructor. I think we need to reduce the CorfuRuntimeParamters configs significantly.", "author": "Maithem", "createdAt": "2020-07-11T06:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1NjIzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r487356233", "bodyText": "fixed.", "author": "hisundar", "createdAt": "2020-09-12T02:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQ2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452607462", "bodyText": "These are not deamon threads, they can hang the JVM on exit.", "author": "Maithem", "createdAt": "2020-07-10T03:48:35Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExOTY0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453119642", "bodyText": "making them daemon threads create other problems, it will ends up masking issues where the vertical subscription thread which should be shutdown before JVM shutdown aren't told to exit. we saw this problem with a few consumers.", "author": "hisundar", "createdAt": "2020-07-10T23:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2NTQ3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453165470", "bodyText": "The streamManager should have some shutdown/close logic where the threads are stopped properly and an exit callback is fired for the subscribers. Not exposing a close method and not managing the life-cycle inside the runtime is kind of problematic. Its not clear whose responsible for releasing those resources.", "author": "Maithem", "createdAt": "2020-07-11T07:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1NjIzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r487356230", "bodyText": "just realized what you are describing as a problem is exactly the solution we want - we DO want to hang the JVM on exit otherwise corfu becomes responsible for an application level bug where the caller did not cleanly unsubscribe() and shutdown the subscription threads.\nCallers are supposed to explicitly detect JVM shutdown and invoke unsubscribe()\nunsubscribe() is the shutdown/close logic.", "author": "hisundar", "createdAt": "2020-09-12T02:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzY3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452607678", "bodyText": "Please name these threads accordingly. Otherwise, its can be hard to profile/debug.", "author": "Maithem", "createdAt": "2020-07-10T03:49:39Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExOTY2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453119667", "bodyText": "will do this. thanks", "author": "hisundar", "createdAt": "2020-07-10T23:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTEwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452609103", "bodyText": "On unsubscribe the stream is not removed from the StreamsView. A series of subscribe/unsubscribe can create a stream leak.", "author": "Maithem", "createdAt": "2020-07-10T03:55:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+            }\n+        }\n+\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                                  long startAddress) {\n+            super(String.format(\"CorfuSubscriber: %s:%s\", listener.toString(), namespace));\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(false)\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        }", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExOTY5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453119695", "bodyText": "thanks will do this.", "author": "hisundar", "createdAt": "2020-07-10T23:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTc4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452609786", "bodyText": "I wouldn't use this API. It's not used and might be buggy. I recommend that you just try to sync anyways. If there are no deltas, the callbacks won't trigger.", "author": "Maithem", "createdAt": "2020-07-10T03:59:10Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExOTkxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453119913", "bodyText": "ok - will choose to sleep if there are no deltas. btw we should consider either fixing this buggy api or removing it\nI see it used in other places as well.", "author": "hisundar", "createdAt": "2020-07-10T23:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2NTYwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453165606", "bodyText": "AbstractContextStreamView::hasNext is actually not being used by the VLO, or internal streaming that's why I'm recommending not to use it, we just dont know it it works. Maybe you can just remove it from the stream API itself.", "author": "Maithem", "createdAt": "2020-07-11T07:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMjE0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452612148", "bodyText": "This will eventually call interrupt on its own self. After the interrupt there is a log line. Once a thread is interrupted it's possible that the subsequent io call fails with ClosedByInterruptException or similar interrupted exceptions.\nAnyways, it seems like the unsubscribe was designed to be called from a different thread, not the thread itself.", "author": "Maithem", "createdAt": "2020-07-10T04:10:56Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzM0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452613347", "bodyText": "Spawning a thread per subscriber seems to be too expensive for what's being achieved.\nI think its better to multiplex these over an executor. The polling logic and life-cycle management is also cleaner with a scheduler executor. You can submit a periodic job that syncs the subscription streams, that will give you a task future that can be canceled. I think that's cleaner than managing the life cycle of the thread yourself.\nI think the code already has some bugs related to the thread life cycle management, so maybe consider just using a scheduled executor.", "author": "Maithem", "createdAt": "2020-07-10T04:16:36Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTE5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453121190", "bodyText": "this was the same comment by @xnull and while it is valid - the plan was to specifically limit this to one thread per subscriber for\n\nkeeps the memory taken by a subscriber completely local to a thread\nlimits the number of threads/subscribers very explicitly\n\nbut the pool idea is definitely valid, I had planned to use it after we have stream tagging because that will change the threading model again.", "author": "hisundar", "createdAt": "2020-07-10T23:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2NTg1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453165858", "bodyText": "A scheduled executor will achieve point 1 and 2. I just don't see a strong reason for not using a scheduled executor.\nMight be missing something, but I don't see this as an intermediate step and I don't see it's relationship with stream tagging.", "author": "Maithem", "createdAt": "2020-07-11T07:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzYxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452613611", "bodyText": "Instead of extending from RuntimeException I think we should introduce CorfuClientExceptions and extend from that. Right now our API with the application is not well-defined and that would be the right step forward.", "author": "Maithem", "createdAt": "2020-07-10T04:17:43Z", "path": "runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.corfudb.runtime.exceptions;\n+\n+/**\n+ * CorfuStore only allows one subscriber for a given namespace.\n+ * If an attempt is made to register another subscriber without terminating or unsubscribing\n+ * the existing subscriber on that namespace this exception will be thrown.\n+ */\n+public class StreamSubscriptionException extends RuntimeException {", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTIxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453121213", "bodyText": "ok - will explore this. thanks", "author": "hisundar", "createdAt": "2020-07-10T23:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzMjM2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452632366", "bodyText": "Can you also implement a close that runtime calls on shutdown ?", "author": "Maithem", "createdAt": "2020-07-10T05:40:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;", "originalCommit": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTIyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453121227", "bodyText": "currently runtime has no visibility into CorfuStore, since CorfuStore runs above.\nneed to figure out a way to tie those two together. if you have any ideas on this, please share.", "author": "hisundar", "createdAt": "2020-07-10T23:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzMjM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2NTcxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r453165710", "bodyText": "I see, but we still need a close method, so that the consumer can explicitly call close if not the our runtime.", "author": "Maithem", "createdAt": "2020-07-11T07:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzMjM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MDA1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488380050", "bodyText": "tied up the runtime.close() to shutdown the executor pool.", "author": "hisundar", "createdAt": "2020-09-15T04:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzMjM2Ng=="}], "type": "inlineReview"}, {"oid": "f1bb1c2d38991ae9a494b27e44741672392a097b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f1bb1c2d38991ae9a494b27e44741672392a097b", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T00:02:59Z", "type": "forcePushed"}, {"oid": "93d834e7710f02680219ef8c93b449c223faa825", "url": "https://github.com/CorfuDB/CorfuDB/commit/93d834e7710f02680219ef8c93b449c223faa825", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T00:07:08Z", "type": "forcePushed"}, {"oid": "d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "url": "https://github.com/CorfuDB/CorfuDB/commit/d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T04:56:26Z", "type": "forcePushed"}, {"oid": "ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "url": "https://github.com/CorfuDB/CorfuDB/commit/ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T05:51:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTMyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488329322", "bodyText": "getTableRegistry() is lazily evaluated, so if the runtime never uses CorfuStore, then taleRegistry will never be created, but when shutting down, calling this will create a new tableRegistry which is not trival (tableRegistry constructor will do io to register itself). I think this needs to be taken care of.", "author": "WenbinZhu", "createdAt": "2020-09-15T01:34:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/CorfuRuntime.java", "diffHunk": "@@ -837,6 +837,7 @@ private void handleUncaughtThread(@Nonnull Thread thread, @Nonnull Throwable thr\n     public void shutdown() {\n         // Stopping async task from fetching layout.\n         isShutdown = true;\n+        getTableRegistry().shutdown();", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3NjUwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489076501", "bodyText": "fixed to remove lombok and explicitly implement the getTableRegistry() construct", "author": "hisundar", "createdAt": "2020-09-15T23:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Mzg1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488353850", "bodyText": "Can convert to local variable.", "author": "WenbinZhu", "createdAt": "2020-09-15T03:01:44Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1MjEwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488852100", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-15T17:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Mzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1NTg4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488355885", "bodyText": "The comment in the StreamSubscriptionException.java says this is thrown when subscribing to the same namespace, but how does the code here preventing that? subscriptions.containsKey(streamListener) checks the streamListener's hashcode() and equals(), but does not check for namespace, which means if client uses a new streamListener but subscribing to same namespace, it's still allowed, right?  Also the original implentation allows subscribing to the same namespace and even same table, is there a reason to change that behavior?", "author": "WenbinZhu", "createdAt": "2020-09-15T03:09:51Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NDg2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488854865", "bodyText": "Subscribing to same namespace and table is allowed. Which is why we caller's hashcode() and equals() are used to validate re-subscription.\nIf the caller does not want to start another subscriber on the same namespace and table, then the hashcode should be constructed from listener name. If caller wants to allow 2 subscriptions on the same namespace+table, then hashcode and equals can just reflect the subscriber's name or other distinguishing fields.\nMentioning this in the comments too.", "author": "hisundar", "createdAt": "2020-09-15T17:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1NTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NjQ4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488856487", "bodyText": "Basically we are saying, \"hey you decide if this is a re-subscription or a new subscription\"", "author": "hisundar", "createdAt": "2020-09-15T17:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1NTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4NTMzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488885336", "bodyText": "Yea my point is the comment in the StreamSubscriptionException should be consistent with the implementation here.", "author": "WenbinZhu", "createdAt": "2020-09-15T18:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1NTg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Njc3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488356777", "bodyText": "I think there should be a limit on maxSubscribers, especially now we have a poller per subscription which increases IO. Besides the tasks scheduled to be run are in an infinite loop (if new data can be fetched), which means if you have more than maxSubscribers subscriptions, it's possible that the new subscriptions will never be scheduled, right?", "author": "WenbinZhu", "createdAt": "2020-09-15T03:13:03Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NzYyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488857629", "bodyText": "That is what I added before, please see comments from @xnull  and @Maithem . I am open to either suggestion.\nNot having a limit means that it will be up to the caller to ensure that they don't create too many subscribers but if they do know what they are doing, then we don't limit that behavior.", "author": "hisundar", "createdAt": "2020-09-15T17:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Njc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1ODEyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488358127", "bodyText": "Maybe we need to make openedStreams a HashSet instead of a List", "author": "WenbinZhu", "createdAt": "2020-09-15T03:17:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/StreamsView.java", "diffHunk": "@@ -104,6 +104,13 @@ public void clear() {\n         openedStreams.clear();\n     }\n \n+    /**\n+     * Remove a specific stream from openedStreams\n+     */\n+    public void removeStream(IStreamView stream) {\n+        openedStreams.remove(stream);", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1ODI0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488858242", "bodyText": "I thought about this, but going by what @apavan said, I wanted to limit the changes made in this PR to just the bug fix.\nunsubscribe() resubscribe() should be very infrequent operations anyway.", "author": "hisundar", "createdAt": "2020-09-15T17:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1ODEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1OTgwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488359809", "bodyText": "I suggest not pass true to cancel(). This will raise UnrecoverableCorfuInterruptedError. We saw a lot of such bugs, and nowadays we are confident to punt these bugs to verticals because corfu never do thread.interupt() or future.cancel(true).", "author": "WenbinZhu", "createdAt": "2020-09-15T03:24:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2MTUxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488361510", "bodyText": "I think we should disable cache for the poller. If you look at privous corfustore stream or our DCN, they both disabled cache to avoid polluting addressSpaceView cache, which could cause a lot of NoRollbackException.", "author": "WenbinZhu", "createdAt": "2020-09-15T03:31:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMTY4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488831680", "bodyText": "sounds good. will do.", "author": "hisundar", "createdAt": "2020-09-15T17:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2MTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3NDg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488374880", "bodyText": "Maybe these two debug messages should be trace level since they are for every update, which will be noisy.", "author": "WenbinZhu", "createdAt": "2020-09-15T04:24:49Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMTk0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488831942", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-15T17:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg2MDU2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488860566", "bodyText": "well not the second one, the second one is needed to debug log running tasks", "author": "hisundar", "createdAt": "2020-09-15T17:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3NDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3ODEwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488378104", "bodyText": "This check is not need, if logData is null, you will break out of the loop in line 201.", "author": "WenbinZhu", "createdAt": "2020-09-15T04:37:17Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);\n+                    break;\n+                }\n+            } while (logData != null);", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMjI5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488832295", "bodyText": "true, just wanted a conditional loop instead of an infinite loop.", "author": "hisundar", "createdAt": "2020-09-15T17:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3ODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MjU1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488382552", "bodyText": "I think unsubscribe should be before onError. If there is an error, verticals need to resubscribe, which should be unsubscribe beforehand. By the way I check current vertical's code, they are actully doing nothing but logging in onError(), which I think is not correct.", "author": "WenbinZhu", "createdAt": "2020-09-15T04:47:00Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);", "originalCommit": "93d834e7710f02680219ef8c93b449c223faa825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzg2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488833866", "bodyText": "hmm unsubscribe() calls the executor pool's thread cancel will might interrupt the thread. I don't know the implications of executing code after interrupt is invoked on the thread.", "author": "hisundar", "createdAt": "2020-09-15T17:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5OTIyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488899225", "bodyText": "This is another comment I had, but that was folded by github, so you probably didn't see it, so pasting here:\n\"I suggest not pass true to cancel(). This will raise UnrecoverableCorfuInterruptedError. We saw a lot of such bugs, and nowadays we are confident to punt these bugs to verticals because corfu never do thread.interupt() or future.cancel(true).\"", "author": "WenbinZhu", "createdAt": "2020-09-15T19:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3MzUxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489073518", "bodyText": "now fixed based on offline discussion about not interrupting thread at all. Brought back the shutdown variable.", "author": "hisundar", "createdAt": "2020-09-15T23:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Njg4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488396885", "bodyText": "Unused variable.", "author": "WenbinZhu", "createdAt": "2020-09-15T05:36:35Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;", "originalCommit": "d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNDM5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488834393", "bodyText": "removed. thanks", "author": "hisundar", "createdAt": "2020-09-15T17:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Njg4NQ=="}], "type": "inlineReview"}, {"oid": "c262dda6554b74bf5d373d97498720259ade1ace", "url": "https://github.com/CorfuDB/CorfuDB/commit/c262dda6554b74bf5d373d97498720259ade1ace", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T18:00:58Z", "type": "forcePushed"}, {"oid": "f3c8a616c69705d5d94123748510b2d232daa3b7", "url": "https://github.com/CorfuDB/CorfuDB/commit/f3c8a616c69705d5d94123748510b2d232daa3b7", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-15T23:26:17Z", "type": "forcePushed"}, {"oid": "c9605990620387b7d185d3dead5eae2d1a627f99", "url": "https://github.com/CorfuDB/CorfuDB/commit/c9605990620387b7d185d3dead5eae2d1a627f99", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-16T00:59:13Z", "type": "forcePushed"}, {"oid": "3ed6772a807ddbe2831412404f1e6d83a2522521", "url": "https://github.com/CorfuDB/CorfuDB/commit/3ed6772a807ddbe2831412404f1e6d83a2522521", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-16T03:17:29Z", "type": "forcePushed"}, {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "url": "https://github.com/CorfuDB/CorfuDB/commit/785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-16T16:45:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjQyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489826427", "bodyText": "@hisundar I think at least we need to log a warning message if the number of subscribers exceeds limit, otherwise it will be hard to debug when such issues happen. Also is 6 a bit large for default maxSubscribers considering each subscriber will now have a thread?", "author": "WenbinZhu", "createdAt": "2020-09-17T00:32:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    public static final int DEFAULT_LONG_RUNNING_TIME_SECS = 1; // When to log long running onNext()\n+    /**\n+     * The actual executor thread pool where the subscribers will run.\n+     */\n+    private ScheduledExecutorService scheduledExecutorService;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    private class StreamSubscriber {\n+        private final SubscriberTask subscriberTask;\n+        private final ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);", "originalCommit": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MTk3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r490441976", "bodyText": "ok, so how about a large limit like 32 at which we will throw an exception. It will only be hit in case there is some bug that is calling subscribe() and leaking?", "author": "hisundar", "createdAt": "2020-09-17T17:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NTc2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r490485764", "bodyText": "Yea we can do that, but one thing I think that is also important is logging the number of subscribers when there are new subscribes, since the current design is supposed to be used by a small number of subscriptions, so if we hit a performance issue, we can easily tell there are too many subscribers.", "author": "WenbinZhu", "createdAt": "2020-09-17T18:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjU5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489826598", "bodyText": "There is already a isShutdown variable on line 168 right?", "author": "WenbinZhu", "createdAt": "2020-09-17T00:32:49Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    public static final int DEFAULT_LONG_RUNNING_TIME_SECS = 1; // When to log long running onNext()\n+    /**\n+     * The actual executor thread pool where the subscribers will run.\n+     */\n+    private ScheduledExecutorService scheduledExecutorService;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    private class StreamSubscriber {\n+        private final SubscriberTask subscriberTask;\n+        private final ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            // Multiple subscribers subscribing to same namespace and table is allowed.\n+            // Which is why we use the caller's hashcode() and equals() are used to validate re-subscription.\n+            // If the caller does not want to start another subscriber on the same namespace & table,\n+            // then the hashcode should be constructed from listener name.\n+            // If caller wants to allow 2 subscriptions on the same namespace+table,\n+            // then hashcode and equals can just reflect the subscriber's name or other distinguishing fields.\n+            // Basically we are saying, \"hey you decide if this is a re-subscription or a new subscription\"\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber streamSubscriber = unsubscribeInternal(streamListener);\n+        if (streamSubscriber != null) {\n+            streamSubscriber.getScheduledFuture().cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * Internal method that can be safely invoked from the same thread executing the task.\n+     * @param streamListener client's listener object.\n+     * @return - returns the stream subscriber context for lifecycle management.\n+     */\n+    private synchronized StreamSubscriber unsubscribeInternal(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return null;\n+        }\n+        // Since we are not force interrupting the thread, set a flag for it to shutdown\n+        subscriber.getSubscriberTask().isShutdown.set(true);\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        return subscriber;\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        @Setter\n+        private final AtomicBoolean isShutdown = new AtomicBoolean(false);\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        public AtomicBoolean shutdown;", "originalCommit": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1MDcyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r490450729", "bodyText": "fixed. thanks", "author": "hisundar", "createdAt": "2020-09-17T17:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjU5OA=="}], "type": "inlineReview"}, {"oid": "48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "url": "https://github.com/CorfuDB/CorfuDB/commit/48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-17T17:59:07Z", "type": "forcePushed"}, {"oid": "4213606f8db70988138fd1b838218527315138fb", "url": "https://github.com/CorfuDB/CorfuDB/commit/4213606f8db70988138fd1b838218527315138fb", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-17T18:15:05Z", "type": "commit"}, {"oid": "4213606f8db70988138fd1b838218527315138fb", "url": "https://github.com/CorfuDB/CorfuDB/commit/4213606f8db70988138fd1b838218527315138fb", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability.", "committedDate": "2020-09-17T18:15:05Z", "type": "forcePushed"}]}