{"pr_number": 2372, "pr_title": "Cluster status: add unit tests", "pr_createdAt": "2020-02-06T18:33:24Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2372", "timeline": [{"oid": "ad708a7b832b0a26455fac9e523f9e33b537aa79", "url": "https://github.com/CorfuDB/CorfuDB/commit/ad708a7b832b0a26455fac9e523f9e33b537aa79", "message": "Cluster status: add unit tests", "committedDate": "2020-02-06T18:31:41Z", "type": "commit"}, {"oid": "837cb61b3768b6e2f6ea9b35bb2e930e6658a5cf", "url": "https://github.com/CorfuDB/CorfuDB/commit/837cb61b3768b6e2f6ea9b35bb2e930e6658a5cf", "message": "Cluster status: add unit tests", "committedDate": "2020-02-06T18:36:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwOTcwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r376109700", "bodyText": "Where these functions just moved, or was there any change in logic?", "author": "vjeko", "createdAt": "2020-02-06T22:08:13Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/ManagementView.java", "diffHunk": "@@ -598,4 +505,136 @@ private Layout getHighestEpochLayout(Map<String, Layout> layoutMap) {\n                     return true;\n                 });\n     }\n+\n+    public static class ClusterHealth {", "originalCommit": "837cb61b3768b6e2f6ea9b35bb2e930e6658a5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzMDMyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r376230327", "bodyText": "Just moved from ManagementView to ClusterHealth", "author": "xnull", "createdAt": "2020-02-07T06:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwOTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNDcwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r376614706", "bodyText": "Can you please explain what the test does? What is the expected behavior and why.", "author": "vjeko", "createdAt": "2020-02-07T21:25:33Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ClusterHealthTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;\n+import org.corfudb.runtime.view.ManagementView.ClusterHealth;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ClusterHealthTest {", "originalCommit": "837cb61b3768b6e2f6ea9b35bb2e930e6658a5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NjEzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r377966133", "bodyText": "done", "author": "xnull", "createdAt": "2020-02-11T23:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNDcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNTExMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r376615112", "bodyText": "Same here.", "author": "vjeko", "createdAt": "2020-02-07T21:26:34Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ManagementViewTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.ClusterStatusReport.NodeStatus;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ManagementViewTest {", "originalCommit": "837cb61b3768b6e2f6ea9b35bb2e930e6658a5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NjE1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r377966153", "bodyText": "done", "author": "xnull", "createdAt": "2020-02-11T23:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNTExMg=="}], "type": "inlineReview"}, {"oid": "c5674d0ea31d6838e44d611a05a5ff9eb9173602", "url": "https://github.com/CorfuDB/CorfuDB/commit/c5674d0ea31d6838e44d611a05a5ff9eb9173602", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-02-11T06:32:55Z", "type": "commit"}, {"oid": "4c851bc4b20e8804c05a018bcae7672fa59e6491", "url": "https://github.com/CorfuDB/CorfuDB/commit/4c851bc4b20e8804c05a018bcae7672fa59e6491", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-02-11T23:27:11Z", "type": "commit"}, {"oid": "95943eb1146ceddedb24f6a0e962a77f2447cf85", "url": "https://github.com/CorfuDB/CorfuDB/commit/95943eb1146ceddedb24f6a0e962a77f2447cf85", "message": "Cluster status: add unit tests", "committedDate": "2020-02-11T23:30:25Z", "type": "commit"}, {"oid": "47a9ff4eae34917c7807b8a70f921f4cd73caee5", "url": "https://github.com/CorfuDB/CorfuDB/commit/47a9ff4eae34917c7807b8a70f921f4cd73caee5", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-02-18T22:21:25Z", "type": "commit"}, {"oid": "40cfe718ec6afaa33cf70cf5cec1636fe36c668e", "url": "https://github.com/CorfuDB/CorfuDB/commit/40cfe718ec6afaa33cf70cf5cec1636fe36c668e", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-05-22T23:51:41Z", "type": "commit"}, {"oid": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "url": "https://github.com/CorfuDB/CorfuDB/commit/4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-06-19T06:24:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2Mjg0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r442962843", "bodyText": "This test is failing in CI. Seems timing related? Can it be made reliable?", "author": "hisundar", "createdAt": "2020-06-19T17:27:17Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ClusterHealthTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;\n+import org.corfudb.runtime.view.ManagementView.ClusterHealth;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ClusterHealthTest {\n+    private final LayoutUtil layoutUtil = new LayoutUtil();\n+\n+    /**\n+     * Get cluster status from a layout with all responsive nodes. Expected result is STABLE status\n+     */\n+    @Test\n+    public void testClusterHealth() {\n+        final String server1 = \"server1\";\n+        final String server2 = \"server2\";\n+        final String server3 = \"server3\";\n+\n+        final List<String> servers = Arrays.asList(server1, server2, server3);\n+        final Layout layout = layoutUtil.getLayout(servers);\n+        layout.setUnresponsiveServers(Arrays.asList(server3));\n+\n+        ClusterHealth clusterHealth = new ClusterHealth();\n+        ClusterStatus status = clusterHealth.getClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);", "originalCommit": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NzE0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r442967144", "bodyText": "will do it, thank you", "author": "xnull", "createdAt": "2020-06-19T17:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwODY5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443108690", "bodyText": "Sundar, there couldn't be any timing issues (unit test, no external invocations), my test was failing intentionally, I wanted to add more unit tests (that's why I made it failed) when I created this PR several months ago and then just forgot to add more tests.\nSo, I just added more cases for ClusterHealth, now everything is covered", "author": "xnull", "createdAt": "2020-06-20T07:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2Mjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzA0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r442983047", "bodyText": "shouldnt the cluster state always be 'unstable' in the absence of a quorum?", "author": "pankti-m", "createdAt": "2020-06-19T18:15:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/ManagementView.java", "diffHunk": "@@ -133,160 +138,41 @@ public void mergeSegments(@Nonnull String endpointToRestoreRedundancy, int retry\n         new RestoreRedundancyMergeSegments(endpointToRestoreRedundancy, runtime, retry, timeout, pollPeriod).invoke();\n     }\n \n-    /**\n-     * If all the layout servers are responsive the cluster status is STABLE,\n-     * if a minority of them are unresponsive then the status is DEGRADED,\n-     * else the cluster is UNAVAILABLE.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getLayoutServersClusterHealth(Layout layout,\n-                                                        Set<String> peerResponsiveNodes) {\n-        ClusterStatus clusterStatus = ClusterStatus.STABLE;\n-        // A quorum of layout servers need to be responsive for the cluster to be STABLE.\n-        List<String> responsiveLayoutServers = new ArrayList<>(layout.getLayoutServers());\n-        // Retain only the responsive servers.\n-        responsiveLayoutServers.retainAll(peerResponsiveNodes);\n-        if (responsiveLayoutServers.size() != layout.getLayoutServers().size()) {\n-            clusterStatus = ClusterStatus.DEGRADED;\n-            int quorumSize = (layout.getLayoutServers().size() / 2) + 1;\n-            if (responsiveLayoutServers.size() < quorumSize) {\n-                clusterStatus = ClusterStatus.UNAVAILABLE;\n-            }\n-        }\n-        return clusterStatus;\n-    }\n-\n-    /**\n-     * If the primary sequencer is unresponsive then the cluster is UNAVAILABLE.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getSequencerServersClusterHealth(Layout layout,\n-                                                           Set<String> peerResponsiveNodes) {\n-        // The primary sequencer should be reachable for the cluster to be STABLE.\n-        return !peerResponsiveNodes.contains(layout.getPrimarySequencer())\n-                ? ClusterStatus.UNAVAILABLE : ClusterStatus.STABLE;\n-    }\n-\n-    /**\n-     * Gets the log unit cluster status based on the replication protocol.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getLogUnitServersClusterHealth(Layout layout,\n-                                                         Set<String> peerResponsiveNodes) {\n-        // logUnitRedundancyStatus marks the cluster as DB_SYNCING if any of the nodes is performing\n-        // stateTransfer and is in process of achieving full redundancy.\n-        ClusterStatus logUnitRedundancyStatus = peerResponsiveNodes.stream()\n-                .anyMatch(s -> getLogUnitNodeStatusInLayout(layout, s) == NodeStatus.DB_SYNCING)\n-                ? ClusterStatus.DB_SYNCING : ClusterStatus.STABLE;\n-        // Check the availability of the log servers in all segments as reads to all addresses\n-        // should be accessible.\n-        ClusterStatus logunitClusterStatus = layout.getSegments().stream()\n-                .map(segment -> segment.getReplicationMode()\n-                        .getClusterHealthForSegment(segment, peerResponsiveNodes))\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-        // Gets max of cluster status and logUnitRedundancyStatus.\n-        return Stream.of(logunitClusterStatus, logUnitRedundancyStatus)\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-    }\n-\n-    /**\n-     * Analyzes the health of the cluster based on the views of the cluster of all the\n-     * ManagementAgents.\n-     * STABLE: if all nodes in the layout are responsive.\n-     * DEGRADED: if a minority of Layout servers\n-     * or a minority of LogUnit servers - in QUORUM_REPLICATION mode only are unresponsive.\n-     * UNAVAILABLE: if a majority of Layout servers or the Primary Sequencer\n-     * or a node in the CHAIN_REPLICATION or a majority of nodes in QUORUM_REPLICATION is\n-     * unresponsive.\n-     *\n-     * @param layout              Layout based on which the health is analyzed.\n-     * @param peerResponsiveNodes Responsive nodes according to the management services.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getClusterHealth(Layout layout, Set<String> peerResponsiveNodes) {\n-\n-        return Stream.of(getLayoutServersClusterHealth(layout, peerResponsiveNodes),\n-                getSequencerServersClusterHealth(layout, peerResponsiveNodes),\n-                getLogUnitServersClusterHealth(layout, peerResponsiveNodes))\n-                // Gets cluster status from the layout, sequencer and log unit clusters.\n-                // The status is then aggregated by the max of the 3 statuses acquired.\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-    }\n-\n-    /**\n-     * Returns a LogUnit Server's status in the layout. It is marked as:\n-     * UP if it is present in all segments or none of the segments and not in the unresponsive list,\n-     * NOTE: A node is UP if its not in any of the segments as it might not be a LogUnit component\n-     * but has only the Layout or the Sequencer (or both) component(s) active.\n-     * DB_SYNCING if it is present in some but not all or none of the segments,\n-     * DOWN if it is present in the unresponsive servers list.\n-     *\n-     * @param layout Layout to check.\n-     * @param server LogUnit Server endpoint.\n-     * @return NodeState with respect to the layout specified.\n-     */\n-    private NodeStatus getLogUnitNodeStatusInLayout(Layout layout, String server) {\n-        if (layout.getUnresponsiveServers().contains(server)) {\n-            return NodeStatus.DOWN;\n-        }\n-        final int segmentsCount = layout.getSegments().size();\n-        int nodeInSegments = 0;\n-        for (LayoutSegment layoutSegment : layout.getSegments()) {\n-            if (layoutSegment.getAllLogServers().contains(server)) {\n-                nodeInSegments++;\n-            }\n-        }\n-        return nodeInSegments == segmentsCount || nodeInSegments == 0\n-                ? NodeStatus.UP : NodeStatus.DB_SYNCING;\n-    }\n-\n     /**\n      * Get the Cluster Status.\n-     *\n+     * <p>\n      * This is reported as follows:\n      * - (1) The status of the cluster itself (regardless of clients connectivity) as reflected in the\n-     *   layout. This information is presented along each node's status (up, down, db_sync).\n-     *\n-     *   It is important to note that as the cluster state is obtained from the layout,\n-     *   when quorum is not available (majority of nodes) there are lower guarantees on the\n-     *   reliability of this state.\n-     *   For example, in the absence of quorum the system might be in an unstable state which\n-     *   cannot converge due to lack of consensus. This is reflected in the\n-     *   cluster status report as clusterStatusReliability.\n-     *\n+     * layout. This information is presented along each node's status (up, down, db_sync).\n+     * <p>\n+     * It is important to note that as the cluster state is obtained from the layout,\n+     * when quorum is not available (majority of nodes) there are lower guarantees on the\n+     * reliability of this state.", "originalCommit": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwODEzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443108135", "bodyText": "As I know, on the client-side it's not possible to know exactly what the cluster state in case of a failure, but if the client can't connect to a server in the cluster it doesn't mean the cluster in the DEGRADED state.\n@annym can explain better than me.", "author": "xnull", "createdAt": "2020-06-20T07:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443156481", "bodyText": "exactly, the fact that a client cannot connect to all 3 servers, does not necessarily imply that the Cluster is UNSTABLE, probably it's all up and running, it's just this client who cannot connect to it. That is why reading the cluster status should consider reliability and connection status, to get an overall look.", "author": "annym", "createdAt": "2020-06-20T20:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzU2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r442983567", "bodyText": "Can you add an example output in the comment?  It is not clear what all info is displayed/collected..", "author": "pankti-m", "createdAt": "2020-06-19T18:17:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/ManagementView.java", "diffHunk": "@@ -133,160 +138,41 @@ public void mergeSegments(@Nonnull String endpointToRestoreRedundancy, int retry\n         new RestoreRedundancyMergeSegments(endpointToRestoreRedundancy, runtime, retry, timeout, pollPeriod).invoke();\n     }\n \n-    /**\n-     * If all the layout servers are responsive the cluster status is STABLE,\n-     * if a minority of them are unresponsive then the status is DEGRADED,\n-     * else the cluster is UNAVAILABLE.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getLayoutServersClusterHealth(Layout layout,\n-                                                        Set<String> peerResponsiveNodes) {\n-        ClusterStatus clusterStatus = ClusterStatus.STABLE;\n-        // A quorum of layout servers need to be responsive for the cluster to be STABLE.\n-        List<String> responsiveLayoutServers = new ArrayList<>(layout.getLayoutServers());\n-        // Retain only the responsive servers.\n-        responsiveLayoutServers.retainAll(peerResponsiveNodes);\n-        if (responsiveLayoutServers.size() != layout.getLayoutServers().size()) {\n-            clusterStatus = ClusterStatus.DEGRADED;\n-            int quorumSize = (layout.getLayoutServers().size() / 2) + 1;\n-            if (responsiveLayoutServers.size() < quorumSize) {\n-                clusterStatus = ClusterStatus.UNAVAILABLE;\n-            }\n-        }\n-        return clusterStatus;\n-    }\n-\n-    /**\n-     * If the primary sequencer is unresponsive then the cluster is UNAVAILABLE.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getSequencerServersClusterHealth(Layout layout,\n-                                                           Set<String> peerResponsiveNodes) {\n-        // The primary sequencer should be reachable for the cluster to be STABLE.\n-        return !peerResponsiveNodes.contains(layout.getPrimarySequencer())\n-                ? ClusterStatus.UNAVAILABLE : ClusterStatus.STABLE;\n-    }\n-\n-    /**\n-     * Gets the log unit cluster status based on the replication protocol.\n-     *\n-     * @param layout              Current layout on which responsiveness was checked.\n-     * @param peerResponsiveNodes responsive nodes in the current layout.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getLogUnitServersClusterHealth(Layout layout,\n-                                                         Set<String> peerResponsiveNodes) {\n-        // logUnitRedundancyStatus marks the cluster as DB_SYNCING if any of the nodes is performing\n-        // stateTransfer and is in process of achieving full redundancy.\n-        ClusterStatus logUnitRedundancyStatus = peerResponsiveNodes.stream()\n-                .anyMatch(s -> getLogUnitNodeStatusInLayout(layout, s) == NodeStatus.DB_SYNCING)\n-                ? ClusterStatus.DB_SYNCING : ClusterStatus.STABLE;\n-        // Check the availability of the log servers in all segments as reads to all addresses\n-        // should be accessible.\n-        ClusterStatus logunitClusterStatus = layout.getSegments().stream()\n-                .map(segment -> segment.getReplicationMode()\n-                        .getClusterHealthForSegment(segment, peerResponsiveNodes))\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-        // Gets max of cluster status and logUnitRedundancyStatus.\n-        return Stream.of(logunitClusterStatus, logUnitRedundancyStatus)\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-    }\n-\n-    /**\n-     * Analyzes the health of the cluster based on the views of the cluster of all the\n-     * ManagementAgents.\n-     * STABLE: if all nodes in the layout are responsive.\n-     * DEGRADED: if a minority of Layout servers\n-     * or a minority of LogUnit servers - in QUORUM_REPLICATION mode only are unresponsive.\n-     * UNAVAILABLE: if a majority of Layout servers or the Primary Sequencer\n-     * or a node in the CHAIN_REPLICATION or a majority of nodes in QUORUM_REPLICATION is\n-     * unresponsive.\n-     *\n-     * @param layout              Layout based on which the health is analyzed.\n-     * @param peerResponsiveNodes Responsive nodes according to the management services.\n-     * @return ClusterStatus\n-     */\n-    private ClusterStatus getClusterHealth(Layout layout, Set<String> peerResponsiveNodes) {\n-\n-        return Stream.of(getLayoutServersClusterHealth(layout, peerResponsiveNodes),\n-                getSequencerServersClusterHealth(layout, peerResponsiveNodes),\n-                getLogUnitServersClusterHealth(layout, peerResponsiveNodes))\n-                // Gets cluster status from the layout, sequencer and log unit clusters.\n-                // The status is then aggregated by the max of the 3 statuses acquired.\n-                .max(Comparator.comparingInt(ClusterStatus::getHealthValue))\n-                .orElse(ClusterStatus.UNAVAILABLE);\n-    }\n-\n-    /**\n-     * Returns a LogUnit Server's status in the layout. It is marked as:\n-     * UP if it is present in all segments or none of the segments and not in the unresponsive list,\n-     * NOTE: A node is UP if its not in any of the segments as it might not be a LogUnit component\n-     * but has only the Layout or the Sequencer (or both) component(s) active.\n-     * DB_SYNCING if it is present in some but not all or none of the segments,\n-     * DOWN if it is present in the unresponsive servers list.\n-     *\n-     * @param layout Layout to check.\n-     * @param server LogUnit Server endpoint.\n-     * @return NodeState with respect to the layout specified.\n-     */\n-    private NodeStatus getLogUnitNodeStatusInLayout(Layout layout, String server) {\n-        if (layout.getUnresponsiveServers().contains(server)) {\n-            return NodeStatus.DOWN;\n-        }\n-        final int segmentsCount = layout.getSegments().size();\n-        int nodeInSegments = 0;\n-        for (LayoutSegment layoutSegment : layout.getSegments()) {\n-            if (layoutSegment.getAllLogServers().contains(server)) {\n-                nodeInSegments++;\n-            }\n-        }\n-        return nodeInSegments == segmentsCount || nodeInSegments == 0\n-                ? NodeStatus.UP : NodeStatus.DB_SYNCING;\n-    }\n-\n     /**\n      * Get the Cluster Status.\n-     *\n+     * <p>\n      * This is reported as follows:\n      * - (1) The status of the cluster itself (regardless of clients connectivity) as reflected in the\n-     *   layout. This information is presented along each node's status (up, down, db_sync).\n-     *\n-     *   It is important to note that as the cluster state is obtained from the layout,\n-     *   when quorum is not available (majority of nodes) there are lower guarantees on the\n-     *   reliability of this state.\n-     *   For example, in the absence of quorum the system might be in an unstable state which\n-     *   cannot converge due to lack of consensus. This is reflected in the\n-     *   cluster status report as clusterStatusReliability.\n-     *\n+     * layout. This information is presented along each node's status (up, down, db_sync).\n+     * <p>\n+     * It is important to note that as the cluster state is obtained from the layout,\n+     * when quorum is not available (majority of nodes) there are lower guarantees on the\n+     * reliability of this state.\n+     * For example, in the absence of quorum the system might be in an unstable state which\n+     * cannot converge due to lack of consensus. This is reflected in the\n+     * cluster status report as clusterStatusReliability.\n+     * <p>\n      * - (2) The connectivity status of the client to every node in the cluster,\n-     *   i.e., can the client connect to the cluster. This will be obtained by\n-     *   ping(ing) every node and show as RESPONSIVE, for successful connections or UNRESPONSIVE for\n-     *   clients unable to communicate.\n-     *\n-     *  In this sense a cluster can be STABLE with all nodes UP, while not being available for a\n-     *  client, as all connections from the client to the cluster nodes are down, showing in this\n-     *  case connectivity status to all nodes as UNRESPONSIVE.\n-     *\n-     *  The ClusterStatusReport consists of the following:\n-     *\n-     *  CLUSTER-SPECIFIC STATUS\n-     *  - clusterStatus: the cluster status a perceived by the system's layout.\n-     *  STABLE, DEGRADED, DB_SYNCING or UNAVAILABLE\n-     *  - nodeStatusMap: each node's status as perceived by the system's layout.\n-     *  (UP, DOWN or DB_SYNC)\n-     *  - Cluster Status Reliability: STRONG_QUORUM, WEAK_NO_QUORUM or UNAVAILABLE\n-     *\n-     *  CLIENT-CLUSTER SPECIFIC STATUS:\n-     *  - clientServerConnectivityStatusMap: the connectivity status of this client to the cluster.\n-     *    (RESPONSIVE, UNRESPONSIVE).\n+     * i.e., can the client connect to the cluster. This will be obtained by\n+     * ping(ing) every node and show as RESPONSIVE, for successful connections or UNRESPONSIVE for\n+     * clients unable to communicate.\n+     * <p>\n+     * In this sense a cluster can be STABLE with all nodes UP, while not being available for a\n+     * client, as all connections from the client to the cluster nodes are down, showing in this\n+     * case connectivity status to all nodes as UNRESPONSIVE.\n+     * <p>\n+     * The ClusterStatusReport consists of the following:\n+     * <p>\n+     * CLUSTER-SPECIFIC STATUS\n+     * - clusterStatus: the cluster status a perceived by the system's layout.\n+     * STABLE, DEGRADED, DB_SYNCING or UNAVAILABLE\n+     * - nodeStatusMap: each node's status as perceived by the system's layout.\n+     * (UP, DOWN or DB_SYNC)\n+     * - Cluster Status Reliability: STRONG_QUORUM, WEAK_NO_QUORUM or UNAVAILABLE\n+     * <p>\n+     * CLIENT-CLUSTER SPECIFIC STATUS:\n+     * - clientServerConnectivityStatusMap: the connectivity status of this client to the cluster.\n+     * (RESPONSIVE, UNRESPONSIVE).", "originalCommit": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwODI2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443108262", "bodyText": "Didn't get your question. There could be only one of those two states RESPONSIVE or UNRESPONSIVE", "author": "xnull", "createdAt": "2020-06-20T07:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4Mzg2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r442983864", "bodyText": "what about the degraded state?", "author": "pankti-m", "createdAt": "2020-06-19T18:17:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/Layout.java", "diffHunk": "@@ -375,10 +375,10 @@ public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {\n             }\n \n             @Override\n-            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,\n-                                                            Set<String> responsiveNodes) {\n-                return !responsiveNodes.containsAll(layoutSegment.getAllLogServers())\n-                        ? ClusterStatus.UNAVAILABLE : ClusterStatus.STABLE;\n+            public ClusterStatus getClusterHealthForSegment(\n+                    LayoutSegment layoutSegment, Set<String> responsiveNodes) {\n+                return responsiveNodes.containsAll(layoutSegment.getAllLogServers())", "originalCommit": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNzk0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443107949", "bodyText": "it's not possible for a chain replication. If at least one node failed, the status gets UNAVAILABLE", "author": "xnull", "createdAt": "2020-06-20T06:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4Mzg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNDE2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443104161", "bodyText": "Looks like server3 is still in the layout segment, so log unit servers' health is unavailable.\nThe expected overall status should be degraded, right? Since the layout server status is 2/3 active.", "author": "zhangn49", "createdAt": "2020-06-20T05:44:04Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ClusterHealthTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;\n+import org.corfudb.runtime.view.ManagementView.ClusterHealth;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ClusterHealthTest {\n+    private final LayoutUtil layoutUtil = new LayoutUtil();\n+\n+    /**\n+     * Get cluster status from a layout with all responsive nodes. Expected result is STABLE status\n+     */\n+    @Test\n+    public void testClusterHealth() {\n+        final String server1 = \"server1\";\n+        final String server2 = \"server2\";\n+        final String server3 = \"server3\";\n+\n+        final List<String> servers = Arrays.asList(server1, server2, server3);\n+        final Layout layout = layoutUtil.getLayout(servers);\n+        layout.setUnresponsiveServers(Arrays.asList(server3));\n+\n+        ClusterHealth clusterHealth = new ClusterHealth();\n+        ClusterStatus status = clusterHealth.getClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);", "originalCommit": "4dae49e8b7379f3ad9a6c3c34dd1f47b23fe6bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwODc0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443108744", "bodyText": "I just added more tests, your case also covered\n\nThe expected overall status should be degraded, right?\n\nyes", "author": "xnull", "createdAt": "2020-06-20T07:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNDE2MQ=="}], "type": "inlineReview"}, {"oid": "af3142f62fd8bed2fbf659758ea590400ee54b44", "url": "https://github.com/CorfuDB/CorfuDB/commit/af3142f62fd8bed2fbf659758ea590400ee54b44", "message": "ClusterStatus unit tests", "committedDate": "2020-06-20T07:06:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443156606", "bodyText": "How different is this test from queryClusterStatus in ManagementViewTest ?\nThis test already exists and it actually is a bit more complete...", "author": "annym", "createdAt": "2020-06-20T20:09:22Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ClusterHealthTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;\n+import org.corfudb.runtime.view.ManagementView.ClusterHealth;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ClusterHealthTest {\n+    private final LayoutUtil layoutUtil = new LayoutUtil();\n+\n+    private final String server1 = \"server1\";\n+    private final String server2 = \"server2\";\n+    private final String server3 = \"server3\";\n+    private final List<String> servers = Arrays.asList(server1, server2, server3);\n+\n+    private final ClusterHealth clusterHealth = new ClusterHealth();\n+\n+    /**\n+     * Test possible cluster statuses for layout servers\n+     */\n+    @Test\n+    public void testLayoutServersHealth(){\n+        Layout layout = layoutUtil.getLayout(servers);\n+        ClusterStatus status = clusterHealth.getLayoutServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);\n+\n+        layout.setUnresponsiveServers(Collections.singletonList(server3));\n+        status = clusterHealth.getLayoutServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.DEGRADED);\n+\n+        layout.setUnresponsiveServers(Arrays.asList(server2, server3));\n+        status = clusterHealth.getLayoutServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.UNAVAILABLE);\n+    }\n+\n+    /**\n+     * Test possible cluster statuses for sequencer servers\n+     */\n+    @Test\n+    public void testSequencerServersHealth(){\n+        Layout layout = layoutUtil.getLayout(servers);\n+        layout.setUnresponsiveServers(Collections.singletonList(server3));\n+\n+        ClusterStatus status = clusterHealth.getSequencerServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);\n+\n+        //Unresponsive sequencer\n+        layout.setUnresponsiveServers(Collections.singletonList(server1));\n+        status = clusterHealth.getSequencerServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.UNAVAILABLE);\n+    }\n+\n+    /**\n+     * Test possible cluster statuses for LogUnit servers\n+     */\n+    @Test\n+    public void testLogUnitServersClusterHealth(){\n+        Layout layout = layoutUtil.getLayout(servers);\n+\n+        ClusterStatus status = clusterHealth.getLogUnitServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);\n+\n+        //invalid segment\n+        layout.setUnresponsiveServers(Collections.singletonList(server3));\n+        status = clusterHealth.getLogUnitServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.UNAVAILABLE);\n+\n+        //exclude unresponsive server\n+        layout.getFirstSegment().getFirstStripe().getLogServers().remove(server3);\n+        status = clusterHealth.getLogUnitServersClusterHealth(\n+                layout, layout.getAllActiveServers()\n+        );\n+        assertThat(status).isEqualTo(ClusterStatus.STABLE);\n+    }\n+\n+    /**\n+     * Get cluster status from a layout with all responsive nodes.\n+     * Expected result is STABLE status\n+     */\n+    @Test\n+    public void testClusterHealth() {", "originalCommit": "af3142f62fd8bed2fbf659758ea590400ee54b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3MTM0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443171347", "bodyText": "That test is more an Integration Test, this one is a unit test.\nNo need to start an entire cluster, no side effects from the environment, the unit test is much simpler.\nI think we need both - integration and unit tests even if some tests are similar.", "author": "xnull", "createdAt": "2020-06-21T00:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443156616", "bodyText": "Please add class description...", "author": "annym", "createdAt": "2020-06-20T20:09:39Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/LayoutUtil.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.view.Layout.LayoutSegment;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class LayoutUtil {", "originalCommit": "af3142f62fd8bed2fbf659758ea590400ee54b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE4MTc0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443181740", "bodyText": "done", "author": "xnull", "createdAt": "2020-06-21T04:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjY5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443156693", "bodyText": "This test already exists in queryClusterStatus in this same file.", "author": "annym", "createdAt": "2020-06-20T20:10:51Z", "path": "runtime/src/test/java/org/corfudb/runtime/view/ManagementViewTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.corfudb.runtime.view;\n+\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.view.ClusterStatusReport.NodeStatus;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ManagementViewTest {\n+    private final LayoutUtil layoutUtil = new LayoutUtil();\n+    private final ManagementView managementView = new ManagementView(Mockito.mock(CorfuRuntime.class));\n+\n+    /**\n+     * Check that getting a quorum layout from the list of layouts works as expected\n+     */\n+    @Test\n+    void testGetLayoutForQuorum() {\n+        final String server1 = \"server1\";\n+        final String server2 = \"server2\";\n+        final String server3 = \"server3\";\n+\n+        final List<String> servers = Arrays.asList(server1, server2, server3);\n+        final Layout layout = layoutUtil.getLayout(servers);\n+\n+        Map<String, Layout> layouts = new HashMap<>();\n+\n+        servers.forEach(server -> layouts.put(server, layout));\n+\n+        Optional<Layout> quorumLayout = managementView.getLayoutFromQuorum(layouts, layouts.size() - 1);\n+        assertThat(quorumLayout).isEqualTo(Optional.of(layout));\n+\n+        quorumLayout = managementView.getLayoutFromQuorum(layouts, layouts.size());\n+        assertThat(quorumLayout).isEqualTo(Optional.of(layout));\n+\n+        quorumLayout = managementView.getLayoutFromQuorum(layouts, layouts.size() + 1);\n+        assertThat(quorumLayout).isEqualTo(Optional.empty());\n+    }\n+\n+    @Test", "originalCommit": "af3142f62fd8bed2fbf659758ea590400ee54b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE4MTcyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2372#discussion_r443181726", "bodyText": "The advantages of the unit test:\n\nno side-effects (no need to start external services - netty, no need for network communication, etc)\nmuch faster\nsimpler to understand, simpler to find what causes the error.\n\nI could delete those checks in queryClusterStatus method if you would like to.\nAlso, I think it's ok to have integration and unit tests even if they check similar parameters.", "author": "xnull", "createdAt": "2020-06-21T04:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjY5Mw=="}], "type": "inlineReview"}, {"oid": "511af8ead81e0777bfc8b6311b117ab80013a1cb", "url": "https://github.com/CorfuDB/CorfuDB/commit/511af8ead81e0777bfc8b6311b117ab80013a1cb", "message": "ClusterStatus unit tests", "committedDate": "2020-06-21T04:55:48Z", "type": "commit"}, {"oid": "1085fdeab12cd0ebdd6c648899a7ce05d377bf84", "url": "https://github.com/CorfuDB/CorfuDB/commit/1085fdeab12cd0ebdd6c648899a7ce05d377bf84", "message": "ClusterStatus unit tests", "committedDate": "2020-06-21T05:29:12Z", "type": "commit"}, {"oid": "cfdc43e173dfd92c8be239ed00642f94000f8b61", "url": "https://github.com/CorfuDB/CorfuDB/commit/cfdc43e173dfd92c8be239ed00642f94000f8b61", "message": "Merge branch 'master' into cluster-status-unit-tests-1", "committedDate": "2020-07-10T00:00:56Z", "type": "commit"}]}