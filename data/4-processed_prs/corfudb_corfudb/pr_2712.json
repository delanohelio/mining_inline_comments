{"pr_number": 2712, "pr_title": "Fail Non-Transactional Enqueue", "pr_createdAt": "2020-08-13T20:01:20Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2712", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzkyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470273924", "bodyText": "I'm concerned, if this change could affect the clients since we changed contract, hope it works", "author": "xnull", "createdAt": "2020-08-13T22:02:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");", "originalCommit": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTczNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470275735", "bodyText": "Unfortunately there isn't much flexibility here. If clients are enqueuing without a transaction then its incorrect. If we start a transaction internally, then that transaction can abort. They're probably not dealing with the TransacationAbort right now", "author": "Maithem", "createdAt": "2020-08-13T22:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDEzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470274132", "bodyText": "final?", "author": "xnull", "createdAt": "2020-08-13T22:03:18Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;", "originalCommit": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjUyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282529", "bodyText": "Done.", "author": "Maithem", "createdAt": "2020-08-13T22:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDIzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470274232", "bodyText": "@AllArgsConstructor ?", "author": "xnull", "createdAt": "2020-08-13T22:03:35Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {", "originalCommit": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjMyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282329", "bodyText": "Done.", "author": "Maithem", "createdAt": "2020-08-13T22:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTMwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470275309", "bodyText": "Just a question: Are we ok with IllegalStateException? Maybe we have a more specific exception?", "author": "xnull", "createdAt": "2020-08-13T22:06:29Z", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -1,38 +1,58 @@\n package org.corfudb.runtime.collections;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+\n import com.google.common.primitives.UnsignedBytes;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuQueue.CorfuQueueRecord;\n import org.corfudb.runtime.view.AbstractViewTest;\n import org.corfudb.util.serializer.Serializers;\n import org.junit.Test;\n \n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n /**\n  * Created by Sundar Sridharan on May 22, 2019\n  */\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n /**\n  * Simple test of basic operations to check that insert order is preserved in the queue.\n  * Created by hisundar on 05/27/2019\n  */\n+@Slf4j\n public class CorfuQueueTest extends AbstractViewTest {\n \n+    @Test\n+    public void failNonTxnEnqueue() {\n+        CorfuQueue<String>\n+                corfuQueue = new CorfuQueue<>(getDefaultRuntime(), \"test\");\n+        Assertions.assertThatThrownBy(() -> corfuQueue.enqueue(\"c\"))\n+                .isInstanceOf(IllegalStateException.class)", "originalCommit": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MzIyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470283229", "bodyText": "I think this should suffice. This exception signals an incorrect usage of the API. There is nothing to handle per-se\n * Signals that a method has been invoked at an illegal or\n * inappropriate time.  In other words, the Java environment or\n * Java application is not in an appropriate state for the requested\n * operation.", "author": "Maithem", "createdAt": "2020-08-13T22:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjU2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470276568", "bodyText": "@hisundar we never clean PreCommitListeners? Is it ok?", "author": "xnull", "createdAt": "2020-08-13T22:09:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {\n+                 this.recordId = recordId;\n+             }\n+\n+             /**\n+              * If we are in a transaction, determine the commit address and fix it up in\n+              * the queue entry.\n+              * @param tokenResponse\n+              */\n+             @Override\n+             public void preCommitCallback(TokenResponse tokenResponse) {\n+                 recordId.setTxSequence(tokenResponse.getSequence());\n+                 log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n+             }\n+         }\n+\n+         QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n+         log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n+         TransactionalContext.getRootContext().addPreCommitListener(addressGetter);", "originalCommit": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjI1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282259", "bodyText": "The listener is part of the TransactionalContext which is thread local. After the transaction completes or fails it will be garbage collected.", "author": "Maithem", "createdAt": "2020-08-13T22:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjU2OA=="}], "type": "inlineReview"}, {"oid": "44c5f6efd1b68484c6d7c9b17158f033ccf1bef8", "url": "https://github.com/CorfuDB/CorfuDB/commit/44c5f6efd1b68484c6d7c9b17158f033ccf1bef8", "message": "Fail Non-Transactional Enqueues\n\nSince CorfuQueue::enqueue depends on a transactional context to\nwork correctly, a validation step is required to fail enqueue\ncalls that are not within a transaction.", "committedDate": "2020-08-13T22:27:44Z", "type": "forcePushed"}, {"oid": "4345276801e5f7881150150eabb6f403de68f4e6", "url": "https://github.com/CorfuDB/CorfuDB/commit/4345276801e5f7881150150eabb6f403de68f4e6", "message": "Fail Non-Transactional Enqueue\n\nSince CorfuQueue::enqueue depends on a transactional context to\nwork correctly, a validation step is required to fail enqueue\ncalls that are not within a transaction.", "committedDate": "2020-08-13T23:18:50Z", "type": "commit"}, {"oid": "4345276801e5f7881150150eabb6f403de68f4e6", "url": "https://github.com/CorfuDB/CorfuDB/commit/4345276801e5f7881150150eabb6f403de68f4e6", "message": "Fail Non-Transactional Enqueue\n\nSince CorfuQueue::enqueue depends on a transactional context to\nwork correctly, a validation step is required to fail enqueue\ncalls that are not within a transaction.", "committedDate": "2020-08-13T23:18:50Z", "type": "forcePushed"}]}