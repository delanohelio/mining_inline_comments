{"pr_number": 2387, "pr_title": "A workaround to hole in tail issue.", "pr_createdAt": "2020-02-10T20:27:10Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2387", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxMjA1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r377312052", "bodyText": "I think its cleaner to just have an SMR that is a whole which is always undoable. When applyUndoRecordUnsafe is called, it just results in a no-op.", "author": "Maithem", "createdAt": "2020-02-10T20:57:32Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/VersionLockedObject.java", "diffHunk": "@@ -629,27 +631,40 @@ protected void rollbackStreamUnsafe(ISMRStream stream, long rollbackVersion) {\n             return;\n         }\n \n-        List<SMREntry> entries = stream.current();\n+        boolean isHole = false;\n+        List<SMREntry> entries = null;\n+        try {\n+            entries = stream.current();\n+        } catch (HoleInStreamException ex) {\n+            isHole = true;\n+        }\n \n-        while (!entries.isEmpty()) {\n-            if (entries.stream().allMatch(SMREntry::isUndoable)) {\n-                // start from the end, process one at a time\n-                ListIterator<SMREntry> it = entries.listIterator(entries.size());\n-                while (it.hasPrevious()) {\n-                    applyUndoRecordUnsafe(it.previous(), stream);\n-                }\n-            } else {\n-                Optional<SMREntry> entry = entries.stream().findFirst();\n-                if (log.isTraceEnabled()) {\n-                    log.trace(\"rollbackStreamUnsafe: one or more stream entries in address @{} are not undoable. \" +\n-                                    \"Undoable entries: {}/{}\", stream.pos(),\n-                            (int) entries.stream().filter(SMREntry::isUndoable).count(),\n-                            entries.size());\n+        while (isHole || !entries.isEmpty()) {\n+            if (!isHole) {\n+                if (entries.stream().allMatch(SMREntry::isUndoable)) {\n+                    // start from the end, process one at a time\n+                    ListIterator<SMREntry> it = entries.listIterator(entries.size());\n+                    while (it.hasPrevious()) {\n+                        applyUndoRecordUnsafe(it.previous(), stream);\n+                    }\n+                } else {\n+                    Optional<SMREntry> entry = entries.stream().findFirst();\n+                    if (log.isTraceEnabled()) {\n+                        log.trace(\"rollbackStreamUnsafe: one or more stream entries in address @{} are not undoable. \" +\n+                                        \"Undoable entries: {}/{}\", stream.pos(),\n+                                (int) entries.stream().filter(SMREntry::isUndoable).count(),\n+                                entries.size());\n+                    }\n+                    throw new NoRollbackException(entry, stream.pos(), rollbackVersion);", "originalCommit": "a89476ad8648ec5e5ec05f5c4b7ac55e10d9e275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MzU0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r377943542", "bodyText": "Rather than signaling this condition via an exception, maybe a better approach would be to have a globally unique instance that signals a hole.", "author": "vjeko", "createdAt": "2020-02-11T22:41:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/StreamViewSMRAdapter.java", "diffHunk": "@@ -96,6 +97,10 @@ public void gc(long trimMark) {\n      */\n     public List<SMREntry> current() {\n         ILogData data = streamView.current();\n+        if (data != null && data.isHole()) {\n+            throw new HoleInStreamException();\n+        }\n+", "originalCommit": "a89476ad8648ec5e5ec05f5c4b7ac55e10d9e275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjU5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r382316594", "bodyText": "We changed to put hole into ResolvedQueue, and return an empty list to be ignored by VLO.", "author": "zhangn49", "createdAt": "2020-02-20T23:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MzU0Mg=="}], "type": "inlineReview"}, {"oid": "f7d065b87a2ce039f0c85873df18d303bd2cf652", "url": "https://github.com/CorfuDB/CorfuDB/commit/f7d065b87a2ce039f0c85873df18d303bd2cf652", "message": "fix hole in tail", "committedDate": "2020-02-19T01:30:32Z", "type": "forcePushed"}, {"oid": "91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "url": "https://github.com/CorfuDB/CorfuDB/commit/91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "message": "fix hole in tail", "committedDate": "2020-02-19T19:12:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxNjIwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381616204", "bodyText": "Can you move this to the caller? if its a no-op, then you skip calling applyUpdateUnsafe", "author": "Maithem", "createdAt": "2020-02-19T23:57:27Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/VersionLockedObject.java", "diffHunk": "@@ -571,6 +577,10 @@ private Object applyUpdateUnsafe(SMREntry entry, long timestamp) {\n                 Address.isAddress(entry.getGlobalAddress()) ? entry.getGlobalAddress() : \"OPT\",\n                 entry.getSMRArguments());\n \n+        if (SMREntry.isNOP(entry)) {", "originalCommit": "91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxOTY2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381619666", "bodyText": "Actually, if StreamViewSMRAdapter filter's these holes out then you dont need any changes in the VLO.", "author": "Maithem", "createdAt": "2020-02-20T00:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxNjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NzMyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381657323", "bodyText": "previous and current will return an empty list, so need to change that while loop a little bit.", "author": "zhangn49", "createdAt": "2020-02-20T01:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxNjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxOTAyNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381619027", "bodyText": "This layer only understands ILogData can you move this conversion to StreamViewSMRAdapter which actually maps ILogData to SMREntry", "author": "Maithem", "createdAt": "2020-02-20T00:06:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -84,11 +86,16 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                 // to be serviced immediately, rather than reading one entry at a time.\n                 ld = read(currentRead, queue);\n \n-                if (queue == getCurrentContext().readQueue && ld != null) {\n+                if (queue == getCurrentContext().readQueue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if (ld.getType() == DataType.HOLE || (ld.containsStream(this.id) &&\n+                            ld.getType() == DataType.DATA)) {\n+                        // Convert hole to NOP\n+                        if (ld.isHole()) {\n+                            ld = new LogData(DataType.DATA, SMREntry.getNOP(), ld.getMetadataMap());\n+                        }\n                         addToResolvedQueue(getCurrentContext(), currentRead);", "originalCommit": "91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxOTMzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381619339", "bodyText": "Can you read back the address and make sure its a hole?", "author": "Maithem", "createdAt": "2020-02-20T00:08:00Z", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuTableTest.java", "diffHunk": "@@ -245,4 +254,46 @@ public void snapshotInvariant() {\n         final Stream<Map.Entry<Integer, Integer>> result = map.entryStream();\n         result.forEach(e -> map.put(new Random().nextInt(), 0));\n     }\n+\n+    @Test\n+    @SuppressWarnings({\"unchecked\", \"checkstyle:magicnumber\"})\n+    public void canHandleHoleInTail() {\n+        UUID streamID = UUID.randomUUID();\n+\n+        CorfuTable<String, String> corfuTable = getDefaultRuntime()\n+                .getObjectsView()\n+                .build()\n+                .setTypeToken(new TypeToken<CorfuTable<String, String>>() {})\n+                .setStreamID(streamID)\n+                .open();\n+\n+        corfuTable.put(\"k1\", \"dog fox cat\");\n+        corfuTable.put(\"k2\", \"dog bat\");\n+        corfuTable.put(\"k3\", \"fox\");\n+\n+        // create a hole\n+        TokenResponse tokenResponse =  getDefaultRuntime()\n+                .getSequencerView()\n+                .next(streamID);\n+\n+        Token token = tokenResponse.getToken();\n+\n+        getDefaultRuntime().getAddressSpaceView()", "originalCommit": "91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY1NTk0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381655941", "bodyText": "Done.", "author": "zhangn49", "createdAt": "2020-02-20T01:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxOTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyMDEzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r381620134", "bodyText": "Yea can get rid of the NOP notion by propagating the holes to the Stream layer but then filtering them out just before consumption in the StreamViewSMRAdapter", "author": "Maithem", "createdAt": "2020-02-20T00:10:40Z", "path": "runtime/src/main/java/org/corfudb/protocols/logprotocol/SMREntry.java", "diffHunk": "@@ -68,6 +77,11 @@\n     @Getter\n     public transient boolean haveUpcallResult = false;\n \n+    /** If smrEntry is NOP for hole */\n+    public static boolean isNOP(SMREntry smrEntry) {\n+        return smrEntry == NOP;\n+    }\n+", "originalCommit": "91b14a7ae2d3034b2b372303cdbb241be08bdbdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07fc9ff8376710e447f26ababd147c04fde5e7a7", "url": "https://github.com/CorfuDB/CorfuDB/commit/07fc9ff8376710e447f26ababd147c04fde5e7a7", "message": "fix hole in tail", "committedDate": "2020-02-20T01:38:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzOTg2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r384139863", "bodyText": "@lixinchengdu I think your initial argument that the object layer should always see SMREntry makes more sense. But even on master, it seems like an empty list is returned (look at line 100).\nI think returning an empty list is error-prone can hide issues, maybe we should explicitly fail if the entry is not ISMRConsumable or a DataType.DATA", "author": "Maithem", "createdAt": "2020-02-25T21:35:11Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/StreamViewSMRAdapter.java", "diffHunk": "@@ -96,6 +96,7 @@ public void gc(long trimMark) {\n      */\n     public List<SMREntry> current() {\n         ILogData data = streamView.current();\n+", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MDYzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r384140634", "bodyText": "Sorry for going back and forth on this, but can we reintroduce the NO-OP SMR ? I think its better to be more concise and handle holes explicitly in the object layer instead of just using an empty list as a signal.", "author": "Maithem", "createdAt": "2020-02-25T21:36:47Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/StreamViewSMRAdapter.java", "diffHunk": "@@ -96,6 +96,7 @@ public void gc(long trimMark) {\n      */\n     public List<SMREntry> current() {\n         ILogData data = streamView.current();\n+\n         if (data == null\n                 || data.getType() != DataType.DATA\n                 || !(data.getPayload(runtime) instanceof ISMRConsumable)) {", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MjA4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r384142081", "bodyText": "If the SMREntry is a no-op we can skip calling applyUndo, likewise we can skip the apply on stream forward?", "author": "Maithem", "createdAt": "2020-02-25T21:39:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/VersionLockedObject.java", "diffHunk": "@@ -631,7 +632,10 @@ protected void rollbackStreamUnsafe(ISMRStream stream, long rollbackVersion) {\n \n         List<SMREntry> entries = stream.current();\n \n-        while (!entries.isEmpty()) {\n+        while (stream.pos() > rollbackVersion) {", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0Mjg5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r384142897", "bodyText": "By the way this will break existing consumers of IStreamView (i.e. transaction pollers), because now see unexpected holes.", "author": "Maithem", "createdAt": "2020-02-25T21:41:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -88,7 +88,8 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if (ld.getType() == DataType.HOLE || (ld.containsStream(this.id) &&", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NDg1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385984859", "bodyText": "They should not IMO. What entries are seen by the client is dictated by getNextEntries() and that function filters out the holes.", "author": "vjeko", "createdAt": "2020-02-29T01:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0Mjg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4MzY0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385983648", "bodyText": "Just making sure my reasoning is correct. If the current entry is a hole, the entries list is going to be empty, making entries.stream().allMatch(SMREntry::isUndoable) evaluate to true.\nAlso, since the list is empty, it.hasPrevious() will always be false.", "author": "vjeko", "createdAt": "2020-02-29T00:52:30Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/VersionLockedObject.java", "diffHunk": "@@ -631,7 +632,10 @@ protected void rollbackStreamUnsafe(ISMRStream stream, long rollbackVersion) {\n \n         List<SMREntry> entries = stream.current();\n \n-        while (!entries.isEmpty()) {\n+        while (stream.pos() > rollbackVersion) {\n+            if (Address.nonAddress(stream.pos())) {\n+                throw new NoRollbackException(stream.pos(), rollbackVersion);\n+            }\n             if (entries.stream().allMatch(SMREntry::isUndoable)) {", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NjkyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385986926", "bodyText": "Yes, hole entry will skip this if block.", "author": "zhangn49", "createdAt": "2020-02-29T01:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4MzY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4Mzk0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385983947", "bodyText": "You can make this a bit cleaner by calling data.isData() and data.isHole().", "author": "vjeko", "createdAt": "2020-02-29T00:54:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractContextStreamView.java", "diffHunk": "@@ -284,7 +284,8 @@ protected boolean doesEntryUpdateContext(final ILogData data) {\n      */\n     private void updatePointer(final ILogData data) {\n         // Update the global pointer, if it is non-checkpoint data.\n-        if (data.getType() == DataType.DATA && !data.hasCheckpointMetadata()) {\n+        if ((data.getType() == DataType.DATA || data.getType() == DataType.HOLE)", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MTI5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385991293", "bodyText": "Done.", "author": "zhangn49", "createdAt": "2020-02-29T02:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4Mzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NDI1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385984253", "bodyText": "Same comment applies here.", "author": "vjeko", "createdAt": "2020-02-29T00:57:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -88,7 +88,8 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if (ld.getType() == DataType.HOLE || (ld.containsStream(this.id) &&\n+                            ld.getType() == DataType.DATA)) {", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e14cd9eb6ac0aa9200a0aafab7d7e2a23154274", "url": "https://github.com/CorfuDB/CorfuDB/commit/6e14cd9eb6ac0aa9200a0aafab7d7e2a23154274", "message": "Fix assertThat and address comment", "committedDate": "2020-02-29T01:31:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NzYzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385987630", "bodyText": "Can you please add a note that this getter is for testing purposes or perhaps the annotation VisibleForTesting", "author": "annym", "createdAt": "2020-02-29T01:25:32Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/VersionLockedObject.java", "diffHunk": "@@ -84,6 +84,7 @@\n     /**\n      * The stream view this object is backed by.\n      */\n+    @Getter", "originalCommit": "09d869b36f618f4e922a97f61ce9472ffb883762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MTQwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385991403", "bodyText": "Sure, I will add a VisibleForTesting function.", "author": "zhangn49", "createdAt": "2020-02-29T02:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385988899", "bodyText": "I am a bit confused, why do we want to surface the hole itself to the object layer? wouldn't that give the wrong behavior? If we are enforcing holes for different reasons (materialize a stream or any other reason), a client should not perceive it...If we are directly consuming the stream it would perceive them right?", "author": "annym", "createdAt": "2020-02-29T01:37:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -84,11 +84,11 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                 // to be serviced immediately, rather than reading one entry at a time.\n                 ld = read(currentRead, queue);\n \n-                if (queue == getCurrentContext().readQueue && ld != null) {\n+                if (queue == getCurrentContext().readQueue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if (ld.isHole() || (ld.containsStream(this.id) && ld.isData())) {", "originalCommit": "6e14cd9eb6ac0aa9200a0aafab7d7e2a23154274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MjAxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385992015", "bodyText": "Do you mean we should add hole to ResolvedQueue in AbstractQueuedStreamView?", "author": "zhangn49", "createdAt": "2020-02-29T02:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzQ1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r385993458", "bodyText": "We are adding it here, right? Which I believe is correct... My question is more like, when it's a hole readNext is being set to false meaning that the upper layer receives this hole. So if you are directly manipulating a stream a nextUpTo would return a hole at some point, or is it further filtered? Maybe I did not see when we filter it in upper layers", "author": "annym", "createdAt": "2020-02-29T02:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzU2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r386627563", "bodyText": "@zhangn49 This is what I mean (run this test). To someone consuming the stream directly we are exposing holes (null entries) which should be transparent to a reader (these holes are our way to avoid other issues with checkpoints):\n@Test\npublic void testNextUpTo() {\n    final int numWrites = 10;\n\n    byte[] testPayload = \"hello world\".getBytes();\n\n    String stream = \"stream1\";\n    UUID id1 = CorfuRuntime.getStreamID(stream);\n\n    StreamingMap<String, String> map = r.getObjectsView()\n            .build()\n            .setStreamName(stream)\n            .setTypeToken(new TypeToken<CorfuTable<String, String>>() {})\n            .open();\n\n    CorfuRuntime producer = getNewRuntime(getDefaultNode())\n            .connect();\n\n    CorfuRuntime consumer = getNewRuntime(getDefaultNode())\n            .connect();\n\n    IStreamView svProducer = producer.getStreamsView().get(id1);\n    IStreamView svConsumer = consumer.getStreamsView().get(id1);\n\n\n    for (int x = 0; x < numWrites; x++) {\n        svProducer.append(testPayload);\n    }\n\n    // Emulate the extra Token the Checkpointer requests before appending a checkpoint\n    // producer.getSequencerView().next(id1);\n    // producer.getAddressSpaceView().write(new Token(0, numWrites), LogData.getHole(numWrites));\n\n    // Get two entries before checkpointing (so we don't load from checkpoint on next access)\n    assertThat(svConsumer.nextUpTo(numWrites).getPayload(consumer)).isEqualTo(testPayload);\n    assertThat(svConsumer.nextUpTo(numWrites).getPayload(consumer)).isEqualTo(testPayload);\n\n    MultiCheckpointWriter checkpointWriter = new MultiCheckpointWriter();\n    checkpointWriter.addMap(map);\n    checkpointWriter.appendCheckpoints(r, \"Author\");\n\n    // Consume Until Tail\n    long tail = consumer.getSequencerView().query(id1);\n    System.out.println(\"Tail is: \" + tail);\n\n    ILogData data;\n    while (svConsumer.hasNext()) {\n        data = svConsumer.nextUpTo(tail);\n        System.out.println(\"Next @\" + data.getGlobalAddress() + \" bp is: \" + data.getBackpointer(id1));\n        assertThat(data.getPayload(consumer)).isEqualTo(testPayload);\n\n    }\n\n}", "author": "annym", "createdAt": "2020-03-02T20:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1NDYyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r386654623", "bodyText": "I see. Since we need VLO's version to point to a hole to avoid unnecessary sync, we are adding hole to streamView.\ngetNextEntries is safe now, since we filter hole out.\nFor nextUpTo/next, it will return a hole to direct sv consumers. It seems we don't have direct consumer right now.\nI am thinking if I can do this in nextUpTo, to skip hole.\n        if (entry != null) {\n            // Update the pointer.\n            updatePointer(entry);\n\n            // Check if entry is a hole\n            if (entry.isHole()) {\n                return nextUpTo(maxGlobal);\n            }\n\n            // Process the next entry, checking if the context has changed.\n            // If the context has changed, we read again, since this entry\n            // does not contain any data, and we need to follow the new\n            // context.\n            if (processEntryForContext(entry)) {\n                return nextUpTo(maxGlobal);\n            }\n        }\n\nIn this case, hasNext() will return true when only hole left in this stream, but looks still consistent with its definition.\n/** Returns whether or not there are potentially more entries in this\n     * stream - this function may return true even if there are no entries\n     * remaining, as addresses may have been acquired by other clients\n     * but not written yet, or the addresses were hole-filled, or just failed.\n     * @return      True, if there are potentially more entries in the stream.\n     */\n    boolean hasNext();", "author": "zhangn49", "createdAt": "2020-03-02T21:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTMxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r386711310", "bodyText": "I Think all you need to do, is in the AddressMapStreamView removeFromQueue, if it is a hole, set readNext=True... and this will automatically filter the hole for you to upper layers. So do something like:\nif (ld.isHole() || (ld.containsStream(this.id) && ld.isData())) {\naddToResolvedQueue(getCurrentContext(), currentRead);\nreadNext = ld.isHole()? true: false;\n}", "author": "annym", "createdAt": "2020-03-02T23:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNDM2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r386724361", "bodyText": "Discussed offline, skip hole in nextUpTo to update pointer.\nAdded comment why we add hole and skip it, also added this unit test to StreamViewTest.", "author": "zhangn49", "createdAt": "2020-03-03T00:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4ODg5OQ=="}], "type": "inlineReview"}, {"oid": "a5c4516c013a0f3111fbb46d345e0aecf220105b", "url": "https://github.com/CorfuDB/CorfuDB/commit/a5c4516c013a0f3111fbb46d345e0aecf220105b", "message": "fix hole in tail\n\nfix test\n\nFix assertThat and address comment\n\nAddress comment", "committedDate": "2020-03-31T17:43:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTA4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r401971084", "bodyText": "Resursive call is not good practice in production, it could blow up stack. I know you are referencing from the recursive code right below, but that is basically dead code.\nAlso, why don't we do this in removeFromQueue?  We can read the next one if current is a hole in removeFromQueue right? That seems cleaner.", "author": "WenbinZhu", "createdAt": "2020-04-01T23:37:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractContextStreamView.java", "diffHunk": "@@ -135,6 +134,13 @@ public final synchronized ILogData nextUpTo(final long maxGlobal) {\n             // Update the pointer.\n             updatePointer(entry);\n \n+            // We added hole to StreamView layer, in order to enable VLO sync to a hole\n+            // and in this way, we can avoid unnecessary sync that call sequencer every time.\n+            // It can expose a hole to sv consumer, so check if entry is a hole.\n+            if (entry.isHole()) {\n+                return nextUpTo(maxGlobal);", "originalCommit": "aefcaf65e973053abc99dd96c7232af5c2db645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAxNjg1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402016855", "bodyText": "Yes, I agree that recursive call is not good.\nIf we have a hole in streamA's tail, we read this hole can continue to read the next one in removeFromQueue, and return null. Then it won't call updatePointer(entry), so pointer is still behind this hole and we do not improve performance.", "author": "zhangn49", "createdAt": "2020-04-02T02:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0MDMzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402040339", "bodyText": "This the problem of existing code organization, we need to clean it up later.\nThough I think this does not matter in your case, as long as you put the hole into the resolvedQueue via addToResolvedQueue, the maxResolution will be updated: https://github.com/CorfuDB/CorfuDB/blob/master/runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java#L87\nthen next time maxResolution will prevent extra sequencer call. But using globalPointer instead of maxResolution can prevent unnecessary TrimmedException, so it's ok for now. I think later on we should reorg this part of code.", "author": "WenbinZhu", "createdAt": "2020-04-02T04:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r401975404", "bodyText": "I feel this might not be completely correct in case of sequencer regress.  I think we need to check containsStream() even for a hole, as a hole could be a real hole, which has no stream info, or a no-op which still belongs to some stream. Consider this case:\n\nIn epoch 0, sequencer issues a token with address 100 to stream A.\nNo one writes to this token, but the client queries sequencer for stream A and get back a bitmap that 100 belongs to stream A.\nEpoch changes to 1, new sequencer boots up, recovers the stream tail map from log unit, since no one writes to that token with address 100, log unit does not know about that token, neither does new sequencer.\nNew sequencer issues token 100 to stream B to new client\nNew client uses this token to enforce a hole for stream B (the checkpoint hole).\nNow the old client which operates on stream A finish the read, but it reads a hole with backpointer of stream B, since it's a hole, you will update the stream A's pointer to point to 100, which belongs to stream B and also put it in to the resolved queue.\n\nSo in this case we end up pointing stream A's pointer to a hole that belongs to stream B and put it into A's resolved queue.", "author": "WenbinZhu", "createdAt": "2020-04-01T23:51:39Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -84,11 +84,11 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                 // to be serviced immediately, rather than reading one entry at a time.\n                 ld = read(currentRead, queue);\n \n-                if (queue == getCurrentContext().readQueue && ld != null) {\n+                if (queue == getCurrentContext().readQueue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if (ld.isHole() || (ld.containsStream(this.id) && ld.isData())) {", "originalCommit": "aefcaf65e973053abc99dd96c7232af5c2db645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODI1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402028251", "bodyText": "Yes, I added check containsStream() for a no-op hole", "author": "zhangn49", "createdAt": "2020-04-02T03:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzI3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r401977278", "bodyText": "Same here, we might end up pointing to an address belonging to a different stream.", "author": "WenbinZhu", "createdAt": "2020-04-01T23:57:45Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractContextStreamView.java", "diffHunk": "@@ -284,7 +290,7 @@ protected boolean doesEntryUpdateContext(final ILogData data) {\n      */\n     private void updatePointer(final ILogData data) {\n         // Update the global pointer, if it is non-checkpoint data.\n-        if (data.getType() == DataType.DATA && !data.hasCheckpointMetadata()) {\n+        if ((data.isData() || data.isHole()) && !data.hasCheckpointMetadata()) {", "originalCommit": "aefcaf65e973053abc99dd96c7232af5c2db645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyODI5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402028299", "bodyText": "Done.", "author": "zhangn49", "createdAt": "2020-04-02T03:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzI3OA=="}], "type": "inlineReview"}, {"oid": "26db940be21a14202929e999696b809df7d22d89", "url": "https://github.com/CorfuDB/CorfuDB/commit/26db940be21a14202929e999696b809df7d22d89", "message": "Fix hole in tail", "committedDate": "2020-04-02T03:11:00Z", "type": "commit"}, {"oid": "26db940be21a14202929e999696b809df7d22d89", "url": "https://github.com/CorfuDB/CorfuDB/commit/26db940be21a14202929e999696b809df7d22d89", "message": "Fix hole in tail", "committedDate": "2020-04-02T03:11:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzODg5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402038897", "bodyText": "This is quite complex, I think it can be simplified to\nif ((ld.isData() || ld.isHole()) && ld.containsStream(this.id)) {\n(You don't need to check ld.getBackpointerMap().isEmpty(), containsStream is enough)", "author": "WenbinZhu", "createdAt": "2020-04-02T03:59:48Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -84,11 +84,13 @@ protected ILogData removeFromQueue(NavigableSet<Long> queue) {\n                 // to be serviced immediately, rather than reading one entry at a time.\n                 ld = read(currentRead, queue);\n \n-                if (queue == getCurrentContext().readQueue && ld != null) {\n+                if (queue == getCurrentContext().readQueue) {\n                     // Validate that the data entry belongs to this stream, otherwise, skip.\n                     // This verification protects from sequencer regression (tokens assigned in an older epoch\n                     // that were never written to, and reassigned on a newer epoch)\n-                    if (ld.containsStream(this.id) && ld.getType() == DataType.DATA) {\n+                    if ((ld.containsStream(this.id) && ld.isData()) ||\n+                            (ld.isHole() && (ld.getBackpointerMap().isEmpty() || ld.containsStream(this.id)))", "originalCommit": "26db940be21a14202929e999696b809df7d22d89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0Nzc3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402047779", "bodyText": "Sorry please ignore the previous commnet, I forgot we also need to include a real hole.\nI think we need to add a special NO_OP type, it's much cleaner in logic, and could solve the recursive call issue (nextUpTo does not need to retry for a NO_OP entry, just return to upper layer), if you would like to do...", "author": "WenbinZhu", "createdAt": "2020-04-02T04:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzODg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA2ODE2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402068161", "bodyText": "NO_OP type is cleaner in logic, but it involves more code reorg... I think we can combine it with further cleanup.", "author": "zhangn49", "createdAt": "2020-04-02T05:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAzODg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0ODgzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402048830", "bodyText": "I think we probably don't need to check containsStream here because when we call this method, logdata that does not belong to this stream should already be filtered out, could you double check?", "author": "WenbinZhu", "createdAt": "2020-04-02T04:45:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractContextStreamView.java", "diffHunk": "@@ -284,7 +290,9 @@ protected boolean doesEntryUpdateContext(final ILogData data) {\n      */\n     private void updatePointer(final ILogData data) {\n         // Update the global pointer, if it is non-checkpoint data.\n-        if (data.getType() == DataType.DATA && !data.hasCheckpointMetadata()) {\n+        if ((data.isData() && !data.hasCheckpointMetadata()) ||\n+                (data.isHole() && (data.getBackpointerMap().isEmpty() || data.containsStream(getCurrentContext().id)))\n+        ) {", "originalCommit": "26db940be21a14202929e999696b809df7d22d89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA2Njk5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2387#discussion_r402066994", "bodyText": "yes, removed.", "author": "zhangn49", "createdAt": "2020-04-02T05:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA0ODgzMA=="}], "type": "inlineReview"}, {"oid": "3df5889a2830524f0685b045efecc832b4d7dc59", "url": "https://github.com/CorfuDB/CorfuDB/commit/3df5889a2830524f0685b045efecc832b4d7dc59", "message": "Addressed comment", "committedDate": "2020-04-02T05:54:02Z", "type": "commit"}, {"oid": "365c54febc829ac239ffc0c51892f95d87364b04", "url": "https://github.com/CorfuDB/CorfuDB/commit/365c54febc829ac239ffc0c51892f95d87364b04", "message": "Merge branch 'master' into hole_in_tail", "committedDate": "2020-04-02T20:20:23Z", "type": "commit"}]}