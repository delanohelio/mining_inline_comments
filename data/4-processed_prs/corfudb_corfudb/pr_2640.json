{"pr_number": 2640, "pr_title": "Handle Trim Exceptions on Shadow Streams", "pr_createdAt": "2020-07-17T22:17:52Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2640", "timeline": [{"oid": "2ad463561e8b0379145f0ba3dac46932704fae1c", "url": "https://github.com/CorfuDB/CorfuDB/commit/2ad463561e8b0379145f0ba3dac46932704fae1c", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2", "committedDate": "2020-07-20T22:48:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNDc5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457804792", "bodyText": "I think this was already merged?", "author": "pankti-m", "createdAt": "2020-07-21T02:50:48Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -23,7 +23,7 @@\n @Slf4j\n public class LogReplicationMetadataManager {\n \n-    private static final String namespace = CORFU_SYSTEM_NAMESPACE;\n+    private static final String NAMESPACE = CORFU_SYSTEM_NAMESPACE;", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5ODcyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458298726", "bodyText": "mmm yeah I thought I had done it previously too. But I checked and it is correctly rebased, I think the only change is that since it's a static it's all caps.", "author": "annym", "createdAt": "2020-07-21T18:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNTI5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457805296", "bodyText": "this will get updated on role change", "author": "pankti-m", "createdAt": "2020-07-21T02:52:43Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -59,15 +67,12 @@\n     private LogReplicationMetadataManager logReplicationMetadataManager;\n     private RxState rxState;\n \n-    private LogReplicationConfig config;\n+    private final LogReplicationConfig config;", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MDA5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458470090", "bodyText": "so we should not make this final?", "author": "pankti-m", "createdAt": "2020-07-22T00:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MTA3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458471071", "bodyText": "sorry, I dint see you had already made that change", "author": "pankti-m", "createdAt": "2020-07-22T00:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457806406", "bodyText": "on receiving snapshot_end, applySnapshotSync applies the entries of the shadow streams.  We may want to move the callback to end there?", "author": "pankti-m", "createdAt": "2020-07-21T02:57:02Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -229,7 +258,13 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         if (rxState.equals(RxState.LOG_ENTRY_SYNC)) {\n             return logEntrySinkBufferManager.processMsgAndBuffer(message);\n         } else {\n-            return snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            LogReplicationEntry ack = snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            if (message.getMetadata().getMessageMetadataType() == SNAPSHOT_END) {\n+                // Notify end of snapshot sync. This is a blocking call.\n+                snapshotSyncPlugin.onSnapshotSyncEnd();", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjI3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458302276", "bodyText": "mmm but the snapshotPlugin is available in this class and not in the snapshotSinkBufferManager.", "author": "annym", "createdAt": "2020-07-21T18:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2OTkwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458469902", "bodyText": "ok, yes since we call it after processMsgAndBuffer(), the apply will have completed.", "author": "pankti-m", "createdAt": "2020-07-22T00:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NzA2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459167066", "bodyText": "Snapshot_end : means the data has been transferred to the standby site and the standby will start to apply the entries from shadow stream to the real streams.", "author": "xiaoqin2012", "createdAt": "2020-07-23T01:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2OTQxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459169413", "bodyText": "Is this a comment or a response to Pankti's comment?\nBecause snapshotSinkBufferManager.processMsgAndBuffer applies the data. So when it comes back we're sure it has been applied.", "author": "annym", "createdAt": "2020-07-23T01:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMDMwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459220301", "bodyText": "Should check the ack message. If there are still message in the buffer to be processed, the snapshot_end will be put into the buffer and the ack could be ack to an earlier message. When get snapshot_end, we need to remember the seqNum of the snapshot_end and check when the ack's seq number is the same as snapshot_end's seq number, it means snapshot_end has been processed.\nAnother option is to query the metadata.", "author": "xiaoqin2012", "createdAt": "2020-07-23T05:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4OTk3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459689976", "bodyText": "@xiaoqin2012 Would it be enough to change that check for:\nif (ack.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED)\nas this is the only ACK sent at the end of all received snapshot sync.", "author": "annym", "createdAt": "2020-07-23T19:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5NjM3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459696372", "bodyText": "mm I'm actually thinking that yeah we probably would need to complement this with keeping the latests started snapshot sync TS in the metadata to cover the case of an ongoing snapshot which is canceled (but still completed out of order)", "author": "annym", "createdAt": "2020-07-23T20:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjU4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457806586", "bodyText": "currentTs instead of buffer?", "author": "pankti-m", "createdAt": "2020-07-21T02:57:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java", "diffHunk": "@@ -142,11 +142,13 @@ public LogReplicationEntry processMsgAndBuffer(LogReplicationEntry dataMessage)\n         long currentTs = getCurrentSeq(dataMessage);\n \n         if (preTs == lastProcessedSeq) {\n+            log.trace(\"Received in order message={}, lastProcessed={}\", currentTs, lastProcessedSeq);\n             sinkManager.processMessage(dataMessage);\n             ackCnt++;\n             lastProcessedSeq = getCurrentSeq(dataMessage);\n             processBuffer();\n         } else if (currentTs > lastProcessedSeq && buffer.size() < maxSize) {\n+            log.debug(\"Received unordered message, buffer={}, lastProcessed={}\", currentTs, lastProcessedSeq);", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjgwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457806807", "bodyText": "can it be made private?", "author": "pankti-m", "createdAt": "2020-07-21T02:58:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/StreamsSnapshotWriter.java", "diffHunk": "@@ -19,84 +19,107 @@\n \n import javax.annotation.concurrent.NotThreadSafe;\n import java.lang.reflect.Array;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.UUID;\n import java.util.stream.Stream;\n \n /**\n- * Writing a snapshot fullsync data\n- * Open streams interested and append all entries\n+ * This class represents the entity responsible of writing streams' snapshots into the standby cluster DB.\n+ *\n+ * Snapshot sync is the process of transferring a snapshot of the DB, for this reason, data is temporarily applied\n+ * to shadow streams in an effort to avoid inconsistent states. Once all the data is received, the shadow streams\n+ * are applied into the actual streams.\n  */\n \n @Slf4j\n @NotThreadSafe\n public class StreamsSnapshotWriter implements SnapshotWriter {\n-    final static String SHADOW_STREAM_NAME_SUFFIX = \"_shadow\";\n-    HashMap<UUID, String> streamViewMap; // It contains all the streams registered for write to.\n-    HashMap<UUID, String> shadowMap;\n-    CorfuRuntime rt;\n \n-    long siteConfigID;\n+    private static final UUID NIL_UUID = new UUID(0,0);\n+    final static String SHADOW_STREAM_SUFFIX = \"_SHADOW\";", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTk4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457809988", "bodyText": "does this only apply to logEntrySync?  because for snapshot sync we only ack after all entries are received...", "author": "pankti-m", "createdAt": "2020-07-21T03:11:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/send/LogReplicationEventMetadata.java", "diffHunk": "@@ -20,12 +20,15 @@\n      */\n     private UUID requestId;\n \n-    /* Represents the last synced timestamp.\n-     *\n-     * For snapshot sync, it represents the base snapshot.\n-     * For log entry sync, it represents the last log entry synced.\n-    */\n-    private long syncTimestamp;\n+    /*\n+     * Represents the last log entry synced timestamp.\n+     */\n+    private long lastLogEntrySyncedTimestamp;", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5OTU2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458299567", "bodyText": "correct, it only applies for LogEntrySync.", "author": "annym", "createdAt": "2020-07-21T18:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxMTU1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457811555", "bodyText": "remove?", "author": "pankti-m", "createdAt": "2020-07-21T03:17:04Z", "path": "test/src/test/java/org/corfudb/integration/AbstractIT.java", "diffHunk": "@@ -556,7 +561,8 @@ public String getOptionsString() {\n          * @throws IOException\n          */\n         public Process runServer() throws IOException {\n-            final String serverConsoleLogPath = CORFU_LOG_PATH + File.separator + host + \"_\" + port + \"_consolelog\";\n+            // final String serverConsoleLogPath = CORFU_LOG_PATH + File.separator + host + \"_\" + port + \"_consolelog\";\n+            final String serverConsoleLogPath = \"/Users/amartinezman/Desktop/gm\" + File.separator + host + \"_\" + port + \"_consolelog\";", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxMTk1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r457811959", "bodyText": "is this log message required?", "author": "pankti-m", "createdAt": "2020-07-21T03:18:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SnapshotSinkBufferManager.java", "diffHunk": "@@ -84,14 +84,8 @@ public LogReplicationEntryMetadata makeAckMessage(LogReplicationEntry entry) {\n      */\n     @Override\n     public boolean verifyMessageType(LogReplicationEntry entry) {\n-        switch (entry.getMetadata().getMessageMetadataType()) {\n-            case SNAPSHOT_MESSAGE:\n-            case SNAPSHOT_END:\n-                return true;\n-            default:\n-                log.error(\"wrong message type \", entry.getMetadata());", "originalCommit": "2ad463561e8b0379145f0ba3dac46932704fae1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNDg4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458304887", "bodyText": "I added it on the caller!", "author": "annym", "createdAt": "2020-07-21T18:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxMTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NDY5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458474696", "bodyText": "I had questions about it in PR, looks like now its fixed, cool", "author": "PavelZaytsev", "createdAt": "2020-07-22T01:07:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/LogReplicationFSM.java", "diffHunk": "@@ -290,26 +289,26 @@ private void consume() {\n             LogReplicationEvent event = eventQueue.take();\n \n             if (event.getType() == LogReplicationEventType.REPLICATION_START) {\n-                baseSnapshot = event.getMetadata().getSyncTimestamp();\n-                ackedTimestamp = baseSnapshot;\n+                baseSnapshot = event.getMetadata().getLastBaseSnapshot();", "originalCommit": "42785963621a5acf02111c8bebe0cde34406cc6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MTc2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r458481763", "bodyText": "yes, most likely you were hitting this bug as well!", "author": "annym", "createdAt": "2020-07-22T01:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NDY5Ng=="}], "type": "inlineReview"}, {"oid": "cd158f283997066598da3407d054407f7de10d01", "url": "https://github.com/CorfuDB/CorfuDB/commit/cd158f283997066598da3407d054407f7de10d01", "message": "Address Comments", "committedDate": "2020-07-22T15:53:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NzU2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459167562", "bodyText": "streamViewMap should not change after initialized?", "author": "xiaoqin2012", "createdAt": "2020-07-23T01:13:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/StreamsSnapshotWriter.java", "diffHunk": "@@ -19,84 +19,106 @@\n \n import javax.annotation.concurrent.NotThreadSafe;\n import java.lang.reflect.Array;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.UUID;\n import java.util.stream.Stream;\n \n /**\n- * Writing a snapshot fullsync data\n- * Open streams interested and append all entries\n+ * This class represents the entity responsible of writing streams' snapshots into the standby cluster DB.\n+ *\n+ * Snapshot sync is the process of transferring a snapshot of the DB, for this reason, data is temporarily applied\n+ * to shadow streams in an effort to avoid inconsistent states. Once all the data is received, the shadow streams\n+ * are applied into the actual streams.\n  */\n \n @Slf4j\n @NotThreadSafe\n public class StreamsSnapshotWriter implements SnapshotWriter {\n-    final static String SHADOW_STREAM_NAME_SUFFIX = \"_shadow\";\n-    HashMap<UUID, String> streamViewMap; // It contains all the streams registered for write to.\n-    HashMap<UUID, String> shadowMap;\n-    CorfuRuntime rt;\n \n-    long siteConfigID;\n+    private static final UUID NIL_UUID = new UUID(0,0);\n+    private final static String SHADOW_STREAM_SUFFIX = \"_SHADOW\";\n+\n+    // Mapping from regular stream Id to stream Name\n+    private HashMap<UUID, String> streamViewMap;\n+    private CorfuRuntime rt;\n+\n+    private long topologyConfigId;\n     private long srcGlobalSnapshot; // The source snapshot timestamp\n     private long recvSeq;\n     private long shadowStreamStartAddress;\n+\n     @Getter\n     private LogReplicationMetadataManager logReplicationMetadataManager;\n-    HashMap<UUID, UUID> uuidMap;\n-    Phase phase;\n-\n-\n-    // The sequence number of the message, it has received.\n-    // It is expecting the message in order of the sequence.\n+    private HashMap<UUID, UUID> uuidMap;\n+    private Phase phase;\n \n     public StreamsSnapshotWriter(CorfuRuntime rt, LogReplicationConfig config, LogReplicationMetadataManager logReplicationMetadataManager) {\n         this.rt = rt;\n         this.logReplicationMetadataManager = logReplicationMetadataManager;\n-        streamViewMap = new HashMap<>();\n-        uuidMap = new HashMap<>();\n-        shadowMap = new HashMap<>();\n-        phase = Phase.TransferPhase;\n-\n-        for (String stream : config.getStreamsToReplicate()) {\n-            String shadowStream = stream + SHADOW_STREAM_NAME_SUFFIX;\n-            UUID streamID = CorfuRuntime.getStreamID(stream);\n-            UUID shadowID = CorfuRuntime.getStreamID(shadowStream);\n-            uuidMap.put(streamID, shadowID);\n-            uuidMap.put(shadowID, streamID);\n-            streamViewMap.put(streamID, stream);\n-            shadowMap.put(shadowID, shadowStream);\n+        this.streamViewMap = new HashMap<>();\n+        this.uuidMap = new HashMap<>();\n+        this.phase = Phase.TRANSFER_PHASE;\n+\n+        initializeShadowStreams(config);\n+    }\n+\n+    /**\n+     * Create shadow streams.\n+     *\n+     * We create a shadow stream per stream to replicate. A shadow stream aims to accumulate updates\n+     * temporarily while the (full) snapshot sync completes. Shadow streams aim to avoid inconsistent\n+     * states while data is still being transferred from active to standby.\n+     *\n+     * We currently, wait for snapshot sync to complete before applying data in shadow streams\n+     * to the actual streams, this means that there is still a window of inconsistency as apply is not atomic,\n+     * but at least inconsistency is at a point where there is guarantee of all data being available on the receiver.\n+     * In the future, we will support Table Aliasing which will enable atomic flip from shadow to regular streams, avoiding\n+     * complete inconsistency.\n+     */\n+    private void initializeShadowStreams(LogReplicationConfig config) {\n+        // For every stream create a shadow stream which name is unique based\n+        // on the original stream and a suffix.\n+        for (String streamName : config.getStreamsToReplicate()) {\n+            String shadowStreamName = streamName + SHADOW_STREAM_SUFFIX;\n+            UUID streamId = CorfuRuntime.getStreamID(streamName);\n+            UUID shadowStreamId = CorfuRuntime.getStreamID(shadowStreamName);\n+            uuidMap.put(streamId, shadowStreamId);\n+            uuidMap.put(shadowStreamId, streamId);\n+            streamViewMap.put(streamId, streamName);\n+", "originalCommit": "cd158f283997066598da3407d054407f7de10d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxMTg5MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459711890", "bodyText": "done.", "author": "annym", "createdAt": "2020-07-23T20:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459168496", "bodyText": "Is it necessary to set ignore the trim? How about there is a bug in the plugin?\nIf the plugin works correct, we should not get trimmed exception. If the plugin doesn't work properly, the working shadow stream can still be trimmed and we get a trim exception, right?", "author": "xiaoqin2012", "createdAt": "2020-07-23T01:17:05Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/StreamsSnapshotWriter.java", "diffHunk": "@@ -205,37 +227,43 @@ public void apply(List<LogReplicationEntry> messages) throws Exception {\n     }\n \n     /**\n-     * Read from the shadow table and write to the real table\n-     * @param uuid: the real table uuid\n+     * Read from the shadow table and write to the original stream\n+     *\n+     * @param streamId regular stream id\n+     * @param seqNum sequence number to apply\n+     * @param snapshot base snapshot timestamp\n      */\n-    public long applyShadowStream(UUID uuid, Long seqNum, long snapshot) {\n-        UUID shadowUUID = uuidMap.get(uuid);\n+    private long applyShadowStream(UUID streamId, long seqNum, long snapshot) {\n+        UUID shadowStreamId = uuidMap.get(streamId);\n+\n+        // We can safely ignore trims on the shadow stream, as our protocol guarantees\n+        // that the checkpointer/trimmer will not run during a snapshot sync. Therefore,\n+        // any observed TrimmedException belongs to different snapshot cycles, for which,\n+        // old data is guaranteed to be applied.\n         StreamOptions options = StreamOptions.builder()\n-                .ignoreTrimmed(false)\n+                .ignoreTrimmed(true)", "originalCommit": "cd158f283997066598da3407d054407f7de10d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE3MDE3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459170177", "bodyText": "If we don't ignore the trim, we'll get TrimmedExceptions on a new snapshot cycle. At the end of the first snapshot cycle we signal the plugin to resume checkpoint/trim, therefore, by the second cycle, the shadow stream has been trimmed one or several times.", "author": "annym", "createdAt": "2020-07-23T01:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE3MTA0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459171045", "bodyText": "Can we still open a stream that has been trimmed but no checkpoint? If there is bug in the plug in, we may lose data.\nCan we bookkeeping the log timestamp where the current snapshot start to write to the shadow stream, while start to apply, we open the the stream and see the start timestamp is not trimmed?", "author": "xiaoqin2012", "createdAt": "2020-07-23T01:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1NjA0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459256047", "bodyText": "mmm, yeah I think this is something we can do. Let me try it out.", "author": "annym", "createdAt": "2020-07-23T07:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMDAzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459700032", "bodyText": "fyi if you plan to do bookkeeping note that the snashotSync plugin already captures this info. please feel free to add a getter method to get the wall clock timestamp when the last snapshot sync requested checkpoint freezing.", "author": "hisundar", "createdAt": "2020-07-23T20:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMzAzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459803030", "bodyText": "I mean the log sequence number not the wall time. I am still curious if the stream can be opened if it has been trimmed without checkpointing.", "author": "xiaoqin2012", "createdAt": "2020-07-24T00:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2ODQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2OTUyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459169521", "bodyText": "We better remove this constructor, or add setting the baseSnapshot.", "author": "xiaoqin2012", "createdAt": "2020-07-23T01:21:46Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/send/LogReplicationEventMetadata.java", "diffHunk": "@@ -53,16 +56,31 @@ public LogReplicationEventMetadata(UUID requestId) {\n      */\n     public LogReplicationEventMetadata(UUID requestId, long syncTimestamp) {\n         this.requestId = requestId;\n-        this.syncTimestamp = syncTimestamp;\n+        this.lastLogEntrySyncedTimestamp = syncTimestamp;", "originalCommit": "cd158f283997066598da3407d054407f7de10d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMzkxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459803919", "bodyText": "For several cases this event only has meaning for log entry and doesn't really handle the baseSnapshot, actually from where we call it, it has no notion of it.", "author": "annym", "createdAt": "2020-07-24T00:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2OTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MDU0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459190542", "bodyText": "Can this method take a CorfuRuntime as a parameter? Without that it's tricky to re-initialize a new runtime just for freezing checkpointing.", "author": "hisundar", "createdAt": "2020-07-23T02:59:16Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultSnapshotSyncPlugin.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.corfudb.infrastructure.logreplication.infrastructure.plugins;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Default Snapshot Sync Plugin\n+ *\n+ * This implementation returns immediately for start and end of a snapshot sync.\n+ */\n+@Slf4j\n+public class DefaultSnapshotSyncPlugin implements ISnapshotSyncPlugin {\n+\n+    @Override\n+    public void onSnapshotSyncStart() {", "originalCommit": "cd158f283997066598da3407d054407f7de10d01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5MDU4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459190589", "bodyText": "Can this method take a CorfuRuntime as a parameter? Without that it's tricky to re-initialize a new runtime just for unfreezing checkpointing.", "author": "hisundar", "createdAt": "2020-07-23T02:59:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/DefaultSnapshotSyncPlugin.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.corfudb.infrastructure.logreplication.infrastructure.plugins;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Default Snapshot Sync Plugin\n+ *\n+ * This implementation returns immediately for start and end of a snapshot sync.\n+ */\n+@Slf4j\n+public class DefaultSnapshotSyncPlugin implements ISnapshotSyncPlugin {\n+\n+    @Override\n+    public void onSnapshotSyncStart() {\n+        log.debug(\"onSnapshotSyncStart :: OK\");\n+    }\n+\n+    @Override\n+    public void onSnapshotSyncEnd() {", "originalCommit": "cd158f283997066598da3407d054407f7de10d01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ce65cc9f4d34954150393f2629ef79025b477bb", "url": "https://github.com/CorfuDB/CorfuDB/commit/6ce65cc9f4d34954150393f2629ef79025b477bb", "message": "pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-23T03:23:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NTcyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459855728", "bodyText": "While doing snapshot transfer, all message has the same snapshottimestamp. May check the metadata's seqNum + 1 = ack's seqNum.", "author": "xiaoqin2012", "createdAt": "2020-07-24T05:16:58Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -226,49 +256,89 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n             return null;\n         }\n \n+        return processReceivedMessage(message);\n+    }\n+\n+    /**\n+     * Process received (valid) message depending on the current rx state (LOG_ENTRY_SYNC or SNAPSHOT_SYNC)\n+     *\n+     * @param message received message\n+     * @return ack\n+     */\n+    private LogReplicationEntry processReceivedMessage(LogReplicationEntry message) {\n         if (rxState.equals(RxState.LOG_ENTRY_SYNC)) {\n             return logEntrySinkBufferManager.processMsgAndBuffer(message);\n         } else {\n-            return snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            LogReplicationEntry ack = snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            if (ack.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n+                long lastStartedSnapshotSync = logReplicationMetadataManager.getLastSnapStartTimestamp();\n+                // Verify this snapshot ACK corresponds to the last initialized/valid snapshot sync\n+                // as a previous one could have been canceled but still processed due to messages being out of order\n+                if (ack.getMetadata().getSnapshotTimestamp() == lastStartedSnapshotSync) {\n+                    // Notify end of snapshot sync. This is a blocking call.", "originalCommit": "93049a8f6a828422a3c8eef481676a31f48e3e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDI3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459864278", "bodyText": "Make it more clear, we start a snapshot transfer for snapshot timestamp 10,\nthe first message is snapshot_start with seqNum= -1 and snapshot timestamp 10,\nthe second message is snapshot_msg with seqNum=0, and snapshot timestamp 10.\nthe last one is snapshot_end with seqNum=1, and snapshot timestamp 10.\nSo all message has the same snapshot timestamp, but different SeqNum.\nMay check the metadata:\nif snapshot appliedDone == ack.snapshottimestamp then it is done. make it more robust the ack's seqNum is seqNum + 1 (seqNum from metadata)", "author": "xiaoqin2012", "createdAt": "2020-07-24T05:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NTcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MzE0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r460173149", "bodyText": "If there are leadership change during full snapshot transfer, we need to consider the following steps:\n\nolder leader make a call to set the trim holder.\nleadership. change at the standby cluster, the new leader will re-run the full cycle of snapshot sync by reset the persisted metadata. // this will block the old leader to clear the trim holder.\nthe new leader set the trim holder again.\n\nIf we guarantee that reset the persisted metadata first, then put trim holder, may it be correct?", "author": "xiaoqin2012", "createdAt": "2020-07-24T16:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDE5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r459860191", "bodyText": "ongoing snapshot sync is ack.getMetadata().getSnapshotTimestamp(), right?", "author": "pankti-m", "createdAt": "2020-07-24T05:37:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -226,49 +256,89 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n             return null;\n         }\n \n+        return processReceivedMessage(message);\n+    }\n+\n+    /**\n+     * Process received (valid) message depending on the current rx state (LOG_ENTRY_SYNC or SNAPSHOT_SYNC)\n+     *\n+     * @param message received message\n+     * @return ack\n+     */\n+    private LogReplicationEntry processReceivedMessage(LogReplicationEntry message) {\n         if (rxState.equals(RxState.LOG_ENTRY_SYNC)) {\n             return logEntrySinkBufferManager.processMsgAndBuffer(message);\n         } else {\n-            return snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            LogReplicationEntry ack = snapshotSinkBufferManager.processMsgAndBuffer(message);\n+            if (ack.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n+                long lastStartedSnapshotSync = logReplicationMetadataManager.getLastSnapStartTimestamp();\n+                // Verify this snapshot ACK corresponds to the last initialized/valid snapshot sync\n+                // as a previous one could have been canceled but still processed due to messages being out of order\n+                if (ack.getMetadata().getSnapshotTimestamp() == lastStartedSnapshotSync) {\n+                    // Notify end of snapshot sync. This is a blocking call.\n+                    snapshotSyncPlugin.onSnapshotSyncEnd(runtime);\n+                } else {\n+                    log.warn(\"SNAPSHOT_SYNC has completed for {}, but new ongoing SNAPSHOT_SYNC is {}\",\n+                            ack.getMetadata().getSnapshotTimestamp(), lastStartedSnapshotSync);", "originalCommit": "93049a8f6a828422a3c8eef481676a31f48e3e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE5MzA5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2640#discussion_r460193095", "bodyText": "No, the ongoing one is the one persisted in the datastore. The ack might come from processing some old stuff in the buffer.", "author": "annym", "createdAt": "2020-07-24T17:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDE5MQ=="}], "type": "inlineReview"}, {"oid": "40de1c1a3a6b4105921622a3accd4f3f72845e0f", "url": "https://github.com/CorfuDB/CorfuDB/commit/40de1c1a3a6b4105921622a3accd4f3f72845e0f", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T07:29:13Z", "type": "forcePushed"}, {"oid": "2cbda2c20885ad2d931367ca306f47c2038379d5", "url": "https://github.com/CorfuDB/CorfuDB/commit/2cbda2c20885ad2d931367ca306f47c2038379d5", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T07:32:34Z", "type": "forcePushed"}, {"oid": "3341a11c1fb492ce1cb928210656087547ae8394", "url": "https://github.com/CorfuDB/CorfuDB/commit/3341a11c1fb492ce1cb928210656087547ae8394", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T07:38:23Z", "type": "forcePushed"}, {"oid": "8aead984e253185a6e9ddf11e0750264df322bf1", "url": "https://github.com/CorfuDB/CorfuDB/commit/8aead984e253185a6e9ddf11e0750264df322bf1", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T19:37:31Z", "type": "forcePushed"}, {"oid": "397e9687a34f03bf5baa5d7ebe681d5a18a114bc", "url": "https://github.com/CorfuDB/CorfuDB/commit/397e9687a34f03bf5baa5d7ebe681d5a18a114bc", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T21:30:08Z", "type": "forcePushed"}, {"oid": "f802c42b293386166061ea0333128763263331df", "url": "https://github.com/CorfuDB/CorfuDB/commit/f802c42b293386166061ea0333128763263331df", "message": "Do not ignore trim on shadow stream", "committedDate": "2020-07-24T22:46:51Z", "type": "forcePushed"}, {"oid": "11986a4ccf6c9970dfc3fe88cbb0f1fc0affce0a", "url": "https://github.com/CorfuDB/CorfuDB/commit/11986a4ccf6c9970dfc3fe88cbb0f1fc0affce0a", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2\n4. Pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-24T22:47:34Z", "type": "forcePushed"}, {"oid": "6c70090d652dbfb50a4f1b8441a68639cc5cae8e", "url": "https://github.com/CorfuDB/CorfuDB/commit/6c70090d652dbfb50a4f1b8441a68639cc5cae8e", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2\n4. Pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-24T22:56:05Z", "type": "forcePushed"}, {"oid": "9a0bcacf20284c8c862b8ef58199fa1cf66fc948", "url": "https://github.com/CorfuDB/CorfuDB/commit/9a0bcacf20284c8c862b8ef58199fa1cf66fc948", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2\n4. Pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-24T23:00:13Z", "type": "forcePushed"}, {"oid": "955129fc0f069d390aca86e87d03abb20c4948c2", "url": "https://github.com/CorfuDB/CorfuDB/commit/955129fc0f069d390aca86e87d03abb20c4948c2", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2\n4. Pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-25T00:26:12Z", "type": "commit"}, {"oid": "955129fc0f069d390aca86e87d03abb20c4948c2", "url": "https://github.com/CorfuDB/CorfuDB/commit/955129fc0f069d390aca86e87d03abb20c4948c2", "message": "Handle Trim Exceptions on Shadow Streams\n\n1. Implement a callback mechanism, where snapshot sync start/end is notified\nto a plugin, so checkpoint/trim is disabled for the duration of snapshot sync.\n2. Bug Fix: properly set base snapshot on renegotiation for two different log entry (delta) sync cycles\n3. Tests to verify 1 and 2\n4. Pass CorfuRuntime instance to the onSnapshotSyncStart/End() calls", "committedDate": "2020-07-25T00:26:12Z", "type": "forcePushed"}]}