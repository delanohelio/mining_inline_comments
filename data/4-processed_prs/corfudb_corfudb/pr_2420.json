{"pr_number": 2420, "pr_title": "Change how StreamView interacts with its trim mark", "pr_createdAt": "2020-02-19T19:22:48Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2420", "timeline": [{"oid": "372cadc82f2885eae1e11aba80c7e2f7ad672511", "url": "https://github.com/CorfuDB/CorfuDB/commit/372cadc82f2885eae1e11aba80c7e2f7ad672511", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-19T19:24:53Z", "type": "forcePushed"}, {"oid": "478420a40def611f4ee0ec1ef41c24559c426cf5", "url": "https://github.com/CorfuDB/CorfuDB/commit/478420a40def611f4ee0ec1ef41c24559c426cf5", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-19T19:49:30Z", "type": "forcePushed"}, {"oid": "ac193cbc51588bf20c68c964bbc4e616961d4684", "url": "https://github.com/CorfuDB/CorfuDB/commit/ac193cbc51588bf20c68c964bbc4e616961d4684", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-19T20:57:17Z", "type": "forcePushed"}, {"oid": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "url": "https://github.com/CorfuDB/CorfuDB/commit/cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-19T21:10:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NTQxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383575415", "bodyText": "typo -> immediately", "author": "annym", "createdAt": "2020-02-24T23:28:12Z", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -210,21 +210,76 @@ public void rawStreamConsumer() {\n                 .setStreamName(tableName)\n                 .open();\n \n-        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n-        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n-        // Seek beyond the last trimmed address.\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n         // The first call to remainingUpTo() will load the checkpoint, and the\n         // second one will fetch the actual data.\n-        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThat(Stream.of(\n+                stream.remainingUpTo(Long.MAX_VALUE), stream.remainingUpTo(Long.MAX_VALUE))\n                 .map(List::size).mapToInt(Integer::intValue).sum())\n                 .isEqualTo(BATCH_SIZE);\n \n         trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n         IntStream.range(0, BATCH_SIZE).forEach(idx -> newMap.put(idx, idx));\n-        Assertions.assertThatThrownBy(() -> s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThatThrownBy(() -> stream.remainingUpTo(Long.MAX_VALUE))\n                 .isInstanceOf(TrimmedException.class);\n     }\n \n+    /**\n+     * Verify that the streaming interface can be consumed directly after\n+     * several checkpoint and trim cycles.\n+     */\n+    @Test\n+    public void rawStreamConsumerMultipleCheckpointTrim() {\n+        final int BATCH_SIZE = 10;\n+        final int CHECKPOINT_SIZE = 3;\n+        final String CHECKPOINT_AUTHOR = \"Author\";\n+        final String tableName = \"test\";\n+        final CorfuTable<Integer, Integer> map = getDefaultRuntime().getObjectsView().build()\n+                .setTypeToken(new TypeToken<CorfuTable<Integer, Integer>>() {})\n+                .setStreamName(tableName)\n+                .open();\n+\n+        final MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter();\n+        mcw.addMap(map);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+        trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        CorfuRuntime newRuntime = getNewRuntime(getDefaultNode()).connect();\n+\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n+        // Replay to the stream to the latest address.\n+        // The first call to remainingUpTo() will load the checkpoint, and the\n+        // second one will fetch the actual data.\n+        Assertions.assertThat(Stream.of(\n+                stream.remainingUpTo(Long.MAX_VALUE), stream.remainingUpTo(Long.MAX_VALUE))\n+                .map(List::size).mapToInt(Integer::intValue).sum())\n+                .isEqualTo(BATCH_SIZE);\n+\n+        // Create a new checkpoint, produce some data and imediatelly consume it.", "originalCommit": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MDEzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383580137", "bodyText": "Could we change this to (BATCH_SIZE, BATCH_SIZE*2)? so we have different indexes, and easily verify if the checkpoint was loaded?", "author": "annym", "createdAt": "2020-02-24T23:43:15Z", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -200,7 +201,6 @@ public void rawStreamConsumer() {\n \n         IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));", "originalCommit": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNDM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r384124385", "bodyText": "Done,", "author": "vjeko", "createdAt": "2020-02-25T21:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MDEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNDU0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383634547", "bodyText": "By looking at this comment \"the first call to remainingUpTo will load the checkpoint, and the second will fetch the actual data\" made me think that we might also have a problem in the AbstractQueuedStreamView, getNextEntries. Because think of the behavior. If you seek up to 13, and you ask for the remaining up to 'X', you should directly obtain all the remaining entries from 13 up to to 'X', you shouldn't have to run it twice, once to load the checkpoint (which anyways is not used because we don't care about the checkpoint entries in this case) and then to complete the rest (13-24).\nNote that this does not affect the Object Layer, cause the object layer goes through the getNextEntry, which first loads from the checkpoint and after (in the same call) looks for the rest. Which is the right behavior to ensure there's no data loss.\nAlso, maybe we don't even need to load the checkpoint (in all cases)... The side door to the stream access (not through the object layer) could probably ignore the checkpoint (in some cases), anyways it is strictly returning the remainingUpTo ... from seek to 'X'.", "author": "annym", "createdAt": "2020-02-25T03:01:46Z", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -210,21 +210,76 @@ public void rawStreamConsumer() {\n                 .setStreamName(tableName)\n                 .open();\n \n-        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n-        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n-        // Seek beyond the last trimmed address.\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n         // The first call to remainingUpTo() will load the checkpoint, and the\n         // second one will fetch the actual data.\n-        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThat(Stream.of(", "originalCommit": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNjU5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383636599", "bodyText": "I tried placing a second\nboolean readQueue2IsEmpty = !fillReadQueue(maxGlobal, context);\n(for quickly testing) in the getNextEntries of AbstractQueueStreamView and that does the job. This would cause the first one to load the checkpoint and the second to load from the regular stream. Perhaps we could push it down to the fillReadQueue so it also discovers the address space for the regular stream after it does it for the checkpoint (we need to double check that does not affect the object layer). I think it won't as the object layer does this through the getNextEntry anyways. But again, maybe we can think of a better strategy as to not load the checkpoint if not needed.", "author": "annym", "createdAt": "2020-02-25T03:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzNzMyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r384237322", "bodyText": "Getting rid of return true; statement in if (context.getCheckpoint() == StreamCheckpoint.UNINITIALIZED)  block and replacing other returns with return areReadQueuesNonEmpty() should resolve the issue.\nIn case when we request an address below the trim mark, the second call to discoverAddressSpace(...) will not get called because of:\n        if (context.getGlobalPointer() >= maxAddress) {\n            return areReadQueuesNonEmpty(context);\n        }", "author": "vjeko", "createdAt": "2020-02-26T02:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNDg3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r384814876", "bodyText": "Turns out we should update the global pointer after loading the checkpoint as well.", "author": "vjeko", "createdAt": "2020-02-26T22:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MDg4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383640882", "bodyText": "Also, this second shouldn't really fail, cause think about it, we did a remaining up to which brought addresses 14-23. The problem is that because of another issue we're writing a hole for every checkpoint and this hole, makes the stream layer try to sync up to 24 (though 24 is a hole, but there's no way for us to know)... This means that, someone consuming the stream regularly will eventually hit this issue whenever the remainingUpTo happens after the checkpoint/trim.", "author": "annym", "createdAt": "2020-02-25T03:30:27Z", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -210,21 +210,76 @@ public void rawStreamConsumer() {\n                 .setStreamName(tableName)\n                 .open();\n \n-        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n-        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n-        // Seek beyond the last trimmed address.\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n         // The first call to remainingUpTo() will load the checkpoint, and the\n         // second one will fetch the actual data.\n-        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThat(Stream.of(\n+                stream.remainingUpTo(Long.MAX_VALUE), stream.remainingUpTo(Long.MAX_VALUE))\n                 .map(List::size).mapToInt(Integer::intValue).sum())\n                 .isEqualTo(BATCH_SIZE);\n \n         trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n         IntStream.range(0, BATCH_SIZE).forEach(idx -> newMap.put(idx, idx));\n-        Assertions.assertThatThrownBy(() -> s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThatThrownBy(() -> stream.remainingUpTo(Long.MAX_VALUE))", "originalCommit": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MTYzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383641632", "bodyText": "Now, we should try to live with this additional hole (at least for now) as it is solving another issue and the alternative to solve that issue had implications in data migration. Still, we might need a notion of the maximum resolved address (including holes) because we filter them in the AbstractQueuedStreamView. This would protect us, when the remainingUpTo is executed before the checkpoint/trim and the last address was a hole.", "author": "annym", "createdAt": "2020-02-25T03:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MDg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2OTg4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383669885", "bodyText": "Good catch! Let me look into this.", "author": "vjeko", "createdAt": "2020-02-25T05:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MDg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0OTUwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r384149509", "bodyText": "@annym Can you take a look at the current approach? Basically we force holes to end up in the resolved queue, which prevents TrimmedException.", "author": "vjeko", "createdAt": "2020-02-25T21:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MDg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzOTY5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r384239699", "bodyText": "We seem to have a notion of the maximum resolved address via the globalPointer within AbstractStreamContext. After making globalPointer hole-aware, the problem does not happen.\n        // Update the global pointer\n        if (readFrom.size() > 0) {\n            context.setGlobalPointerCheckGCTrimMark(readFrom.get(readFrom.size() - 1)\n                    .getGlobalAddress());\n        }", "author": "vjeko", "createdAt": "2020-02-26T02:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0MDg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1NzQzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r383657436", "bodyText": "This part of the code is the same as per the preview test, we can move it to a function to reuse.", "author": "annym", "createdAt": "2020-02-25T04:51:24Z", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -210,21 +210,76 @@ public void rawStreamConsumer() {\n                 .setStreamName(tableName)\n                 .open();\n \n-        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n-        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n-        // Seek beyond the last trimmed address.\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n         // The first call to remainingUpTo() will load the checkpoint, and the\n         // second one will fetch the actual data.\n-        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThat(Stream.of(\n+                stream.remainingUpTo(Long.MAX_VALUE), stream.remainingUpTo(Long.MAX_VALUE))\n                 .map(List::size).mapToInt(Integer::intValue).sum())\n                 .isEqualTo(BATCH_SIZE);\n \n         trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n         IntStream.range(0, BATCH_SIZE).forEach(idx -> newMap.put(idx, idx));\n-        Assertions.assertThatThrownBy(() -> s.remainingUpTo(Long.MAX_VALUE))\n+        Assertions.assertThatThrownBy(() -> stream.remainingUpTo(Long.MAX_VALUE))\n                 .isInstanceOf(TrimmedException.class);\n     }\n \n+    /**\n+     * Verify that the streaming interface can be consumed directly after\n+     * several checkpoint and trim cycles.\n+     */\n+    @Test\n+    public void rawStreamConsumerMultipleCheckpointTrim() {\n+        final int BATCH_SIZE = 10;\n+        final int CHECKPOINT_SIZE = 3;\n+        final String CHECKPOINT_AUTHOR = \"Author\";\n+        final String tableName = \"test\";\n+        final CorfuTable<Integer, Integer> map = getDefaultRuntime().getObjectsView().build()\n+                .setTypeToken(new TypeToken<CorfuTable<Integer, Integer>>() {})\n+                .setStreamName(tableName)\n+                .open();\n+\n+        final MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter();\n+        mcw.addMap(map);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+        trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        CorfuRuntime newRuntime = getNewRuntime(getDefaultNode()).connect();\n+\n+        // Create a new stream and seek beyond the last trimmed address.\n+        IStreamView stream = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        stream.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+\n+        // Replay to the stream to the latest address.\n+        // The first call to remainingUpTo() will load the checkpoint, and the\n+        // second one will fetch the actual data.", "originalCommit": "cba9020c1ce4da133ea62cd6fe0e44b0d1fb546a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "269f140754a6184419e4cf4ae11e28a509b2e87d", "url": "https://github.com/CorfuDB/CorfuDB/commit/269f140754a6184419e4cf4ae11e28a509b2e87d", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-25T21:51:39Z", "type": "forcePushed"}, {"oid": "85a8cc0205560f177f74d4fcb62b59672779812c", "url": "https://github.com/CorfuDB/CorfuDB/commit/85a8cc0205560f177f74d4fcb62b59672779812c", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-25T23:55:19Z", "type": "forcePushed"}, {"oid": "0bd6a52fa97cc0d9e491f8f8d7ee3e8afb7e1846", "url": "https://github.com/CorfuDB/CorfuDB/commit/0bd6a52fa97cc0d9e491f8f8d7ee3e8afb7e1846", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T00:09:33Z", "type": "forcePushed"}, {"oid": "a1dc23cf30684ac0bbb431dcd5519f857de67e7c", "url": "https://github.com/CorfuDB/CorfuDB/commit/a1dc23cf30684ac0bbb431dcd5519f857de67e7c", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T00:43:23Z", "type": "forcePushed"}, {"oid": "253f74158530d80e5ce1dc4a4531877c7c84e2a5", "url": "https://github.com/CorfuDB/CorfuDB/commit/253f74158530d80e5ce1dc4a4531877c7c84e2a5", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T00:44:42Z", "type": "forcePushed"}, {"oid": "5ac9712295e217256b93b4cd29906c87b3cecaf2", "url": "https://github.com/CorfuDB/CorfuDB/commit/5ac9712295e217256b93b4cd29906c87b3cecaf2", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T00:58:35Z", "type": "forcePushed"}, {"oid": "382aee629b98501bae72d5fdabaed2f424607035", "url": "https://github.com/CorfuDB/CorfuDB/commit/382aee629b98501bae72d5fdabaed2f424607035", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T02:08:16Z", "type": "forcePushed"}, {"oid": "d6da345a04d5e9070d145b0fd1ac269ac7338de4", "url": "https://github.com/CorfuDB/CorfuDB/commit/d6da345a04d5e9070d145b0fd1ac269ac7338de4", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T20:33:57Z", "type": "forcePushed"}, {"oid": "ccdf514b2446cb78a01ef0ed8129a6017ffae3a4", "url": "https://github.com/CorfuDB/CorfuDB/commit/ccdf514b2446cb78a01ef0ed8129a6017ffae3a4", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T22:45:14Z", "type": "forcePushed"}, {"oid": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "url": "https://github.com/CorfuDB/CorfuDB/commit/c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-26T23:51:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTc2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385499760", "bodyText": "How could this happen? An entry can't be a hole and a trimmed address at the same time, right? or did you mean to remove them from the uncached data?, in which case for what reason?", "author": "annym", "createdAt": "2020-02-28T04:13:29Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/AddressSpaceView.java", "diffHunk": "@@ -419,7 +419,10 @@ private ILogData cacheLoadAndGet(@NonNull Cache<Long, ILogData> cache, long addr\n \n         final Map<Long, ILogData> uncachedData = fetchAll(addressesToFetch, options);\n         final List<Long> trimmedAddresses = filterTrimmedAddresses(uncachedData);\n+        final List<Long> holes = filterHoles(uncachedData);\n+\n         trimmedAddresses.forEach(uncachedData::remove);\n+        holes.forEach(trimmedAddresses::remove);", "originalCommit": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzODk3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385538977", "bodyText": "This file was suppose to be reverted. Fixed.", "author": "vjeko", "createdAt": "2020-02-28T07:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwNzIyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385507226", "bodyText": "Let's add a comment on why we'll allow holes to surface to upper layers...", "author": "annym", "createdAt": "2020-02-28T04:54:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -341,7 +340,7 @@ private void processTrimmedException(TrimmedException te) {\n \n         // The list to store read results in\n         List<ILogData> readFrom = readAll(toRead).stream()\n-                .filter(x -> x.getType() == DataType.DATA)\n+                .filter(x -> x.getType() == DataType.DATA || x.getType() == DataType.HOLE)", "originalCommit": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzNzcxNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385537715", "bodyText": "They are not really going to surface up in the upper layer. Their lifespan is only limited to this function. But yea, I'll add a comment.", "author": "vjeko", "createdAt": "2020-02-28T07:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwNzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0MDEzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385540137", "bodyText": "yeah exactly I meant the address not the hole itself, cool.", "author": "annym", "createdAt": "2020-02-28T07:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwNzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0NjE0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385546142", "bodyText": "Done.", "author": "vjeko", "createdAt": "2020-02-28T07:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwNzIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODMzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385508331", "bodyText": "Please add comment with example on why we don't filter out the holes ... this will ease future discussions on why this is done.", "author": "annym", "createdAt": "2020-02-28T05:01:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -363,16 +362,16 @@ private void processTrimmedException(TrimmedException te) {\n         }\n \n         // Transfer the addresses of the read entries to the resolved queue\n-        readFrom.stream()\n-                .forEach(x -> addToResolvedQueue(context, x.getGlobalAddress()));\n+        readFrom.forEach(entry -> addToResolvedQueue(context, entry.getGlobalAddress()));", "originalCommit": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0NjE5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385546199", "bodyText": "Done.", "author": "vjeko", "createdAt": "2020-02-28T07:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODQwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385508401", "bodyText": "Please add a final note on why we filter holes right before returning...", "author": "annym", "createdAt": "2020-02-28T05:01:38Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -363,16 +362,16 @@ private void processTrimmedException(TrimmedException te) {\n         }\n \n         // Transfer the addresses of the read entries to the resolved queue\n-        readFrom.stream()\n-                .forEach(x -> addToResolvedQueue(context, x.getGlobalAddress()));\n+        readFrom.forEach(entry -> addToResolvedQueue(context, entry.getGlobalAddress()));\n \n         // Update the global pointer\n         if (readFrom.size() > 0) {\n             context.setGlobalPointerCheckGCTrimMark(readFrom.get(readFrom.size() - 1)\n                     .getGlobalAddress());\n         }\n \n-        return readFrom;\n+        return readFrom.stream().filter(entry -> !entry.isHole())", "originalCommit": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU0NjI0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385546244", "bodyText": "Done.", "author": "vjeko", "createdAt": "2020-02-28T07:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUyMjE4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385522185", "bodyText": "Can you please add a comment on why we need to set the global pointer, it is not obvious for someone with little context.", "author": "annym", "createdAt": "2020-02-28T06:09:22Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -417,7 +416,9 @@ protected boolean fillReadQueue(final long maxGlobal,\n                     log.trace(\"Fill_Read_Queue[{}] Get Stream Address Map using checkpoint with {} entries\",\n                             this, context.readCpQueue.size());\n \n-                    return true;\n+                    // Note: this is a checkpoint, we do not need to verify it is before the trim mark, it actually should be\n+                    // cause this is the last address of the trimmed range.\n+                    context.setGlobalPointer(context.checkpoint.startAddress);", "originalCommit": "c9349ea1b7f9a6220327e40b5d27117f4d1510d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzNzIzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385537236", "bodyText": "This part is going to be reverted as per our discussion.", "author": "vjeko", "createdAt": "2020-02-28T07:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUyMjE4NQ=="}], "type": "inlineReview"}, {"oid": "a461ae7f6abb99b49ca81547e6e93bc484041c19", "url": "https://github.com/CorfuDB/CorfuDB/commit/a461ae7f6abb99b49ca81547e6e93bc484041c19", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-28T07:36:34Z", "type": "forcePushed"}, {"oid": "2e7c87caa44d030bd646b70bdcb9a481683c0ce1", "url": "https://github.com/CorfuDB/CorfuDB/commit/2e7c87caa44d030bd646b70bdcb9a481683c0ce1", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-28T07:38:16Z", "type": "forcePushed"}, {"oid": "53e37ce605637531df37a2be340755cf3273e797", "url": "https://github.com/CorfuDB/CorfuDB/commit/53e37ce605637531df37a2be340755cf3273e797", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-02-28T19:07:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3OTQ1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385879453", "bodyText": "typo -> any", "author": "annym", "createdAt": "2020-02-28T19:26:09Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -363,16 +373,18 @@ private void processTrimmedException(TrimmedException te) {\n         }\n \n         // Transfer the addresses of the read entries to the resolved queue\n-        readFrom.stream()\n-                .forEach(x -> addToResolvedQueue(context, x.getGlobalAddress()));\n+        readFrom.forEach(entry -> addToResolvedQueue(context, entry.getGlobalAddress()));\n \n         // Update the global pointer\n         if (readFrom.size() > 0) {\n             context.setGlobalPointerCheckGCTrimMark(readFrom.get(readFrom.size() - 1)\n                     .getGlobalAddress());\n         }\n \n-        return readFrom;\n+        // Make sure to filter out eny entries that are holes,", "originalCommit": "53e37ce605637531df37a2be340755cf3273e797", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxMDUxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r386610516", "bodyText": "Fixed.", "author": "vjeko", "createdAt": "2020-03-02T19:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3OTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NDY1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385944658", "bodyText": "I think we can combine these two conditions.", "author": "WenbinZhu", "createdAt": "2020-02-28T22:07:25Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -155,53 +155,74 @@ protected boolean discoverAddressSpace(final UUID streamId,\n             if (checkpoint) {\n                 processCheckpoint(streamAddressSpace, filter, queue);\n             } else {\n-                // Transfer discovered addresses to queue. We must limit to maxGlobal,\n-                // as startAddress could be ahead of maxGlobal---in case it reflects\n-                // the tail of the stream.\n-                queue.addAll(streamAddressSpace.copyAddressesToSet(maxGlobal));\n-\n-                long trimMark = streamAddressSpace.getTrimMark();\n-\n-                // In case we are dealing with a stream that does not have the checkpoint\n-                // capability, check to see if we are trying to access an address that has been\n-                // previously trimmed.\n-                if (!isCheckpointCapable()\n-                        && Address.isAddress(trimMark)\n-                        && trimMark > stopAddress) {\n-                    String message = String.format(\"getStreamAddressMap[{%s}] stream has been \" +\n-                                    \"trimmed at address %s and we are trying to access the \" +\n-                                    \"stream starting at address %s. This stream does not have \" +\n-                                    \"the checkpoint capability.\", this, trimMark, stopAddress);\n-                    log.info(message);\n-                    throw new TrimmedException(message);\n-                }\n-                // Address maps might have been trimmed, hence not reflecting all updates to the stream\n-                // For this reason, in the case of a valid trim mark, we must be sure this space is\n-                // already resolved or loaded by a checkpoint.\n-                if (isCheckpointCapable()\n-                        && Address.isAddress(trimMark)\n-                        && !isTrimCoveredByCheckpointOrLocalView(trimMark)) {\n-                    if (getReadOptions().isIgnoreTrim()) {\n-                        log.debug(\"getStreamAddressMap[{}]: Ignoring trimmed exception for address[{}].\",\n-                                this, streamAddressSpace.getTrimMark());\n-                    } else {\n-                        String message = String.format(\"getStreamAddressMap[{%s}] [%d, %d] \" +\n-                                        \"stream has been trimmed at address %s and this space is \" +\n-                                        \"not covered by the loaded checkpoint with start \" +\n-                                        \"address %s, while accessing the stream at version \" +\n-                                        \"%s. Looking for a new checkpoint.\",\n-                                this, stopAddress, startAddress, trimMark,\n-                                getCurrentContext().getCheckpoint().startAddress, maxGlobal);\n-                        throw new TrimmedException(message);\n-                    }\n-                }\n+                moveToReadQueue(streamAddressSpace, queue, startAddress, stopAddress, maxGlobal);\n             }\n         }\n \n         addressCount += queue.size();\n         return !queue.isEmpty();\n     }\n \n+    private void moveToReadQueue(final StreamAddressSpace streamAddressSpace,\n+                                  final NavigableSet<Long> queue,\n+                                  final long startAddress,\n+                                  final long stopAddress,\n+                                  final long maxGlobal) {\n+\n+        // Transfer discovered addresses to queue. We must limit to maxGlobal,\n+        // as startAddress could be ahead of maxGlobal---in case it reflects\n+        // the tail of the stream.\n+        queue.addAll(streamAddressSpace.copyAddressesToSet(maxGlobal));\n+\n+        final long trimMark = streamAddressSpace.getTrimMark();\n+\n+        // No valid trim-mark has been defined,\n+        // thus we cannot run into trimmed address space.\n+        if (!Address.isAddress(trimMark)) {\n+            return;\n+        }\n+\n+        // Trim-mark is below or equal to the lowest address,\n+        // thus we cannot run into trimmed address space.\n+        if (trimMark <= stopAddress) {\n+            return;\n+        }", "originalCommit": "53e37ce605637531df37a2be340755cf3273e797", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMDQ2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r386600460", "bodyText": "I decided to make them separate for readability purposes.", "author": "vjeko", "createdAt": "2020-03-02T19:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NDY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NDg4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r385944889", "bodyText": "isCheckpointCapable() becomes redundant now.", "author": "WenbinZhu", "createdAt": "2020-02-28T22:08:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -155,53 +155,74 @@ protected boolean discoverAddressSpace(final UUID streamId,\n             if (checkpoint) {\n                 processCheckpoint(streamAddressSpace, filter, queue);\n             } else {\n-                // Transfer discovered addresses to queue. We must limit to maxGlobal,\n-                // as startAddress could be ahead of maxGlobal---in case it reflects\n-                // the tail of the stream.\n-                queue.addAll(streamAddressSpace.copyAddressesToSet(maxGlobal));\n-\n-                long trimMark = streamAddressSpace.getTrimMark();\n-\n-                // In case we are dealing with a stream that does not have the checkpoint\n-                // capability, check to see if we are trying to access an address that has been\n-                // previously trimmed.\n-                if (!isCheckpointCapable()\n-                        && Address.isAddress(trimMark)\n-                        && trimMark > stopAddress) {\n-                    String message = String.format(\"getStreamAddressMap[{%s}] stream has been \" +\n-                                    \"trimmed at address %s and we are trying to access the \" +\n-                                    \"stream starting at address %s. This stream does not have \" +\n-                                    \"the checkpoint capability.\", this, trimMark, stopAddress);\n-                    log.info(message);\n-                    throw new TrimmedException(message);\n-                }\n-                // Address maps might have been trimmed, hence not reflecting all updates to the stream\n-                // For this reason, in the case of a valid trim mark, we must be sure this space is\n-                // already resolved or loaded by a checkpoint.\n-                if (isCheckpointCapable()\n-                        && Address.isAddress(trimMark)\n-                        && !isTrimCoveredByCheckpointOrLocalView(trimMark)) {\n-                    if (getReadOptions().isIgnoreTrim()) {\n-                        log.debug(\"getStreamAddressMap[{}]: Ignoring trimmed exception for address[{}].\",\n-                                this, streamAddressSpace.getTrimMark());\n-                    } else {\n-                        String message = String.format(\"getStreamAddressMap[{%s}] [%d, %d] \" +\n-                                        \"stream has been trimmed at address %s and this space is \" +\n-                                        \"not covered by the loaded checkpoint with start \" +\n-                                        \"address %s, while accessing the stream at version \" +\n-                                        \"%s. Looking for a new checkpoint.\",\n-                                this, stopAddress, startAddress, trimMark,\n-                                getCurrentContext().getCheckpoint().startAddress, maxGlobal);\n-                        throw new TrimmedException(message);\n-                    }\n-                }\n+                moveToReadQueue(streamAddressSpace, queue, startAddress, stopAddress, maxGlobal);\n             }\n         }\n \n         addressCount += queue.size();\n         return !queue.isEmpty();\n     }\n \n+    private void moveToReadQueue(final StreamAddressSpace streamAddressSpace,\n+                                  final NavigableSet<Long> queue,\n+                                  final long startAddress,\n+                                  final long stopAddress,\n+                                  final long maxGlobal) {\n+\n+        // Transfer discovered addresses to queue. We must limit to maxGlobal,\n+        // as startAddress could be ahead of maxGlobal---in case it reflects\n+        // the tail of the stream.\n+        queue.addAll(streamAddressSpace.copyAddressesToSet(maxGlobal));\n+\n+        final long trimMark = streamAddressSpace.getTrimMark();\n+\n+        // No valid trim-mark has been defined,\n+        // thus we cannot run into trimmed address space.\n+        if (!Address.isAddress(trimMark)) {\n+            return;\n+        }\n+\n+        // Trim-mark is below or equal to the lowest address,\n+        // thus we cannot run into trimmed address space.\n+        if (trimMark <= stopAddress) {\n+            return;\n+        }\n+\n+        // In case we are dealing with a stream that does not have the checkpoint\n+        // capability (transactional stream for example), raise the exception.\n+        if (!isCheckpointCapable()) {\n+            String message = String.format(\"getStreamAddressMap[{%s}] stream has been \" +\n+                    \"trimmed at address %s and we are trying to access the \" +\n+                    \"stream starting at address %s. This stream does not have \" +\n+                    \"the checkpoint capability.\", this, trimMark, stopAddress);\n+            log.info(message);\n+            throw new TrimmedException(message);\n+        }\n+\n+        // Address maps might have been trimmed, hence not reflecting all updates to the stream\n+        // For this reason, in the case of a valid trim mark, we must be sure this space is\n+        // already resolved or loaded by a checkpoint.\n+        //\n+        // In case of a raw stream (a stream that is not consumed as part of an SMR object),\n+        // checkpoint start address and the trim mark will never match, causing the\n+        // TrimmedException to be thrown whenever trimMark > stopAddress.\n+        if (isCheckpointCapable() && !isTrimCoveredByCheckpointOrLocalView(trimMark)) {", "originalCommit": "53e37ce605637531df37a2be340755cf3273e797", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwOTg2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r386609867", "bodyText": "I agree. I was planning to clean up this logic in the next patch. There is a quite a bit of cleanup that needs to be done. At this point, I want to minimize the amount of changes.", "author": "vjeko", "createdAt": "2020-03-02T19:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxMjQ2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r386612467", "bodyText": "Isn't this what @zhangn49 is addressing in PR #2387?", "author": "annym", "createdAt": "2020-03-02T19:49:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -341,7 +342,16 @@ private void processTrimmedException(TrimmedException te) {\n \n         // The list to store read results in\n         List<ILogData> readFrom = readAll(toRead).stream()\n-                .filter(x -> x.getType() == DataType.DATA)\n+                // If the last address is a hole, we want to update the\n+                // global pointer to include that address as well.\n+                // During a checkpoint, a hole is appended at the end of each\n+                // stream which might end up being used as a trim mark in the\n+                // next trim cycle. If there are no updates between the checkpoint\n+                // and the trim cycle for that stream, there is a chance that the\n+                // last address (hole) will be trimmed, causing the TrimmedException\n+                // to be thrown. By updating the global pointer to include the hole,\n+                // we prevent that from happening.\n+                .filter(x -> x.isData() || x.isHole())", "originalCommit": "c00eadead6638de0213b667d014e7e7394455e8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyMTQxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2420#discussion_r386621416", "bodyText": "If you try running the unit tests from this patch with #2387 changes applies minus this line, you will see that the tests are still failing. I can go into more detail, but it in some circumstances we do not set the global pointer within remainingUpTo():\n        // Nothing read, nothing to process.\n        if (entries.size() == 0) {\n            // We've resolved up to maxGlobal, so remember it. (if it wasn't max)\n            if (maxGlobal != Address.MAX) {\n                // Set Global Pointer and check that it is not pointing to an address in the trimmed space.\n                getCurrentContext().setGlobalPointerCheckGCTrimMark(maxGlobal);\n            }\n            return entries;\n        }\n\nAnd:\n        // Otherwise update the pointer\n        if (maxGlobal != Address.MAX) {\n            // Set Global Pointer and check that it is not pointing to an address in the trimmed space.\n            getCurrentContext().setGlobalPointerCheckGCTrimMark(maxGlobal);\n        } else {\n            // Update pointer from log data and then validate final position of the pointer against GC trim mark.\n            updatePointer(entries.get(entries.size() - 1));\n            getCurrentContext().validateGlobalPointerPosition(getCurrentGlobalPosition());\n        }\n\nWhich means we do not end up exercising changes within  #2387. In one of my other comments I mention a need for a clean up -- this is one of the things I was referring to.", "author": "vjeko", "createdAt": "2020-03-02T20:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxMjQ2Nw=="}], "type": "inlineReview"}, {"oid": "d11583214d77aa1eb3f1ddf42a515e7d74b9bf4f", "url": "https://github.com/CorfuDB/CorfuDB/commit/d11583214d77aa1eb3f1ddf42a515e7d74b9bf4f", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-03-05T21:04:06Z", "type": "commit"}, {"oid": "d11583214d77aa1eb3f1ddf42a515e7d74b9bf4f", "url": "https://github.com/CorfuDB/CorfuDB/commit/d11583214d77aa1eb3f1ddf42a515e7d74b9bf4f", "message": "Change how StreamView interacts with its trim mark\n\nWhen StreamView is being consumed directly, its trim mark will change\ndue to externally triggered calls to gc(...). Even when the read range\nis above the trim mark, TrimmedException will be thrown because\ngetCheckpoint().startAddress < trimMark.", "committedDate": "2020-03-05T21:04:06Z", "type": "forcePushed"}]}