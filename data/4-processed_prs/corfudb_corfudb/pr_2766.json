{"pr_number": 2766, "pr_title": "CorfuStore V2: Read Your Own Writes!", "pr_createdAt": "2020-09-09T23:36:39Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2766", "timeline": [{"oid": "b06d44a522e247ed167355520e5d099c68aaaf1d", "url": "https://github.com/CorfuDB/CorfuDB/commit/b06d44a522e247ed167355520e5d099c68aaaf1d", "message": "CorfuStore V2: Read Your Own Writes!\n\nTxBuilder can do reads!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.", "committedDate": "2020-09-12T00:15:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0ODU0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488148541", "bodyText": "more of a question for LR team: Do we need snapshot queries for this method. Can we get rid of timestamp useage in this method ? What will be wrong if we do that ?", "author": "medhavidhawan", "createdAt": "2020-09-14T18:49:18Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogEntryWriter.java", "diffHunk": "@@ -122,7 +122,7 @@ private void processMsg(LogReplicationEntry txMessage) {\n             }\n         }\n \n-        txBuilder.commit(timestamp);\n+        txBuilder.commit();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyODcyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488228729", "bodyText": "could you please add this behaviour to method level comments as well.", "author": "medhavidhawan", "createdAt": "2020-09-14T21:24:39Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMTY2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488331667", "bodyText": "also, can we print something which can tell which Tx we are already a part of?", "author": "pankti-m", "createdAt": "2020-09-15T01:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyODcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NzExMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488877111", "bodyText": "done. can you please help review/approve?", "author": "hisundar", "createdAt": "2020-09-15T18:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyODcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzMDQxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488230417", "bodyText": "if you are taking in user specified function, can we wrap it in a try catch to avoid issues from user code. Also can we add some metrics(latency) here as we are dealing with user specified functions.", "author": "medhavidhawan", "createdAt": "2020-09-14T21:28:13Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NzQ2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488877461", "bodyText": "done. wrapped in try/catch block.\nmetrics will come in separately for not just this function but others too.", "author": "hisundar", "createdAt": "2020-09-15T18:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzMDQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzNTI5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488235293", "bodyText": "do we need this variable yet ? Currently we still have TransactionContext in TLS so this variable seems redundant for now ?", "author": "medhavidhawan", "createdAt": "2020-09-14T21:39:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n         });\n         return this;\n     }\n \n     /**\n-     *\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n      * @param streamId\n      * @param updateEntry\n      * @return\n      */\n     public TxBuilder logUpdate(UUID streamId, SMREntry updateEntry) {\n-\n         operations.add(() -> {\n-        TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n         });\n         return this;\n     }\n \n     /**\n-     * Touches the specified key without mutating the version of the record.\n-     * This provides read after write conflict semantics.\n+     * Clears the entire table.\n      *\n-     * @param tableName Table name to perform the touch on.\n-     * @param key       Key to touch.\n+     * @param table Table object to perform the delete on.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder touch(@Nonnull final String tableName,\n-                    @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n-        operations.add(() -> {\n-            //TODO: Validate the get is executed.\n-            CorfuRecord<V, M> record = table.get(key);\n-        });\n+    TxBuilder clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clear);\n         return this;\n     }\n \n     /**\n      * Deletes the specified key.\n      *\n-     * @param tableName Table name to perform the delete on.\n-     * @param key       Key.\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder delete(@Nonnull final String tableName,\n+    TxBuilder delete(@Nonnull Table<K, V, M> table,\n                      @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n         operations.add(() -> table.delete(key));\n         return this;\n     }\n \n-    private void txBegin() {\n-        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n-                .TXBuild()\n-                .type(TransactionType.OPTIMISTIC);\n-        if (timestamp != null) {\n-            transactionBuilder.snapshot(new Token(timestamp.getEpoch(), timestamp.getSequence()));\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        }\n+        try {\n+            txBeginInternal();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        } finally {\n+            txEndInternal();\n         }\n-        transactionBuilder.build().begin();\n     }\n \n-    private void txEnd() {\n-        this.objectsView.TXEnd();\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            return table.getByIndex(indexName, indexKey);\n+        }\n+        try {\n+            txBeginInternal();\n+            return table.getByIndex(indexName, indexKey);\n+        } finally {\n+            txEndInternal();\n+        }\n     }\n \n     /**\n-     * Commit the transaction.\n-     * The commit call begins a Corfu transaction at the latest timestamp, applies all the updates and then\n-     * ends the Corfu transaction.\n-     * The commit returns successfully if the transaction was committed.\n-     * Otherwise this throws a TransactionAbortedException.\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n      */\n-    public void commit() {\n-        commit(null);\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            return table.count();\n+        }\n+        try {\n+            txBeginInternal();\n+            return table.count();\n+        } finally {\n+            txEndInternal();\n+        }\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            return table.keySet();\n+        }\n+        try {\n+            txBeginInternal();\n+            return table.keySet();\n+        } finally {\n+            txEndInternal();\n+        }\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            return table.scanAndFilterByEntry(entryPredicate);\n+        }\n+        try {\n+            txBeginInternal();\n+            return table.scanAndFilterByEntry(entryPredicate);\n+        } finally {\n+            txEndInternal();\n+        }\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private void txBeginInternal() {\n+        if (!startedReadWriteTxn) {", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3ODUxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488878517", "bodyText": "Good question - not right now, we can just as well use the TransactionalContext but we really want to get away from ThreadLocal to allow multiplexing multiple transactions in the same thread. This variable allows for that migration.", "author": "hisundar", "createdAt": "2020-09-15T18:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzNTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDkwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488270902", "bodyText": "There is a lot of repetitive code here. Can we abstract this such that there is no code repetition.", "author": "medhavidhawan", "createdAt": "2020-09-14T22:34:06Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n         });\n         return this;\n     }\n \n     /**\n-     *\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n      * @param streamId\n      * @param updateEntry\n      * @return\n      */\n     public TxBuilder logUpdate(UUID streamId, SMREntry updateEntry) {\n-\n         operations.add(() -> {\n-        TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n         });\n         return this;\n     }\n \n     /**\n-     * Touches the specified key without mutating the version of the record.\n-     * This provides read after write conflict semantics.\n+     * Clears the entire table.\n      *\n-     * @param tableName Table name to perform the touch on.\n-     * @param key       Key to touch.\n+     * @param table Table object to perform the delete on.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder touch(@Nonnull final String tableName,\n-                    @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n-        operations.add(() -> {\n-            //TODO: Validate the get is executed.\n-            CorfuRecord<V, M> record = table.get(key);\n-        });\n+    TxBuilder clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clear);\n         return this;\n     }\n \n     /**\n      * Deletes the specified key.\n      *\n-     * @param tableName Table name to perform the delete on.\n-     * @param key       Key.\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder delete(@Nonnull final String tableName,\n+    TxBuilder delete(@Nonnull Table<K, V, M> table,\n                      @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n         operations.add(() -> table.delete(key));\n         return this;\n     }\n \n-    private void txBegin() {\n-        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n-                .TXBuild()\n-                .type(TransactionType.OPTIMISTIC);\n-        if (timestamp != null) {\n-            transactionBuilder.snapshot(new Token(timestamp.getEpoch(), timestamp.getSequence()));\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        }\n+        try {\n+            txBeginInternal();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        } finally {\n+            txEndInternal();\n         }\n-        transactionBuilder.build().begin();\n     }\n \n-    private void txEnd() {\n-        this.objectsView.TXEnd();\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        if (readYourUncommittedWrites) {", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3ODkzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488878933", "bodyText": "I was trying to do this, but the variance in the return types for each of these read functions makes it tricky to create a common function. open to ideas though.", "author": "hisundar", "createdAt": "2020-09-15T18:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2Njc1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r491266757", "bodyText": "done. removed all the repetitive code.", "author": "hisundar", "createdAt": "2020-09-19T04:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjI0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488302247", "bodyText": "on L60 and L66, should the metadata be changed to Message.class?", "author": "pankti-m", "createdAt": "2020-09-14T23:58:53Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -49,7 +53,7 @@ public LogReplicationMetadataManager(CorfuRuntime rt, long topologyConfigId, Str\n         this.corfuStore = new CorfuStore(runtime);\n         metadataTableName = getPersistedWriterMetadataTableName(localClusterId);\n         try {\n-            this.corfuStore.openTable(NAMESPACE,\n+            metadataTable = this.corfuStore.openTable(NAMESPACE,", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4MTkzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488881933", "bodyText": "No, that would imply that they want to send in a non-null metadata which is not the intent.", "author": "hisundar", "createdAt": "2020-09-15T18:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3MjM2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489972365", "bodyText": "got it, thanks", "author": "pankti-m", "createdAt": "2020-09-17T05:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzEzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488303139", "bodyText": "we can replace all these with getTxBuilder()", "author": "pankti-m", "createdAt": "2020-09-15T00:01:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -159,7 +163,7 @@ public void setupTopologyConfigId(long topologyConfigId) {\n             return;\n         }\n \n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE, IsolationLevel.snapshot(timestamp));", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4MjM4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488882381", "bodyText": "I did not fully evaluate the reason why timestamp is used. I saw @medhavidhawan 's comments also asking for the same.\nWould prefer @xiaoqin2012 or @annym to comment.", "author": "hisundar", "createdAt": "2020-09-15T18:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODY1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488328655", "bodyText": "what does this mean?", "author": "pankti-m", "createdAt": "2020-09-15T01:31:30Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -96,7 +95,7 @@ private boolean TxBegin() {\n         }\n         corfuRuntime.getObjectsView()\n                 .TXBuild()\n-                .type(TransactionType.OPTIMISTIC)\n+                .type(TransactionType.WRITE_AFTER_WRITE)", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4MjY3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488882671", "bodyText": "it means only writes will generate conflicts. It is needed since we are now allowing reads and writes in a single transaction mode.", "author": "hisundar", "createdAt": "2020-09-15T18:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NjM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489976385", "bodyText": "prior to UFO also a transaction could have reads and writes, correct?", "author": "pankti-m", "createdAt": "2020-09-17T05:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2NjczNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r491266734", "bodyText": "conflicts are only generated on writes in a WRITE_AFTER_WRITE transaction.\nWe were using OPTIMISTIC transaction before for the use of the touch api which needed only reads to generate a conflict.\nBut now that touch is also moved up to shim layer, we can go back to using WRITE_AFTER_WRITE transaction model", "author": "hisundar", "createdAt": "2020-09-19T04:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTkyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488329921", "bodyText": "why did we remove the tx calls and validation for metadata?  Also, can we update the comment to say what it will return if the key does not exist?", "author": "pankti-m", "createdAt": "2020-09-15T01:36:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -156,43 +120,18 @@ private void TxEnd() {\n     }\n \n     /**\n-     * Update an existing key with the provided value.\n+     * Update an existing key with the provided value. Create if it does not exist.\n      *\n      * @param key      Key.\n      * @param value    Value.\n      * @param metadata Metadata.\n      * @return Previously stored value for the provided key.\n      */\n     @Nullable\n-    CorfuRecord<V, M> update(@Nonnull final K key,\n-                             @Nonnull final V value,\n-                             @Nullable final M metadata) {\n-        boolean beganNewTxn = false;\n-        try {\n-            beganNewTxn = TxBegin();\n-            M newMetadata = null;\n-            if (metadataOptions.isMetadataEnabled()) {\n-                if (metadata == null) {\n-                    throw new RuntimeException(\"Table::update needs non-null metadata\");\n-                }\n-                CorfuRecord<V, M> previous = corfuTable.get(key);\n-                M previousMetadata;\n-                boolean isCreate = false;\n-                if (previous == null) { // Really a create() call not an update.\n-                    previousMetadata = (M) metadataOptions.getDefaultMetadataInstance();\n-                    isCreate = true;\n-                } else {\n-                    previousMetadata = previous.getMetadata();\n-                }\n-                validateVersion(previousMetadata, metadata);\n-                newMetadata = mergeOldAndNewMetadata(previousMetadata, metadata, isCreate);\n-            }\n-            return corfuTable.put(key, new CorfuRecord<>(value, newMetadata));\n-        } finally {\n-            if (beganNewTxn) {\n-                TxEnd();\n-            }\n-        }\n+    CorfuRecord<V, M> put(@Nonnull final K key,\n+                          @Nonnull final V value,\n+                          @Nullable final M metadata) {\n+        return corfuTable.put(key, new CorfuRecord<>(value, metadata));", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4MzA1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488883058", "bodyText": "done. added comments. validation and metadata handling is vertical specific and will need to move to shim layer.", "author": "hisundar", "createdAt": "2020-09-15T18:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3Njk3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489976972", "bodyText": "cant find anything in the comments....", "author": "pankti-m", "createdAt": "2020-09-17T05:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMDU1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488330556", "bodyText": "is @nonnull annotation appropriate for primitive types?", "author": "pankti-m", "createdAt": "2020-09-15T01:38:41Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4MzI0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488883247", "bodyText": "good point, let me remove it.", "author": "hisundar", "createdAt": "2020-09-15T18:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjM4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488332388", "bodyText": "why do we need to make it public?", "author": "pankti-m", "createdAt": "2020-09-15T01:45:01Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMzAyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488333021", "bodyText": "this means we require the clients to first call getTable() and then put().  Any reason for breaking it down?", "author": "pankti-m", "createdAt": "2020-09-15T01:47:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMzg0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488333844", "bodyText": "this would throw NPE if table.get(key) returns null.  We can move it after L132", "author": "pankti-m", "createdAt": "2020-09-15T01:50:01Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NjgwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489576800", "bodyText": "this whole line was a copy paste bug. removed it in latest patch.", "author": "hisundar", "createdAt": "2020-09-16T16:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMzg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzNzkxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488337919", "bodyText": "this will not get executed in case if readYourUncommittedWrites==true, right?", "author": "pankti-m", "createdAt": "2020-09-15T02:04:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n         });\n         return this;\n     }\n \n     /**\n-     *\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n      * @param streamId\n      * @param updateEntry\n      * @return\n      */\n     public TxBuilder logUpdate(UUID streamId, SMREntry updateEntry) {\n-\n         operations.add(() -> {\n-        TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n         });\n         return this;\n     }\n \n     /**\n-     * Touches the specified key without mutating the version of the record.\n-     * This provides read after write conflict semantics.\n+     * Clears the entire table.\n      *\n-     * @param tableName Table name to perform the touch on.\n-     * @param key       Key to touch.\n+     * @param table Table object to perform the delete on.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder touch(@Nonnull final String tableName,\n-                    @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n-        operations.add(() -> {\n-            //TODO: Validate the get is executed.\n-            CorfuRecord<V, M> record = table.get(key);\n-        });\n+    TxBuilder clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clear);\n         return this;\n     }\n \n     /**\n      * Deletes the specified key.\n      *\n-     * @param tableName Table name to perform the delete on.\n-     * @param key       Key.\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder delete(@Nonnull final String tableName,\n+    TxBuilder delete(@Nonnull Table<K, V, M> table,\n                      @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n         operations.add(() -> table.delete(key));\n         return this;\n     }\n \n-    private void txBegin() {\n-        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n-                .TXBuild()\n-                .type(TransactionType.OPTIMISTIC);\n-        if (timestamp != null) {\n-            transactionBuilder.snapshot(new Token(timestamp.getEpoch(), timestamp.getSequence()));\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        }\n+        try {\n+            txBeginInternal();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        } finally {\n+            txEndInternal();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4OTY0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489089649", "bodyText": "yes, the code returns before", "author": "hisundar", "createdAt": "2020-09-16T00:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzNzkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzODQ4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488338483", "bodyText": "this will not get executed if readYourUncommittedWrites is true?.  same with other methods", "author": "pankti-m", "createdAt": "2020-09-15T02:06:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n         });\n         return this;\n     }\n \n     /**\n-     *\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n      * @param streamId\n      * @param updateEntry\n      * @return\n      */\n     public TxBuilder logUpdate(UUID streamId, SMREntry updateEntry) {\n-\n         operations.add(() -> {\n-        TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n         });\n         return this;\n     }\n \n     /**\n-     * Touches the specified key without mutating the version of the record.\n-     * This provides read after write conflict semantics.\n+     * Clears the entire table.\n      *\n-     * @param tableName Table name to perform the touch on.\n-     * @param key       Key to touch.\n+     * @param table Table object to perform the delete on.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder touch(@Nonnull final String tableName,\n-                    @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n-        operations.add(() -> {\n-            //TODO: Validate the get is executed.\n-            CorfuRecord<V, M> record = table.get(key);\n-        });\n+    TxBuilder clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clear);\n         return this;\n     }\n \n     /**\n      * Deletes the specified key.\n      *\n-     * @param tableName Table name to perform the delete on.\n-     * @param key       Key.\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder delete(@Nonnull final String tableName,\n+    TxBuilder delete(@Nonnull Table<K, V, M> table,\n                      @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n         operations.add(() -> table.delete(key));\n         return this;\n     }\n \n-    private void txBegin() {\n-        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n-                .TXBuild()\n-                .type(TransactionType.OPTIMISTIC);\n-        if (timestamp != null) {\n-            transactionBuilder.snapshot(new Token(timestamp.getEpoch(), timestamp.getSequence()));\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        }\n+        try {\n+            txBeginInternal();\n+            CorfuRecord<V, M> record = table.get(key);\n+            return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+        } finally {\n+            txEndInternal();\n         }\n-        transactionBuilder.build().begin();\n     }\n \n-    private void txEnd() {\n-        this.objectsView.TXEnd();\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();\n+            return table.getByIndex(indexName, indexKey);\n+        }\n+        try {\n+            txBeginInternal();\n+            return table.getByIndex(indexName, indexKey);\n+        } finally {\n+            txEndInternal();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4OTc0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489089741", "bodyText": "yes, the return method earlier bypasses this section if readYourUncommittedWrites is true", "author": "hisundar", "createdAt": "2020-09-16T00:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzODQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzOTkwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488339900", "bodyText": "if we clear all the operations, write operations will also get lost, right?", "author": "pankti-m", "createdAt": "2020-09-15T02:11:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -42,141 +52,291 @@\n     @Nonnull\n     TxBuilder(@Nonnull final ObjectsView objectsView,\n               @Nonnull final TableRegistry tableRegistry,\n-              @Nonnull final String namespace) {\n-        this.objectsView = objectsView;\n+              @Nonnull final String namespace,\n+              @Nonnull final IsolationLevel isolationLevel,\n+              @Nonnull final boolean readYourUncommittedWrites) {\n+            this.objectsView = objectsView;\n         this.tableRegistry = tableRegistry;\n         this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.readYourUncommittedWrites = readYourUncommittedWrites;\n+        this.startedReadWriteTxn = false;\n         this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new RuntimeException(\"Cannot start new transaction in this thread without ending previous one\");\n+        }\n     }\n \n-    private <K extends Message, V extends Message, M extends Message>\n+    public  <K extends Message, V extends Message, M extends Message>\n     Table<K, V, M> getTable(@Nonnull final String tableName) {\n         return this.tableRegistry.getTable(this.namespace, tableName);\n     }\n \n     /**\n-     * Creates a record for the specified key.\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n      *\n-     * @param tableName Table name to perform the create on.\n-     * @param key       Key.\n-     * @param value     Value to create.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder create(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder put(@Nonnull Table<K, V, M> table,\n+                  @Nonnull final K key,\n+                  @Nonnull final V value,\n+                  @Nullable final M metadata) {\n         operations.add(() -> {\n-            table.create(key, value, metadata);\n+            table.put(key, value, metadata);\n         });\n         return this;\n     }\n \n     /**\n-     * Updates the value on the specified key.\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n      *\n-     * @param tableName Table name to perform the update on.\n-     * @param key       Key.\n-     * @param value     Value to update.\n-     * @param <K>       Type of Key.\n-     * @param <V>       Type of Value.\n-     * @return TxBuilder instance.\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxBuilder instance\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder update(@Nonnull final String tableName,\n-                     @Nonnull final K key,\n-                     @Nonnull final V value,\n-                     @Nullable final M metadata) {\n-        Table<K, V, M> table = getTable(tableName);\n+    TxBuilder merge(@Nonnull Table<K, V, M> table,\n+                    @Nonnull final K key,\n+                    @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                    @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        V currentVal = table.get(key).getPayload();\n+        if (currentVal == null) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"No value found for Key %s.  Please create a record first\", key));\n+        }\n         operations.add(() -> {\n-            table.update(key, value, metadata);\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            if (oldRecord == null) {\n+                throw new RuntimeException(\"merge: cannot find previous value for key=\"+key);\n+            }\n+            CorfuRecord<V, M> mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n         });\n         return this;\n     }\n \n     /**\n-     *\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n      * @param streamId\n      * @param updateEntry\n      * @return\n      */\n     public TxBuilder logUpdate(UUID streamId, SMREntry updateEntry) {\n-\n         operations.add(() -> {\n-        TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n         });\n         return this;\n     }\n \n     /**\n-     * Touches the specified key without mutating the version of the record.\n-     * This provides read after write conflict semantics.\n+     * Clears the entire table.\n      *\n-     * @param tableName Table name to perform the touch on.\n-     * @param key       Key to touch.\n+     * @param table Table object to perform the delete on.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder touch(@Nonnull final String tableName,\n-                    @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n-        operations.add(() -> {\n-            //TODO: Validate the get is executed.\n-            CorfuRecord<V, M> record = table.get(key);\n-        });\n+    TxBuilder clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clear);\n         return this;\n     }\n \n     /**\n      * Deletes the specified key.\n      *\n-     * @param tableName Table name to perform the delete on.\n-     * @param key       Key.\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n      * @param <K>       Type of Key.\n      * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n      * @return TxBuilder instance.\n      */\n     @Nonnull\n     public <K extends Message, V extends Message, M extends Message>\n-    TxBuilder delete(@Nonnull final String tableName,\n+    TxBuilder delete(@Nonnull Table<K, V, M> table,\n                      @Nonnull final K key) {\n-        Table<K, V, M> table = getTable(tableName);\n         operations.add(() -> table.delete(key));\n         return this;\n     }\n \n-    private void txBegin() {\n-        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n-                .TXBuild()\n-                .type(TransactionType.OPTIMISTIC);\n-        if (timestamp != null) {\n-            transactionBuilder.snapshot(new Token(timestamp.getEpoch(), timestamp.getSequence()));\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        if (readYourUncommittedWrites) {\n+            txBeginInternal();\n+            operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+            operations.clear();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4OTkwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489089901", "bodyText": "we apply them first and then clear() right?", "author": "hisundar", "createdAt": "2020-09-16T00:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzOTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0MDM2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r488340368", "bodyText": "should we set startedReadWriteTxn=false here also?", "author": "pankti-m", "createdAt": "2020-09-15T02:12:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxBuilder.java", "diffHunk": "@@ -185,17 +345,25 @@ public void commit() {\n      * if no snapshot is specified, applies all the updates and then ends the Corfu transaction.\n      * The commit returns successfully if the transaction was committed.\n      * Otherwise this throws a TransactionAbortedException.\n-     *\n-     * @param timestamp Timestamp to commit the transaction on.\n+     * @return - address at which the commit of this transaction occurred.\n      */\n-    public void commit(final Timestamp timestamp) {\n-        this.timestamp = timestamp;\n-        try {\n-            txBegin();\n+    public long commit() {\n+        long commitAddress;\n+        try { // batch up all the operations and apply them in a new transaction started here.\n+            txBeginInternal();\n             operations.forEach(Runnable::run);\n         } finally {\n-            txEnd();\n-            operations.clear();\n+            commitAddress = endTxn();", "originalCommit": "b06d44a522e247ed167355520e5d099c68aaaf1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA5MzYxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489093617", "bodyText": "not sure why - if readYour writes then it gets set in txnBeginInternal if not it would have started whenever the transaction would have actually begun right?", "author": "hisundar", "createdAt": "2020-09-16T00:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0MDM2OA=="}], "type": "inlineReview"}, {"oid": "7c719f45cf5db81c21bd28bc6ca0569f97bb4d6c", "url": "https://github.com/CorfuDB/CorfuDB/commit/7c719f45cf5db81c21bd28bc6ca0569f97bb4d6c", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\nMark existing api as deprecated.", "committedDate": "2020-09-16T00:40:55Z", "type": "forcePushed"}, {"oid": "123593af8e7a536a811cda1f8541eef8b75210ae", "url": "https://github.com/CorfuDB/CorfuDB/commit/123593af8e7a536a811cda1f8541eef8b75210ae", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\nMark existing api as deprecated.\n+Sample SHIM layer for metadata management with tests", "committedDate": "2020-09-16T21:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NDQ0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489974440", "bodyText": "not sure I understand this interface...  Is it to be used for read_committed isolation level in future?  How is it different from the previous method?", "author": "pankti-m", "createdAt": "2020-09-17T05:11:29Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -131,21 +131,55 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                IsolationLevel.snapshot());\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.\n+     * The transaction does not begin until either a commit or the first read is invoked.\n+     * On read or commit the latest available snapshot will be used to resolve the transaction.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @param isolationLevel Snapshot (latest or specific) at which the transaction must execute.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace, IsolationLevel isolationLevel) {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MzMyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490473323", "bodyText": "Backward compatibility. tx() method returns the old implementation to avoid changing existing consumers.", "author": "hisundar", "createdAt": "2020-09-17T18:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NDY3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489974673", "bodyText": "bit confused by the comment.. how is this method different from the previous one?", "author": "pankti-m", "createdAt": "2020-09-17T05:12:22Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -131,21 +131,55 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                IsolationLevel.snapshot());\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MzY1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490473655", "bodyText": "Backward compatibility. Notice the subtle use of the txn (new) vs tx (old).", "author": "hisundar", "createdAt": "2020-09-17T18:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NjE0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489976144", "bodyText": "can we use CorfuRuntime.getStreamID(tableName)?", "author": "pankti-m", "createdAt": "2020-09-17T05:17:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -72,6 +74,7 @@ public Table(@Nonnull final String namespace,\n         this.corfuRuntime = corfuRuntime;\n         this.namespace = namespace;\n         this.fullyQualifiedTableName = fullyQualifiedTableName;\n+        this.streamUUID = UUID.nameUUIDFromBytes(this.fullyQualifiedTableName.getBytes());", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NzA3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490447075", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-17T17:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3NjE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3ODcwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489978700", "bodyText": "comment could be updated with the recent changes of reads inside transaction", "author": "pankti-m", "createdAt": "2020-09-17T05:26:34Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3OTEyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489979123", "bodyText": "add param comment for isolation level", "author": "pankti-m", "createdAt": "2020-09-17T05:28:00Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MDQ1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492360455", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-09-21T21:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3OTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk3OTI0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489979241", "bodyText": "nit - indentation", "author": "pankti-m", "createdAt": "2020-09-17T05:28:26Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MDU0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489980544", "bodyText": "are we getting rid of touch() api?", "author": "pankti-m", "createdAt": "2020-09-17T05:32:51Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MDY0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492360640", "bodyText": "no was just missed. thanks", "author": "hisundar", "createdAt": "2020-09-21T21:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MDU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MTY1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489981656", "bodyText": "add table param", "author": "pankti-m", "createdAt": "2020-09-17T05:36:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MTA2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492361063", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-09-21T21:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MzI3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489983278", "bodyText": "if the timestamp has not been specified, we need to take the snapshot at the current timestamp, right?  Something like transactionBuilder.snapshot(currentTimestamp)..", "author": "pankti-m", "createdAt": "2020-09-17T05:41:49Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return true;\n+        }\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MjI1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492362251", "bodyText": "by not specifying any timestamp value that is what should happen internally when we call Corfu's TXBEGIN right?", "author": "hisundar", "createdAt": "2020-09-21T21:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4MzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTAyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489985024", "bodyText": "Why maybe?  Also, what is the use of the return value?  Cant we make it \"void txBegin()\"?", "author": "pankti-m", "createdAt": "2020-09-17T05:47:40Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4OTM3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490489370", "bodyText": "maybe just denotes that it may not actually start a transaction. If a previous call had already started a transaction then this method will not start one. The return type just captures this.", "author": "hisundar", "createdAt": "2020-09-17T19:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTIzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489985233", "bodyText": "why do we check this?  There is no way to call this from non-transactionally, right?", "author": "pankti-m", "createdAt": "2020-09-17T05:48:29Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NjYzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490446636", "bodyText": "we don't want to keep starting new transactions so only way is to check if this thread already has a transaction started.", "author": "hisundar", "createdAt": "2020-09-17T17:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTY1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489985653", "bodyText": "All read apis will be called from within the transaction, which means we will return from L279 and never start the transaction... Am I missing something?", "author": "pankti-m", "createdAt": "2020-09-17T05:49:52Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return true;\n+        }\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NjMzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490446337", "bodyText": "278 will return false if it is the first read api, so we will start the transaction on the first read and skip it for subsequent reads.", "author": "hisundar", "createdAt": "2020-09-17T17:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTk0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489985946", "bodyText": "this is only being called from txEnd().  Can we move everything here in txEnd() and remove this method?", "author": "pankti-m", "createdAt": "2020-09-17T05:50:37Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return true;\n+        }\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+        return false;\n+    }\n+\n+    private long txEndInternal() {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NTc3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490445771", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-17T17:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NjcwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489986700", "bodyText": "nit - space before and after \"+\"", "author": "pankti-m", "createdAt": "2020-09-17T05:52:45Z", "path": "runtime/src/main/java/org/corfudb/runtime/exceptions/TransactionAlreadyStartedException.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.corfudb.runtime.exceptions;\n+\n+import lombok.NoArgsConstructor;\n+\n+/**\n+ * Can't start a transaction on a thread if there is one already in progress.\n+ * Hopefully in the future once we migrate away from thread-local storage\n+ * this exception type can disappear.\n+ *\n+ * created by hisundar 2020-09-15\n+ */\n+@NoArgsConstructor\n+public class TransactionAlreadyStartedException extends RuntimeException {\n+    public TransactionAlreadyStartedException(String message) {\n+        super(\"An exsiting transaction is still in progress. \"+message);", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NTY3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490445673", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-17T17:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NjcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMzE3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489113178", "bodyText": "Need to add @deprecated to this api.", "author": "WenbinZhu", "createdAt": "2020-09-16T01:48:41Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -131,21 +131,80 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                IsolationLevel.snapshot(),\n+                false);\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.\n+     * The transaction does not begin until a commit is invoked.\n+     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @param isolationLevel Snapshot (latest or specific) at which the transaction must execute.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace, IsolationLevel isolationLevel) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                isolationLevel,\n+                false);\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.\n+     * The transaction does not begin until a commit is invoked.\n+     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @param isolationLevel Snapshot (latest or specific) at which the transaction must execute.\n+     * @param readYourUncommittedWrites does the transaction wish to see its own uncommitted writes\n+     *                                  this parameter has implications on the length of a transaction\n+     *                                  it also has implications on use of thread's context\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace, IsolationLevel isolationLevel,\n+                          boolean readYourUncommittedWrites) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                isolationLevel,\n+                readYourUncommittedWrites);\n+    }\n+\n     /**\n      * Provides a query interface.", "originalCommit": "7c719f45cf5db81c21bd28bc6ca0569f97bb4d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NTU2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490445564", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-17T17:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMzE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMzc5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489113792", "bodyText": "This line seems a bit confusing, I think it should be \"Start a transaction with snapshot isolation level at the latest available corfu snapshot.\"", "author": "WenbinZhu", "createdAt": "2020-09-16T01:50:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -131,21 +131,80 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.", "originalCommit": "7c719f45cf5db81c21bd28bc6ca0569f97bb4d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NTQ3OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490445478", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-17T17:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMzc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg1MjcxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489852718", "bodyText": "Looks like a IDE automated refactor, but this is not referring to the ufo TxnContext, I think it refers to the Lombok generated TransactionBuilder for Transaction.java, when using runtime.TXBuild().build().", "author": "WenbinZhu", "createdAt": "2020-09-17T01:24:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "diffHunk": "@@ -15,7 +15,7 @@\n /**\n  * A snapshot transactional context.\n  *\n- * <p>Given the snapshot (log address) given by the TxBuilder,\n+ * <p>Given the snapshot (log address) given by the TxnContext,", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NTIyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490445228", "bodyText": "good catch, yes IDE got confused.", "author": "hisundar", "createdAt": "2020-09-17T17:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg1MjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg2ODkyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489868928", "bodyText": "The transaction is started after this, so there will still be a window where others can modify the schema, so should this be put in the transcation below?", "author": "WenbinZhu", "createdAt": "2020-09-17T01:50:10Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -167,23 +167,23 @@ void registerTable(@Nonnull String namespace,\n         TableMetadata.Builder metadataBuilder = TableMetadata.newBuilder();\n         metadataBuilder.setDiskBased(tableOptions.getPersistentDataPath().isPresent());\n \n-        // Schema validation to ensure that there is either proper modification of the schema across open calls.\n-        // Or no modification to the protobuf files.\n-        boolean hasSchemaChanged = false;\n-        CorfuRecord<TableDescriptors, TableMetadata> oldRecord = this.registryTable.get(tableNameKey);\n-        if (oldRecord != null) {\n-            if (!oldRecord.getPayload().getFileDescriptorsMap().equals(tableDescriptors.getFileDescriptorsMap())) {\n-                hasSchemaChanged = true;\n-                log.error(\"registerTable: Schema update detected for table \"+namespace+\" \"+ tableName);\n-                log.debug(\"registerTable: old schema:\"+oldRecord.getPayload().getFileDescriptorsMap());\n-                log.debug(\"registerTable: new schema:\"+tableDescriptors.getFileDescriptorsMap());\n-            }\n-        }\n         int numRetries = 9; // Since this is an internal transaction, retry a few times before giving up.\n         long finalAddress = Address.NON_ADDRESS;\n         while (numRetries-- > 0) {\n+            // Schema validation to ensure that there is either proper modification of the schema across open calls.\n+            // Or no modification to the protobuf files.\n+            boolean hasSchemaChanged = false;\n+            CorfuRecord<TableDescriptors, TableMetadata> oldRecord = this.registryTable.get(tableNameKey);\n+            if (oldRecord != null) {\n+                if (!oldRecord.getPayload().getFileDescriptorsMap().equals(tableDescriptors.getFileDescriptorsMap())) {\n+                    hasSchemaChanged = true;\n+                    log.error(\"registerTable: Schema update detected for table \"+namespace+\" \"+ tableName);\n+                    log.debug(\"registerTable: old schema:\"+oldRecord.getPayload().getFileDescriptorsMap());\n+                    log.debug(\"registerTable: new schema:\"+tableDescriptors.getFileDescriptorsMap());\n+                }\n+            }", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5ODAzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490498031", "bodyText": "yes, its a small cost to pay for a potential but. fixed.", "author": "hisundar", "createdAt": "2020-09-17T19:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg2ODkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg3NjQyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489876420", "bodyText": "Since we changed implentation, this needs be changed as well right? Maybe \"on the first read operation or at the time...\"", "author": "WenbinZhu", "createdAt": "2020-09-17T02:01:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/IsolationLevel.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.Getter;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+\n+/**\n+ * Used to specify which transaction isolation level will be used for the TxnContext transactions.\n+ * Following isolation levels are supported:\n+ *  1. SNAPSHOT() - all writes and reads will happen at a specific timestamp\n+ *      1.a - the default timestamp is implicitly derived on the first read operation\n+ *            in read-your-write transactions or at the time of commit in write-only transactions.", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDg4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490444881", "bodyText": "thanks fixed the comment.", "author": "hisundar", "createdAt": "2020-09-17T17:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg3NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg3NzgxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489877814", "bodyText": "Expand.", "author": "WenbinZhu", "createdAt": "2020-09-17T02:04:13Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -4,7 +4,6 @@\n import com.google.protobuf.Message;\n \n import java.util.*;", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg4MjU1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r489882555", "bodyText": "protected can be removed.", "author": "WenbinZhu", "createdAt": "2020-09-17T02:12:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -298,15 +337,34 @@ public int count() {\n     /**\n      * Get by secondary index.\n      *\n+     * @param <I>       Type of index key.\n      * @param indexName Index name.\n      * @param indexKey  Index key.\n+     * @return Collection of entries filtered by the secondary index.\n+     */\n+    @Nonnull\n+    <I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull final String indexName,\n+                    @Nonnull final I indexKey) {\n+        return corfuTable.getByIndex(() -> indexName, indexKey).stream()\n+                .map(entry -> new CorfuStoreEntry<K, V, M>(entry.getKey(),\n+                        entry.getValue().getPayload(),\n+                        entry.getValue().getMetadata()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Get by secondary index.\n+     *\n      * @param <I>       Type of index key.\n+     * @param indexName Index name.\n+     * @param indexKey  Index key.\n      * @return Collection of entries filtered by the secondary index.\n      */\n     @Nonnull\n     protected <I extends Comparable<I>>", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4OTI0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490089244", "bodyText": "I think this exception can be handled by user, instead of we catching. Think about a normal put() operation, which could also throw an exception. User should call our API in a try catch finally block.", "author": "WenbinZhu", "createdAt": "2020-09-17T09:06:17Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA5MDQzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490090436", "bodyText": "Do we need to check the namespace of the table here or maybe in shim layer? Since now user can pass any table instead of a table name.", "author": "WenbinZhu", "createdAt": "2020-09-17T09:08:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0NDY4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490444686", "bodyText": "Good catch. Will add this check and throw an exception if caller tries to insert data of one table into a different namespace.", "author": "hisundar", "createdAt": "2020-09-17T17:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA5MDQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEwNTA1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490105054", "bodyText": "The return value is not used.", "author": "WenbinZhu", "createdAt": "2020-09-17T09:31:08Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwOTM4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490509382", "bodyText": "removed.", "author": "hisundar", "createdAt": "2020-09-17T19:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEwNTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMDU2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490110569", "bodyText": "endTxn() is also called when committing write transaction, so the comment here needs to be changed.", "author": "WenbinZhu", "createdAt": "2020-09-17T09:40:34Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return true;\n+        }\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+        return false;\n+    }\n+\n+    private long txEndInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return this.objectsView.TXEnd();\n+        }\n+        return Address.NON_ADDRESS;\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * The commit call begins a Corfu transaction at the specified snapshot or at the latest snapshot\n+     * if no snapshot is specified, applies all the updates and then ends the Corfu transaction.\n+     * The commit returns successfully if the transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        long commitAddress;\n+        try { // batch up all the operations and apply them in a new transaction started here.\n+            txBeginMaybe();\n+            operations.forEach(Runnable::run);\n+        } finally {\n+            commitAddress = endTxn();\n+        }\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly end a read only transaction to clean up resources\n+     * Explicitly abort a transaction in case of an external condition\n+     */", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTA2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490511061", "bodyText": "fixed.", "author": "hisundar", "createdAt": "2020-09-17T19:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMzc3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490113773", "bodyText": "Can we just do\npublic long commit() {\n        long commitAddress;\n        txBeginMaybe();\n        operations.forEach(Runnable::run);\n        operations.clear();\n        return this.objectsView.TXEnd();\n}\n\nBecause anyway user needs to start transaction in try finally block to prevent there code throwing exception and not cleaning up resource.", "author": "WenbinZhu", "createdAt": "2020-09-17T09:45:44Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.exceptions.AbortCause;\n+import org.corfudb.runtime.exceptions.TransactionAbortedException;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+            this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Throwable throwable) {\n+                throw new TransactionAbortedException(\n+                        new TxResolutionInfo(table.getStreamUUID(), this.isolationLevel.getTimestamp()),\n+                        AbortCause.USER,\n+                        throwable,\n+                        TransactionalContext.getCurrentContext());\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        operations.add(table::clearAll);\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginMaybe();\n+        operations.forEach(Runnable::run); // Apply all pending mutations for reads to see it.\n+        operations.clear();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the corfu transaction. When not reading transactional writes, the internal\n+     * corfu transaction will begin on transaction commit()\n+     */\n+    private boolean txBeginMaybe() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return true;\n+        }\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+        return false;\n+    }\n+\n+    private long txEndInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            return this.objectsView.TXEnd();\n+        }\n+        return Address.NON_ADDRESS;\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * The commit call begins a Corfu transaction at the specified snapshot or at the latest snapshot\n+     * if no snapshot is specified, applies all the updates and then ends the Corfu transaction.\n+     * The commit returns successfully if the transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        long commitAddress;\n+        try { // batch up all the operations and apply them in a new transaction started here.\n+            txBeginMaybe();\n+            operations.forEach(Runnable::run);\n+        } finally {\n+            commitAddress = endTxn();\n+        }\n+        return commitAddress;\n+    }", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0MzUxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490443518", "bodyText": "Just wanted the try {} finally{} block for collecting metrics on how many transactions are aborting. If we just call TXEnd() without any try catch block then we can't capture this metric right?", "author": "hisundar", "createdAt": "2020-09-17T17:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MTI5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490481292", "bodyText": "Then the try should be on endTxn() right? But here the try is on applying the inmemory operations. Since user code can throw exceptions anytime even before commit, which is effectively an abort. So I guess we just need to collect the metrics on aborts thrown from underlying runtime.getObjectsView.TXEnd().", "author": "WenbinZhu", "createdAt": "2020-09-17T18:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMTMwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490511309", "bodyText": "but will add it in the metrics PR not here.", "author": "hisundar", "createdAt": "2020-09-17T19:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNzE2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490527165", "bodyText": "@hisundar I think the current usage of try finally block here might have some problem. If exception happens in operations.forEach(Runnable::run), then endTxn() will still be called. However endTxn() is not just resource cleanup, it also includes doing actual commit, which means you could exceute part of the operations list and hit an exception and then trying to commit that partial transaction, right?", "author": "WenbinZhu", "createdAt": "2020-09-17T19:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMzc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExNTk1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490115952", "bodyText": "Looks like UFOStoreTestImpl and UFOTxnTestImpl.java are just wrapping the CorfuStore and TxnContext with no other logic, so why do we need them? Is it because you are going to add new logics later?", "author": "WenbinZhu", "createdAt": "2020-09-17T09:49:31Z", "path": "test/src/test/java/org/corfudb/runtime/collections/UFOStoreTestImpl.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * UFOStore is a thin layer over CorfuStore that provides certain metadata management\n+ * that carry business logic specific to verticals.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+class UFOStoreTestImpl {", "originalCommit": "123593af8e7a536a811cda1f8541eef8b75210ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Mzc3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r490443770", "bodyText": "yes the latter, I am still in the process of porting the metadata revision, timestamp logic there.", "author": "hisundar", "createdAt": "2020-09-17T17:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExNTk1Mg=="}], "type": "inlineReview"}, {"oid": "103afe9d994da9f9076a389af74bbc78e84c621f", "url": "https://github.com/CorfuDB/CorfuDB/commit/103afe9d994da9f9076a389af74bbc78e84c621f", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\nMark existing api as deprecated.\n+Sample SHIM layer for metadata management with tests", "committedDate": "2020-09-18T17:40:38Z", "type": "forcePushed"}, {"oid": "53e144ff67a1fef22e23c4d96cfaf42a56c48ffb", "url": "https://github.com/CorfuDB/CorfuDB/commit/53e144ff67a1fef22e23c4d96cfaf42a56c48ffb", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\n+Sample SHIM layer for metadata management with tests\nMark existing api as deprecated.", "committedDate": "2020-09-18T21:55:01Z", "type": "forcePushed"}, {"oid": "41d9f35a85373355989af25d243355cad5fd6a70", "url": "https://github.com/CorfuDB/CorfuDB/commit/41d9f35a85373355989af25d243355cad5fd6a70", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\n+Sample SHIM layer for metadata management with tests\nMark existing api as deprecated.", "committedDate": "2020-09-20T07:50:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyODY0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492228644", "bodyText": "nit - may want to change to \"transaction context instance\"", "author": "pankti-m", "createdAt": "2020-09-21T17:28:55Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -122,28 +122,63 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction with snapshot isolation level at the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzMDkzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492230938", "bodyText": "this is incorrect right?  the latest available snapshot may not be used if a specific timestamp is provided.  In future, isolation level can also be different.", "author": "pankti-m", "createdAt": "2020-09-21T17:32:37Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -122,28 +122,63 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction with snapshot isolation level at the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                IsolationLevel.snapshot());\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.\n+     * The transaction does not begin until either a commit or the first read is invoked.\n+     * On read or commit the latest available snapshot will be used to resolve the transaction.", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzMTExNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492231114", "bodyText": "builder -> context?", "author": "pankti-m", "createdAt": "2020-09-21T17:32:54Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -122,28 +122,63 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction with snapshot isolation level at the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @return Returns a transaction builder instance.\n+     */\n+    @Nonnull\n+    public TxnContext txn(@Nonnull final String namespace) {\n+        return new TxnContext(\n+                this.runtime.getObjectsView(),\n+                this.runtime.getTableRegistry(),\n+                namespace,\n+                IsolationLevel.snapshot());\n+    }\n+\n+    /**\n+     * Start appending mutations to a transaction.\n+     * The transaction does not begin until either a commit or the first read is invoked.\n+     * On read or commit the latest available snapshot will be used to resolve the transaction.\n+     *\n+     * @param namespace Namespace of the tables involved in the transaction.\n+     * @param isolationLevel Snapshot (latest or specific) at which the transaction must execute.\n+     * @return Returns a transaction builder instance.", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzNTc3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492235772", "bodyText": "can these stats be made private?", "author": "pankti-m", "createdAt": "2020-09-21T17:40:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -47,9 +48,29 @@\n     @Getter\n     private final String fullyQualifiedTableName;\n \n+    @Getter\n+    private final UUID streamUUID;\n+\n     @Getter\n     private final MetadataOptions metadataOptions;\n \n+    /**\n+     * List of Metrics captured on this table\n+     */\n+    public final SimpleTimingStat writeOnlyTxnTimes = new SimpleTimingStat();", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NDYzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492394634", "bodyText": "we can but I thought it is better to make it publicly accessible for simplicity.", "author": "hisundar", "createdAt": "2020-09-21T23:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzNTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTEwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492261101", "bodyText": "should this be an exception or log an error that txEnd was called outside a transaction context?", "author": "pankti-m", "createdAt": "2020-09-21T18:25:14Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,387 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numPuts.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numMerges.incrementAndGet();\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(table::clearAll);\n+        table.numClears.incrementAndGet();\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGets.incrementAndGet();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * apply all pending operations after starting the corfu transaction.\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBegin(Table<K, V, M> tableBeingRead) {\n+        if (tableBeingRead != null) { // called from one of the read api\n+            if (!operations.isEmpty()) { // We have buffered some writes before..\n+                operations.forEach(Runnable::run); // apply them for dirty reads to see\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+            }\n+            if (txnType == TxnType.writeAndReads) {\n+                // Not the first dirty read, don't change the txnType here\n+            } else { // Called from read api where no writes have been seen\n+                txnType = TxnType.readOnly;\n+            }\n+            tablesInTxn.add(tableBeingRead);\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            if (tableBeingRead == null  // i.e, called from commit() but corfu txn was started!\n+                    && !operations.isEmpty()) { // We have pending writes to apply\n+                txnType = TxnType.writeAndReads; // Reads, then writes and now commit()\n+            }\n+            return;\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Explicitly end a read only transaction to clean up resources\n+     * Internally used at the end of commit() to commit the corfu transaction\n+     * @return the address at which the corfu transaction committed.\n+     */\n+    public long txEnd() {\n+        operations.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            long commitAddress = this.objectsView.TXEnd();\n+            long timeElapsed = System.nanoTime() - txnStartTime;\n+            switch (txnType) {\n+                case readOnly:\n+                    tablesInTxn.forEach(t -> t.readOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeOnly:\n+                    tablesInTxn.forEach(t -> t.writeOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeAndReads:\n+                    tablesInTxn.forEach(t -> t.readWriteTxnTimes.set(timeElapsed));\n+                    break;\n+            }\n+            tablesInTxn.clear();\n+            return commitAddress;\n+        }\n+        return Address.NON_ADDRESS;", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1MDUyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492350528", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-09-21T21:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MjY0Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492262643", "bodyText": "can this be made private?", "author": "pankti-m", "createdAt": "2020-09-21T18:28:01Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,387 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numPuts.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numMerges.incrementAndGet();\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(table::clearAll);\n+        table.numClears.incrementAndGet();\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGets.incrementAndGet();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * apply all pending operations after starting the corfu transaction.\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBegin(Table<K, V, M> tableBeingRead) {\n+        if (tableBeingRead != null) { // called from one of the read api\n+            if (!operations.isEmpty()) { // We have buffered some writes before..\n+                operations.forEach(Runnable::run); // apply them for dirty reads to see\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+            }\n+            if (txnType == TxnType.writeAndReads) {\n+                // Not the first dirty read, don't change the txnType here\n+            } else { // Called from read api where no writes have been seen\n+                txnType = TxnType.readOnly;\n+            }\n+            tablesInTxn.add(tableBeingRead);\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            if (tableBeingRead == null  // i.e, called from commit() but corfu txn was started!\n+                    && !operations.isEmpty()) { // We have pending writes to apply\n+                txnType = TxnType.writeAndReads; // Reads, then writes and now commit()\n+            }\n+            return;\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Explicitly end a read only transaction to clean up resources\n+     * Internally used at the end of commit() to commit the corfu transaction\n+     * @return the address at which the corfu transaction committed.\n+     */\n+    public long txEnd() {", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM1MDE4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492350183", "bodyText": "Since we agreed that read-your-writes will be the default, we need a public method for query transactions to end()", "author": "hisundar", "createdAt": "2020-09-21T21:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2ODM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492268385", "bodyText": "can we give a generic namespace?", "author": "pankti-m", "createdAt": "2020-09-21T18:38:26Z", "path": "test/src/test/java/org/corfudb/runtime/collections/UFOStoreTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+import org.corfudb.runtime.view.AbstractViewTest;\n+import org.corfudb.test.SampleSchema;\n+import org.corfudb.test.SampleSchema.EventInfo;\n+import org.corfudb.test.SampleSchema.ManagedMetadata;\n+import org.corfudb.test.SampleSchema.Uuid;\n+import org.junit.Test;\n+\n+import java.util.UUID;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+/**\n+ * To ensure that feature changes in CorfuStore do not break verticals,\n+ * we simulate their usage pattern with a implementation and tests.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+public class UFOStoreTest extends AbstractViewTest {\n+    /**\n+     * UFOStoreTestImpl stores 3 pieces of information - key, value and metadata\n+     * This test demonstrates how metadata field options esp \"version\" can be used and verified.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void checkRevisionValidation() throws Exception {\n+\n+        // Get a Corfu Runtime instance.\n+        CorfuRuntime corfuRuntime = getDefaultRuntime();\n+\n+        // Creating Corfu Store using a connected corfu client.\n+        UFOStoreTestImpl ufoStore = new UFOStoreTestImpl(corfuRuntime);\n+\n+        // Define a namespace for the table.\n+        final String globalManager = \"global-manager\";", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0OTc2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492349768", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-21T21:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2ODM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MDE5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492270193", "bodyText": "I think it is better to give only 1 interface for ending all types of transactions(rw, read-only and write-only).  All transactions can end using commit() is my suggestion.", "author": "pankti-m", "createdAt": "2020-09-21T18:41:45Z", "path": "test/src/test/java/org/corfudb/runtime/collections/UFOStoreTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+import org.corfudb.runtime.view.AbstractViewTest;\n+import org.corfudb.test.SampleSchema;\n+import org.corfudb.test.SampleSchema.EventInfo;\n+import org.corfudb.test.SampleSchema.ManagedMetadata;\n+import org.corfudb.test.SampleSchema.Uuid;\n+import org.junit.Test;\n+\n+import java.util.UUID;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+/**\n+ * To ensure that feature changes in CorfuStore do not break verticals,\n+ * we simulate their usage pattern with a implementation and tests.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+public class UFOStoreTest extends AbstractViewTest {\n+    /**\n+     * UFOStoreTestImpl stores 3 pieces of information - key, value and metadata\n+     * This test demonstrates how metadata field options esp \"version\" can be used and verified.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void checkRevisionValidation() throws Exception {\n+\n+        // Get a Corfu Runtime instance.\n+        CorfuRuntime corfuRuntime = getDefaultRuntime();\n+\n+        // Creating Corfu Store using a connected corfu client.\n+        UFOStoreTestImpl ufoStore = new UFOStoreTestImpl(corfuRuntime);\n+\n+        // Define a namespace for the table.\n+        final String globalManager = \"global-manager\";\n+        // Define table name.\n+        final String tableName = \"EventInfo\";\n+\n+        // Create & Register the table.\n+        // This is required to initialize the table for the current corfu client.\n+        Table<Uuid, EventInfo, ManagedMetadata> table = ufoStore.openTable(\n+                globalManager,\n+                tableName,\n+                Uuid.class,\n+                EventInfo.class,\n+                ManagedMetadata.class,\n+                // TableOptions includes option to choose - Memory/Disk based corfu table.\n+                TableOptions.builder().build());\n+\n+        UUID uuid1 = UUID.nameUUIDFromBytes(\"1\".getBytes());\n+        Uuid key1 = Uuid.newBuilder()\n+                .setMsb(uuid1.getMostSignificantBits()).setLsb(uuid1.getLeastSignificantBits())\n+                .build();\n+        ManagedMetadata user_1 = ManagedMetadata.newBuilder().setCreateUser(\"user_1\").build();\n+        long expectedVersion = 0L;\n+\n+        ufoStore.txn(globalManager)\n+                .putRecord(tableName, key1,\n+                        EventInfo.newBuilder().setName(\"abc\").build(),\n+                        user_1)\n+                .commit();\n+\n+        UFOTxnTestImpl queryTxn = ufoStore.txn(globalManager);\n+        CorfuStoreEntry<Uuid, EventInfo, ManagedMetadata> entry = null;\n+        try {\n+            entry = queryTxn.getRecord(table, key1);\n+        } catch (Throwable throwable) {\n+            assertThat(throwable).isEqualTo(null);\n+        } finally {\n+            queryTxn.txnEnd();", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0OTY5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492349696", "bodyText": "commit() is widely used to denote a change. Query is a read-only operation, that's one reason for separation.\nThe other reason is to start the transaction the right way - we use commit() to denote a write transaction.", "author": "hisundar", "createdAt": "2020-09-21T21:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MTQ4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492271480", "bodyText": "Can you rename it to something else?  Because we also have a UFOStoreTest which is a test class and not related to this impl.", "author": "pankti-m", "createdAt": "2020-09-21T18:44:14Z", "path": "test/src/test/java/org/corfudb/runtime/collections/UFOStoreTestImpl.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * UFOStore is a thin layer over CorfuStore that provides certain metadata management\n+ * that carry business logic specific to verticals.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+class UFOStoreTestImpl {", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0NDcxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492344714", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-21T21:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MTQ4MA=="}], "type": "inlineReview"}, {"oid": "4b3f6690fe29f84490809abf65080583d0eb497d", "url": "https://github.com/CorfuDB/CorfuDB/commit/4b3f6690fe29f84490809abf65080583d0eb497d", "message": "add touch api", "committedDate": "2020-09-21T23:04:14Z", "type": "forcePushed"}, {"oid": "fe376d896af3f12c817819083e7a23bdd41fecf1", "url": "https://github.com/CorfuDB/CorfuDB/commit/fe376d896af3f12c817819083e7a23bdd41fecf1", "message": "add touch api", "committedDate": "2020-09-21T23:09:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492278481", "bodyText": "Missing javadoc comment.", "author": "WenbinZhu", "createdAt": "2020-09-21T18:56:58Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/SimpleTimingStat.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.gson.JsonObject;\n+import lombok.Getter;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Minimalistic stats to capture time taken\n+ * created by hisundar 2020-09-20\n+ */\n+public class SimpleTimingStat {\n+    private long num = 0L;\n+    private long avg = 0L;\n+    private long max = Long.MIN_VALUE;\n+    private long min = Long.MAX_VALUE;\n+\n+    /**\n+     * @param val - time elapsed in nano seconds\n+     */\n+    public synchronized void set(long val) {\n+        num++;\n+        if (val > max) {\n+            max = val;\n+        }\n+        if (val < min) {\n+            min = val;\n+        }\n+        avg = ((num-1)*avg + val)/num;\n+    }\n+\n+    /**", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MzczOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493063738", "bodyText": "added.", "author": "hisundar", "createdAt": "2020-09-22T22:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODYwMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492278600", "bodyText": "Missing javadoc comment.", "author": "WenbinZhu", "createdAt": "2020-09-21T18:57:12Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/SimpleTimingStat.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.gson.JsonObject;\n+import lombok.Getter;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Minimalistic stats to capture time taken\n+ * created by hisundar 2020-09-20\n+ */\n+public class SimpleTimingStat {\n+    private long num = 0L;\n+    private long avg = 0L;\n+    private long max = Long.MIN_VALUE;\n+    private long min = Long.MAX_VALUE;\n+\n+    /**", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Mzk3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493063975", "bodyText": "added.", "author": "hisundar", "createdAt": "2020-09-22T22:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTcwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492281706", "bodyText": "I think it's better to put these stats in a class.", "author": "WenbinZhu", "createdAt": "2020-09-21T19:02:50Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -47,9 +48,29 @@\n     @Getter\n     private final String fullyQualifiedTableName;\n \n+    @Getter\n+    private final UUID streamUUID;\n+\n     @Getter\n     private final MetadataOptions metadataOptions;\n \n+    /**\n+     * List of Metrics captured on this table\n+     */\n+    public final SimpleTimingStat writeOnlyTxnTimes = new SimpleTimingStat();\n+    public final SimpleTimingStat readOnlyTxnTimes = new SimpleTimingStat();\n+    public final SimpleTimingStat readWriteTxnTimes = new SimpleTimingStat();\n+    public final AtomicLong numPuts = new AtomicLong(0L);\n+    public final AtomicLong numMerges = new AtomicLong(0L);\n+    public final AtomicLong numDeletes = new AtomicLong(0L);\n+    public final AtomicLong numClears = new AtomicLong(0L);\n+    public final AtomicLong numGets = new AtomicLong(0L);\n+    public final AtomicLong numCounts = new AtomicLong(0L);\n+    public final AtomicLong numKeySets = new AtomicLong(0L);\n+    public final AtomicLong numScans = new AtomicLong(0L);\n+    public final AtomicLong numGetByIndex = new AtomicLong(0L);\n+    public final AtomicLong numTxnAborts = new AtomicLong(0L);", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2ODQzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493068431", "bodyText": "done. added new metrics class.", "author": "hisundar", "createdAt": "2020-09-22T22:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4NTk4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492285983", "bodyText": "Why private is removed?", "author": "WenbinZhu", "createdAt": "2020-09-21T19:10:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -343,7 +420,7 @@ private M mergeOldAndNewMetadata(@Nonnull M previousMetadata,\n         return (M) builder.build();\n     }\n \n-    private void validateVersion(@Nullable M previousMetadata,\n+    void validateVersion(@Nullable M previousMetadata,", "originalCommit": "39a49789ce9b51c4b47ae59561f201c235d99b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2ODY0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493068648", "bodyText": "actually I don't know must have been for some other thing. I can put it back.", "author": "hisundar", "createdAt": "2020-09-22T22:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4NTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNTcxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492415719", "bodyText": "This line seems a bit confusing, I think it should be \"Start a transaction with snapshot isolation level at the latest available corfu snapshot.\"", "author": "WenbinZhu", "createdAt": "2020-09-22T00:19:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -122,28 +122,63 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction at the isolation level of the latest available corfu snapshot.", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2ODg1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493068855", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-22T22:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzQzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492417437", "bodyText": "I think it's better to put them in a class.", "author": "WenbinZhu", "createdAt": "2020-09-22T00:26:49Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -47,9 +48,30 @@\n     @Getter\n     private final String fullyQualifiedTableName;\n \n+    @Getter\n+    private final UUID streamUUID;\n+\n     @Getter\n     private final MetadataOptions metadataOptions;\n \n+    /**\n+     * List of Metrics captured on this table\n+     */\n+    public final SimpleTimingStat writeOnlyTxnTimes = new SimpleTimingStat();\n+    public final SimpleTimingStat readOnlyTxnTimes = new SimpleTimingStat();\n+    public final SimpleTimingStat readWriteTxnTimes = new SimpleTimingStat();\n+    public final AtomicLong numPuts = new AtomicLong(0L);\n+    public final AtomicLong numMerges = new AtomicLong(0L);\n+    public final AtomicLong numTouches = new AtomicLong(0L);\n+    public final AtomicLong numDeletes = new AtomicLong(0L);\n+    public final AtomicLong numClears = new AtomicLong(0L);\n+    public final AtomicLong numGets = new AtomicLong(0L);\n+    public final AtomicLong numCounts = new AtomicLong(0L);\n+    public final AtomicLong numKeySets = new AtomicLong(0L);\n+    public final AtomicLong numScans = new AtomicLong(0L);\n+    public final AtomicLong numGetByIndex = new AtomicLong(0L);\n+    public final AtomicLong numTxnAborts = new AtomicLong(0L);", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTA4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493069088", "bodyText": "done. put in separate class.", "author": "hisundar", "createdAt": "2020-09-22T22:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzUwOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492417509", "bodyText": "Per my previous comment, if we put these stats in a class, the we don't have the create json objects every time, just return that object, right? Or there are other reasons you need to use json to return?", "author": "WenbinZhu", "createdAt": "2020-09-22T00:27:09Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -367,4 +445,28 @@ private void validateVersion(@Nullable M previousMetadata,\n             }\n         }\n     }\n+\n+    public JsonObject metricsAsJsonObject() {", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTIwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493069202", "bodyText": "done. put in separate class with toString()", "author": "hisundar", "createdAt": "2020-09-22T22:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzg2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492417869", "bodyText": "Should these two lines be put in the lambda? Because If somehow txn gets aborted before the first read operation or commit (basically before lambda is executed), then the stats should not be updated.", "author": "WenbinZhu", "createdAt": "2020-09-22T00:28:46Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,427 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numPuts.incrementAndGet();\n+        tablesInTxn.add(table);", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTQzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493069433", "bodyText": "hmm.. sure that's one way to consider the stats. done.", "author": "hisundar", "createdAt": "2020-09-22T22:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyOTk1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492429950", "bodyText": "The logic here seems not correct. If this is the first time to call txBegin with tableBeingRead != null, since the transaction is not started yet, there is no TransactionalContext, but you still run the operations on line 344, which means they will be non-transactional writes. Did I miss anything?", "author": "WenbinZhu", "createdAt": "2020-09-22T01:20:59Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,427 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numPuts.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numMerges.incrementAndGet();\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numTouches.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(table::clearAll);\n+        table.numClears.incrementAndGet();\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGets.incrementAndGet();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * apply all pending operations after starting the corfu transaction.\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBegin(Table<K, V, M> tableBeingRead) {\n+        if (tableBeingRead != null) { // called from one of the read api\n+            if (!operations.isEmpty()) { // We have buffered some writes before..\n+                operations.forEach(Runnable::run); // apply them for dirty reads to see\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+            }", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA3MzU4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493073581", "bodyText": "good catch - I was trying to refactor to avoid repetition and ended up missing this case.\nThe implementation is still filled with if - else logic, so please feel free to suggest a better alternative.", "author": "hisundar", "createdAt": "2020-09-22T22:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyOTk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzMzEzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r492433135", "bodyText": "I think the implementation if txEnd() deviates from what we discussed, we can discuss offline. Also numTxnAborts only counts for application initiated, which I think might not be quite useful, because what matters most is the database initiated aborts that are caused by conflicts, sequencer overflows, etc.", "author": "WenbinZhu", "createdAt": "2020-09-22T01:35:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,427 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numPuts.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numMerges.incrementAndGet();\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        table.numTouches.incrementAndGet();\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(table::clearAll);\n+        table.numClears.incrementAndGet();\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGets.incrementAndGet();\n+        CorfuRecord<V, M> record = table.get(key);\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBegin(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * apply all pending operations after starting the corfu transaction.\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBegin(Table<K, V, M> tableBeingRead) {\n+        if (tableBeingRead != null) { // called from one of the read api\n+            if (!operations.isEmpty()) { // We have buffered some writes before..\n+                operations.forEach(Runnable::run); // apply them for dirty reads to see\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+            }\n+            if (txnType != TxnType.writeAndReads) {\n+                txnType = TxnType.readOnly; // Called from read api where no writes have been seen\n+            } // else not the first dirty read, don't change the txnType here\n+\n+            tablesInTxn.add(tableBeingRead);\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            if (tableBeingRead == null  // i.e, called from commit() but corfu txn was started!\n+                    && !operations.isEmpty()) { // We have pending writes to apply\n+                txnType = TxnType.writeAndReads; // Reads, then writes and now commit()\n+            }\n+            return;\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Explicitly end a read only transaction to clean up resources\n+     * Internally used at the end of commit() to commit the corfu transaction\n+     * @return the address at which the corfu transaction committed.\n+     */\n+    public long txEnd() {", "originalCommit": "fe376d896af3f12c817819083e7a23bdd41fecf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA3MDk1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493070959", "bodyText": "done. captured the corfu transaction aborts as well.\nwhat should the txEnd() do instead?", "author": "hisundar", "createdAt": "2020-09-22T22:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzMzEzNQ=="}], "type": "inlineReview"}, {"oid": "f0c27eed3915b295a60053271cd65d644e2511d5", "url": "https://github.com/CorfuDB/CorfuDB/commit/f0c27eed3915b295a60053271cd65d644e2511d5", "message": "add touch api\n\nRefactor metrics out to separate layer\nRefactor decision logic in txBegin", "committedDate": "2020-09-22T23:51:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDM2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493780363", "bodyText": "what is the usecase for it?", "author": "pankti-m", "createdAt": "2020-09-23T17:52:40Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2MDg2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495160868", "bodyText": "good question - I can't say - maybe something like no config value exists but both writers want to know if that value has been modified.", "author": "hisundar", "createdAt": "2020-09-25T18:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4NzY4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493787683", "bodyText": "can you change the api as per the comment or vice versa?", "author": "pankti-m", "createdAt": "2020-09-23T18:04:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2MjA0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495162041", "bodyText": "done. fix up the comment.", "author": "hisundar", "createdAt": "2020-09-25T18:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4NzY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5MzczNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493793736", "bodyText": "This case is not very clear.  No tables are being read(tableBeingRead = null).  We can simply return, right?\nCan you add some more comments here?", "author": "pankti-m", "createdAt": "2020-09-23T18:14:52Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2MjM3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495162376", "bodyText": "that's what we do - we just return, just adding trace line to indicate that this is what is happening just in case we want to debug.", "author": "hisundar", "createdAt": "2020-09-25T18:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5MzczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5NTcxOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493795719", "bodyText": "this means it is a write-only transaction and the transaction has already started.  How does it mean it is outside the scope?", "author": "pankti-m", "createdAt": "2020-09-23T18:18:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2MzIwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495163207", "bodyText": "if commit() is called and no dirty reads have happened then that means corfu transaction should NOT have started.\nBut if we are in this case it means someone started a transaction out side of the TxnContext - that is not allowed and so we should throw an error.\nThat's why these cases are important - they highlight issues like this.", "author": "hisundar", "createdAt": "2020-09-25T18:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5NTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMzM0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493803340", "bodyText": "shouldnt they all be in caps?", "author": "pankti-m", "createdAt": "2020-09-23T18:31:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2MzI1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495163258", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-25T18:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMzM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDQ4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493804481", "bodyText": "how can we say that?  the type could have been write-only also without any prior reads....", "author": "pankti-m", "createdAt": "2020-09-23T18:33:31Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTA1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495165057", "bodyText": "this case is only when called from read-api. if writes have happened then the write buffer will have writes.", "author": "hisundar", "createdAt": "2020-09-25T18:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDkyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493804923", "bodyText": "what are we trying to differentiate in these if-else?  Somehow it is not clear to me", "author": "pankti-m", "createdAt": "2020-09-23T18:34:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");\n+                    txnType = TxnType.readOnly;\n+                } else {\n+                    log.trace(\"More reads in transaction that had writes before\");", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NjMzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495166335", "bodyText": "added a comment. we do not want to mark a transaction as read-only if there have been dirty writes before.\nconsider this case:\nwrite\nread < dirty read -\nread < case 7 else part here", "author": "hisundar", "createdAt": "2020-09-25T18:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNTY5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493805691", "bodyText": "I think the previous implementation of txBegin was simpler.. any reason why it was changed?  Do we need to differentiate between the 8 cases?", "author": "pankti-m", "createdAt": "2020-09-23T18:35:32Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NjkxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495166916", "bodyText": "because each of these 8 cases have different outcomes which either influence how the transaction is to be started or how we classify the transaction type for recording stats.\nWe can consider other ideas as long as it handles all the cases.", "author": "hisundar", "createdAt": "2020-09-25T18:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNTY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODM1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493808353", "bodyText": "I think this line is a bit confusing now that we have both reads and writes in the same transaction.", "author": "pankti-m", "createdAt": "2020-09-23T18:40:05Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");\n+                    txnType = TxnType.readOnly;\n+                } else {\n+                    log.trace(\"More reads in transaction that had writes before\");\n+                }\n+                break;\n+            default:\n+                log.warn(\"Unsupported decision logic for txn begin\");\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction.\n+     */\n+    private void txBeginInternal() {\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2ODE1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495168152", "bodyText": "modified comment.", "author": "hisundar", "createdAt": "2020-09-25T18:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzM2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493813363", "bodyText": "Override annotation", "author": "pankti-m", "createdAt": "2020-09-23T18:45:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");\n+                    txnType = TxnType.readOnly;\n+                } else {\n+                    log.trace(\"More reads in transaction that had writes before\");\n+                }\n+                break;\n+            default:\n+                log.warn(\"Unsupported decision logic for txn begin\");\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction.\n+     */\n+    private void txBeginInternal() {\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * The commit returns successfully if the transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        txBeginAndApply(null);\n+        long commitAddress = Address.NON_ADDRESS;\n+        if (TransactionalContext.isInTransaction()) {\n+            try {\n+                commitAddress = this.objectsView.TXEnd();\n+            } catch (Exception ex) {\n+                tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+                tablesInTxn.clear();\n+                throw ex;\n+            }\n+            long timeElapsed = System.nanoTime() - txnStartTime;\n+            switch (txnType) {\n+                case readOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().writeOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeAndReads:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readWriteTxnTimes.set(timeElapsed));\n+                    break;\n+                default:\n+                    log.error(\"UNKNOWN TxnType!!\");\n+                    break;\n+            }\n+        }\n+        tablesInTxn.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        tablesInTxn.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            this.objectsView.TXAbort();\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+        }\n+    }\n+\n+    /**\n+     * Cleanup the transaction resources.\n+     * If invoked on transaction with just queries, record the time taken.\n+     */\n+    public void close() {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2ODIxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495168214", "bodyText": "added.", "author": "hisundar", "createdAt": "2020-09-25T18:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxMzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjI2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493852265", "bodyText": "with isolation level -> with snapshot isolation level", "author": "WenbinZhu", "createdAt": "2020-09-23T19:45:33Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -122,28 +124,63 @@ public void deleteTable(String namespace, String tableName) {\n     }\n \n     /**\n-     * Start appending mutations to a transaction.\n-     * The transaction does not begin until a commit is invoked.\n-     * On a commit the latest available snapshot will be used to resolve the transaction.\n+     * Start a transaction with snapshot isolation level at the latest available corfu snapshot.\n+     * The transaction does not begin until either a commit is invoked or a read happens.\n      *\n      * @param namespace Namespace of the tables involved in the transaction.\n      * @return Returns a transaction builder instance.\n      */\n     @Nonnull\n+    @Deprecated\n     public TxBuilder tx(@Nonnull final String namespace) {\n         return new TxBuilder(\n                 this.runtime.getObjectsView(),\n                 this.runtime.getTableRegistry(),\n                 namespace);\n     }\n \n+    /**\n+     * Start a transaction with isolation level at the latest available snapshot.", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2ODc5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495168792", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-25T18:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MzU0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493853544", "bodyText": "Unused import.", "author": "WenbinZhu", "createdAt": "2020-09-23T19:47:54Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -1,10 +1,10 @@\n package org.corfudb.runtime.collections;\n \n+import com.google.gson.JsonObject;", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2ODk1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495168951", "bodyText": "removed.", "author": "hisundar", "createdAt": "2020-09-25T18:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTI5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493881298", "bodyText": "This should not be error level right?", "author": "WenbinZhu", "createdAt": "2020-09-23T20:39:54Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -173,23 +173,22 @@ void registerTable(@Nonnull String namespace,\n         TableMetadata.Builder metadataBuilder = TableMetadata.newBuilder();\n         metadataBuilder.setDiskBased(tableOptions.getPersistentDataPath().isPresent());\n \n-        // Schema validation to ensure that there is either proper modification of the schema across open calls.\n-        // Or no modification to the protobuf files.\n-        boolean hasSchemaChanged = false;\n-        CorfuRecord<TableDescriptors, TableMetadata> oldRecord = this.registryTable.get(tableNameKey);\n-        if (oldRecord != null) {\n-            if (!oldRecord.getPayload().getFileDescriptorsMap().equals(tableDescriptors.getFileDescriptorsMap())) {\n-                hasSchemaChanged = true;\n-                log.error(\"registerTable: Schema update detected for table \"+namespace+\" \"+ tableName);\n-                log.debug(\"registerTable: old schema:\"+oldRecord.getPayload().getFileDescriptorsMap());\n-                log.debug(\"registerTable: new schema:\"+tableDescriptors.getFileDescriptorsMap());\n-            }\n-        }\n         int numRetries = 9; // Since this is an internal transaction, retry a few times before giving up.\n         long finalAddress = Address.NON_ADDRESS;\n         while (numRetries-- > 0) {\n+            // Schema validation to ensure that there is either proper modification of the schema across open calls.\n+            // Or no modification to the protobuf files.\n             try {\n-                this.runtime.getObjectsView().TXBuild().type(TransactionType.OPTIMISTIC).build().begin();\n+                this.runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE).build().begin();\n+                boolean hasSchemaChanged = false;\n+                CorfuRecord<TableDescriptors, TableMetadata> oldRecord = this.registryTable.get(tableNameKey);\n+                if (oldRecord != null && !oldRecord.getPayload().getFileDescriptorsMap()\n+                        .equals(tableDescriptors.getFileDescriptorsMap())) {\n+                    hasSchemaChanged = true;\n+                    log.error(\"registerTable: Schema update detected for table {}${}\", namespace, tableName);", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2OTA5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495169099", "bodyText": "changed to WARN", "author": "hisundar", "createdAt": "2020-09-25T18:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDg5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493884895", "bodyText": "Cannot add comment on line 208, so putting here: I think it's better to use TransactionalContext.isInTransaction() instead of finalAddress == Address.NON_ADDRESS", "author": "WenbinZhu", "createdAt": "2020-09-23T20:46:35Z", "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -198,6 +197,7 @@ void registerTable(@Nonnull String namespace,\n                             new CorfuRecord<>(tableDescriptors, metadataBuilder.build()));\n                 }\n                 finalAddress = this.runtime.getObjectsView().TXEnd();\n+                break;\n             } catch (TransactionAbortedException txAbort) {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3MDIwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495170207", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-25T18:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4OTE2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493889161", "bodyText": "We should extract this sanity check to a common method to avoid a lot of duplicate codes, or use guava's preconditions", "author": "WenbinZhu", "createdAt": "2020-09-23T20:54:42Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5OTU5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494599591", "bodyText": "agree repeated code.", "author": "medhavidhawan", "createdAt": "2020-09-24T20:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4OTE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3MDM4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495170381", "bodyText": "done, moved to common method.", "author": "hisundar", "createdAt": "2020-09-25T18:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4OTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDI3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493980279", "bodyText": "Put this and the end  to make this same as in close()?", "author": "WenbinZhu", "createdAt": "2020-09-24T01:01:27Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");\n+                    txnType = TxnType.readOnly;\n+                } else {\n+                    log.trace(\"More reads in transaction that had writes before\");\n+                }\n+                break;\n+            default:\n+                log.warn(\"Unsupported decision logic for txn begin\");\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction.\n+     */\n+    private void txBeginInternal() {\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * The commit returns successfully if the transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        txBeginAndApply(null);\n+        long commitAddress = Address.NON_ADDRESS;\n+        if (TransactionalContext.isInTransaction()) {\n+            try {\n+                commitAddress = this.objectsView.TXEnd();\n+            } catch (Exception ex) {\n+                tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+                tablesInTxn.clear();\n+                throw ex;\n+            }\n+            long timeElapsed = System.nanoTime() - txnStartTime;\n+            switch (txnType) {\n+                case readOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().writeOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeAndReads:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readWriteTxnTimes.set(timeElapsed));\n+                    break;\n+                default:\n+                    log.error(\"UNKNOWN TxnType!!\");\n+                    break;\n+            }\n+        }\n+        tablesInTxn.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        tablesInTxn.clear();", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3MzI1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495173256", "bodyText": "not sure how - they are doing different things right?", "author": "hisundar", "createdAt": "2020-09-25T18:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTA4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493981084", "bodyText": "Incomplete javadoc.\nAlso there are two \"@param tableBeingRead\", one of them should be removed.", "author": "WenbinZhu", "createdAt": "2020-09-24T01:04:53Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3MzQ0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495173447", "bodyText": "done, removed", "author": "hisundar", "createdAt": "2020-09-25T18:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NTg2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493985868", "bodyText": "This method impl is really hard to read...Let's discuss offline to simplify it, I have some idea in mind that might help", "author": "WenbinZhu", "createdAt": "2020-09-24T01:23:44Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NDQ4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495174480", "bodyText": "Sure, like I mentioned to @pankti-m 's comments as well any ideas are welcome as long as they address all the cases and it is easy to verify by reading.", "author": "hisundar", "createdAt": "2020-09-25T18:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NjkxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r493986914", "bodyText": "I think we cannot check this condition here. Even if it's a read only txn, if an unexpected execption happens during txn and we come here to clean up resource, then the transaction is actually failed, so we should not set this metrics in that case, right?", "author": "WenbinZhu", "createdAt": "2020-09-24T01:27:17Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {\n+            case 0: // commit() on a normal write-only transaction!\n+                log.trace(\"commit() applying {} operations\", operations.size());\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeOnly;\n+                break;\n+            case 1: // commit() called without a corfu transaction or buffered writes!\n+                log.warn(\"commit called on an empty transaction!\");\n+                break;\n+            case 2: // commit() called but corfu txn already begun for reads\n+                log.trace(\"commit() applying pending {} operations after reads\", operations.size());\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 3: // commit called in a read-only transaction.\n+                if (txnType == TxnType.readOnly) {\n+                    log.trace(\"Ending a read-only transaction\");\n+                } else if (txnType == TxnType.writeAndReads) {\n+                    log.trace(\"Ending a dirty-read transaction!\");\n+                } else { // Attempting to commit a corfu txn started outside this scope!\n+                    log.error(\"commit() on a transaction started outside scope of this thread!\");\n+                    throw new IllegalStateException(\n+                            \"commit() invoked but transaction not started in this thread!\");\n+                }\n+                break;\n+            case 4:\n+                log.trace(\"Dirty reads invoked. Applying {} in thread\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                operations.forEach(Runnable::run);\n+                operations.clear();\n+                txnType = TxnType.writeAndReads;\n+                break;\n+            case 5: // Normal path for a starting a transaction to do queries.\n+                log.trace(\"Starting a transaction for reading data\");\n+                tablesInTxn.add(tableBeingRead);\n+                txBeginInternal();\n+                txnType = TxnType.readOnly;\n+                break;\n+            case 6:\n+                log.trace(\"More dirty reads. Applying {}\", operations.size());\n+                tablesInTxn.add(tableBeingRead);\n+                operations.forEach(Runnable::run);\n+                txnType = TxnType.writeAndReads;\n+                operations.clear();\n+                break;\n+            case 7:\n+                tablesInTxn.add(tableBeingRead);\n+                if (txnType != TxnType.writeAndReads) {\n+                    log.trace(\"More reads in same transaction\");\n+                    txnType = TxnType.readOnly;\n+                } else {\n+                    log.trace(\"More reads in transaction that had writes before\");\n+                }\n+                break;\n+            default:\n+                log.warn(\"Unsupported decision logic for txn begin\");\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction.\n+     */\n+    private void txBeginInternal() {\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * The commit returns successfully if the transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        txBeginAndApply(null);\n+        long commitAddress = Address.NON_ADDRESS;\n+        if (TransactionalContext.isInTransaction()) {\n+            try {\n+                commitAddress = this.objectsView.TXEnd();\n+            } catch (Exception ex) {\n+                tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+                tablesInTxn.clear();\n+                throw ex;\n+            }\n+            long timeElapsed = System.nanoTime() - txnStartTime;\n+            switch (txnType) {\n+                case readOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeOnly:\n+                    tablesInTxn.forEach(t -> t.getMetrics().writeOnlyTxnTimes.set(timeElapsed));\n+                    break;\n+                case writeAndReads:\n+                    tablesInTxn.forEach(t -> t.getMetrics().readWriteTxnTimes.set(timeElapsed));\n+                    break;\n+                default:\n+                    log.error(\"UNKNOWN TxnType!!\");\n+                    break;\n+            }\n+        }\n+        tablesInTxn.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        tablesInTxn.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            this.objectsView.TXAbort();\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+        }\n+    }\n+\n+    /**\n+     * Cleanup the transaction resources.\n+     * If invoked on transaction with just queries, record the time taken.\n+     */\n+    public void close() {\n+        if (TransactionalContext.isInTransaction()) {\n+            if (txnType == TxnType.readOnly) {\n+                long timeElapsed = System.nanoTime() - txnStartTime;\n+                tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NDkwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495174905", "bodyText": "its a tradeoff - either we don't allow autocloseable on the queries or take the price of recording aborted read-only transaction times. I took the latter since autoclosable on reads is a useful feature requested by consumers.", "author": "hisundar", "createdAt": "2020-09-25T18:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NjkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMTAzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494601032", "bodyText": "just make sure throwing exceptions inside lambda works as expected ? Not sure if it works as expected.", "author": "medhavidhawan", "createdAt": "2020-09-24T20:47:13Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NTA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495175064", "bodyText": "it does - we have tests validating the same in UfoStoreTest.java", "author": "hisundar", "createdAt": "2020-09-25T18:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxOTk0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494619944", "bodyText": "This method is hard to read. can we simplify ? the numbers are hard to read as we lose context.", "author": "medhavidhawan", "createdAt": "2020-09-24T21:26:17Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId\n+     * @param updateEntry\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        txBeginAndApply(table); // Apply pending writes (if any) & begin corfu txn if thread hasn't begun one\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction if started by a read operation,\n+     * Cases to consider:\n+     *   Bit2      Bit1         Bit0\n+     *  isRead   hasTxnBegun   isEmptyWriteBuffer\n+     *  ======= ===========   ================\n+     * 0 commit noTxnStarted  buffered writes => start txn, apply writes, writeOnlyTxn\n+     * 1 commit noTxnStarted  no writes       => start txn, writeOnlyTxn\n+     * 2 commit txnStarted    buffered writes => apply writes, writeAndReadTxn\n+     * 3 commit txnStarted    no writes       => do nothing!\n+     * 4 readApi noTxnStarted buffered writes => start txn, apply writes, writeAndReadTxn\n+     * 5 readApi noTxnStarted no writes       => start txn, readOnlyTxn\n+     * 6 readApi txnStarted   buffered writes => apply writes, writeAndReadTxn\n+     * 7 readApi txnStarted   no writes       => readOnlyTxn iff not writeAndReadTxn\n+     *\n+     * @param tableBeingRead - am i being called from read api\n+     * @param <K>\n+     * @param <V>\n+     * @param <M>\n+     * @param tableBeingRead - only read transactions set this value\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void txBeginAndApply(Table<K, V, M> tableBeingRead) {\n+        int decision = 0x0;\n+        if (tableBeingRead != null) {\n+            decision |= 0x04;\n+        }\n+        if (TransactionalContext.isInTransaction()) {\n+            decision |= 0x02;\n+        }\n+        if (operations.isEmpty()) {\n+            decision |= 0x01;\n+        }\n+        switch (decision) {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NTU1Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495175552", "bodyText": "It is, but this is the only way I found to actually handle all the different cases along with their sub cases without flooding the function with super complex if-else-if-else logic. But I am open to any other ideas or suggestions as long as it handles all the cases.", "author": "hisundar", "createdAt": "2020-09-25T18:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxOTk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyNzUwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496027507", "bodyText": "Not sure if the suggestions are any better, you can decide:\n\nIf if-else logic is turning out to be complicated you can try if statements with return. This will have multiple return points.\nI am not against switch case of this kind in a lot of ways this is neater. So if you want to go with this, why not use enums or numerical constants so that you have very intuitive names for each case match.", "author": "medhavidhawan", "createdAt": "2020-09-28T15:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxOTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDk5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494620992", "bodyText": "Maybe the comment is off or the name is off but should this be in corfu side ?", "author": "medhavidhawan", "createdAt": "2020-09-24T21:28:38Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOStoreBase.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.CorfuStoreMetadata;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * UFOStore is a thin layer over CorfuStore that provides certain metadata management", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NjA2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495176068", "bodyText": "this is the only way we can write tests in Corfu to catch regressions that would impact verticals.\nIt is code duplication across repos but the ability to catch regressions in my opinion outweighs the duplication.", "author": "hisundar", "createdAt": "2020-09-25T18:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNDExOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495724119", "bodyText": "ok Can you take the name UFO out. Just give it generic corfu names.", "author": "medhavidhawan", "createdAt": "2020-09-28T06:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjYwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494622603", "bodyText": "why is this here ? should this not be in nsx.", "author": "medhavidhawan", "createdAt": "2020-09-24T21:32:11Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOTxnBase.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Thin shim layer around CorfuStore's TxnContext for providing metadata management\n+ * capabilities.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+class UFOTxnBase implements AutoCloseable {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NjI1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495176255", "bodyText": "if Corfu API changes we want to have test that catch and fail it right away.", "author": "hisundar", "createdAt": "2020-09-25T18:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMjYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyOTkyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494629924", "bodyText": "hopefully throw inside a lambda works as per expectations. Please check and maybe unit test.", "author": "medhavidhawan", "createdAt": "2020-09-24T21:48:43Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,517 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private enum TxnType {\n+        writeOnly,\n+        readOnly,\n+        writeAndReads,\n+    }\n+    private TxnType txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        this.txnType = TxnType.writeOnly;\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        tablesInTxn.add(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NjQ2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495176465", "bodyText": "we have tests to catch staleRevision exception in UfoStoreTest.java", "author": "hisundar", "createdAt": "2020-09-25T18:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyOTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NDI2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494674263", "bodyText": "NIT: Add space after this line.", "author": "WenbinZhu", "createdAt": "2020-09-25T00:01:45Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOTxnBase.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Thin shim layer around CorfuStore's TxnContext for providing metadata management\n+ * capabilities.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+class UFOTxnBase implements AutoCloseable {\n+    /**\n+     * Internal CorfuStore's txnContext\n+     */\n+    private TxnContext txnContext;\n+\n+    public UFOTxnBase(TxnContext txnContext) {\n+        this.txnContext = txnContext;\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     * There are several overloaded flavors of put to support optional fields like\n+     * metadata, tableNames and the force set of metadata\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(table, key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(table, key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, forceSetMetadata);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param forceSetMetadata if specified, metadata will not be validated, just set\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+\n+        if (forceSetMetadata || metadata == null) {\n+            this.txnContext = txnContext.put(table, key, value, null);\n+            return this;\n+        }\n+\n+        this.txnContext = txnContext.merge(table, key,\n+                this::fixUpMetadata, new CorfuRecord<>(value, metadata));\n+        return this;\n+    }\n+\n+    /**\n+     * Core logic for handling metadata modifications on mutations", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NjU0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495176545", "bodyText": "done. thanks", "author": "hisundar", "createdAt": "2020-09-25T18:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NDU1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494674556", "bodyText": "Need to format the code, the indent is somehow mis-aligned", "author": "WenbinZhu", "createdAt": "2020-09-25T00:02:51Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOTxnBase.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Thin shim layer around CorfuStore's TxnContext for providing metadata management\n+ * capabilities.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+class UFOTxnBase implements AutoCloseable {\n+    /**\n+     * Internal CorfuStore's txnContext\n+     */\n+    private TxnContext txnContext;\n+\n+    public UFOTxnBase(TxnContext txnContext) {\n+        this.txnContext = txnContext;\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     * There are several overloaded flavors of put to support optional fields like\n+     * metadata, tableNames and the force set of metadata\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(table, key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(table, key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, forceSetMetadata);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param forceSetMetadata if specified, metadata will not be validated, just set\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+\n+        if (forceSetMetadata || metadata == null) {\n+            this.txnContext = txnContext.put(table, key, value, null);\n+            return this;\n+        }\n+\n+        this.txnContext = txnContext.merge(table, key,\n+                this::fixUpMetadata, new CorfuRecord<>(value, metadata));\n+        return this;\n+    }\n+\n+    /**\n+     * Core logic for handling metadata modifications on mutations\n+     * @param oldRecord - The previous fetched record that exists in the table.\n+     * @param deltaUpdate - New record that will be inserted/updated.\n+     * @param <K> - type of the key\n+     * @param <V> - type of the value or payload\n+     * @param <M> - type of the metadata\n+     * @return the merged record that will be inserted into the table.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    CorfuRecord<V, M> fixUpMetadata(CorfuRecord<V, M> oldRecord, CorfuRecord<V, M> deltaUpdate) {\n+        M deltaMetadata = deltaUpdate.getMetadata();\n+            final Message.Builder builder = deltaMetadata.toBuilder();\n+            long currentTime = System.currentTimeMillis();", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3Njk1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495176958", "bodyText": "fixed.", "author": "hisundar", "createdAt": "2020-09-25T19:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTE5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494675197", "bodyText": "Looks like revision == 0 means uninitialized (because on line 147 givenRevision == 0 means not set), but when creating the record for the first time (oldRecord == null), why do we set it to 0? Should it be 1?", "author": "WenbinZhu", "createdAt": "2020-09-25T00:05:14Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOTxnBase.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Thin shim layer around CorfuStore's TxnContext for providing metadata management\n+ * capabilities.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+class UFOTxnBase implements AutoCloseable {\n+    /**\n+     * Internal CorfuStore's txnContext\n+     */\n+    private TxnContext txnContext;\n+\n+    public UFOTxnBase(TxnContext txnContext) {\n+        this.txnContext = txnContext;\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     * There are several overloaded flavors of put to support optional fields like\n+     * metadata, tableNames and the force set of metadata\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(table, key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(table, key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, forceSetMetadata);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param forceSetMetadata if specified, metadata will not be validated, just set\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+\n+        if (forceSetMetadata || metadata == null) {\n+            this.txnContext = txnContext.put(table, key, value, null);\n+            return this;\n+        }\n+\n+        this.txnContext = txnContext.merge(table, key,\n+                this::fixUpMetadata, new CorfuRecord<>(value, metadata));\n+        return this;\n+    }\n+\n+    /**\n+     * Core logic for handling metadata modifications on mutations\n+     * @param oldRecord - The previous fetched record that exists in the table.\n+     * @param deltaUpdate - New record that will be inserted/updated.\n+     * @param <K> - type of the key\n+     * @param <V> - type of the value or payload\n+     * @param <M> - type of the metadata\n+     * @return the merged record that will be inserted into the table.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    CorfuRecord<V, M> fixUpMetadata(CorfuRecord<V, M> oldRecord, CorfuRecord<V, M> deltaUpdate) {\n+        M deltaMetadata = deltaUpdate.getMetadata();\n+            final Message.Builder builder = deltaMetadata.toBuilder();\n+            long currentTime = System.currentTimeMillis();\n+            for (Descriptors.FieldDescriptor fieldDescriptor : deltaMetadata.getDescriptorForType().getFields()) {\n+                switch (fieldDescriptor.getName()) {\n+                    case \"revision\":\n+                        if (oldRecord == null || oldRecord.getMetadata() == null) {\n+                            builder.setField(fieldDescriptor, 0L);\n+                        } else {\n+                            Long prevRevision = (Long) oldRecord.getMetadata().getField(fieldDescriptor);\n+                            Long givenRevision = (Long)deltaMetadata.getField(fieldDescriptor);\n+                            if ((givenRevision > 0 && // Validate revision only if set\n+                                    prevRevision.longValue() == givenRevision.longValue())\n+                            || givenRevision == 0) { // Do not validate revision if field isn't set\n+                                builder.setField(fieldDescriptor, prevRevision + 1);\n+                            } else {\n+                                throw new StaleRevisionUpdateException(prevRevision, givenRevision);\n+                            }", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NzE0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495177142", "bodyText": "I realized but there is a bug that revision must start with 0!", "author": "hisundar", "createdAt": "2020-09-25T19:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NzM1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r494677357", "bodyText": "This fieldDescriptor is from deltaMetadata in the for loop, how could deltaMetadata.hasField(fieldDescriptor) be false? I think we need to loop over oldRecord's fieldDescriptor file descriptor as well for merge, right?", "author": "WenbinZhu", "createdAt": "2020-09-25T00:12:40Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/UFOTxnBase.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.StaleRevisionUpdateException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Thin shim layer around CorfuStore's TxnContext for providing metadata management\n+ * capabilities.\n+ *\n+ * Created by hisundar on 2020-09-16\n+ */\n+@Slf4j\n+class UFOTxnBase implements AutoCloseable {\n+    /**\n+     * Internal CorfuStore's txnContext\n+     */\n+    private TxnContext txnContext;\n+\n+    public UFOTxnBase(TxnContext txnContext) {\n+        this.txnContext = txnContext;\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     * There are several overloaded flavors of put to support optional fields like\n+     * metadata, tableNames and the force set of metadata\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(table, key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, null, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(table, key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, false);\n+    }\n+\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull String tableName,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+        return putRecord(this.txnContext.getTable(tableName), key, value, metadata, forceSetMetadata);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table    Table object to perform the create/update on.\n+     * @param key      Key of the record.\n+     * @param value    Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param forceSetMetadata if specified, metadata will not be validated, just set\n+     * @param <K>      Type of Key.\n+     * @param <V>      Type of Value.\n+     * @param <M>      Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    UFOTxnBase putRecord(@Nonnull Table<K, V, M> table,\n+                         @Nonnull final K key,\n+                         @Nonnull final V value,\n+                         @Nullable final M metadata,\n+                         boolean forceSetMetadata) {\n+\n+        if (forceSetMetadata || metadata == null) {\n+            this.txnContext = txnContext.put(table, key, value, null);\n+            return this;\n+        }\n+\n+        this.txnContext = txnContext.merge(table, key,\n+                this::fixUpMetadata, new CorfuRecord<>(value, metadata));\n+        return this;\n+    }\n+\n+    /**\n+     * Core logic for handling metadata modifications on mutations\n+     * @param oldRecord - The previous fetched record that exists in the table.\n+     * @param deltaUpdate - New record that will be inserted/updated.\n+     * @param <K> - type of the key\n+     * @param <V> - type of the value or payload\n+     * @param <M> - type of the metadata\n+     * @return the merged record that will be inserted into the table.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    CorfuRecord<V, M> fixUpMetadata(CorfuRecord<V, M> oldRecord, CorfuRecord<V, M> deltaUpdate) {\n+        M deltaMetadata = deltaUpdate.getMetadata();\n+            final Message.Builder builder = deltaMetadata.toBuilder();\n+            long currentTime = System.currentTimeMillis();\n+            for (Descriptors.FieldDescriptor fieldDescriptor : deltaMetadata.getDescriptorForType().getFields()) {\n+                switch (fieldDescriptor.getName()) {\n+                    case \"revision\":\n+                        if (oldRecord == null || oldRecord.getMetadata() == null) {\n+                            builder.setField(fieldDescriptor, 0L);\n+                        } else {\n+                            Long prevRevision = (Long) oldRecord.getMetadata().getField(fieldDescriptor);\n+                            Long givenRevision = (Long)deltaMetadata.getField(fieldDescriptor);\n+                            if ((givenRevision > 0 && // Validate revision only if set\n+                                    prevRevision.longValue() == givenRevision.longValue())\n+                            || givenRevision == 0) { // Do not validate revision if field isn't set\n+                                builder.setField(fieldDescriptor, prevRevision + 1);\n+                            } else {\n+                                throw new StaleRevisionUpdateException(prevRevision, givenRevision);\n+                            }\n+                        }\n+                        break;\n+                    case \"create_time\":\n+                        if (oldRecord == null) {\n+                            builder.setField(fieldDescriptor, currentTime);\n+                        }\n+                        break;\n+                    case \"last_modified_time\":\n+                        builder.setField(fieldDescriptor, currentTime);\n+                        break;\n+                    default: // By default just merge any field not explicitly set with prev value\n+                        if (oldRecord != null\n+                                && oldRecord.getMetadata() != null\n+                                && oldRecord.getMetadata().hasField(fieldDescriptor)\n+                                && !deltaMetadata.hasField(fieldDescriptor)) {", "originalCommit": "dfb56fcf703b677359f9af6a17556625987b8fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3NzQ0MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r495177440", "bodyText": "hasField() will fire only if it has been set, different from whether it has the descriptor right?", "author": "hisundar", "createdAt": "2020-09-25T19:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NzM1Nw=="}], "type": "inlineReview"}, {"oid": "9c83ac71d61de78577f0e17e62e7061ea75e876b", "url": "https://github.com/CorfuDB/CorfuDB/commit/9c83ac71d61de78577f0e17e62e7061ea75e876b", "message": "Make TxnContext AutoCloseable", "committedDate": "2020-09-25T19:03:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwNzQ4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496307480", "bodyText": "Touch seems to be a read & write operation, so the txnType needs to be READ_WRITE?", "author": "WenbinZhu", "createdAt": "2020-09-29T00:29:36Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,431 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,", "originalCommit": "aa95a819deb282f300d9adcd9214d88097bed83f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDA5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496944099", "bodyText": "no, touch is entirely encapsulated within the lambda so we treat it as a write-only operation.", "author": "hisundar", "createdAt": "2020-09-29T18:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwNzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwODQwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496308408", "bodyText": "Why is this validation only for write operations? Should this also be done for reads?", "author": "WenbinZhu", "createdAt": "2020-09-29T00:33:13Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,431 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }", "originalCommit": "aa95a819deb282f300d9adcd9214d88097bed83f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDM2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496944368", "bodyText": "reads can query any namespace - we want to retain this behavior to not break any existing use cases.", "author": "hisundar", "createdAt": "2020-09-29T18:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwODQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTU1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496959553", "bodyText": "Initially reads can query an namespace because reads are outside of txnContext,  but now reads are part of txnContext. Letting reads to query any namespace,  but writes to query only one namespace seems a bit weird...", "author": "WenbinZhu", "createdAt": "2020-09-29T18:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwOTc1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496309755", "bodyText": "Can we add a sanity check in commit() that checks if we are still inside the transcation context to prevent the case that commit is called twice or it's called outside of try finally block?", "author": "WenbinZhu", "createdAt": "2020-09-29T00:38:16Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,431 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {", "originalCommit": "aa95a819deb282f300d9adcd9214d88097bed83f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDYxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496944611", "bodyText": "done.", "author": "hisundar", "createdAt": "2020-09-29T18:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwOTc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDY1Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496310653", "bodyText": "The order of these statements seems incorrect, tablesInTxn is  cleared on line 406, but then it's iterated on line 409", "author": "WenbinZhu", "createdAt": "2020-09-29T00:41:55Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,431 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        operations.forEach(Runnable::run);\n+        long commitAddress = Address.NON_ADDRESS;\n+        try {\n+            commitAddress = this.objectsView.TXEnd();\n+        } catch (Exception ex) {\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+            tablesInTxn.clear();\n+            throw ex;\n+        }\n+        long timeElapsed = System.nanoTime() - txnStartTime;\n+        switch (txnType) {\n+            case READ_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+                break;\n+            case WRITE_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().writeOnlyTxnTimes.set(timeElapsed));\n+                break;\n+            case READ_WRITE:\n+                tablesInTxn.forEach(t -> t.getMetrics().readWriteTxnTimes.set(timeElapsed));\n+                break;\n+            default:\n+                log.error(\"UNKNOWN TxnType!!\");\n+                break;\n+        }\n+        tablesInTxn.clear();\n+        operations.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        tablesInTxn.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            this.objectsView.TXAbort();\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+        }", "originalCommit": "aa95a819deb282f300d9adcd9214d88097bed83f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDcyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496944724", "bodyText": "done", "author": "hisundar", "createdAt": "2020-09-29T18:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMjY0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496312649", "bodyText": "I think if you want to support the case that user can end read-only transaction without calling commit, then it's better to use this.objectsView.TxEnd() instead of this.objectsView.TXAbort(), because maybe Corfu internally bookkeeps some metrics or having logs, if using TXAbort, that will confuse the corfu logging and metrics. I personally think we should not support this, because it seems error prone: imagining the txn was intially read-only and user didn't write commit(), later they modifiied the transaction and added some write logic, but forget to add commit(), then since we only log a warning here, it will silently fail. I think we should encourage standarizing the transaction commit pattern to avoid confusion and possible mistakes.", "author": "WenbinZhu", "createdAt": "2020-09-29T00:50:00Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,431 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().numPuts.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().numMerges.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().numTouches.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().numClears.incrementAndGet();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().numDeletes.incrementAndGet();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().numGets.incrementAndGet();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numGetByIndex.incrementAndGet();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numCounts.incrementAndGet();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numKeySets.incrementAndGet();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().numScans.incrementAndGet();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        operations.forEach(Runnable::run);\n+        long commitAddress = Address.NON_ADDRESS;\n+        try {\n+            commitAddress = this.objectsView.TXEnd();\n+        } catch (Exception ex) {\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+            tablesInTxn.clear();\n+            throw ex;\n+        }\n+        long timeElapsed = System.nanoTime() - txnStartTime;\n+        switch (txnType) {\n+            case READ_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+                break;\n+            case WRITE_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().writeOnlyTxnTimes.set(timeElapsed));\n+                break;\n+            case READ_WRITE:\n+                tablesInTxn.forEach(t -> t.getMetrics().readWriteTxnTimes.set(timeElapsed));\n+                break;\n+            default:\n+                log.error(\"UNKNOWN TxnType!!\");\n+                break;\n+        }\n+        tablesInTxn.clear();\n+        operations.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        tablesInTxn.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            this.objectsView.TXAbort();\n+            tablesInTxn.forEach(t -> t.getMetrics().numTxnAborts.incrementAndGet());\n+        }\n+    }\n+\n+    /**\n+     * Cleanup the transaction resources.\n+     * If invoked on transaction with just queries, record the time taken.\n+     */\n+    @Override\n+    public void close() {\n+        if (TransactionalContext.isInTransaction()) {\n+            if (txnType == READ_ONLY) {\n+                long timeElapsed = System.nanoTime() - txnStartTime;\n+                tablesInTxn.forEach(t -> t.getMetrics().readOnlyTxnTimes.set(timeElapsed));\n+            } else {\n+                log.warn(\"close()ing a transaction with mutations without calling commit()!\");\n+            }\n+            this.objectsView.TXAbort();", "originalCommit": "aa95a819deb282f300d9adcd9214d88097bed83f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NTM3MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496945370", "bodyText": "Yes, but Autcoclosable in query was an ask. will add TxEnd() but that's about the best we can do I guess.", "author": "hisundar", "createdAt": "2020-09-29T18:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMjY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1NzM1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r496957351", "bodyText": "I think we don't need to satisfy every ask from the applications, for this one, they just want a convenience, but that convenience is breaking our commit pattern and can lead to more problems, I feel it's not worth to do that...", "author": "WenbinZhu", "createdAt": "2020-09-29T18:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMjY0OQ=="}], "type": "inlineReview"}, {"oid": "325cb6e0fb2fbec241a3d1868f83985dc7657356", "url": "https://github.com/CorfuDB/CorfuDB/commit/325cb6e0fb2fbec241a3d1868f83985dc7657356", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\n+Sample SHIM layer for metadata management with tests\nMark existing api as deprecated.\nCapture TxnContext level api metrics like\nnumber of times an api is invoked.\nThe time transactions take.\nStore it in the Table.\nHave Json methods to return Json formatted\nadd touch api\nMake TxnContext AutoCloseable\nStart transaction at start of TxnContext", "committedDate": "2020-09-30T20:51:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ0NzIzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498447239", "bodyText": "this will be already checked in txBeginInternal in the constructor.  Is it required again?", "author": "pankti-m", "createdAt": "2020-10-01T18:46:15Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,435 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().incNumPuts();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().incNumMerges();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().incNumTouches();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().incNumClears();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().incNumDeletes();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().incNumGets();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumGetByIndexes();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumCounts();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumKeySets();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumScans();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        if (!TransactionalContext.isInTransaction()) {", "originalCommit": "ca0cee1ccdd210b7487c50425e40a86f98a81c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTIzOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498551239", "bodyText": "its just a precaution against misuse. if someone calls commit() twice", "author": "hisundar", "createdAt": "2020-10-01T22:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ0NzIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MTYwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498451601", "bodyText": "should objectsView.abort() be called?", "author": "pankti-m", "createdAt": "2020-10-01T18:54:47Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,435 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().incNumPuts();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().incNumMerges();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().incNumTouches();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().incNumClears();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().incNumDeletes();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().incNumGets();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumGetByIndexes();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumCounts();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumKeySets();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumScans();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        if (!TransactionalContext.isInTransaction()) {\n+            throw new IllegalStateException(\"commit() called without a transaction!\");\n+        }\n+        operations.forEach(Runnable::run);\n+        long commitAddress;\n+        try {\n+            commitAddress = this.objectsView.TXEnd();\n+        } catch (Exception ex) {\n+            tablesInTxn.forEach(t -> t.getMetrics().incNumTxnAborts());", "originalCommit": "ca0cee1ccdd210b7487c50425e40a86f98a81c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MjcxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498552714", "bodyText": "no, that's why we have close() which should call abort() incase TXEnd() fails to do so (which it shouldn't)", "author": "hisundar", "createdAt": "2020-10-01T23:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MjMwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498452302", "bodyText": "how can we say there are mutations?", "author": "pankti-m", "createdAt": "2020-10-01T18:56:03Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,435 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().incNumPuts();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().incNumMerges();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().incNumTouches();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().incNumClears();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().incNumDeletes();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().incNumGets();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumGetByIndexes();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumCounts();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumKeySets();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumScans();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.error(\"Cannot start new transaction in this thread without ending previous one\");\n+            throw new TransactionAlreadyStartedException(TransactionalContext.getRootContext().toString());\n+        }\n+        this.txnStartTime = System.nanoTime();\n+        Transaction.TransactionBuilder transactionBuilder = this.objectsView\n+                .TXBuild()\n+                .type(TransactionType.WRITE_AFTER_WRITE);\n+        if (isolationLevel.getTimestamp() != Token.UNINITIALIZED) {\n+            transactionBuilder.snapshot(isolationLevel.getTimestamp());\n+        }\n+        transactionBuilder.build().begin();\n+    }\n+\n+    /**\n+     * Commit the transaction.\n+     * For a transaction that only has write operations, this method will start and end\n+     * a corfu transaction keeping the \"critical\" section small while batching up all updates.\n+     * For a transaction that has reads, this will end the transaction.\n+     * The commit returns successfully if the write transaction was committed.\n+     * Otherwise this throws a TransactionAbortedException with a cause.\n+     * The cause and the caller's intent of the transaction can determine if this aborted\n+     * Transaction can be retried.\n+     * @return - address at which the commit of this transaction occurred.\n+     */\n+    public long commit() {\n+        if (!TransactionalContext.isInTransaction()) {\n+            throw new IllegalStateException(\"commit() called without a transaction!\");\n+        }\n+        operations.forEach(Runnable::run);\n+        long commitAddress;\n+        try {\n+            commitAddress = this.objectsView.TXEnd();\n+        } catch (Exception ex) {\n+            tablesInTxn.forEach(t -> t.getMetrics().incNumTxnAborts());\n+            tablesInTxn.clear();\n+            throw ex;\n+        }\n+        long timeElapsed = System.nanoTime() - txnStartTime;\n+        switch (txnType) {\n+            case READ_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().setReadOnlyTxnTimes(timeElapsed));\n+                break;\n+            case WRITE_ONLY:\n+                tablesInTxn.forEach(t -> t.getMetrics().setWriteOnlyTxnTimes(timeElapsed));\n+                break;\n+            case READ_WRITE:\n+                tablesInTxn.forEach(t -> t.getMetrics().setReadWriteTxnTimes(timeElapsed));\n+                break;\n+            default:\n+                log.error(\"UNKNOWN TxnType!!\");\n+                break;\n+        }\n+        tablesInTxn.clear();\n+        operations.clear();\n+        return commitAddress;\n+    }\n+\n+    /**\n+     * Explicitly abort a transaction in case of an external failure\n+     */\n+    public void txAbort() {\n+        operations.clear();\n+        if (TransactionalContext.isInTransaction()) {\n+            this.objectsView.TXAbort();\n+            tablesInTxn.forEach(t -> t.getMetrics().incNumTxnAborts());\n+        }\n+        tablesInTxn.clear();\n+    }\n+\n+    /**\n+     * Cleanup the transaction resources.\n+     * If invoked on transaction with just queries, record the time taken.\n+     */\n+    @Override\n+    public void close() {\n+        if (TransactionalContext.isInTransaction()) {\n+            log.warn(\"close()ing a {} transaction with mutations without calling commit()!\", txnType);", "originalCommit": "ca0cee1ccdd210b7487c50425e40a86f98a81c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTQ3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498551479", "bodyText": "thanks fixed the log message.", "author": "hisundar", "createdAt": "2020-10-01T22:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MzE4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498453180", "bodyText": "do we need this validation for tables being read as well?", "author": "pankti-m", "createdAt": "2020-10-01T18:57:51Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,435 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {", "originalCommit": "ca0cee1ccdd210b7487c50425e40a86f98a81c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTg2Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498551862", "bodyText": "No, they say. we checked again right", "author": "hisundar", "createdAt": "2020-10-01T22:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1MzE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1NjQxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498456413", "bodyText": "is it better to ignore and not start a transaction instead of throwing an exception?  there can be cases where the same method in client code needs to start a transaction in some cases but is being called from a parent transaction in others", "author": "pankti-m", "createdAt": "2020-10-01T19:04:25Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/TxnContext.java", "diffHunk": "@@ -0,0 +1,435 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.TransactionAlreadyStartedException;\n+import org.corfudb.runtime.object.transactions.Transaction;\n+import org.corfudb.runtime.object.transactions.TransactionType;\n+import org.corfudb.runtime.object.transactions.TransactionalContext;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.TableRegistry;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+/**\n+ * TxnContext is the access layer for binding all the CorfuStore CRUD operations.\n+ * It can help reduce the footprint of a CorfuStore transaction by only having writes in it.\n+ * All mutations/writes are aggregated and applied at once a the time of commit() call\n+ * where a real corfu transaction is started.\n+ *\n+ * Created by hisundar, @wenbinzhu, @pankti-m on 2020-09-15\n+ */\n+@Slf4j\n+public class TxnContext implements AutoCloseable {\n+\n+    private final ObjectsView objectsView;\n+    private final TableRegistry tableRegistry;\n+    private final String namespace;\n+    private final IsolationLevel isolationLevel;\n+    private final List<Runnable> operations;\n+    private final Set<Table> tablesInTxn;\n+    private long txnStartTime = 0L;\n+    private static final byte READ_ONLY  = 0x01;\n+    private static final byte WRITE_ONLY = 0x02;\n+    private static final byte READ_WRITE = 0x03;\n+    private byte txnType;\n+\n+    /**\n+     * Creates a new TxnContext.\n+     *\n+     * @param objectsView   ObjectsView from the Corfu client.\n+     * @param tableRegistry Table Registry.\n+     * @param namespace     Namespace boundary defined for the transaction.\n+     * @param isolationLevel How should this transaction be applied/evaluated.\n+     */\n+    @Nonnull\n+    TxnContext(@Nonnull final ObjectsView objectsView,\n+               @Nonnull final TableRegistry tableRegistry,\n+               @Nonnull final String namespace,\n+               @Nonnull final IsolationLevel isolationLevel) {\n+        this.objectsView = objectsView;\n+        this.tableRegistry = tableRegistry;\n+        this.namespace = namespace;\n+        this.isolationLevel = isolationLevel;\n+        this.operations = new ArrayList<>();\n+        this.tablesInTxn = new HashSet<>();\n+        txBeginInternal(); // May throw exception if transaction was already started\n+    }\n+\n+    public  <K extends Message, V extends Message, M extends Message>\n+    Table<K, V, M> getTable(@Nonnull final String tableName) {\n+        return this.tableRegistry.getTable(this.namespace, tableName);\n+    }\n+\n+    /**\n+     *************************** WRITE APIs *****************************************\n+     */\n+\n+    /**\n+     * All write api must be validate to ensure that the table belongs to the namespace.\n+     *\n+     * @param table - table being written to\n+     * @param <K> -type of the key\n+     * @param <V> - type of the payload/value\n+     * @param <M> - type of the metadata\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void validateTableWrittenIsInNamespace(@Nonnull Table<K, V, M> table) {\n+        if (!table.getNamespace().equals(namespace)) {\n+            throw new IllegalArgumentException(\"TxnContext can't apply table from namespace \"\n+                    + table.getNamespace() + \" to transaction on namespace \" + namespace);\n+        }\n+        txnType |= WRITE_ONLY;\n+        tablesInTxn.add(table);\n+    }\n+\n+    /**\n+     * put the value on the specified key create record if it does not exist.\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record.\n+     * @param value Value or payload of the record.\n+     * @param metadata Metadata associated with the record.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext put(@Nonnull Table<K, V, M> table,\n+                   @Nonnull final K key,\n+                   @Nonnull final V value,\n+                   @Nullable final M metadata) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.put(key, value, metadata);\n+            table.getMetrics().incNumPuts();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Merges the delta value with the old value by applying a caller specified BiFunction and writes\n+     * the final value.\n+     *\n+     * @param table Table object to perform the merge operation on.\n+     * @param key            Key\n+     * @param mergeOperator  Function to apply to get the new value\n+     * @param recordDelta    Argument to pass to the mutation function\n+     * @param <K>            Type of Key.\n+     * @param <V>            Type of Value.\n+     * @param <M>            Type of Metadata.\n+     * @return TxnContext instance\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext merge(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key,\n+                     @Nonnull BiFunction<CorfuRecord<V, M>, CorfuRecord<V,M>, CorfuRecord<V,M>> mergeOperator,\n+                     @Nonnull final CorfuRecord<V,M> recordDelta) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V,M> oldRecord = table.get(key);\n+            CorfuRecord<V, M> mergedRecord;\n+            try {\n+                mergedRecord = mergeOperator.apply(oldRecord, recordDelta);\n+            } catch (Exception ex) {\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort merge: {}\", table.getFullyQualifiedTableName(), ex);\n+                throw ex;\n+            }\n+            table.put(key, mergedRecord.getPayload(), mergedRecord.getMetadata());\n+            table.getMetrics().incNumMerges();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * touch() is a call to create a conflict on a read in a write-only transaction\n+     *\n+     * @param table Table object to perform the create/update on.\n+     * @param key   Key of the record to touch.\n+     * @param <K>   Type of Key.\n+     * @param <V>   Type of Value.\n+     * @param <M>   Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext touch(@Nonnull Table<K, V, M> table,\n+                     @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            CorfuRecord<V, M> touchedObject = table.get(key);\n+            if (touchedObject != null) {\n+                table.put(key, touchedObject.getPayload(), touchedObject.getMetadata());\n+            } else { // TODO: add support for touch()ing an object that hasn't been created.\n+                txAbort(); // explicitly abort this transaction and then throw the abort manually\n+                log.error(\"TX Abort touch on non-existing object: in \"+ table.getFullyQualifiedTableName());\n+                throw new UnsupportedOperationException(\n+                        \"Attempt to touch() a non-existing object in \"\n+                                + table.getFullyQualifiedTableName());\n+            }\n+            table.getMetrics().incNumTouches();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Apply a Corfu SMREntry directly to a stream. This can be used for replaying the mutations\n+     * directly into the underlying stream bypassing the object layer entirely.\n+     * @param streamId - UUID of the stream on which the logUpdate is being added to.\n+     * @param updateEntry - the actual State Machine Replicated entry.\n+     * @return\n+     */\n+    public TxnContext logUpdate(UUID streamId, SMREntry updateEntry) {\n+        operations.add(() -> {\n+            TransactionalContext.getCurrentContext().logUpdate(streamId, updateEntry);\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Clears the entire table.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext clear(@Nonnull Table<K, V, M> table) {\n+        validateTableWrittenIsInNamespace(table);\n+        operations.add(() -> {\n+            table.clearAll();\n+            table.getMetrics().incNumClears();\n+        });\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the specified key.\n+     *\n+     * @param table Table object to perform the delete on.\n+     * @param key       Key of the record to be deleted.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <M>       Type of Metadata.\n+     * @return TxnContext instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    TxnContext delete(@Nonnull Table<K, V, M> table,\n+                      @Nonnull final K key) {\n+        validateTableWrittenIsInNamespace(table);\n+        table.getMetrics().incNumDeletes();\n+        operations.add(() -> table.deleteRecord(key));\n+        return this;\n+    }\n+\n+    /**\n+     *************************** READ API *****************************************\n+     */\n+\n+    /**\n+     * get the full record from the table given a key.\n+     * If this is invoked on a Read-Your-Writes transaction, it will result in starting a corfu transaction\n+     * and applying all the updates done so far.\n+     *\n+     * @param table Table object to retrieve the record from\n+     * @param key   Key of the record.\n+     * @return CorfuStoreEntry<Key, Value, Metadata> instance.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message>\n+    CorfuStoreEntry<K, V, M> getRecord(@Nonnull Table<K, V, M> table,\n+                              @Nonnull final K key) {\n+        applyWritesForReadOnTable(table);\n+        CorfuRecord<V, M> record = table.get(key);\n+        table.getMetrics().incNumGets();\n+        return new CorfuStoreEntry<K, V, M>(key, record.getPayload(), record.getMetadata());\n+    }\n+\n+    /**\n+     * Query by a secondary index.\n+     *\n+     * @param table Table object.\n+     * @param indexName Index name. In case of protobuf-defined secondary index it is the field name.\n+     * @param indexKey  Key to query.\n+     * @param <K>       Type of Key.\n+     * @param <V>       Type of Value.\n+     * @param <I>       Type of index/secondary key.\n+     * @return Result of the query.\n+     */\n+    @Nonnull\n+    public <K extends Message, V extends Message, M extends Message, I extends Comparable<I>>\n+    List<CorfuStoreEntry<K, V, M>> getByIndex(@Nonnull Table<K, V, M> table,\n+                                              @Nonnull final String indexName,\n+                                              @Nonnull final I indexKey) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumGetByIndexes();\n+        return table.getByIndex(indexName, indexKey);\n+    }\n+\n+    /**\n+     * Gets the count of records in the table at a particular timestamp.\n+     *\n+     * @param table - the table whose count is requested.\n+     * @return Count of records.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    int count(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumCounts();\n+        return table.count();\n+    }\n+\n+    /**\n+     * Gets all the keys of a table.\n+     *\n+     * @param table - the table whose keys are requested.\n+     * @return keyset of the table\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    Set<K> keySet(@Nonnull final Table<K, V, M> table) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumKeySets();\n+        return table.keySet();\n+    }\n+\n+    /**\n+     * Scan and filter by entry.\n+     *\n+     * @param table Table< K, V, M > object on which the scan must be done.\n+     * @param entryPredicate Predicate to filter the entries.\n+     * @return Collection of filtered entries.\n+     */\n+    public <K extends Message, V extends Message, M extends Message>\n+    List<CorfuStoreEntry<K, V, M>> executeQuery(@Nonnull final Table<K, V, M> table,\n+                                                @Nonnull final Predicate<CorfuStoreEntry<K, V, M>> entryPredicate) {\n+        applyWritesForReadOnTable(table);\n+        table.getMetrics().incNumScans();\n+        return table.scanAndFilterByEntry(entryPredicate);\n+    }\n+\n+    /**\n+     * Apply all pending writes (if any) to serve read queries.\n+     */\n+    private <K extends Message, V extends Message, M extends Message>\n+    void applyWritesForReadOnTable(Table<K, V, M> tableBeingRead) {\n+        tablesInTxn.add(tableBeingRead);\n+        txnType |= READ_ONLY;\n+        if (!operations.isEmpty()) {\n+            operations.forEach(Runnable::run);\n+            operations.clear();\n+        }\n+    }\n+\n+    /**\n+     * Start the actual corfu transaction. Ensure there isn't one already in the same thread.\n+     */\n+    private void txBeginInternal() {\n+        if (TransactionalContext.isInTransaction()) {", "originalCommit": "ca0cee1ccdd210b7487c50425e40a86f98a81c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MjI2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r498552265", "bodyText": "then there is no way to validate if this is by intent or a bug. we want to only have one way of doing things that is to pass the TxnContext around to all those who need to share the same atomic operation.", "author": "hisundar", "createdAt": "2020-10-01T23:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1NjQxMw=="}], "type": "inlineReview"}, {"oid": "23e7afd471efbf1a3440a87e9181cdf5c42b2a65", "url": "https://github.com/CorfuDB/CorfuDB/commit/23e7afd471efbf1a3440a87e9181cdf5c42b2a65", "message": "Add DropWizard Metrics integration support for CorfuStore", "committedDate": "2020-10-01T20:07:29Z", "type": "forcePushed"}, {"oid": "43e4c1f43c121f883e12606707caadec07ac38b1", "url": "https://github.com/CorfuDB/CorfuDB/commit/43e4c1f43c121f883e12606707caadec07ac38b1", "message": "Add DropWizard Metrics integration support for CorfuStore", "committedDate": "2020-10-01T23:04:55Z", "type": "forcePushed"}, {"oid": "12a390333605eda868fce55628460ac1858f4d3f", "url": "https://github.com/CorfuDB/CorfuDB/commit/12a390333605eda868fce55628460ac1858f4d3f", "message": "Add DropWizard Metrics integration support for CorfuStore\n\nUse SharedMetricRegistries if available", "committedDate": "2020-10-01T23:34:33Z", "type": "forcePushed"}, {"oid": "b8e2c68bad69160071581912b95819afd0e18968", "url": "https://github.com/CorfuDB/CorfuDB/commit/b8e2c68bad69160071581912b95819afd0e18968", "message": "Add DropWizard Metrics integration support for CorfuStore\n\nUse SharedMetricRegistries if available", "committedDate": "2020-10-05T22:49:11Z", "type": "forcePushed"}, {"oid": "35e9ec6ca91059cae190d512256b5e13c1033f98", "url": "https://github.com/CorfuDB/CorfuDB/commit/35e9ec6ca91059cae190d512256b5e13c1033f98", "message": "CorfuStore: Adding proto table options for features", "committedDate": "2020-10-09T17:16:20Z", "type": "forcePushed"}, {"oid": "c6a91ec167f166c5ce1f7a81732c4ed1cc64aafc", "url": "https://github.com/CorfuDB/CorfuDB/commit/c6a91ec167f166c5ce1f7a81732c4ed1cc64aafc", "message": "CorfuStore V2: Read Your Own Writes!\n\nNew TxnContext can do reads and writes!\nIsolationLevel added with SNAPSHOT isolation\nCreate & Update collapsed into one put() to avoid\ndoing read-check-write cycle in write path.\n\n+Sample SHIM layer for metadata management with tests\nMark existing api as deprecated.\nCapture TxnContext level api metrics like\nnumber of times an api is invoked.\nThe time transactions take.\nStore it in the Table.\nHave Json methods to return Json formatted\nadd touch api\nMake TxnContext AutoCloseable\nStart transaction at start of TxnContext", "committedDate": "2020-10-09T23:47:44Z", "type": "commit"}, {"oid": "1e6471cf949400546d5a51ff2f7172a47c9863e5", "url": "https://github.com/CorfuDB/CorfuDB/commit/1e6471cf949400546d5a51ff2f7172a47c9863e5", "message": "Add DropWizard Metrics integration support for CorfuStore\n\nUse SharedMetricRegistries if available", "committedDate": "2020-10-09T23:47:44Z", "type": "commit"}, {"oid": "7342b5459f4e27e24e9ca1175e71223ad4dd098e", "url": "https://github.com/CorfuDB/CorfuDB/commit/7342b5459f4e27e24e9ca1175e71223ad4dd098e", "message": "CorfuStore: Adding proto table options for features", "committedDate": "2020-10-09T23:48:31Z", "type": "commit"}, {"oid": "7342b5459f4e27e24e9ca1175e71223ad4dd098e", "url": "https://github.com/CorfuDB/CorfuDB/commit/7342b5459f4e27e24e9ca1175e71223ad4dd098e", "message": "CorfuStore: Adding proto table options for features", "committedDate": "2020-10-09T23:48:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjY3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r502716676", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-09T23:58:18Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -195,13 +207,28 @@ private void TxEnd() {\n         }\n     }\n \n+    /**\n+     * Update an existing key with the provided value. Create if it does not exist.\n+     *\n+     * @param key      Key.\n+     * @param value    Value.\n+     * @param metadata Metadata.\n+     * @return Previously stored value for the provided key - null if create.\n+     */\n+    CorfuRecord<V, M> put(@Nonnull final K key,", "originalCommit": "7342b5459f4e27e24e9ca1175e71223ad4dd098e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjY4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2766#discussion_r502716680", "bodyText": "Codacy found an issue: Use explicit scoping instead of the default package private level", "author": "corfudb-bot", "createdAt": "2020-10-09T23:58:19Z", "path": "runtime/src/main/java/org/corfudb/runtime/collections/Table.java", "diffHunk": "@@ -214,14 +241,33 @@ private void TxEnd() {\n         }\n     }\n \n+    /**\n+     * Delete a record mapped to the specified key.\n+     *\n+     * @param key Key.\n+     * @return Previously stored Corfu Record.\n+     */\n+    @Nullable\n+    CorfuRecord<V, M> deleteRecord(@Nonnull final K key) {\n+        return corfuTable.remove(key);\n+    }\n+\n+    /**\n+     * Clear All table entries.\n+     */\n+    void clearAll() {", "originalCommit": "7342b5459f4e27e24e9ca1175e71223ad4dd098e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}