{"pr_number": 8640, "pr_title": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs", "pr_createdAt": "2020-07-24T21:55:32Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8640", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0MzMzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r460943333", "bodyText": "Should this exist? I think updateConfigsInEnvironmentByCrn is sufficient and also it doesn't have consequence for things like reusing cluster names.", "author": "jamisonbennett", "createdAt": "2020-07-27T14:44:09Z", "path": "environment-api/src/main/java/com/sequenceiq/environment/api/v1/environment/endpoint/EnvironmentEndpoint.java", "diffHunk": "@@ -205,4 +205,18 @@ SimpleEnvironmentResponses deleteMultipleByCrns(Set<String> crns,\n     @ApiOperation(value = EnvironmentOpDescription.CLI_COMMAND, produces = MediaType.APPLICATION_JSON, notes = ENVIRONMENT_NOTES,\n             nickname = \"getCreateEnvironmentForCli\")\n     Object getCreateEnvironmentForCli(@NotNull @Valid EnvironmentRequest environmentRequest);\n+\n+    @POST\n+    @Path(\"/crn/{crn}/update_config\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = EnvironmentOpDescription.UPDATE_CONFIG_BY_CRN, produces = MediaType.APPLICATION_JSON, notes = ENVIRONMENT_NOTES,\n+        nickname = \"updateConfigsInEnvironmentByCrnV1\")\n+    void updateConfigsInEnvironmentByCrn(@PathParam(\"crn\") String crn);\n+\n+    @POST\n+    @Path(\"/name/{name}/update_config\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = EnvironmentOpDescription.UPDATE_CONFIG_BY_NAME, produces = MediaType.APPLICATION_JSON, notes = ENVIRONMENT_NOTES,", "originalCommit": "06585e009249694c467400932eb19b62d8228140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk3MzgxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r460973812", "bodyText": "Just have it in there to maintain consistency of how Env service functions are defined.   I'm 50/50 on it being there.  The cluster name reuse is limited by tenant anyways.   But in this case since we are removing auth checks and it won't have an x-cdp-actor-crn it might be best to remove it.", "author": "wonderslug", "createdAt": "2020-07-27T15:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0MzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3MjMxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r461172313", "bodyText": "Removed the call", "author": "wonderslug", "createdAt": "2020-07-27T21:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0MzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0NDU5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r460944596", "bodyText": "I don't see this class referenced anywhere.", "author": "jamisonbennett", "createdAt": "2020-07-27T14:45:47Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/event/EnvStackConfigUpdatesFailedEvent.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.environment.environment.flow.config.update.event;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.flow.reactor.api.event.BaseFailedFlowEvent;\n+\n+public class EnvStackConfigUpdatesFailedEvent extends BaseFailedFlowEvent implements Selectable {", "originalCommit": "06585e009249694c467400932eb19b62d8228140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2OTU4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r461169582", "bodyText": "Yeah.  Removed", "author": "wonderslug", "createdAt": "2020-07-27T21:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0NDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAyOTE4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463029181", "bodyText": "Now, this class is referenced but it is never instantiated. So the flow will never trigger a failure action because this type is the only type that is selected by FAILED_ENV_STACK_CONIFG_UPDATES_EVENT. This means that STACK_CONFIG_UPDATES_FAILED_STATE is logically unreachable.\nI think the action code or handler code should have a catch (Exception e) which creates an EnvStackConfigUpdatesFailedEvent and sends that event.", "author": "jamisonbennett", "createdAt": "2020-07-30T14:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0NDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA5NDEwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463094100", "bodyText": "Yeah. made some assumptions we talked about.  Added", "author": "wonderslug", "createdAt": "2020-07-30T15:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0NDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0OTQ5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r460949492", "bodyText": "Is mutableNamesList.retainAll(remaining) needed? It looks like mutableNamesList just goes out of scope and results is a different container based on the continents of mutableNamesList.", "author": "jamisonbennett", "createdAt": "2020-07-27T14:52:11Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {\n+                return AttemptResults.finishWith(null);\n+            }\n+            List<String> remaining = new ArrayList<>();\n+            List<AttemptResult<Void>> results = collectStackUpdateConfigResults(mutableNamesList,\n+                remaining, envId);\n+            mutableNamesList.retainAll(remaining);", "originalCommit": "06585e009249694c467400932eb19b62d8228140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk2OTc0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r460969741", "bodyText": "No, it's not out of scope.  Its definition is outside the lambda.  So it gets maintained.  The function that is returned keeps getting run and referencing the scope with the mutableNamesList since it was defined in that scope.    Lambdas are weird.", "author": "wonderslug", "createdAt": "2020-07-27T15:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0OTQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA5OTY1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r461099659", "bodyText": "Thanks. You are right. I missed that.", "author": "jamisonbennett", "createdAt": "2020-07-27T18:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0OTQ5Mg=="}], "type": "inlineReview"}, {"oid": "d050661c401008cb0e4e853ad9191fdc19be0c96", "url": "https://github.com/hortonworks/cloudbreak/commit/d050661c401008cb0e4e853ad9191fdc19be0c96", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-07-27T21:04:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTg5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462205898", "bodyText": "this is not used", "author": "lacikaaa", "createdAt": "2020-07-29T10:41:00Z", "path": "environment-api/src/main/java/com/sequenceiq/environment/api/doc/environment/EnvironmentOpDescription.java", "diffHunk": "@@ -22,6 +22,8 @@\n     public static final String VERIFY_CREDENTIAL_BY_CRN = \"Verifies the credential used by the given environment.\";\n     public static final String CLI_COMMAND = \"produce cli command input for environment creation\";\n     public static final String GET_CRN_BY_NAME = \"Get the crn of an environment by name.\";\n+    public static final String UPDATE_CONFIG_BY_CRN = \"Update the configuration for all stacks in the Environment by the Environment CRN\";\n+    public static final String UPDATE_CONFIG_BY_NAME = \"Update the configuration for all stacks in the Environment by the Environment name\";", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MzczOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462393738", "bodyText": "Yeap forgot to remove it when I pulled the update by name call.", "author": "wonderslug", "createdAt": "2020-07-29T15:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyOTM1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465829353", "bodyText": "still present but not used", "author": "lacikaaa", "createdAt": "2020-08-05T15:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMzgyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466003823", "bodyText": "well its not now damnit!  :)", "author": "wonderslug", "createdAt": "2020-08-05T21:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNjk4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462206984", "bodyText": "I couldn't find any usage", "author": "lacikaaa", "createdAt": "2020-07-29T10:43:06Z", "path": "environment-api/src/main/java/com/sequenceiq/environment/api/v1/environment/model/request/EnvironmentEditRequest.java", "diffHunk": "@@ -45,6 +45,9 @@\n     @ApiModelProperty(EnvironmentModelDescription.AWS_PARAMETERS)\n     private AwsEnvironmentParameters aws;\n \n+    @ApiModelProperty(EnvironmentModelDescription.UPDATE_STACKS_CONFIG)\n+    private Boolean updateStacksConfig = false;", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzMTQ2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462631462", "bodyText": "Yeah removed. old hanger on", "author": "wonderslug", "createdAt": "2020-07-29T22:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNjk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzMxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462207315", "bodyText": "couldn't find usage", "author": "lacikaaa", "createdAt": "2020-07-29T10:43:52Z", "path": "environment-api/src/main/java/com/sequenceiq/environment/api/v1/environment/model/response/EnvironmentStatus.java", "diffHunk": "@@ -59,7 +59,9 @@\n     START_FREEIPA_STARTED(\"Starting Free IPA\"),\n     START_FREEIPA_FAILED(\"Failed to Start Free IPA\"),\n \n-    FREEIPA_DELETED_ON_PROVIDER_SIDE(\"Free IPA deleted on cloud provider side\");\n+    FREEIPA_DELETED_ON_PROVIDER_SIDE(\"Free IPA deleted on cloud provider side\"),\n+\n+    STACKS_CONFIG_UPDATE_IN_PROGRESS(\"Stack configuration updates in progress\");", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc0MTA2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463741064", "bodyText": "I still don't see this used...", "author": "jamisonbennett", "createdAt": "2020-07-31T17:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1NDU2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464454561", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-08-03T14:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzEzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462213136", "bodyText": "I would use FlowLogDBService#findAllByResourceIdAndFinalizedIsFalseOrderByCreatedDesc here as it would spare some resources:\n\nwon't fetch db again for the environment\nyou could loose the finalized check in the next if\nyou could loose try-catch and use isEmpty instead", "author": "lacikaaa", "createdAt": "2020-07-29T10:56:00Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.PollGroup;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.flow.config.update.config.EnvStackConfigUpdatesFlowConfig;\n+import com.sequenceiq.environment.store.EnvironmentInMemoryStateStore;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.FlowCancelService;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackService.class);\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final FlowCancelService flowCancelService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackService(\n+        StackV4Endpoint stackV4Endpoint,\n+        FlowCancelService flowCancelService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.flowCancelService = flowCancelService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public void triggerConfigUpdateForStack(String stackName) {\n+        try {\n+            stackV4Endpoint.updatePillarConfigurationByName(0L, stackName);\n+        } catch (BadRequestException bre) {\n+            LOGGER.info(String\n+                .format(\"Unable to start config update for stack %s.  Message is %s\", stackName,\n+                    bre.getMessage()));\n+            throw bre;\n+        }\n+    }\n+\n+    public void cancelRunningStackConfigUpdates(Environment environment) {\n+        try {\n+            FlowLog flowLog = flowLogDBService.getLastFlowLogByResourceCrnOrName(environment.getResourceCrn());", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzMTEyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462631127", "bodyText": "I think in this case we want it to fetch from the DB again.  Since it is how we are checking for a running flow across multiple instances of the service, we need to check and not depend on a possible slow cache.", "author": "wonderslug", "createdAt": "2020-07-29T22:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNjczNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463536735", "bodyText": "you misinterpreted what I said. If you check the implementation, getLastFlowLogByResourceCrnOrName will fetch the environment again to get it's id. While you already has the environment and could use it's id.", "author": "lacikaaa", "createdAt": "2020-07-31T10:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5ODE4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463698186", "bodyText": "k fixed", "author": "wonderslug", "createdAt": "2020-07-31T16:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDQxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462214411", "bodyText": "this flowType check doesn't seem right to me.\nsimple EnvStackConfigUpdatesFlowConfig.class.equals(flowLog.getFlowType()) should work here", "author": "lacikaaa", "createdAt": "2020-07-29T10:58:43Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.PollGroup;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.flow.config.update.config.EnvStackConfigUpdatesFlowConfig;\n+import com.sequenceiq.environment.store.EnvironmentInMemoryStateStore;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.FlowCancelService;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackService.class);\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final FlowCancelService flowCancelService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackService(\n+        StackV4Endpoint stackV4Endpoint,\n+        FlowCancelService flowCancelService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.flowCancelService = flowCancelService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public void triggerConfigUpdateForStack(String stackName) {\n+        try {\n+            stackV4Endpoint.updatePillarConfigurationByName(0L, stackName);\n+        } catch (BadRequestException bre) {\n+            LOGGER.info(String\n+                .format(\"Unable to start config update for stack %s.  Message is %s\", stackName,\n+                    bre.getMessage()));\n+            throw bre;\n+        }\n+    }\n+\n+    public void cancelRunningStackConfigUpdates(Environment environment) {\n+        try {\n+            FlowLog flowLog = flowLogDBService.getLastFlowLogByResourceCrnOrName(environment.getResourceCrn());\n+            if (!flowLog.getFinalized() && flowLog.getFlowType() != null\n+                && flowLog.getFlowType().getCanonicalName()\n+                .equals(EnvStackConfigUpdatesFlowConfig.class.getCanonicalName())) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNjIyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462626220", "bodyText": "yeah seems clearer", "author": "wonderslug", "createdAt": "2020-07-29T22:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNzM3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462217370", "bodyText": "I think you should catch WebApplicationException also and use WebApplicationExceptionMessageExtractor to get the message, just to be sure", "author": "lacikaaa", "createdAt": "2020-07-29T11:04:58Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.PollGroup;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.flow.config.update.config.EnvStackConfigUpdatesFlowConfig;\n+import com.sequenceiq.environment.store.EnvironmentInMemoryStateStore;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.FlowCancelService;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackService.class);\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final FlowCancelService flowCancelService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackService(\n+        StackV4Endpoint stackV4Endpoint,\n+        FlowCancelService flowCancelService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.flowCancelService = flowCancelService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public void triggerConfigUpdateForStack(String stackName) {\n+        try {\n+            stackV4Endpoint.updatePillarConfigurationByName(0L, stackName);\n+        } catch (BadRequestException bre) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwMTQ2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462701469", "bodyText": "Looking at it probabbly only should catch WebApplicationException here.\nThe rethrow allows the discrimination for the BadRequest to be retried\nand anything else (like a 404 or 401) to cancel the polling.\nBut im open to options on it.  Thoughts?", "author": "wonderslug", "createdAt": "2020-07-30T02:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxOTQyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462219422", "bodyText": "unnecessary linebreak", "author": "lacikaaa", "createdAt": "2020-07-29T11:09:00Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTQ3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462585478", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-29T21:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxOTQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyODQ4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465828481", "bodyText": "this and the ones in doExecute parameter list still present", "author": "lacikaaa", "createdAt": "2020-08-05T15:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxOTQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwNDQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466004490", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-08-05T21:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxOTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMDEyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462220123", "bodyText": "all doExecute has linebreaks, please clean them up", "author": "lacikaaa", "createdAt": "2020-07-29T11:10:27Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);\n+\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentStatusUpdateService environmentStatusUpdateService;\n+\n+    private final EnvironmentMetricService metricService;\n+\n+    public EnvStackConfigUpdatesActions(EnvironmentService environmentService,\n+        EnvironmentStatusUpdateService environmentStatusUpdateService,\n+        EnvironmentMetricService metricService) {\n+        this.environmentService = environmentService;\n+        this.environmentStatusUpdateService = environmentStatusUpdateService;\n+        this.metricService = metricService;\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_START_STATE\")\n+    public Action<?, ?> collectClusterInfo() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStackConfigUpdatesEvent.class) {\n+\n+            @Override\n+            protected void doExecute(", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTUxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462585514", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-29T21:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMDEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTMzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462221334", "bodyText": "shouldn't be there a start?", "author": "lacikaaa", "createdAt": "2020-07-29T11:12:56Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);\n+\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentStatusUpdateService environmentStatusUpdateService;\n+\n+    private final EnvironmentMetricService metricService;\n+\n+    public EnvStackConfigUpdatesActions(EnvironmentService environmentService,\n+        EnvironmentStatusUpdateService environmentStatusUpdateService,\n+        EnvironmentMetricService metricService) {\n+        this.environmentService = environmentService;\n+        this.environmentStatusUpdateService = environmentStatusUpdateService;\n+        this.metricService = metricService;\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_START_STATE\")\n+    public Action<?, ?> collectClusterInfo() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStackConfigUpdatesEvent.class) {\n+\n+            @Override\n+            protected void doExecute(\n+                CommonContext context, EnvStackConfigUpdatesEvent payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_STARTED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_START_STATE);\n+\n+                sendEvent(context,\n+                    EnvStackConfigUpdatesHandlerSelectors.STACK_CONFIG_UPDATES_HANDLER_EVENT\n+                        .selector(), environmentDto);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FINISHED_STATE\")\n+    public Action<?, ?> finishedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(ResourceCrnPayload.class) {\n+            @Override\n+            protected void doExecute(CommonContext context, ResourceCrnPayload payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_FINISHED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FINISHED_STATE);\n+                metricService.incrementMetricCounter(MetricType.ENV_STACK_CONFIG_UPDATE_FINISHED,", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjI5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462586294", "bodyText": "On the metrics side I doesnt look like there is a start on the other env service\nflows,  so I followed the pattern", "author": "wonderslug", "createdAt": "2020-07-29T21:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTYwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462221600", "bodyText": "this log message is not right", "author": "lacikaaa", "createdAt": "2020-07-29T11:13:34Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);\n+\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentStatusUpdateService environmentStatusUpdateService;\n+\n+    private final EnvironmentMetricService metricService;\n+\n+    public EnvStackConfigUpdatesActions(EnvironmentService environmentService,\n+        EnvironmentStatusUpdateService environmentStatusUpdateService,\n+        EnvironmentMetricService metricService) {\n+        this.environmentService = environmentService;\n+        this.environmentStatusUpdateService = environmentStatusUpdateService;\n+        this.metricService = metricService;\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_START_STATE\")\n+    public Action<?, ?> collectClusterInfo() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStackConfigUpdatesEvent.class) {\n+\n+            @Override\n+            protected void doExecute(\n+                CommonContext context, EnvStackConfigUpdatesEvent payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_STARTED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_START_STATE);\n+\n+                sendEvent(context,\n+                    EnvStackConfigUpdatesHandlerSelectors.STACK_CONFIG_UPDATES_HANDLER_EVENT\n+                        .selector(), environmentDto);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FINISHED_STATE\")\n+    public Action<?, ?> finishedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(ResourceCrnPayload.class) {\n+            @Override\n+            protected void doExecute(CommonContext context, ResourceCrnPayload payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_FINISHED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FINISHED_STATE);\n+                metricService.incrementMetricCounter(MetricType.ENV_STACK_CONFIG_UPDATE_FINISHED,\n+                    environmentDto);\n+                LOGGER.info(\"Flow entered into ENV_STOP_FINISHED_STATE\");", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MTU4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462461587", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-29T17:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMjMwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462222300", "bodyText": "EnvStopFailedEvent?", "author": "lacikaaa", "createdAt": "2020-07-29T11:15:01Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);\n+\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentStatusUpdateService environmentStatusUpdateService;\n+\n+    private final EnvironmentMetricService metricService;\n+\n+    public EnvStackConfigUpdatesActions(EnvironmentService environmentService,\n+        EnvironmentStatusUpdateService environmentStatusUpdateService,\n+        EnvironmentMetricService metricService) {\n+        this.environmentService = environmentService;\n+        this.environmentStatusUpdateService = environmentStatusUpdateService;\n+        this.metricService = metricService;\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_START_STATE\")\n+    public Action<?, ?> collectClusterInfo() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStackConfigUpdatesEvent.class) {\n+\n+            @Override\n+            protected void doExecute(\n+                CommonContext context, EnvStackConfigUpdatesEvent payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_STARTED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_START_STATE);\n+\n+                sendEvent(context,\n+                    EnvStackConfigUpdatesHandlerSelectors.STACK_CONFIG_UPDATES_HANDLER_EVENT\n+                        .selector(), environmentDto);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FINISHED_STATE\")\n+    public Action<?, ?> finishedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(ResourceCrnPayload.class) {\n+            @Override\n+            protected void doExecute(CommonContext context, ResourceCrnPayload payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_FINISHED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FINISHED_STATE);\n+                metricService.incrementMetricCounter(MetricType.ENV_STACK_CONFIG_UPDATE_FINISHED,\n+                    environmentDto);\n+                LOGGER.info(\"Flow entered into ENV_STOP_FINISHED_STATE\");\n+                sendEvent(context, FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT.event(), payload);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FAILED_STATE\")\n+    public Action<?, ?> failedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStopFailedEvent.class) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMTEyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462601126", "bodyText": "Yeah  thats where the class I removed from Jamisons code review was supposed to go\nwell back in there now.", "author": "wonderslug", "createdAt": "2020-07-29T21:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMjMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNTU0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462225545", "bodyText": "what will be the env state in case of a failure?", "author": "lacikaaa", "createdAt": "2020-07-29T11:21:40Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/EnvStackConfigUpdatesActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.environment.environment.flow.config.update;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.ResourceCrnPayload;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.stop.event.EnvStopFailedEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.environment.service.EnvironmentStatusUpdateService;\n+import com.sequenceiq.environment.metrics.EnvironmentMetricService;\n+import com.sequenceiq.environment.metrics.MetricType;\n+import com.sequenceiq.flow.core.CommonContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+@Configuration\n+public class EnvStackConfigUpdatesActions {\n+\n+    private static final Logger LOGGER = LoggerFactory\n+        .getLogger(EnvStackConfigUpdatesActions.class);\n+\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentStatusUpdateService environmentStatusUpdateService;\n+\n+    private final EnvironmentMetricService metricService;\n+\n+    public EnvStackConfigUpdatesActions(EnvironmentService environmentService,\n+        EnvironmentStatusUpdateService environmentStatusUpdateService,\n+        EnvironmentMetricService metricService) {\n+        this.environmentService = environmentService;\n+        this.environmentStatusUpdateService = environmentStatusUpdateService;\n+        this.metricService = metricService;\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_START_STATE\")\n+    public Action<?, ?> collectClusterInfo() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStackConfigUpdatesEvent.class) {\n+\n+            @Override\n+            protected void doExecute(\n+                CommonContext context, EnvStackConfigUpdatesEvent payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_STARTED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_START_STATE);\n+\n+                sendEvent(context,\n+                    EnvStackConfigUpdatesHandlerSelectors.STACK_CONFIG_UPDATES_HANDLER_EVENT\n+                        .selector(), environmentDto);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FINISHED_STATE\")\n+    public Action<?, ?> finishedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(ResourceCrnPayload.class) {\n+            @Override\n+            protected void doExecute(CommonContext context, ResourceCrnPayload payload,\n+                Map<Object, Object> variables) {\n+\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateEnvironmentStatusAndNotify(context, payload,\n+                        getCurrentStatus(payload.getResourceId()),\n+                        ResourceEvent.ENVIRONMENT_STACK_CONFIGS_UPDATE_FINISHED,\n+                        EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FINISHED_STATE);\n+                metricService.incrementMetricCounter(MetricType.ENV_STACK_CONFIG_UPDATE_FINISHED,\n+                    environmentDto);\n+                LOGGER.info(\"Flow entered into ENV_STOP_FINISHED_STATE\");\n+                sendEvent(context, FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT.event(), payload);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"STACK_CONFIG_UPDATES_FAILED_STATE\")\n+    public Action<?, ?> failedAction() {\n+        return new AbstractEnvStackConfigUpdatesAction<>(EnvStopFailedEvent.class) {\n+            @Override\n+            protected void doExecute(CommonContext context, EnvStopFailedEvent payload,\n+                Map<Object, Object> variables) {\n+                LOGGER.warn(\n+                    String.format(\"Failed to update environments stack configs '%s'. Status: '%s'.\",\n+                        payload.getEnvironmentDto(), payload.getEnvironmentStatus()),\n+                    payload.getException());\n+                EnvironmentDto environmentDto = environmentStatusUpdateService\n+                    .updateFailedEnvironmentStatusAndNotify(context, payload,", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzY0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462463642", "bodyText": "The environment state itself is being maintained.\nThis flow does not really effect the state of the environment it is effecting the\nclusters in it.  The overall envrionment state should not change from what it is\nunless its effect by the state of Environment level clustrers in it,  live FreeIPA\nwhich is not hit by this.", "author": "wonderslug", "createdAt": "2020-07-29T17:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NTk3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463555976", "bodyText": "then what's the purpose of invoking this method in these steps? only sending notification?\nI'm just confused why we need to lookup the env from db, update the status to the same, save it back if it's state won't change. maybe this is the right way to send notification in case of env service, it's just looks there are some extra steps we don't need here.", "author": "lacikaaa", "createdAt": "2020-07-31T11:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMjk3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463602972", "bodyText": "Its to update the ResourceEvent status text that's associated with the Environment.  When the flow is going it updates those in the events view of the Clusters for the config.  This way there is a notification of the event to the customer without adjusting the status of the environment.", "author": "wonderslug", "createdAt": "2020-07-31T13:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMyOTUwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464329507", "bodyText": "thanks for the clarification", "author": "lacikaaa", "createdAt": "2020-08-03T10:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNjE3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462226170", "bodyText": "I think it should be cluster, customer would recognize that better. maybe", "author": "lacikaaa", "createdAt": "2020-07-29T11:22:56Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/config/EnvStackConfigUpdatesFlowConfig.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.environment.environment.flow.config.update.config;\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState.FINAL_STATE;\n+import static com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState.INIT_STATE;\n+import static com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FAILED_STATE;\n+import static com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_FINISHED_STATE;\n+import static com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState.STACK_CONFIG_UPDATES_START_STATE;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.ENV_STACK_CONFIG_UPDATES_START_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FINISH_ENV_STACK_CONFIG_UPDATES_EVENT;\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.environment.environment.flow.config.update.EnvStackConfigUpdatesState;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors;\n+import com.sequenceiq.flow.core.config.AbstractFlowConfiguration;\n+import com.sequenceiq.flow.core.config.RetryableFlowConfiguration;\n+import java.util.List;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class EnvStackConfigUpdatesFlowConfig extends\n+    AbstractFlowConfiguration<EnvStackConfigUpdatesState, EnvStackConfigUpdatesStateSelectors>\n+    implements RetryableFlowConfiguration<EnvStackConfigUpdatesStateSelectors> {\n+\n+    private static final List<Transition<EnvStackConfigUpdatesState, EnvStackConfigUpdatesStateSelectors>>\n+        TRANSITIONS = new Transition.Builder<EnvStackConfigUpdatesState, EnvStackConfigUpdatesStateSelectors>()\n+        .defaultFailureEvent(FAILED_ENV_STACK_CONIFG_UPDATES_EVENT)\n+\n+        .from(INIT_STATE).to(STACK_CONFIG_UPDATES_START_STATE)\n+        .event(ENV_STACK_CONFIG_UPDATES_START_EVENT).defaultFailureEvent()\n+\n+        .from(STACK_CONFIG_UPDATES_START_STATE).to(STACK_CONFIG_UPDATES_FINISHED_STATE)\n+        .event(FINISH_ENV_STACK_CONFIG_UPDATES_EVENT).defaultFailureEvent()\n+\n+        .from(STACK_CONFIG_UPDATES_FINISHED_STATE).to(FINAL_STATE)\n+        .event(FINALIZE_ENV_STACK_CONIFG_UPDATES_EVENT).defaultFailureEvent()\n+\n+        .build();\n+\n+    protected EnvStackConfigUpdatesFlowConfig() {\n+        super(EnvStackConfigUpdatesState.class, EnvStackConfigUpdatesStateSelectors.class);\n+    }\n+\n+    @Override\n+    protected List<Transition<EnvStackConfigUpdatesState, EnvStackConfigUpdatesStateSelectors>> getTransitions() {\n+        return TRANSITIONS;\n+    }\n+\n+    @Override\n+    protected FlowEdgeConfig<EnvStackConfigUpdatesState, EnvStackConfigUpdatesStateSelectors> getEdgeConfig() {\n+        return new FlowEdgeConfig<>(INIT_STATE, FINAL_STATE, STACK_CONFIG_UPDATES_FAILED_STATE,\n+            HANDLE_FAILED_ENV_STACK_CONIFG_UPDATES_EVENT);\n+    }\n+\n+    @Override\n+    public EnvStackConfigUpdatesStateSelectors[] getEvents() {\n+        return EnvStackConfigUpdatesStateSelectors.values();\n+    }\n+\n+    @Override\n+    public EnvStackConfigUpdatesStateSelectors[] getInitEvents() {\n+        return new EnvStackConfigUpdatesStateSelectors[]{ENV_STACK_CONFIG_UPDATES_START_EVENT};\n+    }\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Update all Environment Stacks configuration\";", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1OTA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462459091", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-29T17:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNzQ0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462227447", "bodyText": ".event() is might be better", "author": "lacikaaa", "createdAt": "2020-07-29T11:25:24Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/handler/StackConfigUpdatesHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.environment.environment.flow.config.update.handler;\n+\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesEvent.EnvStackConfigUpdatesEventBuilder;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesHandlerSelectors;\n+import com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors;\n+import com.sequenceiq.environment.environment.service.stack.StackPollerService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.reactor.api.event.EventSender;\n+import com.sequenceiq.flow.reactor.api.handler.EventSenderAwareHandler;\n+import org.springframework.stereotype.Component;\n+import reactor.bus.Event;\n+\n+@Component\n+public class StackConfigUpdatesHandler extends EventSenderAwareHandler<EnvironmentDto> {\n+\n+    private final StackPollerService stackPollerService;\n+\n+    public StackConfigUpdatesHandler(EventSender eventSender,\n+        StackPollerService stackPollerService) {\n+        super(eventSender);\n+        this.stackPollerService = stackPollerService;\n+    }\n+\n+    @Override\n+    public String selector() {\n+        return EnvStackConfigUpdatesHandlerSelectors.STACK_CONFIG_UPDATES_HANDLER_EVENT\n+            .name();", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDM3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462460373", "bodyText": "Ok  im all for abstraction, fixed", "author": "wonderslug", "createdAt": "2020-07-29T17:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNzQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODEzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462228134", "bodyText": "please add some tests", "author": "lacikaaa", "createdAt": "2020-07-29T11:26:58Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxOTkxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462719918", "bodyText": "yeah get some in tomorrow", "author": "wonderslug", "createdAt": "2020-07-30T03:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzNjc1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465836753", "bodyText": "please add some test as this class has some complex logic", "author": "lacikaaa", "createdAt": "2020-08-05T16:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMzMwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466003302", "bodyText": "added. accidentally closed it when I went on a resolving rampage", "author": "wonderslug", "createdAt": "2020-08-05T21:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODI3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462228275", "bodyText": "not used, please consider adding some log", "author": "lacikaaa", "createdAt": "2020-07-29T11:27:14Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzE3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463707176", "bodyText": "added", "author": "wonderslug", "createdAt": "2020-07-31T16:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyODI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIzMTAxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462231014", "bodyText": "iinstead of checking the flow maybe you should rely on EnvironmentInMemoryStateStore, but I think we will need somebody from env team to help out here", "author": "lacikaaa", "createdAt": "2020-07-29T11:32:33Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxMDA1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462610051", "bodyText": "I tried that.  Couple of issues with it.\nBiggest issue is that it will not stop the\nflow if it is running on a different instance of the environment service.\nEnvironmentInMemoryStateStore just ends up as a local ConcurrentHashMap.\nOther issue is that even locally you have no way to guarantee that the CANCELED value\nis picked up by the sleeping polling instance before the the new Polling instance starts\nand resets it to POLLING since it is only referenced by environment id.\nBoth of these led to just checking the state of the flow and if it has been\ncanceled or not.  This allows for cross instance control and explicit stopping\nof the prior flow instance.", "author": "wonderslug", "createdAt": "2020-07-29T21:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIzMTAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MDQzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462250436", "bodyText": "if there is some error calling CB here, it's not really handled. Is it on purpose to leave it to the handler to handle it?", "author": "lacikaaa", "createdAt": "2020-07-29T12:11:00Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackPollerService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+import com.dyngr.Polling;\n+import com.dyngr.core.AttemptMaker;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackViewV4Responses;\n+import com.sequenceiq.environment.environment.poller.StackPollerProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackPollerService {\n+\n+    private static final List<Status> SKIPPED_STATES = List.of(\n+        Status.CREATE_FAILED,\n+        Status.STOPPED,\n+        Status.STOP_IN_PROGRESS,\n+        Status.STOP_REQUESTED,\n+        Status.DELETE_IN_PROGRESS,\n+        Status.DELETE_COMPLETED,\n+        Status.DELETED_ON_PROVIDER_SIDE,\n+        Status.DELETE_FAILED,\n+        Status.PRE_DELETE_IN_PROGRESS,\n+        Status.START_FAILED,\n+        Status.EXTERNAL_DATABASE_CREATION_FAILED,\n+        Status.EXTERNAL_DATABASE_DELETION_FINISHED,\n+        Status.EXTERNAL_DATABASE_DELETION_FAILED\n+    );\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final StackPollerProvider stackPollerProvider;\n+\n+    @Value(\"${env.stack.config.update.polling.attemptCount:120}\")\n+    private Integer attemptCount;\n+\n+    @Value(\"${env.stack.config.update.sleep.time.seconds:60}\")\n+    private Integer sleepTime;\n+\n+    public StackPollerService(\n+        StackV4Endpoint stackV4Endpoint,\n+        StackPollerProvider stackPollerProvider) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.stackPollerProvider = stackPollerProvider;\n+    }\n+\n+    public void updateStackConfigurations(Long envId, String envCrn, String flowId) {\n+        List<String> stackNames = getUpdateableStacks(envCrn);\n+        startStackConfigUpdatePolling(envCrn, stackNames,\n+            stackPollerProvider.stackUpdateConfigPoller(stackNames, envId, flowId));\n+    }\n+\n+    private void startStackConfigUpdatePolling(String envCrn, List<String> stackNames,\n+        AttemptMaker<Void> attemptMaker) {\n+        if (CollectionUtils.isNotEmpty(stackNames)) {\n+            Polling.stopAfterAttempt(attemptCount)\n+                .stopIfException(true)\n+                .waitPeriodly(sleepTime, TimeUnit.SECONDS)\n+                .run(attemptMaker);\n+        }\n+    }\n+\n+    private List<String> getUpdateableStacks(String envCrn) {\n+        StackViewV4Responses stackViewV4Responses = stackV4Endpoint.list(0L, envCrn, false);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwMDY1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462700656", "bodyText": "Yes if its unable to get a list of Stacks form CB then the whole flow should fail.", "author": "wonderslug", "createdAt": "2020-07-30T02:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MDQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462251197", "bodyText": "envCrn is not used", "author": "lacikaaa", "createdAt": "2020-07-29T12:12:27Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackPollerService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+import com.dyngr.Polling;\n+import com.dyngr.core.AttemptMaker;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackViewV4Responses;\n+import com.sequenceiq.environment.environment.poller.StackPollerProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackPollerService {\n+\n+    private static final List<Status> SKIPPED_STATES = List.of(\n+        Status.CREATE_FAILED,\n+        Status.STOPPED,\n+        Status.STOP_IN_PROGRESS,\n+        Status.STOP_REQUESTED,\n+        Status.DELETE_IN_PROGRESS,\n+        Status.DELETE_COMPLETED,\n+        Status.DELETED_ON_PROVIDER_SIDE,\n+        Status.DELETE_FAILED,\n+        Status.PRE_DELETE_IN_PROGRESS,\n+        Status.START_FAILED,\n+        Status.EXTERNAL_DATABASE_CREATION_FAILED,\n+        Status.EXTERNAL_DATABASE_DELETION_FINISHED,\n+        Status.EXTERNAL_DATABASE_DELETION_FAILED\n+    );\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final StackPollerProvider stackPollerProvider;\n+\n+    @Value(\"${env.stack.config.update.polling.attemptCount:120}\")\n+    private Integer attemptCount;\n+\n+    @Value(\"${env.stack.config.update.sleep.time.seconds:60}\")\n+    private Integer sleepTime;\n+\n+    public StackPollerService(\n+        StackV4Endpoint stackV4Endpoint,\n+        StackPollerProvider stackPollerProvider) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.stackPollerProvider = stackPollerProvider;\n+    }\n+\n+    public void updateStackConfigurations(Long envId, String envCrn, String flowId) {\n+        List<String> stackNames = getUpdateableStacks(envCrn);\n+        startStackConfigUpdatePolling(envCrn, stackNames,\n+            stackPollerProvider.stackUpdateConfigPoller(stackNames, envId, flowId));\n+    }\n+\n+    private void startStackConfigUpdatePolling(String envCrn, List<String> stackNames,", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5NzY5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462697699", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-30T02:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTMzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462251332", "bodyText": "unnecessary linebreak", "author": "lacikaaa", "createdAt": "2020-07-29T12:12:43Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackPollerService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+import com.dyngr.Polling;\n+import com.dyngr.core.AttemptMaker;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackViewV4Responses;\n+import com.sequenceiq.environment.environment.poller.StackPollerProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackPollerService {\n+\n+    private static final List<Status> SKIPPED_STATES = List.of(\n+        Status.CREATE_FAILED,\n+        Status.STOPPED,\n+        Status.STOP_IN_PROGRESS,\n+        Status.STOP_REQUESTED,\n+        Status.DELETE_IN_PROGRESS,\n+        Status.DELETE_COMPLETED,\n+        Status.DELETED_ON_PROVIDER_SIDE,\n+        Status.DELETE_FAILED,\n+        Status.PRE_DELETE_IN_PROGRESS,\n+        Status.START_FAILED,\n+        Status.EXTERNAL_DATABASE_CREATION_FAILED,\n+        Status.EXTERNAL_DATABASE_DELETION_FINISHED,\n+        Status.EXTERNAL_DATABASE_DELETION_FAILED\n+    );\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final StackPollerProvider stackPollerProvider;\n+\n+    @Value(\"${env.stack.config.update.polling.attemptCount:120}\")\n+    private Integer attemptCount;\n+\n+    @Value(\"${env.stack.config.update.sleep.time.seconds:60}\")\n+    private Integer sleepTime;\n+\n+    public StackPollerService(\n+        StackV4Endpoint stackV4Endpoint,\n+        StackPollerProvider stackPollerProvider) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.stackPollerProvider = stackPollerProvider;\n+    }\n+\n+    public void updateStackConfigurations(Long envId, String envCrn, String flowId) {\n+        List<String> stackNames = getUpdateableStacks(envCrn);\n+        startStackConfigUpdatePolling(envCrn, stackNames,\n+            stackPollerProvider.stackUpdateConfigPoller(stackNames, envId, flowId));\n+    }\n+\n+    private void startStackConfigUpdatePolling(String envCrn, List<String> stackNames,\n+        AttemptMaker<Void> attemptMaker) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5NzcyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462697724", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-30T02:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTk5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462251994", "bodyText": "maybe we should switch to stopAfterDelay, os the attempt count won't have affect on how long we poll this. what do you think?", "author": "lacikaaa", "createdAt": "2020-07-29T12:13:58Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/stack/StackPollerService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.environment.environment.service.stack;\n+\n+import com.dyngr.Polling;\n+import com.dyngr.core.AttemptMaker;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackViewV4Responses;\n+import com.sequenceiq.environment.environment.poller.StackPollerProvider;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class StackPollerService {\n+\n+    private static final List<Status> SKIPPED_STATES = List.of(\n+        Status.CREATE_FAILED,\n+        Status.STOPPED,\n+        Status.STOP_IN_PROGRESS,\n+        Status.STOP_REQUESTED,\n+        Status.DELETE_IN_PROGRESS,\n+        Status.DELETE_COMPLETED,\n+        Status.DELETED_ON_PROVIDER_SIDE,\n+        Status.DELETE_FAILED,\n+        Status.PRE_DELETE_IN_PROGRESS,\n+        Status.START_FAILED,\n+        Status.EXTERNAL_DATABASE_CREATION_FAILED,\n+        Status.EXTERNAL_DATABASE_DELETION_FINISHED,\n+        Status.EXTERNAL_DATABASE_DELETION_FAILED\n+    );\n+\n+    private final StackV4Endpoint stackV4Endpoint;\n+\n+    private final StackPollerProvider stackPollerProvider;\n+\n+    @Value(\"${env.stack.config.update.polling.attemptCount:120}\")\n+    private Integer attemptCount;\n+\n+    @Value(\"${env.stack.config.update.sleep.time.seconds:60}\")\n+    private Integer sleepTime;\n+\n+    public StackPollerService(\n+        StackV4Endpoint stackV4Endpoint,\n+        StackPollerProvider stackPollerProvider) {\n+        this.stackV4Endpoint = stackV4Endpoint;\n+        this.stackPollerProvider = stackPollerProvider;\n+    }\n+\n+    public void updateStackConfigurations(Long envId, String envCrn, String flowId) {\n+        List<String> stackNames = getUpdateableStacks(envCrn);\n+        startStackConfigUpdatePolling(envCrn, stackNames,\n+            stackPollerProvider.stackUpdateConfigPoller(stackNames, envId, flowId));\n+    }\n+\n+    private void startStackConfigUpdatePolling(String envCrn, List<String> stackNames,\n+        AttemptMaker<Void> attemptMaker) {\n+        if (CollectionUtils.isNotEmpty(stackNames)) {\n+            Polling.stopAfterAttempt(attemptCount)", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwMDA4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462700087", "bodyText": "Yeah makes sense.  Provides more percise control of how long it runs.", "author": "wonderslug", "createdAt": "2020-07-30T02:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MzYyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462253621", "bodyText": "why don't we use crn here? I think crn provides some additional uniqueness", "author": "lacikaaa", "createdAt": "2020-07-29T12:16:56Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {\n+                return AttemptResults.finishWith(null);\n+            }\n+            List<String> remaining = new ArrayList<>();\n+            List<AttemptResult<Void>> results = collectStackUpdateConfigResults(mutableNamesList,\n+                remaining, envId);\n+            mutableNamesList.retainAll(remaining);\n+            return evaluateResult(results);\n+        };\n+    }\n+\n+    private List<AttemptResult<Void>> collectStackUpdateConfigResults(List<String> stackNames,\n+        List<String> remaining, Long envId) {\n+        return stackNames.stream()\n+            .map(stackName -> fetchStackUpdateConfigResults(remaining, stackName, envId))\n+            .collect(Collectors.toList());\n+    }\n+\n+    private AttemptResult<Void> fetchStackUpdateConfigResults(List<String> remainingStacks,\n+        String stackName, Long envId) {\n+        try {\n+            stackService.triggerConfigUpdateForStack(stackName);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMjgxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462622818", "bodyText": "This simple fronts the CB core stackV4Endpoint.updatePillarConfigurationByName which is\nname based and the CB core pattern for all of these is name based.\nDo we want to start shifting to CRN based for those APIs?", "author": "wonderslug", "createdAt": "2020-07-29T22:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNDgxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463534811", "bodyText": "so inter service communication should use crn. see @horadla23 comment on cb developer channel on slack:\n\nAdam Laszlo Horvath  15:19\nI have a request to everyone who is designing, adding, modifying any APIs in CB code. If it is possible, please use CRN of a resource instead of name, since generally CRN is used in the whole platform to identify a resource and also during authorization it requires additional database query to find out the CRN based on the name, because we need CRN to authorize a call in UMS.", "author": "lacikaaa", "createdAt": "2020-07-31T10:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzM4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463707386", "bodyText": "K done", "author": "wonderslug", "createdAt": "2020-07-31T16:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MzYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1Mzg2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462253866", "bodyText": "env id not used\nline break", "author": "lacikaaa", "createdAt": "2020-07-29T12:17:21Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {\n+                return AttemptResults.finishWith(null);\n+            }\n+            List<String> remaining = new ArrayList<>();\n+            List<AttemptResult<Void>> results = collectStackUpdateConfigResults(mutableNamesList,\n+                remaining, envId);\n+            mutableNamesList.retainAll(remaining);\n+            return evaluateResult(results);\n+        };\n+    }\n+\n+    private List<AttemptResult<Void>> collectStackUpdateConfigResults(List<String> stackNames,\n+        List<String> remaining, Long envId) {\n+        return stackNames.stream()\n+            .map(stackName -> fetchStackUpdateConfigResults(remaining, stackName, envId))\n+            .collect(Collectors.toList());\n+    }\n+\n+    private AttemptResult<Void> fetchStackUpdateConfigResults(List<String> remainingStacks,\n+        String stackName, Long envId) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzAyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462623026", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-29T22:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1Mzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1OTA2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462259069", "bodyText": "so instead of passing in the remainingStacks paramater and adding stuff, why don't we return with AttemptResult<String>?", "author": "lacikaaa", "createdAt": "2020-07-29T12:26:46Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {\n+                return AttemptResults.finishWith(null);\n+            }\n+            List<String> remaining = new ArrayList<>();\n+            List<AttemptResult<Void>> results = collectStackUpdateConfigResults(mutableNamesList,\n+                remaining, envId);\n+            mutableNamesList.retainAll(remaining);\n+            return evaluateResult(results);\n+        };\n+    }\n+\n+    private List<AttemptResult<Void>> collectStackUpdateConfigResults(List<String> stackNames,\n+        List<String> remaining, Long envId) {\n+        return stackNames.stream()\n+            .map(stackName -> fetchStackUpdateConfigResults(remaining, stackName, envId))\n+            .collect(Collectors.toList());\n+    }\n+\n+    private AttemptResult<Void> fetchStackUpdateConfigResults(List<String> remainingStacks,\n+        String stackName, Long envId) {\n+        try {\n+            stackService.triggerConfigUpdateForStack(stackName);\n+            return AttemptResults.finishWith(null);\n+        } catch (BadRequestException e) {\n+            remainingStacks.add(stackName);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNzg2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462617867", "bodyText": "Because the stack name gets added to the remainingStacks and is processed\nby reference in stackUpdateConfigPoller.  AttemptResult  would not\nallow it to be processed in the as I have to have a return type of AttemptResult\nto handle all the cases and force a check against null in the results.\nThis is the same pattern used for the Datahub polling to stop multiple datahubs.", "author": "wonderslug", "createdAt": "2020-07-29T22:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1OTA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNTExNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463535115", "bodyText": "thanks for the clarification", "author": "lacikaaa", "createdAt": "2020-07-31T10:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1OTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDcyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462260721", "bodyText": "I think you should use anyMatch here instead of count and filter if I understand the code well", "author": "lacikaaa", "createdAt": "2020-07-29T12:29:47Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/poller/StackPollerProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.environment.environment.poller;\n+\n+import com.dyngr.core.AttemptMaker;\n+import com.dyngr.core.AttemptResult;\n+import com.dyngr.core.AttemptResults;\n+import com.dyngr.core.AttemptState;\n+import com.sequenceiq.environment.environment.service.stack.StackService;\n+import com.sequenceiq.flow.core.FlowConstants;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import com.sequenceiq.flow.service.flowlog.FlowLogDBService;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.ws.rs.BadRequestException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class StackPollerProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StackPollerProvider.class);\n+\n+    private final StackService stackService;\n+\n+    private final FlowLogDBService flowLogDBService;\n+\n+    public StackPollerProvider(\n+        StackService stackService,\n+        FlowLogDBService flowLogDBService) {\n+        this.stackService = stackService;\n+        this.flowLogDBService = flowLogDBService;\n+    }\n+\n+    public AttemptMaker<Void> stackUpdateConfigPoller(List<String> stackNames, Long envId, String flowId) {\n+        List<String> mutableNamesList = new ArrayList<>(stackNames);\n+        return () -> {\n+            Optional<FlowLog> flowLog = flowLogDBService.getLastFlowLog(flowId);\n+            if (flowLog.isPresent() && flowLog.get().getCurrentState().equals(FlowConstants.CANCELLED_STATE)) {\n+                return AttemptResults.finishWith(null);\n+            }\n+            List<String> remaining = new ArrayList<>();\n+            List<AttemptResult<Void>> results = collectStackUpdateConfigResults(mutableNamesList,\n+                remaining, envId);\n+            mutableNamesList.retainAll(remaining);\n+            return evaluateResult(results);\n+        };\n+    }\n+\n+    private List<AttemptResult<Void>> collectStackUpdateConfigResults(List<String> stackNames,\n+        List<String> remaining, Long envId) {\n+        return stackNames.stream()\n+            .map(stackName -> fetchStackUpdateConfigResults(remaining, stackName, envId))\n+            .collect(Collectors.toList());\n+    }\n+\n+    private AttemptResult<Void> fetchStackUpdateConfigResults(List<String> remainingStacks,\n+        String stackName, Long envId) {\n+        try {\n+            stackService.triggerConfigUpdateForStack(stackName);\n+            return AttemptResults.finishWith(null);\n+        } catch (BadRequestException e) {\n+            remainingStacks.add(stackName);\n+            return AttemptResults.justContinue();\n+        } catch (Exception e) {\n+            return AttemptResults.breakFor(e);\n+        }\n+    }\n+\n+    AttemptResult<Void> evaluateResult(List<AttemptResult<Void>> results) {\n+        Optional<AttemptResult<Void>> error = results.stream()\n+            .filter(it -> it.getState() == AttemptState.BREAK).findFirst();\n+        if (error.isPresent()) {\n+            return error.get();\n+        }\n+        long count = results.stream().filter(it -> it.getState() == AttemptState.CONTINUE).count();\n+        if (count > 0) {", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMTI2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462621267", "bodyText": "Can do it, but it ends up being the same thing.  Not sure which is more clear.\nPredicate<AttemptResult<Void>> stateCheck = it -> it.getState() == AttemptState.CONTINUE;\nif (results.stream().anyMatch(stateCheck)) {\n\nversus\nlong count = results.stream().filter(it -> it.getState() == AttemptState.CONTINUE).count();\nif (count > 0) {\n\nI think the anyMatch adds more overhead needing an additional object, but in the scheme of things  it really makes no difference.", "author": "wonderslug", "createdAt": "2020-07-29T22:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MzE0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463543144", "bodyText": "yeah, that's not better, but this is what I was trying to suggest:\n\t\tboolean continueResult = results.stream().anyMatch(result -> result.getState() == AttemptState.CONTINUE);\n        if (continueResult) {\n            return AttemptResults.justContinue();\n        }\n\nor even better moving this to a method:\n        if (shouldContinue(results)) {\n            return AttemptResults.justContinue();\n        }\n...\n    private boolean shouldContinue(List<AttemptResult<Void>> results) {\n        return results.stream().anyMatch(result -> result.getState() == AttemptState.CONTINUE);\n    }", "author": "lacikaaa", "createdAt": "2020-07-31T10:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwNzk0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r463607944", "bodyText": "sounds good to me.", "author": "wonderslug", "createdAt": "2020-07-31T13:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NDcxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462264710", "bodyText": "why are you fetching the env here if you fetch it in triggerStackConfigUpdates again? this method actually uses the same findByResourceCrnAndAccountIdAndArchivedIsFalse, just calls a converter later", "author": "lacikaaa", "createdAt": "2020-07-29T12:36:52Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentStackConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.sequenceiq.environment.environment.service;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.EnvironmentReactorFlowManager;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class EnvironmentStackConfigUpdateService {\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentReactorFlowManager reactorFlowManager;\n+\n+    public EnvironmentStackConfigUpdateService(\n+        EnvironmentService environmentService,\n+        EnvironmentReactorFlowManager reactorFlowManager) {\n+        this.environmentService = environmentService;\n+        this.reactorFlowManager = reactorFlowManager;\n+    }\n+\n+    public void updateAllStackConfigsByCrn(String crn) {\n+        String accountId = Crn.fromString(crn).getAccountId();\n+        EnvironmentDto environment = environmentService.getByCrnAndAccountId(crn, accountId);", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwNDQ3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462704473", "bodyText": "Yeah that can be cleaned up a little.", "author": "wonderslug", "createdAt": "2020-07-30T02:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NDcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462265156", "bodyText": "are you sure about this?", "author": "lacikaaa", "createdAt": "2020-07-29T12:37:38Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/v1/EnvironmentController.java", "diffHunk": "@@ -306,4 +311,10 @@ public Object getCreateEnvironmentForCli(EnvironmentRequest environmentRequest)\n         Credential credential = credentialService.getByNameForAccountId(environmentRequest.getCredentialName(), accountId, ENVIRONMENT);\n         return environmentService.getCreateEnvironmentForCli(environmentRequest, credential.getCloudPlatform());\n     }\n+\n+    @Override\n+    @DisableCheckPermissions", "originalCommit": "d050661c401008cb0e4e853ad9191fdc19be0c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM5MjIzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462392236", "bodyText": "Yes.   This is going to eventually be an automated event that happens that will have no actual end-user initiating it so it won't have someone other than \"internal actor\" permissions to check against.   Validation of the manual repair action is happening at the environment API endpoint.  This API call will not be exposed as a public API and will not have an issue of external calls being made to it.", "author": "wonderslug", "createdAt": "2020-07-29T15:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyOTg2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462429861", "bodyText": "you can authorize this similar to changeTelemetryFeatures method\n@CheckPermissionByResourceCrn(action = AuthorizationResourceAction.EDIT_ENVIRONMENT)\n    public DetailedEnvironmentResponse changeTelemetryFeaturesByEnvironmentCrn(@ResourceCrn String crn, @Valid FeaturesRequest request)\n\nunless you have a good reason for it, please do not use @DisabledCheckPermissions", "author": "horadla23", "createdAt": "2020-07-29T16:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjkwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462466909", "bodyText": "As I said above, this is going to be an automatically called function that will not have an external user.  Do we have Internal Actor support that will allow it to have permissions checked against?", "author": "wonderslug", "createdAt": "2020-07-29T17:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MzE4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462483188", "bodyText": "What do you mean under automatically called event? Will it be called in flow? If you are not calling it with internal actor explicitly, in threadlocal we will find the an user Crn.\nregardless of this is an automatically called method, if someone make this API call manually, they can call it withouth authz using DisabledChekPermissions annotation.", "author": "horadla23", "createdAt": "2020-07-29T17:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NDg1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462484856", "bodyText": "but you can check readme of authorization-common module to find out how you can make it possible to call with internal actor", "author": "horadla23", "createdAt": "2020-07-29T17:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0MzM1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462543353", "bodyText": "So what I mean by automatically is that eventually, the FreeIPA HA recovery will detect a crash of a node and bring up a replacement node.  Not a flow, more like a result of an action from a \"cron'ed\" status check.  This recovery is manual right now but will be automatic and this API call will be made to update the pillar config across an environment.  So there will be no thread-local user outside of one for the application itself, internal actor.\nAs well its an internal to the Control Plane API call, not available external.  I think this is a difference in philosophy in parts of the application.  In general from a thunderhead standpoint only publicly available API calls check, usually by the API service that fronts the internal service.  Internal services are openly available to be used by any other microservice.  From a CB standpoint, we are checking every API call every time, no matter if it is public or not.  This makes it very hard for anything like an automated service to be able to make calls to CB based services.  It has no \"user\" to work with except for an Internal Actor which would have access to everything anyways.", "author": "wonderslug", "createdAt": "2020-07-29T19:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1MDcwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462550709", "bodyText": "since anyone can make a cdp cli command or ui call using cb related apis, this is not true and every cb api can become public anytime, thus we enforce authorization, cc @lnardai", "author": "horadla23", "createdAt": "2020-07-29T19:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MDUwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462590505", "bodyText": "The proper method for this seems to be the @InternalOnly annotation.", "author": "wonderslug", "createdAt": "2020-07-29T21:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxOTE0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462719140", "bodyText": "Im not sure how \"anyone\" is able to do this.  This has to be a service deployed within the k8s CP or have an external API exposed via and API services for the CLI have to be defined in the CDP sdk and API documents.  This is the reason we have things like the environment service in the thunderhead fronting various things like the CB environment service or the datalake API service in thunderhead to front the CB datalake service.\nWhat we are talking about is controlled access by internal trusted services within the control plane.  Are you saying there is some other way that we expose these APIs to the public?", "author": "wonderslug", "createdAt": "2020-07-30T03:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MTAyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r462961021", "bodyText": "You are correct, the cdp-cli works through the API services. But if you check the UI many API calls are not relying on the API services but go through another route, called dps-gateway. For that reason we can't just leave API's \"unprotected\", we need to specify at least they should used only internally, otherwise with the right URL they are accessible.", "author": "lnardai", "createdAt": "2020-07-30T12:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NTE1Ng=="}], "type": "inlineReview"}, {"oid": "f687be18dee7f04d12886049143cb8adc81463a5", "url": "https://github.com/hortonworks/cloudbreak/commit/f687be18dee7f04d12886049143cb8adc81463a5", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-07-30T03:39:30Z", "type": "forcePushed"}, {"oid": "7aa92ae1201b85d66d37dbb7d62baca09ef79b7d", "url": "https://github.com/hortonworks/cloudbreak/commit/7aa92ae1201b85d66d37dbb7d62baca09ef79b7d", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-07-30T15:36:07Z", "type": "forcePushed"}, {"oid": "769011dade94e6ef024ac4b427c4b28b42cee5ed", "url": "https://github.com/hortonworks/cloudbreak/commit/769011dade94e6ef024ac4b427c4b28b42cee5ed", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-07-31T16:38:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDQ1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464334456", "bodyText": "nit: this could be also event()", "author": "lacikaaa", "createdAt": "2020-08-03T10:41:16Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/config/update/event/EnvStackConfigUpdatesFailedEvent.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.environment.environment.flow.config.update.event;\n+\n+\n+\n+import static com.sequenceiq.environment.environment.flow.config.update.event.EnvStackConfigUpdatesStateSelectors.FAILED_ENV_STACK_CONIFG_UPDATES_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.environment.environment.EnvironmentStatus;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.flow.reactor.api.event.BaseFailedFlowEvent;\n+\n+public class EnvStackConfigUpdatesFailedEvent extends BaseFailedFlowEvent implements Selectable {\n+\n+    private final EnvironmentDto environmentDto;\n+\n+    private final EnvironmentStatus environmentStatus;\n+\n+    public EnvStackConfigUpdatesFailedEvent(EnvironmentDto environmentDto, Exception exception, EnvironmentStatus environmentStatus) {\n+        super(FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.name(), environmentDto.getResourceId(),\n+                environmentDto.getName(), environmentDto.getResourceCrn(), exception);\n+        this.environmentDto = environmentDto;\n+        this.environmentStatus = environmentStatus;\n+    }\n+\n+    @Override\n+    public String selector() {\n+        return FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.name();", "originalCommit": "769011dade94e6ef024ac4b427c4b28b42cee5ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1MzkzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464453932", "bodyText": "in", "author": "wonderslug", "createdAt": "2020-08-03T14:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MTMzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464341339", "bodyText": "I think if you switch to safeFromString method it should guarantee that it's a valid crn and it has account id or an Exception would be thrown", "author": "lacikaaa", "createdAt": "2020-08-03T10:56:55Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentStackConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.environment.environment.service;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.flow.EnvironmentReactorFlowManager;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class EnvironmentStackConfigUpdateService {\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentReactorFlowManager reactorFlowManager;\n+\n+    public EnvironmentStackConfigUpdateService(\n+        EnvironmentService environmentService,\n+        EnvironmentReactorFlowManager reactorFlowManager) {\n+        this.environmentService = environmentService;\n+        this.reactorFlowManager = reactorFlowManager;\n+    }\n+\n+    public void updateAllStackConfigsByCrn(String envCrn) {\n+        String accountId = Crn.fromString(envCrn).getAccountId();\n+        if (accountId == null) {\n+            throw new NotFoundException(String.format(\"No account id found for crn '%s'\", envCrn));\n+        }", "originalCommit": "769011dade94e6ef024ac4b427c4b28b42cee5ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1Mzg3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464453879", "bodyText": "in", "author": "wonderslug", "createdAt": "2020-08-03T14:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MTMzOQ=="}], "type": "inlineReview"}, {"oid": "d167dcd04d5e94fd9ae3e927e7b655edbfe62ee3", "url": "https://github.com/hortonworks/cloudbreak/commit/d167dcd04d5e94fd9ae3e927e7b655edbfe62ee3", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-03T14:37:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464463863", "bodyText": "I am not sure that is it affects the UI but probably @keyki know this", "author": "doktoric", "createdAt": "2020-08-03T14:50:12Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/stacks/StackV4Endpoint.java", "diffHunk": "@@ -275,10 +275,10 @@ FlowIdentifier setClusterMaintenanceMode(@PathParam(\"workspaceId\") Long workspac\n     FlowIdentifier updateSaltByName(@PathParam(\"workspaceId\") Long workspaceId, @PathParam(\"name\") String name);\n \n     @PUT\n-    @Path(\"{name}/pillar_config_update\")\n+    @Path(\"crn/{crn}/pillar_config_update\")", "originalCommit": "d167dcd04d5e94fd9ae3e927e7b655edbfe62ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NDI3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464464276", "bodyText": "@horadla23 any authorization is required here ?", "author": "doktoric", "createdAt": "2020-08-03T14:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxNDYwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464514601", "bodyText": "The whole controller was set to @DisableCheckPermissions by @keyki", "author": "wonderslug", "createdAt": "2020-08-03T16:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxNTM0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464515344", "bodyText": "It should not affect the UI.  I added this in the just previous PR to be called by this explicitly.  It will never have been used by the UI.", "author": "wonderslug", "createdAt": "2020-08-03T16:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxNzI4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r464517288", "bodyText": "i have another pr regarding this stack api authorization, for now it is good with disabledcheckpermissions annotation", "author": "horadla23", "createdAt": "2020-08-03T16:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA0Mjk5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465042995", "bodyText": "change regarding stack api authorization is merged, please use same right to check permission as used for other stack api methods @CheckPermissionByAccount(action = AuthorizationResourceAction.USE_INTERNALLY) and also annotate crn param with @TenantAwareParam and it should work", "author": "horadla23", "createdAt": "2020-08-04T13:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwNDY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466004692", "bodyText": "added and in", "author": "wonderslug", "createdAt": "2020-08-05T21:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mzg2Mw=="}], "type": "inlineReview"}, {"oid": "11d41d542fd0ba45a56564a225c8d35955491775", "url": "https://github.com/hortonworks/cloudbreak/commit/11d41d542fd0ba45a56564a225c8d35955491775", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-04T19:21:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzUzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465813533", "bodyText": "could you add some test for this change? either via RestUrlParserTest or you could create a new test class\nthanks", "author": "lacikaaa", "createdAt": "2020-08-05T15:30:28Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/structuredevent/rest/urlparsers/V4ExistingResourceByCrnOrNameRestUrlParser.java", "diffHunk": "@@ -18,11 +18,11 @@\n     // v4/{workspaceId}/blueprints/name/{name}\n     // v4/{workspaceId}/blueprints/crn/{name}\n     private static final Pattern PATTERN = Pattern\n-            .compile(\"v4/(\\\\d+)/(blueprints|image_catalogs|recipes|stacks|distrox|cluster_templates)/(?:name|crn)/([^/]+)\");\n+            .compile(\"v4/(\\\\d+)/(blueprints|image_catalogs|recipes|stacks|distrox|cluster_templates)/(?:name|crn)/([^/]+)(/\\\\w+)?\");", "originalCommit": "11d41d542fd0ba45a56564a225c8d35955491775", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMzM5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465823392", "bodyText": "The RestUrlParserTest already catches this as part of the test.\ntestIfRestUrlParserMissing goes through every URL pattern defined in the controllers and makes sure all of the defined URLs have a parser.  So for every existing stack URla don't the new one get caught and the pattern applied to.  The reason for the change to V4ExistingResourceByCrnOrNameRestUrlParser.java was that the new URL pattern with crn and an action on the crn was failing.  So testIfRestUrlParserMissing checks all URL patterns against the V4ExistingResourceByCrnOrNameRestUrlParser Pattern.", "author": "wonderslug", "createdAt": "2020-08-05T15:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzOTA1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465839059", "bodyText": "thanks for clarification!", "author": "lacikaaa", "createdAt": "2020-08-05T16:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDcxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465820716", "bodyText": "nit: this is not necessary as safeFromString will throw an exception in case crn doesn't match the pattern, which enforces the accountid can't be empty.", "author": "lacikaaa", "createdAt": "2020-08-05T15:41:00Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentStackConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.environment.environment.service;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.common.exception.NotFoundException;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.flow.EnvironmentReactorFlowManager;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class EnvironmentStackConfigUpdateService {\n+    private final EnvironmentService environmentService;\n+\n+    private final EnvironmentReactorFlowManager reactorFlowManager;\n+\n+    public EnvironmentStackConfigUpdateService(\n+        EnvironmentService environmentService,\n+        EnvironmentReactorFlowManager reactorFlowManager) {\n+        this.environmentService = environmentService;\n+        this.reactorFlowManager = reactorFlowManager;\n+    }\n+\n+    public void updateAllStackConfigsByCrn(String envCrn) {\n+        String accountId = Crn.safeFromString(envCrn).getAccountId();\n+        if (accountId == null) {\n+            throw new NotFoundException(String.format(\"No account id found for crn '%s'\", envCrn));\n+        }", "originalCommit": "11d41d542fd0ba45a56564a225c8d35955491775", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyOTk4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r465829987", "bodyText": "this is not used", "author": "lacikaaa", "createdAt": "2020-08-05T15:54:32Z", "path": "environment-api/src/main/java/com/sequenceiq/environment/api/doc/environment/EnvironmentModelDescription.java", "diffHunk": "@@ -93,6 +93,7 @@\n \n     public static final String PROXYCONFIG_NAME = \"Name of the proxyconfig of the environment.\";\n     public static final String PROXYCONFIG_RESPONSE = \"ProxyConfig attached to the environment.\";\n+    public static final String UPDATE_STACKS_CONFIG = \"Update the configuration for all Stacks in the Environment.\";", "originalCommit": "11d41d542fd0ba45a56564a225c8d35955491775", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff8a03e38089f9448bb2464907a84ba7fbf2798a", "url": "https://github.com/hortonworks/cloudbreak/commit/ff8a03e38089f9448bb2464907a84ba7fbf2798a", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-05T16:04:22Z", "type": "forcePushed"}, {"oid": "557053d4030382c68c7cb7c905666337cb98f06f", "url": "https://github.com/hortonworks/cloudbreak/commit/557053d4030382c68c7cb7c905666337cb98f06f", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-05T21:08:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNDQ4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466224487", "bodyText": "I think this change broke the API compatibility", "author": "doktoric", "createdAt": "2020-08-06T08:10:29Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/stacks/StackV4Endpoint.java", "diffHunk": "@@ -293,11 +293,10 @@ FlowIdentifier updateSaltByName(@PathParam(\"workspaceId\") Long workspaceId, @Pat\n             @AccountId @QueryParam(\"accountId\") String accountId);\n \n     @PUT\n-    @Path(\"{name}/pillar_config_update\")\n+    @Path(\"crn/{crn}/pillar_config_update\")", "originalCommit": "557053d4030382c68c7cb7c905666337cb98f06f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI2ODUyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466268525", "bodyText": "in that case please leave here the original one, and it should throw an exception and have deprecated annotation", "author": "lacikaaa", "createdAt": "2020-08-06T09:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNzA0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466437041", "bodyText": "This was added by me in CB-6364 and is not used by anything other than this call from environment service.  It has not been pushed out and I think CRN is the proper way to go for specificity.\nAnd as we talked about here.\n#8640 (comment)", "author": "wonderslug", "createdAt": "2020-08-06T14:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg1MjgwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r466852809", "bodyText": "yes, but unfortunately if it's in the older branch we don't have a way to ignore this and even if we merge this, all the other PR will fail with this swagger issue. there will be a procedure to remove unused APIs, but currently the only thing we can do is to keep this one, in the implementation throw an exception, and create the right one with crn. I'm not happy with this, but there is no other way around it.", "author": "lacikaaa", "createdAt": "2020-08-07T06:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzQ1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8640#discussion_r467187459", "bodyText": "done", "author": "wonderslug", "createdAt": "2020-08-07T17:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNDQ4Nw=="}], "type": "inlineReview"}, {"oid": "bb77c7410d793e79c2074ca3d27a381f24e62ed2", "url": "https://github.com/hortonworks/cloudbreak/commit/bb77c7410d793e79c2074ca3d27a381f24e62ed2", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-06T18:38:45Z", "type": "forcePushed"}, {"oid": "2fee47ec14c94dde7bed5ad5b70737804efcccf9", "url": "https://github.com/hortonworks/cloudbreak/commit/2fee47ec14c94dde7bed5ad5b70737804efcccf9", "message": "code review", "committedDate": "2020-08-07T17:53:17Z", "type": "forcePushed"}, {"oid": "e409707ac32743d6e88bcd20a387b51811d59409", "url": "https://github.com/hortonworks/cloudbreak/commit/e409707ac32743d6e88bcd20a387b51811d59409", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-10T15:35:50Z", "type": "forcePushed"}, {"oid": "34cfb178fdfe216ca4bf24516fb552795658d178", "url": "https://github.com/hortonworks/cloudbreak/commit/34cfb178fdfe216ca4bf24516fb552795658d178", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-10T17:01:40Z", "type": "commit"}, {"oid": "34cfb178fdfe216ca4bf24516fb552795658d178", "url": "https://github.com/hortonworks/cloudbreak/commit/34cfb178fdfe216ca4bf24516fb552795658d178", "message": "CB-6363: Create an Env api and flow which updates the Envs Stacks pillar configs\n\nThis adds an API and flow to the environment service which allows for\nthe updating of all of a Environments Stacks pillar configs.\n\nThis is primarily needed for FreeIPA right now, when a FreeIPA DNS\nserver changes IP to allow all of the Clusters within an environment\nto update their DNS server IP addresses.\n\nThe APIs added are:\nPOST /v1/env/name/{name}/update_config\nPOST /v1/env/crn/{crn}/update_config\n\nThese do not have authorization on them and should only ever be\ncalled from internal to the Control Plane.  They kick off the\nEnvStackConfigUpdates Flow which collects all of the stacks for\nthe environment and calls the Cloudbreak API and Flow created in\nCB-6364.  It does not monitor these flows, it just keeps\nretrying until it successfully submits a request for the pillar configs\nto be updated.\n\nIf another call to update the configs for the stacks come in while\none is processing and retrying, it first call will be canceled and the\nsecond will start the process again for all stacks.  This is to make sure\nthat all stacks are updated for when the latest call comes in.\n\nIt will retry submitting pillar updates every 60 seconds for 120 tries.\nThis is to give enough time for current running flows to finish allows\nthe pillar configs update to catch up the stack that did have flows running.\n\nThis is covered by the one-pager here:\nhttps://docs.google.com/document/d/1ntWZF1WP9BVRU8mP9IEzFnN63-qggG9CNEImVbXjs9I", "committedDate": "2020-08-10T17:01:40Z", "type": "forcePushed"}]}