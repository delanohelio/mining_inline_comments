{"pr_number": 8651, "pr_title": "Flow documentation improvement", "pr_createdAt": "2020-07-27T17:17:54Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8651", "timeline": [{"oid": "29e4fbc4689b30a4f03c2d8e7e7c55c7dab52034", "url": "https://github.com/hortonworks/cloudbreak/commit/29e4fbc4689b30a4f03c2d8e7e7c55c7dab52034", "message": "Flow documentation improvement", "committedDate": "2020-07-28T06:06:34Z", "type": "forcePushed"}, {"oid": "1d1491fd22851beeb2fc03b6e36da7e23117554e", "url": "https://github.com/hortonworks/cloudbreak/commit/1d1491fd22851beeb2fc03b6e36da7e23117554e", "message": "Flow documentation improvement", "committedDate": "2020-07-28T06:43:44Z", "type": "forcePushed"}, {"oid": "6c65ce5c30a2b4971211711032278cb0cba0556c", "url": "https://github.com/hortonworks/cloudbreak/commit/6c65ce5c30a2b4971211711032278cb0cba0556c", "message": "Flow documentation improvement", "committedDate": "2020-07-31T10:58:38Z", "type": "forcePushed"}, {"oid": "fba8ae23b180ace4c3819a544cca690f69f265f6", "url": "https://github.com/hortonworks/cloudbreak/commit/fba8ae23b180ace4c3819a544cca690f69f265f6", "message": "Flow documentation improvement", "committedDate": "2020-07-31T11:11:38Z", "type": "forcePushed"}, {"oid": "845d3472d1e043f776e540cf0597e8d2be0f4dcf", "url": "https://github.com/hortonworks/cloudbreak/commit/845d3472d1e043f776e540cf0597e8d2be0f4dcf", "message": "Flow documentation improvement", "committedDate": "2020-08-03T07:49:51Z", "type": "forcePushed"}, {"oid": "8204babbde2c4e661f9efc5bfd1b8ca36e7216cb", "url": "https://github.com/hortonworks/cloudbreak/commit/8204babbde2c4e661f9efc5bfd1b8ca36e7216cb", "message": "Flow documentation improvement", "committedDate": "2020-08-03T12:17:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1MjEzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8651#discussion_r464952131", "bodyText": "*consume", "author": "lnardai", "createdAt": "2020-08-04T10:24:13Z", "path": "flow/README.md", "diffHunk": "@@ -51,13 +51,286 @@ You can implement the following interfaces for the flow to be more flexible:\n   - from the last state the finalize event will be sent automatically and the flow will be finished\n \n ## Example \"Hello world\" flow:\n-- HelloWordState: FlowState implementation\n-- HelloWorldEvent: FlowEvent implementation\n-- HelloWorldFlowConfig: flow configuration for the \"Hello world\" flow\n-- HelloWorldActions: Bean configurations for the abstract actions connected to the flow states\n-- HelloWorldContext: flow context for the \"Hello world\" flow\n-- Flow control event: HelloWorldFlowTriggerEvent, HelloWorldLongLastingTaskSuccessResponse, HelloWorldLongLastingTaskFailureResponse\n-- Reactor handler events: HelloWorldLongLAstingTaskTriggerEvent. Will send the flow control events with\n+#### Flow states\n+Lets define flow states for our flow. You have to implement *FlowState* interface and define your state enums.\n+\n+We will have the following states:\n+* INIT_STATE\n+* HELLO_WORLD_START_STATE\n+* HELLO_WORLD_FINISHED_STATE\n+* HELLO_WORLD_FAILED_STATE\n+* FINAL_STATE\n+\n+In code:\n+```java\n+public enum HelloWorldState implements FlowState {\n+   INIT_STATE,\n+   HELLO_WORLD_START_STATE,\n+   HELLO_WORLD_FINISHED_STATE,\n+   HELLO_WORLD_FAILED_STATE,\n+   FINAL_STATE\n+}\n+```\n+\n+You can define restart action for your flow, it will be used when you restart a failed flow. For example in data lake service we are using \n+*FillInMemoryStateStoreRestartAction*. It will update the data lake\u2019s status in the *DatalakeInMemoryStateStore* to *CANCELLED* or *POLLABLE* based on the status. \n+We are using this to cancel running flows. If you have a data lake install flow and it is polling cloudbreak for stack status, then if you send a terminate \n+request we shall cancel the installation flow. It happens through this in-memory store. \n+\n+You can override restartAction this way:\n+```java\n+   @Override\n+   public Class<? extends RestartAction> restartAction() {\n+       return FillInMemoryStateStoreRestartAction.class;\n+   }\n+```\n+\n+#### Flow events\n+Events will be sent to flow engine. Flow will change it\u2019s states on these events.\n+```java\n+public enum HelloWorldEvent implements FlowEvent {\n+   HELLOWORLD_TRIGGER_EVENT,\n+   HELLOWORLD_FINISHED_EVENT,\n+   FINALIZE_HELLOWORLD_EVENT,\n+   HELLOWORLD_SOMETHING_WENT_WRONG,\n+   HELLOWORLD_FAILHANDLED_EVENT;\n+\n+   private String selector;\n+\n+   HelloWorldEvent() {\n+       this.selector = name();\n+   }\n+\n+   @Override\n+   public String event() {\n+       return selector;\n+   }\n+}\n+```\n+#### Flow config\n+We have to define which state follows which state. For this reason you have to implement a Flow config. It extends from *AbstractFlowConfiguration*. \n+If you want it to be retryable, then implement *RetryableFlowConfiguration*.\n+\n+First define transition with *Transition.Builder* class. It is a generic class with two type. First type is the state enum, second type is the event enum. \n+Define the default failure event, in our case it is *HELLOWORLD_SOMETHING_WENT_WRONG*. Then you can define state changes in your flow. Every state changes needs \n+a from - to on which event and what event will be triggered on failure. It can be the *defaultFailureEvent* or you can define a specific failure event like \n+*HELLOWORLD_FIRST_STEP_WENT_WRONG_EVENT* in the second step.\n+\n+You have to define flow edge config, it will define what is your init and final state, the default failure state and the fail handled event. \n+We need fail handled event for restart. If this event arrives it means we handled failure correctly so it can be restarted.\n+\n+*getEvents* method should return your events, *getInitEvents* should return your initial event(s) and *getRetryableEvent* returns the event we can recover from.\n+```java\n+@Component\n+public class HelloWorldFlowConfig extends AbstractFlowConfiguration<HelloWorldState, HelloWorldEvent> implements RetryableFlowConfiguration<HelloWorldEvent> {\n+   private static final List<Transition<HelloWorldState, HelloWorldEvent>> TRANSITIONS = new Transition.Builder<HelloWorldState, HelloWorldEvent>()\n+           .defaultFailureEvent(HELLOWORLD_SOMETHING_WENT_WRONG)\n+\n+           .from(INIT_STATE)\n+           .to(HELLO_WORLD_FIRST_STEP_STATE)\n+           .event(HELLOWORLD_TRIGGER_EVENT)\n+           .noFailureEvent()\n+\n+           .from(HELLO_WORLD_FIRST_STEP_STATE)\n+           .to(HELLO_WORLD_SECOND_STEP_STATE)\n+           .event(HELLOWORLD_FIRST_STEP_FINISHED_EVENT)\n+           .failureEvent(HELLOWORLD_FIRST_STEP_WENT_WRONG_EVENT)\n+\n+           .from(HELLO_WORLD_SECOND_STEP_STATE)\n+           .to(HELLO_WORLD_FINISHED_STATE)\n+           .event(HELLOWORLD_SECOND_STEP_FINISHED_EVENT)\n+           .defaultFailureEvent()\n+\n+           .from(HELLO_WORLD_FINISHED_STATE)\n+           .to(FINAL_STATE)\n+           .event(FINALIZE_HELLOWORLD_EVENT)\n+           .defaultFailureEvent()\n+           .build();\n+\n+   private static final FlowEdgeConfig<HelloWorldState, HelloWorldEvent> EDGE_CONFIG = new FlowEdgeConfig<>(INIT_STATE, FINAL_STATE, HELLO_WORLD_FAILED_STATE, HELLOWORLD_FAILHANDLED_EVENT);\n+\n+   public HelloWorldFlowConfig() {\n+       super(HelloWorldState.class, HelloWorldEvent.class);\n+   }\n+\n+   @Override\n+   public HelloWorldEvent[] getEvents() {\n+       return HelloWorldEvent.values();\n+   }\n+\n+   @Override\n+   public HelloWorldEvent[] getInitEvents() {\n+       return new HelloWorldEvent[] {\n+               HELLOWORLD_TRIGGER_EVENT\n+       };\n+   }\n+\n+   @Override\n+   public String getDisplayName() {\n+       return \"Hello world\";\n+   }\n+\n+   @Override\n+   public HelloWorldEvent getRetryableEvent() {\n+       return HELLOWORLD_FAILHANDLED_EVENT;\n+   }\n+\n+   @Override\n+   protected List<Transition<HelloWorldState, HelloWorldEvent>> getTransitions() {\n+       return TRANSITIONS;\n+   }\n+\n+   @Override\n+   protected FlowEdgeConfig<HelloWorldState, HelloWorldEvent> getEdgeConfig() {\n+       return EDGE_CONFIG;\n+   }\n+}\n+```\n+#### Actions\n+We will implement the actions for flow states. Let\u2019s see first state *HELLO_WORLD_FIRST_STEP_STATE*. In flow config we have the following lines: \n+```java\n+.from(INIT_STATE)\n+.to(HELLO_WORLD_FIRST_STEP_STATE)\n+.event(HELLOWORLD_TRIGGER_EVENT)\n+```\n+So flow will move from *INIT_STATE* to *HELLO_WORLD_FIRST_STEP_STATE* when *HELLOWORLD_TRIGGER_EVENT* arrives. This is how you can move from one state to another. \n+As you can remember in *FlowEdgeConfig* we defined the start event for our new flow:  \n+```java\n+@Override\n+public HelloWorldEvent[] getInitEvents() {\n+   return new HelloWorldEvent[] {\n+           HELLOWORLD_TRIGGER_EVENT\n+   };\n+}\n+```\n+We will implement actions in *HelloWorldActions* class. You can see below we have a Bean with name *HELLO_WORLD_FIRST_STEP_STATE*. This is the first action in \n+our flow. In doExecute you can do the implementation for this state. This time we just print a log message and send an \n+*HelloWorldFirstStepLongLastingTaskTriggerEvent*, but why we do this? This is where handlers come into picture.\n+```java\n+@Configuration\n+public class HelloWorldActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HelloWorldActions.class);\n+\n+    @Bean(name = \"HELLO_WORLD_FIRST_STEP_STATE\")\n+    public Action<?, ?> firstStep() {\n+        return new AbstractHelloWorldAction<>(HelloWorldFlowTrigger.class) {\n+            @Override\n+            protected void doExecute(HelloWorldContext context, HelloWorldFlowTrigger payload, Map<Object, Object> variables) {\n+                LOGGER.info(\"Hello world first step in progress, we are sending an event for a handler, because it is a long lasting task\");\n+                HelloWorldFirstStepLongLastingTaskTriggerEvent taskTriggerEvent = new HelloWorldFirstStepLongLastingTaskTriggerEvent(payload.getResourceId());\n+                sendEvent(context, taskTriggerEvent);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"HELLO_WORLD_FIRST_STEP_FAILED_STATE\")\n+    public Action<?, ?> firstStepFailedAction() {\n+        return new AbstractHelloWorldAction<>(HelloWorldFirstStepLongLastingTaskFailureResponse.class) {\n+\n+            @Override\n+            protected void doExecute(HelloWorldContext context, HelloWorldFirstStepLongLastingTaskFailureResponse payload, Map<Object, Object> variables) {\n+                sendEvent(context, HELLOWORLD_FAILHANDLED_EVENT.event(), payload);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"HELLO_WORLD_SECOND_STEP_STATE\")\n+    public Action<?, ?> secondStep() {\n+        return new AbstractHelloWorldAction<>(HelloWorldFirstStepLongLastingTaskSuccessResponse.class) {\n+            @Override\n+            protected void doExecute(HelloWorldContext context, HelloWorldFirstStepLongLastingTaskSuccessResponse payload, Map<Object, Object> variables) {\n+                LOGGER.info(\"Hello world second step in progress..\");\n+                HelloWorldSecondStepSuccessful helloWorldSecondStepSuccessful = new HelloWorldSecondStepSuccessful(payload.getResourceId());\n+                sendEvent(context, HELLOWORLD_SECOND_STEP_FINISHED_EVENT.event(), helloWorldSecondStepSuccessful);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"HELLO_WORLD_FINISHED_STATE\")\n+    public Action<?, ?> finishedAction() {\n+        return new AbstractHelloWorldAction<>(HelloWorldSecondStepSuccessful.class) {\n+            @Override\n+            protected void doExecute(HelloWorldContext context, HelloWorldSecondStepSuccessful payload, Map<Object, Object> variables) {\n+                LOGGER.info(\"Hello world finished!\");\n+                sendEvent(context, FINALIZE_HELLOWORLD_EVENT.event(), payload);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"HELLO_WORLD_FAILED_STATE\")\n+    public Action<?, ?> failedAction() {\n+        return new AbstractHelloWorldAction<>(HelloWorldFailedEvent.class) {\n+\n+            @Override\n+            protected void doExecute(HelloWorldContext context, HelloWorldFailedEvent payload, Map<Object, Object> variables) {\n+                sendEvent(context, HELLOWORLD_FAILHANDLED_EVENT.event(), payload);\n+            }\n+        };\n+    }\n+\n+    private abstract static class AbstractHelloWorldAction<P extends Payload> extends AbstractAction<HelloWorldState, HelloWorldEvent, HelloWorldContext, P> {\n+\n+        protected AbstractHelloWorldAction(Class<P> payloadClass) {\n+            super(payloadClass);\n+        }\n+\n+        @Override\n+        protected HelloWorldContext createFlowContext(FlowParameters flowParameters, StateContext<HelloWorldState, HelloWorldEvent> stateContext, P payload) {\n+            return new HelloWorldContext(flowParameters);\n+        }\n+\n+        @Override\n+        protected Object getFailurePayload(P payload, Optional<HelloWorldContext> flowContext, Exception ex) {\n+            return new HelloWorldFailedEvent(payload.getResourceId(), ex);\n+        }\n+    }\n+}\n+```\n+*getFailurePayload* method is called when somehow an unexpected exception happens in your action's *doExecute*. It should return with your failure payload, \n+usually it contains an exception.\n+#### Handlers\n+If you have to do something that can takes long time, like a remote call or polling something, then you shouldn\u2019t do it in an action\u2019s *doExecute* method. \n+If you do this then it will consump one reactor thread and after a while it can happen there will be no available threads for reactor to process events for new ", "originalCommit": "8204babbde2c4e661f9efc5bfd1b8ca36e7216cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "228f3c8f2201852cc967379ab984a67185d8152a", "url": "https://github.com/hortonworks/cloudbreak/commit/228f3c8f2201852cc967379ab984a67185d8152a", "message": "Flow documentation improvement", "committedDate": "2020-08-04T10:37:19Z", "type": "forcePushed"}, {"oid": "0cde96b7dbfc7c94fac764c482c7e5e0b4c201be", "url": "https://github.com/hortonworks/cloudbreak/commit/0cde96b7dbfc7c94fac764c482c7e5e0b4c201be", "message": "Flow documentation improvement", "committedDate": "2020-08-04T11:21:04Z", "type": "forcePushed"}, {"oid": "a22155a10908d15ea0c5ab717a646e599e76c169", "url": "https://github.com/hortonworks/cloudbreak/commit/a22155a10908d15ea0c5ab717a646e599e76c169", "message": "Flow documentation improvement", "committedDate": "2020-08-04T12:13:09Z", "type": "forcePushed"}, {"oid": "50445d6ba5b554b1dfd52313e43f313eb1789f42", "url": "https://github.com/hortonworks/cloudbreak/commit/50445d6ba5b554b1dfd52313e43f313eb1789f42", "message": "Flow documentation improvement", "committedDate": "2020-08-05T07:26:13Z", "type": "forcePushed"}, {"oid": "cb99cf3b1a5e064bcaeac47125ca96db927e6c33", "url": "https://github.com/hortonworks/cloudbreak/commit/cb99cf3b1a5e064bcaeac47125ca96db927e6c33", "message": "Flow documentation improvement", "committedDate": "2020-08-05T07:36:52Z", "type": "commit"}, {"oid": "cb99cf3b1a5e064bcaeac47125ca96db927e6c33", "url": "https://github.com/hortonworks/cloudbreak/commit/cb99cf3b1a5e064bcaeac47125ca96db927e6c33", "message": "Flow documentation improvement", "committedDate": "2020-08-05T07:36:52Z", "type": "forcePushed"}]}