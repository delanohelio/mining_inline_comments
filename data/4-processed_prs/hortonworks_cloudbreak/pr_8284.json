{"pr_number": 8284, "pr_title": "CB-7215 Add CB service changes to perform database backup/restore", "pr_createdAt": "2020-06-15T19:59:47Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8284", "timeline": [{"oid": "978bcb1fb5b6050ec1d522ad92158859e5f8bc18", "url": "https://github.com/hortonworks/cloudbreak/commit/978bcb1fb5b6050ec1d522ad92158859e5f8bc18", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nThis change conflict with the change for CB-7212, and can't be merged in until\nCB-7212 has been merged in and the conflicts resolved.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-15T21:02:09Z", "type": "forcePushed"}, {"oid": "98f1ede0554e56d2556c95d4fcc6da4f39fd626e", "url": "https://github.com/hortonworks/cloudbreak/commit/98f1ede0554e56d2556c95d4fcc6da4f39fd626e", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nThis change conflict with the change for CB-7212, and can't be merged in until\nCB-7212 has been merged in and the conflicts resolved.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-17T15:02:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1Nzk1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442457954", "bodyText": "The FreeIPA management service uses an operation service to allocate operation IDs rather than just returning the flow ID. That way you can check the status of the operation. I would recommend checking to see if StackOperationService or ClusterOperationService should be used here.\nThe same thing applies to restoreDatabaseByName().", "author": "jamisonbennett", "createdAt": "2020-06-18T19:37:28Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java", "diffHunk": "@@ -197,11 +197,15 @@ public FlowIdentifier updateSaltByName(Long workspaceId, String name) {\n \n     @Override\n     public BackupV4Response backupDatabaseByName(Long workspaceId, String name, String backupLocation, String backupId) {\n-        return null;\n+        FlowIdentifier flowIdentifier =\n+            stackOperations.backupClusterDatabase(NameOrCrn.ofName(name), workspaceId, backupLocation, backupId);\n+        return new BackupV4Response(flowIdentifier);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMDQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442830490", "bodyText": "@jamisonbennett we are using a similar approach for this.\nHere is the flow Datalake-dr service -> datalake Service -> CB Service.\nDatalake service returns an operation id that can used to poll the status. Datalake service keeps polling for the stack status and will update the operation status accordingly.", "author": "kkalvagadda1", "createdAt": "2020-06-19T13:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1Nzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzOTg0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443039842", "bodyText": "What is the difference between an operation and a flow? Is there a has-a or is-a relationship between them? Or are they different notions of a thing going on in the datalake?", "author": "brycederriso", "createdAt": "2020-06-19T20:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1Nzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2MTIxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443361213", "bodyText": "operation(id) was introduced by @handavid in FreeIPA for usersync as it's not running in a flow, and back then flowid wasn't present on the api. So if you are running a flow it should be enough to expose flowid", "author": "lacikaaa", "createdAt": "2020-06-22T07:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1Nzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Mzk1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442463951", "bodyText": "nit: It looks like 2 of the 3 the derived classes implement getFailurePayload() returning null. If you move that here it will remove the redundant code.", "author": "jamisonbennett", "createdAt": "2020-06-18T19:47:15Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/restore/AbstractDatabaseRestoreAction.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.flow.core.AbstractAction;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowState;\n+\n+public abstract class AbstractDatabaseRestoreAction<P extends Payload>", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4ODEyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442888126", "bodyText": "Same as the other comment about getFailurePayload().", "author": "hreeve-cloudera", "createdAt": "2020-06-19T14:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Mzk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0MzE1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443443150", "bodyText": "same as for backup part", "author": "lacikaaa", "createdAt": "2020-06-22T09:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Mzk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDI0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442464249", "bodyText": "nit: It looks like 2 of the 3 the derived classes implement getFailurePayload() returning null. If you move that here it will remove the redundant code.", "author": "jamisonbennett", "createdAt": "2020-06-18T19:47:52Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/backup/AbstractDatabaseBackupAction.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.flow.core.AbstractAction;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowState;\n+\n+public abstract class AbstractDatabaseBackupAction<P extends Payload>", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4NzcyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442887728", "bodyText": "The code isn't technically redundant, because one has the signature getFailurePayload(DatabaseBackupSuccess payload...) and the other has the signature getFailurePayload(DatabaseBackupFailedEvent payload...). I tried replacing them with a generic getFailurePayload(StackEvent payload...) method here, but that doesn't work.", "author": "hreeve-cloudera", "createdAt": "2020-06-19T14:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzOTM0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443439341", "bodyText": "you could use the payload and add it here so you won't have to implement there", "author": "lacikaaa", "createdAt": "2020-06-22T09:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMjEzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442832136", "bodyText": "Your project setting could be different. That is any the imports are re-ordered. Can you check?", "author": "kkalvagadda1", "createdAt": "2020-06-19T13:12:14Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/stacks/StackV4Endpoint.java", "diffHunk": "@@ -1,5 +1,45 @@\n package com.sequenceiq.cloudbreak.api.endpoint.v4.stacks;\n \n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.ClusterRepairV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.MaintenanceModeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackScaleV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.UpdateClusterV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.UserNamePasswordV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.GeneratedBlueprintV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.RetryableFlowResponse;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackStatusV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackViewV4Responses;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.dr.BackupV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.dr.RestoreV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeOptionV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeV4Response;\n+import com.sequenceiq.cloudbreak.doc.Notes;\n+import com.sequenceiq.cloudbreak.doc.OperationDescriptions.StackOpDescription;\n+import com.sequenceiq.cloudbreak.jerseyclient.RetryAndMetrics;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import java.util.List;\n+import java.util.Set;\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotEmpty;\n+import javax.validation.constraints.NotNull;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.MediaType;\n+", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4MjMzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442882333", "bodyText": "I've followed the instructions in the cloudbreak README.md to import all the Intellij settings it asked me to, and this is how my IDE re-orders the imports. I can't change it; if I try to move the imports at all it will automatically move them back. My IDE didn't do this before I imported the cloudbreak project settings, so I'm not sure what to do about it now.", "author": "hreeve-cloudera", "createdAt": "2020-06-19T14:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMjEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4MzE4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442883186", "bodyText": "The original authors might not have had those imports, so it could be normal that you will get a reordering.", "author": "gergopapi2", "createdAt": "2020-06-19T14:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMjEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5NjMxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442896313", "bodyText": "My IDE reorders the imports of any file I add new imports to. That's okay if it's reordering it to what the imports are supposed to look like. And I imported the cloudbreak settings so I have to assume it is. But it's not just new imports, it's all imports in the file.", "author": "hreeve-cloudera", "createdAt": "2020-06-19T15:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMjEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTE0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442871140", "bodyText": "It should be BACKUP_IN_PROGRESS", "author": "kkalvagadda1", "createdAt": "2020-06-19T14:25:32Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Service;\n+\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FINISHED;\n+\n+@Service\n+public class BackupRestoreStatusService {\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    public void backupDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database backup \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTYzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442871637", "bodyText": "It applies to both updateClusterStatusByStackId and fireEventAndLog.", "author": "kkalvagadda1", "createdAt": "2020-06-19T14:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTk3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442871973", "bodyText": "Status should be BACKUP_FAILED.", "author": "kkalvagadda1", "createdAt": "2020-06-19T14:27:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Service;\n+\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FINISHED;\n+\n+@Service\n+public class BackupRestoreStatusService {\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    public void backupDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database backup \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_IN_PROGRESS.name(), DATALAKE_DATABASE_BACKUP);\n+    }\n+\n+    public void backupDatabaseFinished(long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_FINISHED, \"Database was successfully backed up.\");\n+        clusterService.updateClusterStatusByStackId(stackId, Status.AVAILABLE);\n+        flowMessageService.fireEventAndLog(stackId, Status.AVAILABLE.name(), DATALAKE_DATABASE_BACKUP_FINISHED);\n+    }\n+\n+    public void handleDatabaseBackupFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_FAILED, errorReason);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_BACKUP_FAILED, errorReason);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MjIyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442872224", "bodyText": "Should be RESTORE_IN_PROGRESS", "author": "kkalvagadda1", "createdAt": "2020-06-19T14:27:27Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Service;\n+\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FINISHED;\n+\n+@Service\n+public class BackupRestoreStatusService {\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    public void backupDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database backup \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_IN_PROGRESS.name(), DATALAKE_DATABASE_BACKUP);\n+    }\n+\n+    public void backupDatabaseFinished(long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_FINISHED, \"Database was successfully backed up.\");\n+        clusterService.updateClusterStatusByStackId(stackId, Status.AVAILABLE);\n+        flowMessageService.fireEventAndLog(stackId, Status.AVAILABLE.name(), DATALAKE_DATABASE_BACKUP_FINISHED);\n+    }\n+\n+    public void handleDatabaseBackupFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_FAILED, errorReason);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_BACKUP_FAILED, errorReason);\n+    }\n+\n+    public void restoreDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database restore \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_IN_PROGRESS.name(), DATALAKE_DATABASE_RESTORE);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MjQ1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442872458", "bodyText": "Should be RESTORE_FAILED", "author": "kkalvagadda1", "createdAt": "2020-06-19T14:27:51Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Service;\n+\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_BACKUP_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.DATALAKE_DATABASE_RESTORE_FINISHED;\n+\n+@Service\n+public class BackupRestoreStatusService {\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    public void backupDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database backup \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_IN_PROGRESS.name(), DATALAKE_DATABASE_BACKUP);\n+    }\n+\n+    public void backupDatabaseFinished(long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_FINISHED, \"Database was successfully backed up.\");\n+        clusterService.updateClusterStatusByStackId(stackId, Status.AVAILABLE);\n+        flowMessageService.fireEventAndLog(stackId, Status.AVAILABLE.name(), DATALAKE_DATABASE_BACKUP_FINISHED);\n+    }\n+\n+    public void handleDatabaseBackupFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_FAILED, errorReason);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_BACKUP_FAILED, errorReason);\n+    }\n+\n+    public void restoreDatabase(long stackId, String backupId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_BACKUP_IN_PROGRESS, \"Initiating database restore \" + backupId);\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_IN_PROGRESS);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_IN_PROGRESS.name(), DATALAKE_DATABASE_RESTORE);\n+    }\n+\n+    public void restoreDatabaseFinished(long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.DATABASE_RESTORE_FINISHED, \"Database was successfully restored.\");\n+        clusterService.updateClusterStatusByStackId(stackId, Status.AVAILABLE);\n+        flowMessageService.fireEventAndLog(stackId, Status.AVAILABLE.name(), DATALAKE_DATABASE_RESTORE_FINISHED);\n+    }\n+\n+    public void handleDatabaseRestoreFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n+        clusterService.updateClusterStatusByStackId(stackId, Status.UPDATE_FAILED, errorReason);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_RESTORE_FAILED, errorReason);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MTY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442891692", "bodyText": "I think final states should be mapped to Status.AVAILABLE. I think if the state is not available state, no other can be run on it after that.", "author": "kkalvagadda1", "createdAt": "2020-06-19T15:02:20Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/common/DetailedStackStatus.java", "diffHunk": "@@ -73,7 +73,14 @@\n \n     CLUSTER_MANAGER_UPGRADE_FAILED(Status.AVAILABLE),\n     CLUSTER_UPGRADE_FAILED(Status.AVAILABLE),\n-    CLUSTER_UPGRADE_FINISHED(Status.AVAILABLE);\n+    CLUSTER_UPGRADE_FINISHED(Status.AVAILABLE),\n+    // Database backup/restore statuses\n+    DATABASE_BACKUP_IN_PROGRESS(Status.BACKUP_IN_PROGRESS),\n+    DATABASE_BACKUP_FINISHED(Status.BACKUP_FINISHED),\n+    DATABASE_BACKUP_FAILED(Status.BACKUP_FAILED),\n+    DATABASE_RESTORE_IN_PROGRESS(Status.RESTORE_IN_PROGRESS),\n+    DATABASE_RESTORE_FINISHED(Status.RESTORE_FINISHED),\n+    DATABASE_RESTORE_FAILED(Status.RESTORE_FAILED);", "originalCommit": "55021251ac918a73f2bab1115e9a5d6fa212f570", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDYxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442904612", "bodyText": "I think, regardless of the result, status should be mapped to Status.AVAILABLE.", "author": "kkalvagadda1", "createdAt": "2020-06-19T15:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk0NjU1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r442946554", "bodyText": "Status.AVAILABLE has a StatusKind of StatusKind.FINAL. The FINISHED and FAILED enums here also have StatusKind.FINAL, which I believe indicates they're done and will put the cluster back into a state where additional operations can be run. I did run multiple backups on the same cluster as part of my testing, so each one did seem to be getting resolved.", "author": "hreeve-cloudera", "createdAt": "2020-06-19T16:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NjY3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443056671", "bodyText": "I'm of the opinion that correctly handling paths is scary/hard, but this also decently easy to test.\nCould you run some unit tests against the scheme or fullLocation handling?\nRefactoring to something like:\npublic static SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) {\n        String fullLocation = buildFullLocation(location, backupId, cloudPlatform); // test me\n\n        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n        return new SaltConfig(servicePillar);\n    }\n\npublic static String buildFullLocation (String location, String backupId, String cloudPlatform) {\n        String fullLocation = location + \"/\" + backupId + \"_database_backup\";\n        String scheme;\n        if (\"aws\".equalsIgnoreCase(cloudPlatform)) {\n            scheme = \"s3:/\";\n        } else if (\"azure\".equalsIgnoreCase(cloudPlatform)) {\n            // TODO verify this is right when azure flow is working\n            scheme = \"abfs:/\";\n        } else {\n            throw new UnsupportedOperationException(\"Cloud platform \" + cloudPlatform + \"not supported for backup/restore\");\n        }\n\n        if (fullLocation.startsWith(\"/\")) {\n            fullLocation = scheme + fullLocation;\n        } else {\n            fullLocation = scheme + fullLocation.substring(fullLocation.indexOf(\"//\") + 1);\n        }\n        return fullLocation;\n}", "author": "brycederriso", "createdAt": "2020-06-19T21:50:25Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/HandlerMethods.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public class HandlerMethods {\n+\n+    private HandlerMethods() {\n+\n+    }\n+\n+    public static SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) {", "originalCommit": "c4e96284d23b4725ffd3eca4bca167b68950deb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443058874", "bodyText": "I can write some unit tests around that, but am I handling paths incorrectly here? Outside of the requested refactor?", "author": "hreeve-cloudera", "createdAt": "2020-06-19T21:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NjY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEzNzgzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443137830", "bodyText": "I don't think we handle a relative path like bucket/backups correctly here:\nfullLocation = scheme + fullLocation.substring(fullLocation.indexOf(\"//\") + 1);\nWe'd get s3:/bucket/backups, right? I'm not sure how resilient this method needs to be.\nTo be pedantic, we may want to define the schemes without the slash to follow the URI specification, if we ever do try to use them with the URI constructor I think it would blow up.\nI'd consider using the URI class to at least guarantee that we have a valid URI coming out of this, though it may not be a valid s3/abfs/hdfs uri.", "author": "brycederriso", "createdAt": "2020-06-20T15:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NjY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjkyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443156928", "bodyText": "I was using the URI class originally, but it wasn't doing exactly what I wanted so I changed it. That's no excuse for not digging into what I was doing wrong though :). I've updated the code to use URIs and added unit tests around it.", "author": "hreeve-cloudera", "createdAt": "2020-06-20T20:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NjY3MQ=="}], "type": "inlineReview"}, {"oid": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "url": "https://github.com/hortonworks/cloudbreak/commit/e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "message": "Adding HandlerMethodsTest", "committedDate": "2020-06-20T20:24:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzNzkwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443437906", "bodyText": "is this really necessary?", "author": "lacikaaa", "createdAt": "2020-06-22T09:40:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/backup/DatabaseBackupActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseBackupTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup.DatabaseBackupEvent.DATABASE_BACKUP_FAILED_EVENT;\n+\n+@Configuration\n+public class DatabaseBackupActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_BACKUP_STATE\")\n+    public Action<?, ?> backupDatabase() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupTriggerEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupTriggerEvent payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseBackupRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseBackupFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FINISHED_STATE\")\n+    public Action<?, ?> databaseBackupFinished() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupSuccess.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupSuccess payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, null, null);\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupSuccess payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabaseFinished(context.getStackId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new StackEvent(DatabaseBackupEvent.DATABASE_BACKUP_FINALIZED_EVENT.event(), context.getStackId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupSuccess payload, Optional<BackupRestoreContext> flowContext, Exception ex) {", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzODI0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443438247", "bodyText": "same, I don't think this is necessary", "author": "lacikaaa", "createdAt": "2020-06-22T09:40:48Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/backup/DatabaseBackupActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseBackupTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup.DatabaseBackupEvent.DATABASE_BACKUP_FAILED_EVENT;\n+\n+@Configuration\n+public class DatabaseBackupActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_BACKUP_STATE\")\n+    public Action<?, ?> backupDatabase() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupTriggerEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupTriggerEvent payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseBackupRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseBackupFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FINISHED_STATE\")\n+    public Action<?, ?> databaseBackupFinished() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupSuccess.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupSuccess payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, null, null);\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupSuccess payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabaseFinished(context.getStackId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new StackEvent(DatabaseBackupEvent.DATABASE_BACKUP_FINALIZED_EVENT.event(), context.getStackId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupSuccess payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FAILED_STATE\")\n+    public Action<?, ?> databaseBackupFailedAction() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupFailedEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupFailedEvent payload) {\n+                Flow flow = getFlow(flowParameters.getFlowId());\n+                Stack stack = stackService.getById(payload.getResourceId());\n+                MDCBuilder.buildMdcContext(stack);\n+                flow.setFlowFailed(payload.getException());\n+                return BackupRestoreContext.from(flowParameters, payload, null, null);\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupFailedEvent payload, Map<Object, Object> variables) throws Exception {\n+                backupRestoreStatusService.handleDatabaseBackupFailure(context.getStackId(), payload.getException().getMessage(), payload.getDetailedStatus());\n+                sendEvent(context, DATABASE_BACKUP_FAILED_EVENT.event(), payload);\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupFailedEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0MDcwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443440702", "bodyText": "default context creation should go into abstract action", "author": "lacikaaa", "createdAt": "2020-06-22T09:45:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/backup/DatabaseBackupActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseBackupTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup.DatabaseBackupEvent.DATABASE_BACKUP_FAILED_EVENT;\n+\n+@Configuration\n+public class DatabaseBackupActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_BACKUP_STATE\")\n+    public Action<?, ?> backupDatabase() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupTriggerEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupTriggerEvent payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseBackupRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseBackupFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FINISHED_STATE\")\n+    public Action<?, ?> databaseBackupFinished() {\n+        return new AbstractDatabaseBackupAction<>(DatabaseBackupSuccess.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0MzU1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443443551", "bodyText": "same as for backup, general context creation should go into abstract", "author": "lacikaaa", "createdAt": "2020-06-22T09:50:23Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/restore/DatabaseRestoreActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseRestoreTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.restore.DatabaseRestoreEvent.DATABASE_RESTORE_FAILED_EVENT;\n+\n+@Configuration\n+public class DatabaseRestoreActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_RESTORE_STATE\")\n+    public Action<?, ?> restoreDatabase() {\n+        return new AbstractDatabaseRestoreAction<>(DatabaseRestoreTriggerEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseRestoreTriggerEvent payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseRestoreTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.restoreDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseRestoreRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseRestoreTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseRestoreFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_RESTORE_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_RESTORE_FINISHED_STATE\")\n+    public Action<?, ?> databaseRestoreFinished() {\n+        return new AbstractDatabaseRestoreAction<>(DatabaseRestoreSuccess.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NDA4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443444081", "bodyText": "I think context should be set by flow core here (same applies to backup). Is there a reason you added it here?", "author": "lacikaaa", "createdAt": "2020-06-22T09:51:15Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/restore/DatabaseRestoreActions.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseRestoreTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.restore.DatabaseRestoreEvent.DATABASE_RESTORE_FAILED_EVENT;\n+\n+@Configuration\n+public class DatabaseRestoreActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_RESTORE_STATE\")\n+    public Action<?, ?> restoreDatabase() {\n+        return new AbstractDatabaseRestoreAction<>(DatabaseRestoreTriggerEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseRestoreTriggerEvent payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseRestoreTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.restoreDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseRestoreRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseRestoreTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseRestoreFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_RESTORE_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_RESTORE_FINISHED_STATE\")\n+    public Action<?, ?> databaseRestoreFinished() {\n+        return new AbstractDatabaseRestoreAction<>(DatabaseRestoreSuccess.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseRestoreSuccess payload) {\n+                return BackupRestoreContext.from(flowParameters, payload, null, null);\n+            }\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseRestoreSuccess payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.restoreDatabaseFinished(context.getStackId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new StackEvent(DatabaseRestoreEvent.DATABASE_RESTORE_FINALIZED_EVENT.event(), context.getStackId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseRestoreSuccess payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_RESTORE_FAILED_STATE\")\n+    public Action<?, ?> databaseRestoreFailedAction() {\n+        return new AbstractDatabaseRestoreAction<>(DatabaseRestoreFailedEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseRestoreFailedEvent payload) {\n+                Flow flow = getFlow(flowParameters.getFlowId());\n+                Stack stack = stackService.getById(payload.getResourceId());\n+                MDCBuilder.buildMdcContext(stack);", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU5ODE3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443598176", "bodyText": "I'm not sure what you mean. I was using the the ClusterUpgradeActions class as a base, and basically copied what it did for failures. This is my first time working in this code, so I don't have the context for why everything I was looking at as an example works the way it does. Do you have an example of what you mean?", "author": "hreeve-cloudera", "createdAt": "2020-06-22T14:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAzNTE1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444035153", "bodyText": "I also had to check this. So what I found:\n\nif you use ErrorHandlerAwareReactorEventFactory it will set MdcContext in the headers and flow engine will persist this\nif the above is set then LogContextAspects will load it and set it when a flow step is starting\nif we would like to set it, we usually do it in the context creation part, which is in the flow's abstract action in most cases, as it is the same throughout that flow\n\nif I were you I would remove that MDCBuilder line and check the logs, and check them with it, to see if there is any difference", "author": "lacikaaa", "createdAt": "2020-06-23T07:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5MTE3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446091175", "bodyText": "if you fix the MdcContext when triggering the flow this MDCContext build here could be omitted I think", "author": "lacikaaa", "createdAt": "2020-06-26T10:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NTQwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443445402", "bodyText": "Can we drop the static methods and convert this to a component and use it with inject?", "author": "lacikaaa", "createdAt": "2020-06-22T09:53:31Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/HandlerMethods.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public class HandlerMethods {", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NTUzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443445537", "bodyText": "also rename this please", "author": "lacikaaa", "createdAt": "2020-06-22T09:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NTQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0Nzk4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443447982", "bodyText": "I don't think UnsupportedOperationException is the right one here\nalso we usually put cloud platform dependent stuff into cloud modules so we have mostly generic parts here", "author": "lacikaaa", "createdAt": "2020-06-22T09:57:56Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/HandlerMethods.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public class HandlerMethods {\n+\n+    private HandlerMethods() {\n+\n+    }\n+\n+    public static SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        String fullLocation = buildFullLocation(location, backupId, cloudPlatform);\n+\n+        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n+        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n+            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n+        return new SaltConfig(servicePillar);\n+    }\n+\n+    public static String buildFullLocation(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        URI uri = new URI(location);\n+        String fullLocation;\n+        if (\"aws\".equalsIgnoreCase(cloudPlatform)) {\n+            if (uri.getScheme() != null && !uri.getScheme().startsWith(\"s3\")) {\n+                throw new UnsupportedOperationException(\"Incorrect URL scheme for AWS cloud platform: \" + location);", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMjUwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443602501", "bodyText": "Why do you think UnsupportedOperationException isn't the right exception here?\nI don't know enough about the cloudbreak codebase to know how to address your comment about the cloud modules. What do you want me to do there?", "author": "hreeve-cloudera", "createdAt": "2020-06-22T14:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0Nzk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTYzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r445171635", "bodyText": "This is now being handled by BackupRestoreV4RequestValidator.", "author": "hreeve-cloudera", "createdAt": "2020-06-24T21:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0Nzk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTE2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443449165", "bodyText": "are we sure about this? what if termination is triggered during backup?", "author": "lacikaaa", "createdAt": "2020-06-22T10:00:02Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/backup/DatabaseBackupHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.HandlerMethods;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseBackupHandler extends ExceptionCatcherEventHandler<DatabaseBackupRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseBackupHandler.class);\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseBackupRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseBackupFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database backup event...\");\n+        DatabaseBackupRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);\n+            Set<String> gatewayFQDN = Collections.singleton(gatewayInstance.getDiscoveryFQDN());\n+            ExitCriteriaModel noExitModel = ClusterDeletionBasedExitCriteriaModel.nonCancellableModel();", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTAzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443605036", "bodyText": "Are we sure about what? The ExitCriteriaModel? Because honestly, I'm not sure about that at all. I don't know what ClusterDeletionBasedExitCriteriaModel is or if this is the right choice for our flow. I talked about it with Krisztian briefly, and this was his suggestion, but I don't yet have the context to know why this is right or wrong. Can you or anyone else explain exactly what the ExitCriteriaModel is and how it should be used?", "author": "hreeve-cloudera", "createdAt": "2020-06-22T14:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4Nzk5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444087999", "bodyText": "this ExitCriteriaModel is for defining if salt polling/running should be canceled. So it's like if you would like to stop CB to poll the saltorchestrator when the cluster is terminated you should use the ClusterDeletionBasedExitCriteriaModel. As you run your salt states in the cluster I think it would make sense to use it, so CB would free up those threads and won't poll until timeout", "author": "lacikaaa", "createdAt": "2020-06-23T09:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTQ3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443449479", "bodyText": "error/warn should be better level", "author": "lacikaaa", "createdAt": "2020-06-22T10:00:38Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/backup/DatabaseBackupHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.HandlerMethods;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseBackupHandler extends ExceptionCatcherEventHandler<DatabaseBackupRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseBackupHandler.class);\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseBackupRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseBackupFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database backup event...\");\n+        DatabaseBackupRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);\n+            Set<String> gatewayFQDN = Collections.singleton(gatewayInstance.getDiscoveryFQDN());\n+            ExitCriteriaModel noExitModel = ClusterDeletionBasedExitCriteriaModel.nonCancellableModel();\n+            SaltConfig saltConfig = HandlerMethods.createSaltConfig(request.getBackupLocation(), request.getBackupId(), stack.getCloudPlatform());\n+            hostOrchestrator.backupDatabase(gatewayConfig, gatewayFQDN, stackUtil.collectReachableNodes(stack), saltConfig, noExitModel);\n+\n+            result = new DatabaseBackupSuccess(stackId);\n+        } catch (Exception e) {\n+            LOGGER.info(\"Database backup event failed\", e);", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTY5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443449694", "bodyText": "same here", "author": "lacikaaa", "createdAt": "2020-06-22T10:01:00Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/restore/DatabaseRestoreHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.HandlerMethods;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseRestoreHandler extends ExceptionCatcherEventHandler<DatabaseRestoreRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseRestoreHandler.class);\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseRestoreRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseRestoreFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_RESTORE_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database restore event...\");\n+        DatabaseRestoreRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);\n+            Set<String> gatewayFQDN = Collections.singleton(gatewayInstance.getDiscoveryFQDN());\n+            ExitCriteriaModel noExitModel = ClusterDeletionBasedExitCriteriaModel.nonCancellableModel();", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0OTc2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443449766", "bodyText": "also the same", "author": "lacikaaa", "createdAt": "2020-06-22T10:01:07Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/restore/DatabaseRestoreHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.HandlerMethods;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseRestoreHandler extends ExceptionCatcherEventHandler<DatabaseRestoreRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseRestoreHandler.class);\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseRestoreRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseRestoreFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_RESTORE_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database restore event...\");\n+        DatabaseRestoreRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);\n+            Set<String> gatewayFQDN = Collections.singleton(gatewayInstance.getDiscoveryFQDN());\n+            ExitCriteriaModel noExitModel = ClusterDeletionBasedExitCriteriaModel.nonCancellableModel();\n+            SaltConfig saltConfig = HandlerMethods.createSaltConfig(request.getBackupLocation(), request.getBackupId(), stack.getCloudPlatform());\n+            hostOrchestrator.restoreDatabase(gatewayConfig, gatewayFQDN, stackUtil.collectReachableNodes(stack), saltConfig, noExitModel);\n+\n+            result = new DatabaseRestoreSuccess(stackId);\n+        } catch (Exception e) {\n+            LOGGER.info(\"Database restore event failed\", e);", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MDc0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443450740", "bodyText": "why can't this work by crn?", "author": "lacikaaa", "createdAt": "2020-06-22T10:02:54Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -315,6 +316,26 @@ public Stack getStackByCrn(String crn) {\n         return stackCommonService.getRetryableFlows(name, workspaceId);\n     }\n \n+    public FlowIdentifier backupClusterDatabase(@NotNull NameOrCrn nameOrCrn, Long workspaceId, String location, String backupId) {\n+        LOGGER.debug(\"Starting cluster database backup: \" + nameOrCrn);\n+        if (nameOrCrn.hasName()) {", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwODA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443608091", "bodyText": "It theoretically can. It's just that in the datalake disaster recovery service flow, the user only has the option to provide the environment name, not the CRN. So we only expect to get the name when it calls cloudbreak to do the backup/restore.", "author": "hreeve-cloudera", "createdAt": "2020-06-22T14:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MDc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0ODYwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444048602", "bodyText": "I see, but if you check everything else (except upgrade, which I don't know why) supports both crn and name. I think this should too", "author": "lacikaaa", "createdAt": "2020-06-23T08:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MDc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTA2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443451060", "bodyText": "same, why is it restricted to name?", "author": "lacikaaa", "createdAt": "2020-06-22T10:03:28Z", "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -315,6 +316,26 @@ public Stack getStackByCrn(String crn) {\n         return stackCommonService.getRetryableFlows(name, workspaceId);\n     }\n \n+    public FlowIdentifier backupClusterDatabase(@NotNull NameOrCrn nameOrCrn, Long workspaceId, String location, String backupId) {\n+        LOGGER.debug(\"Starting cluster database backup: \" + nameOrCrn);\n+        if (nameOrCrn.hasName()) {\n+            return databaseBackupRestoreService.backupDatabase(workspaceId, nameOrCrn.getName(), location, backupId);\n+        } else {\n+            LOGGER.debug(\"No stack name provided for backup, found: \" + nameOrCrn);\n+            throw new BadRequestException(\"Please provide a stack name for backup\");\n+        }\n+    }\n+\n+    public FlowIdentifier restoreClusterDatabase(@NotNull NameOrCrn nameOrCrn, Long workspaceId, String location, String backupId) {\n+        LOGGER.debug(\"Starting cluster database restore: \" + nameOrCrn);\n+        if (nameOrCrn.hasName()) {", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MzI4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443453287", "bodyText": "this part is the same as in restoreDatabase, could you refactor it into a separate method?", "author": "lacikaaa", "createdAt": "2020-06-22T10:07:30Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -856,6 +856,46 @@ public String name() {\n         }\n     }\n \n+    @Override\n+    public void backupDatabase(GatewayConfig primaryGateway, Set<String> target, Set<Node> allNodes, SaltConfig saltConfig,\n+            ExitCriteriaModel exitModel) throws CloudbreakOrchestratorFailedException {\n+        try (SaltConnector sc = createSaltConnector(primaryGateway)) {\n+            for (Entry<String, SaltPillarProperties> propertiesEntry : saltConfig.getServicePillarConfig().entrySet()) {\n+                OrchestratorBootstrap pillarSave = new PillarSave(sc, Sets.newHashSet(primaryGateway.getPrivateAddress()), propertiesEntry.getValue());\n+                Callable<Boolean> saltPillarRunner = saltRunner.runner(pillarSave, exitCriteria, exitModel);\n+                saltPillarRunner.call();\n+            }", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MzcwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r443453700", "bodyText": "as I see the 2 method is the same except this parameter, could you refactor them to reflect this and eliminate duplication?", "author": "lacikaaa", "createdAt": "2020-06-22T10:08:17Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -856,6 +856,46 @@ public String name() {\n         }\n     }\n \n+    @Override\n+    public void backupDatabase(GatewayConfig primaryGateway, Set<String> target, Set<Node> allNodes, SaltConfig saltConfig,\n+            ExitCriteriaModel exitModel) throws CloudbreakOrchestratorFailedException {\n+        try (SaltConnector sc = createSaltConnector(primaryGateway)) {\n+            for (Entry<String, SaltPillarProperties> propertiesEntry : saltConfig.getServicePillarConfig().entrySet()) {\n+                OrchestratorBootstrap pillarSave = new PillarSave(sc, Sets.newHashSet(primaryGateway.getPrivateAddress()), propertiesEntry.getValue());\n+                Callable<Boolean> saltPillarRunner = saltRunner.runner(pillarSave, exitCriteria, exitModel);\n+                saltPillarRunner.call();\n+            }\n+\n+            StateRunner stateRunner = new StateRunner(target, allNodes, DATABASE_BACKUP);", "originalCommit": "e117cc071b93d2d2cb72ad82ffdbd82a080d5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTUyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444089528", "bodyText": "this should be either private or in a separate class, as it's not called from anywhere else", "author": "lacikaaa", "createdAt": "2020-06-23T09:28:50Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/BackupRestoreSaltConfigGenerator.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.springframework.stereotype.Component;\n+\n+import static java.util.Collections.singletonMap;\n+\n+@Component\n+public class BackupRestoreSaltConfigGenerator {\n+\n+    public SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        String fullLocation = buildFullLocation(location, backupId, cloudPlatform);\n+\n+        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n+        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n+            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n+        return new SaltConfig(servicePillar);\n+    }\n+\n+    public String buildFullLocation(String location, String backupId, String cloudPlatform) throws URISyntaxException {", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTg0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444089849", "bodyText": "backupid is not used", "author": "lacikaaa", "createdAt": "2020-06-23T09:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NDU2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444094564", "bodyText": "there is a class, CloudStorageConfigGenerator maybe it worth checking out if you could use/reuse some parts of it", "author": "lacikaaa", "createdAt": "2020-06-23T09:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzNTgwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444535801", "bodyText": "It's called from BackupRestoreSaltConfigGeneratorTest. I've made it package local.\nI accidentally deleted the part where backupId was used when I refactored this code. It's been added back.\nI looked at CloudStorageConfigGenerator.  I prefer what I'm doing here, so unless there's a strong reason to change it I'm going to keep what I have.", "author": "hreeve-cloudera", "createdAt": "2020-06-23T22:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc2MjUxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444762511", "bodyText": "at least \"aws\" and \"azure\" should be replaced with CloudConstants/CloudPlatform", "author": "lacikaaa", "createdAt": "2020-06-24T09:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5MDQyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444090421", "bodyText": "could you do this before we merge this pr?", "author": "lacikaaa", "createdAt": "2020-06-23T09:30:24Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/BackupRestoreSaltConfigGenerator.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.springframework.stereotype.Component;\n+\n+import static java.util.Collections.singletonMap;\n+\n+@Component\n+public class BackupRestoreSaltConfigGenerator {\n+\n+    public SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        String fullLocation = buildFullLocation(location, backupId, cloudPlatform);\n+\n+        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n+        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n+            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n+        return new SaltConfig(servicePillar);\n+    }\n+\n+    public String buildFullLocation(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        URI uri = new URI(location);\n+        String fullLocation;\n+        if (\"aws\".equalsIgnoreCase(cloudPlatform)) {\n+            if (uri.getScheme() != null && !uri.getScheme().startsWith(\"s3\")) {\n+                throw new UnsupportedOperationException(\"Incorrect URL scheme for AWS cloud platform: \" + location);\n+            }\n+            fullLocation = \"s3://\" + uri.getSchemeSpecificPart().replaceAll(\"^/+\", \"\");\n+        } else if (\"azure\".equalsIgnoreCase(cloudPlatform)) {\n+            // TODO verify this is right when azure flow is working", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NTEyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444095126", "bodyText": "I think validating this here is a bit late. This should be caught when processing the request. Just check how this works for logging/telemetry", "author": "lacikaaa", "createdAt": "2020-06-23T09:38:21Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/BackupRestoreSaltConfigGenerator.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.springframework.stereotype.Component;\n+\n+import static java.util.Collections.singletonMap;\n+\n+@Component\n+public class BackupRestoreSaltConfigGenerator {\n+\n+    public SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        String fullLocation = buildFullLocation(location, backupId, cloudPlatform);\n+\n+        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n+        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n+            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n+        return new SaltConfig(servicePillar);\n+    }\n+\n+    public String buildFullLocation(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        URI uri = new URI(location);\n+        String fullLocation;\n+        if (\"aws\".equalsIgnoreCase(cloudPlatform)) {\n+            if (uri.getScheme() != null && !uri.getScheme().startsWith(\"s3\")) {\n+                throw new UnsupportedOperationException(\"Incorrect URL scheme for AWS cloud platform: \" + location);", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI5NjkyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444296927", "bodyText": "Where is the logging/telemetry logic? This is my first experience in this codebase so I'm not sure exactly what you're referencing.", "author": "hreeve-cloudera", "createdAt": "2020-06-23T15:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MDIwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444770208", "bodyText": "so the validation should be done around DatabaseBackupRestoreService#backupDatabase/restoreDatabase and the flow shouldn't be started with invalid input\nif you check LoggingBase it has separate input for AWS/Azure and those have validators, so it's checked on request time", "author": "lacikaaa", "createdAt": "2020-06-24T09:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTQyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r445171427", "bodyText": "I've added a BackupRestoreV4RequestValidator class and unit tests for it. It checks the location scheme, and also makes sure that required parameters are set.", "author": "hreeve-cloudera", "createdAt": "2020-06-24T21:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5NzQyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444097425", "bodyText": "I won't go over all of your requests, but please fix them all.\nSo you shouldn't do this. If you check StackEvent it has already an implementation which will return with the same by default.", "author": "lacikaaa", "createdAt": "2020-06-23T09:42:23Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/dr/restore/DatabaseRestoreRequest.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.BackupRestoreEvent;\n+\n+public class DatabaseRestoreRequest extends BackupRestoreEvent {\n+\n+    public DatabaseRestoreRequest(Long stackId, String backupLocation, String backupId) {\n+        super(stackId, backupLocation, backupId);\n+    }\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseRestoreRequest\";\n+    }", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5ODIyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444098222", "bodyText": "please use EventSelectorUtil here also. And fix in other places too if necessary", "author": "lacikaaa", "createdAt": "2020-06-23T09:43:45Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/restore/DatabaseRestoreHandler.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.BackupRestoreSaltConfigGenerator;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseRestoreHandler extends ExceptionCatcherEventHandler<DatabaseRestoreRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseRestoreHandler.class);\n+\n+    @Inject\n+    private BackupRestoreSaltConfigGenerator saltConfigGenerator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return \"DatabaseRestoreRequest\";\n+    }", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwMzIwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r444103202", "bodyText": "so we usually we do this the other way around. I would omit this part and let EventSelectorUtil take care of the selector here.\nI would modify DatabaseBackupEvent like this:\nDATABASE_BACKUP_FINISHED_EVENT(EventSelectorUtil.selector(DatabaseBackupSuccess.class)),\ncould you check the other events to be in line with this pattern?", "author": "lacikaaa", "createdAt": "2020-06-23T09:52:15Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/dr/backup/DatabaseBackupSuccess.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.BackupRestoreEvent;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup.DatabaseBackupEvent.DATABASE_BACKUP_FINISHED_EVENT;\n+\n+public class DatabaseBackupSuccess extends BackupRestoreEvent {\n+\n+    public DatabaseBackupSuccess(Long stackId) {\n+        super(stackId, null, null);\n+    }\n+\n+    @Override\n+    public String selector() {\n+        return DATABASE_BACKUP_FINISHED_EVENT.event();", "originalCommit": "e2de4c18d49e806d546a1c2cd46e7e5f06490c35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34ff57eb6ff10d0b664cae0ee8ca486fe92528f2", "url": "https://github.com/hortonworks/cloudbreak/commit/34ff57eb6ff10d0b664cae0ee8ca486fe92528f2", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-23T17:02:46Z", "type": "forcePushed"}, {"oid": "ca570f3a48caa3b5750a25fbe8f0e34996cfeee9", "url": "https://github.com/hortonworks/cloudbreak/commit/ca570f3a48caa3b5750a25fbe8f0e34996cfeee9", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-23T22:00:24Z", "type": "forcePushed"}, {"oid": "c6d15dc522d6af408ca7d2bd6396becc1db80fde", "url": "https://github.com/hortonworks/cloudbreak/commit/c6d15dc522d6af408ca7d2bd6396becc1db80fde", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-24T21:02:55Z", "type": "forcePushed"}, {"oid": "d6d66085a1c6b7218732ee2d06d53df2c0a0823d", "url": "https://github.com/hortonworks/cloudbreak/commit/d6d66085a1c6b7218732ee2d06d53df2c0a0823d", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-25T01:51:48Z", "type": "forcePushed"}, {"oid": "5e2684436c936a26ab513e9abd422bb016a1f6fa", "url": "https://github.com/hortonworks/cloudbreak/commit/5e2684436c936a26ab513e9abd422bb016a1f6fa", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-25T03:04:06Z", "type": "forcePushed"}, {"oid": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "url": "https://github.com/hortonworks/cloudbreak/commit/90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-25T15:41:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4Nzg4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446087889", "bodyText": "after this line you should build mdccontext with MDCBuilder.buildMdcContext\nsame for restore", "author": "lacikaaa", "createdAt": "2020-06-26T09:56:39Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/DatabaseBackupRestoreService.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.controller.validation.dr.BackupRestoreV4RequestValidator;\n+import com.sequenceiq.cloudbreak.core.flow2.service.ReactorFlowManager;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.core.FlowLogService;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class DatabaseBackupRestoreService {\n+\n+    private static final String DATALAKE_DATABASE_BACKUP = \"DATALAKE_DATABASE_BACKUP\";\n+\n+    private static final String DATALAKE_DATABASE_RESTORE = \"DATALAKE_DATABASE_RESTORE\";\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FlowLogService flowLogService;\n+\n+    @Inject\n+    private ReactorFlowManager flowManager;\n+\n+    @Inject\n+    private CloudbreakEventService eventService;\n+\n+    @Inject\n+    private BackupRestoreV4RequestValidator requestValidator;\n+\n+    public void validate(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        ValidationResult validationResult = requestValidator.validate(stack, location, backupId);\n+        if (validationResult.hasError()) {\n+            throw new BadRequestException(validationResult.getFormattedErrors());\n+        }\n+    }\n+\n+    public FlowIdentifier backupDatabase(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIxMDk4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446210987", "bodyText": "will do", "author": "kkalvagadda1", "createdAt": "2020-06-26T14:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4Nzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4ODIzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446088233", "bodyText": "I don't think you should need this as the flow engine would reject this flow if other is running", "author": "lacikaaa", "createdAt": "2020-06-26T09:57:22Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/DatabaseBackupRestoreService.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.controller.validation.dr.BackupRestoreV4RequestValidator;\n+import com.sequenceiq.cloudbreak.core.flow2.service.ReactorFlowManager;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.core.FlowLogService;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class DatabaseBackupRestoreService {\n+\n+    private static final String DATALAKE_DATABASE_BACKUP = \"DATALAKE_DATABASE_BACKUP\";\n+\n+    private static final String DATALAKE_DATABASE_RESTORE = \"DATALAKE_DATABASE_RESTORE\";\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FlowLogService flowLogService;\n+\n+    @Inject\n+    private ReactorFlowManager flowManager;\n+\n+    @Inject\n+    private CloudbreakEventService eventService;\n+\n+    @Inject\n+    private BackupRestoreV4RequestValidator requestValidator;\n+\n+    public void validate(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        ValidationResult validationResult = requestValidator.validate(stack, location, backupId);\n+        if (validationResult.hasError()) {\n+            throw new BadRequestException(validationResult.getFormattedErrors());\n+        }\n+    }\n+\n+    public FlowIdentifier backupDatabase(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        List<FlowLog> flowLogs = flowLogService.findAllByResourceIdAndFinalizedIsFalseOrderByCreatedDesc(stack.getId());\n+        if (!CollectionUtils.isEmpty(flowLogs)) {\n+            String errorMsg = String.format(\"Database backup cannot be performed because there is an active flow running: %s\",\n+                flowLogs.stream().map(FlowLog::toString));\n+            eventService.fireCloudbreakEvent(\n+                stack.getId(),\n+                DATALAKE_DATABASE_BACKUP,\n+                ResourceEvent.DATALAKE_DATABASE_BACKUP_COULD_NOT_START,\n+                List.of(errorMsg));\n+            throw new BadRequestException(errorMsg);\n+        } else {", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NjgxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446096814", "bodyText": "just for future safety I would do else if here for Azure. When we introduce a new SPI support, like GCP we have to modify it here, so maybe an exception for unsupported SPI would be necessary to notice this easily", "author": "lacikaaa", "createdAt": "2020-06-26T10:15:49Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/BackupRestoreSaltConfigGenerator.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltPillarProperties;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.common.type.CloudConstants.AWS;\n+import static java.util.Collections.singletonMap;\n+\n+@Component\n+public class BackupRestoreSaltConfigGenerator {\n+\n+    public SaltConfig createSaltConfig(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        String fullLocation = buildFullLocation(location, backupId, cloudPlatform);\n+\n+        Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n+        servicePillar.put(\"disaster-recovery\", new SaltPillarProperties(\"/postgresql/disaster_recovery.sls\",\n+            singletonMap(\"disaster_recovery\", singletonMap(\"object_storage_url\", fullLocation))));\n+        return new SaltConfig(servicePillar);\n+    }\n+\n+    String buildFullLocation(String location, String backupId, String cloudPlatform) throws URISyntaxException {\n+        URI uri = new URI(location);\n+        String suffix = '/' + backupId + \"_database_backup\";\n+        String fullLocation;\n+        if (AWS.equalsIgnoreCase(cloudPlatform)) {\n+            fullLocation = \"s3://\" + uri.getSchemeSpecificPart().replaceAll(\"^/+\", \"\");\n+        } else {\n+            fullLocation = \"abfs://\" + uri.getSchemeSpecificPart().replaceAll(\"^/+\", \"\");\n+        }", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4Mjc5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446182798", "bodyText": "So I originally had an else if, and then a final else that threw an UnsupportedOperationException. You said I shouldn't be throwing an UnsupportedOperationException, but you didn't answer when I asked what I should be doing instead. So instead I made the BackupRestoreV4RequestValidator, which validates the scheme is either AWS or AZURE before the flow gets here, and removed the UnsupportedOperationException. Are you saying I should add it back? Is there some other exception type I should be using?", "author": "hreeve-cloudera", "createdAt": "2020-06-26T13:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5OTc4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446099782", "bodyText": "something is off with your formatter I think. I reformatted this class on your branch from my idea, and it restored the original formatting. Could you make sure you have loaded the config for your idea?", "author": "lacikaaa", "createdAt": "2020-06-26T10:22:07Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -81,8 +48,37 @@\n import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n import com.sequenceiq.cloudbreak.service.Retry;\n import com.sequenceiq.cloudbreak.util.CompressUtil;\n-\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import static com.sequenceiq.cloudbreak.common.type.OrchestratorConstants.SALT;\n+import static com.sequenceiq.cloudbreak.common.type.RecipeExecutionPhase.PRE_CLOUDERA_MANAGER_START;\n+import static com.sequenceiq.cloudbreak.common.type.RecipeExecutionPhase.convert;\n+import static com.sequenceiq.cloudbreak.util.FileReaderUtils.readFileFromClasspath;", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4ODcyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446188728", "bodyText": "I've loaded the config as instructed in the cloudbreak README at least twice. I'm not sure what else to do at this point.", "author": "hreeve-cloudera", "createdAt": "2020-06-26T13:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5OTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMDg4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446100886", "bodyText": "if you fix the context at trigger you might omit this line", "author": "lacikaaa", "createdAt": "2020-06-26T10:24:46Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/backup/DatabaseBackupActions.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.AbstractBackupRestoreActions;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.BackupRestoreStatusService;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatabaseBackupTriggerEvent;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr.backup.DatabaseBackupEvent.DATABASE_BACKUP_FAIL_HANDLED_EVENT;\n+\n+@Configuration\n+public class DatabaseBackupActions {\n+\n+    @Inject\n+    private BackupRestoreStatusService backupRestoreStatusService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Bean(name = \"DATABASE_BACKUP_STATE\")\n+    public Action<?, ?> backupDatabase() {\n+        return new AbstractBackupRestoreActions<>(DatabaseBackupTriggerEvent.class) {\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupTriggerEvent payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabase(context.getStackId(), context.getBackupId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new DatabaseBackupRequest(context.getStackId(), context.getBackupLocation(), context.getBackupId());\n+            }\n+\n+            @Override\n+            protected Object getFailurePayload(DatabaseBackupTriggerEvent payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+                return DatabaseBackupFailedEvent.from(payload, ex, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FINISHED_STATE\")\n+    public Action<?, ?> databaseBackupFinished() {\n+        return new AbstractBackupRestoreActions<>(DatabaseBackupSuccess.class) {\n+\n+            @Override\n+            protected void doExecute(BackupRestoreContext context, DatabaseBackupSuccess payload, Map<Object, Object> variables) {\n+                backupRestoreStatusService.backupDatabaseFinished(context.getStackId());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(BackupRestoreContext context) {\n+                return new StackEvent(DatabaseBackupEvent.DATABASE_BACKUP_FINALIZED_EVENT.event(), context.getStackId());\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DATABASE_BACKUP_FAILED_STATE\")\n+    public Action<?, ?> databaseBackupFailedAction() {\n+        return new AbstractBackupRestoreActions<>(DatabaseBackupFailedEvent.class) {\n+\n+            @Override\n+            protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+                    DatabaseBackupFailedEvent payload) {\n+                Flow flow = getFlow(flowParameters.getFlowId());\n+                Stack stack = stackService.getById(payload.getResourceId());\n+                MDCBuilder.buildMdcContext(stack);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMjg2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446102862", "bodyText": "both azure and aws patterns could be compiled and be static final, like:\nprivate static final Pattern AWS_PATTERN_COMPILED = Pattern.compile(AWS_PATTERN, Pattern.CASE_INSENSITIVE);", "author": "lacikaaa", "createdAt": "2020-06-26T10:29:02Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/dr/BackupRestoreV4RequestValidator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.sequenceiq.cloudbreak.controller.validation.dr;\n+\n+import com.google.common.base.Strings;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.common.type.CloudConstants.AWS;\n+import static com.sequenceiq.cloudbreak.common.type.CloudConstants.AZURE;\n+\n+@Component\n+public class BackupRestoreV4RequestValidator {\n+\n+    private static final String AWS_PATTERN = \"(^s3[a|n]?$)|(^$)\";\n+\n+    private static final String AZURE_PATTERN = \"(^abfs[s]?$)|(^$)\";\n+\n+    public ValidationResult validate(Stack stack, String location, String backupId) {\n+        ValidationResult.ValidationResultBuilder resultBuilder = ValidationResult.builder();\n+        String cloudPlatform = stack.cloudPlatform();\n+\n+        if (Strings.isNullOrEmpty(backupId)) {\n+            resultBuilder.error(\"Parameter backupId required\");\n+        }\n+        if (Strings.isNullOrEmpty(location)) {\n+            resultBuilder.error(\"Parameter backupLocation required\");\n+        } else {\n+            validateCloudLocationScheme(cloudPlatform, location, resultBuilder);\n+        }\n+        return resultBuilder.build();\n+    }\n+\n+    private void validateCloudLocationScheme(String cloudPlatform, String location, ValidationResult.ValidationResultBuilder resultBuilder) {\n+        try {\n+            URI uri = new URI(location);\n+            if (AWS.equalsIgnoreCase(cloudPlatform)) {\n+                if (uri.getScheme() != null) {\n+                    Matcher matcher = Pattern.compile(AWS_PATTERN, Pattern.CASE_INSENSITIVE).matcher(uri.getScheme());", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODAzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446108031", "bodyText": "please add this to the mapToFailedIfInProgress method switch\nsame for RESTORE_IN_PROGRESS", "author": "lacikaaa", "createdAt": "2020-06-26T10:41:30Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/common/Status.java", "diffHunk": "@@ -38,7 +34,13 @@\n     EXTERNAL_DATABASE_CREATION_FAILED(StatusKind.FINAL),\n     EXTERNAL_DATABASE_DELETION_IN_PROGRESS(StatusKind.PROGRESS),\n     EXTERNAL_DATABASE_DELETION_FINISHED(StatusKind.PROGRESS),\n-    EXTERNAL_DATABASE_DELETION_FAILED(StatusKind.FINAL);\n+    EXTERNAL_DATABASE_DELETION_FAILED(StatusKind.FINAL),\n+    BACKUP_IN_PROGRESS(StatusKind.PROGRESS),", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMDcyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446110728", "bodyText": "I'm very afraid of this could cause NullPointerException somewhere. If you check the failure handling action it will use the payload, and if there is a null pointer I think it would make the flow stuck for a while", "author": "lacikaaa", "createdAt": "2020-06-26T10:48:22Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/AbstractBackupRestoreActions.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.BackupRestoreEvent;\n+import com.sequenceiq.flow.core.AbstractAction;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.FlowState;\n+import java.util.Optional;\n+import org.springframework.statemachine.StateContext;\n+\n+public abstract class AbstractBackupRestoreActions<P extends BackupRestoreEvent>\n+    extends AbstractAction<FlowState, FlowEvent, BackupRestoreContext, P> {\n+\n+    protected AbstractBackupRestoreActions(Class<P> payloadClass) {\n+        super(payloadClass);\n+    }\n+\n+    @Override\n+    protected BackupRestoreContext createFlowContext(FlowParameters flowParameters, StateContext<FlowState, FlowEvent> stateContext,\n+            P payload) {\n+        return BackupRestoreContext.from(flowParameters, payload, payload.getBackupLocation(), payload.getBackupId());\n+    }\n+\n+    @Override\n+    protected Object getFailurePayload(P payload, Optional<BackupRestoreContext> flowContext, Exception ex) {\n+        return null;", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzMjUwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446232501", "bodyText": "Used StackFailureEvent as the default here instead of null.", "author": "hreeve-cloudera", "createdAt": "2020-06-26T14:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMDcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMjc3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446112770", "bodyText": "I'm a bit confused here and maybe @foldik or @bbihari could chime in.\nSo I think FINISHED states shouldn't be here, as it would mean everything should be back to normal and operational.\nAlso, I think if backup fails, it shouldn't mean that the cluster isn't operational, or does it?", "author": "lacikaaa", "createdAt": "2020-06-26T10:53:38Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/job/StackStatusCheckerJob.java", "diffHunk": "@@ -141,8 +138,10 @@ protected void executeInternal(JobExecutionContext context) throws JobExecutionE\n                 Status.MAINTENANCE_MODE_ENABLED,\n                 Status.EXTERNAL_DATABASE_CREATION_IN_PROGRESS,\n                 Status.BACKUP_IN_PROGRESS,\n+                Status.BACKUP_FINISHED,\n                 Status.BACKUP_FAILED,\n                 Status.RESTORE_IN_PROGRESS,\n+                Status.RESTORE_FINISHED,\n                 Status.RESTORE_FAILED", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3OTM0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446179344", "bodyText": "It shouldn't, no.", "author": "hreeve-cloudera", "createdAt": "2020-06-26T13:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMjc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzMzE5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446233199", "bodyText": "I've gone ahead and removed the FINISHED enums. If @foldik or @bbihari have any other suggestions I'll make them later.", "author": "hreeve-cloudera", "createdAt": "2020-06-26T14:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMjc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwMTQ5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446901493", "bodyText": "Every new status enum value should be categorized as syncable/ignored/unschedulable.\nIf it's \"unschedulable\" then that state should be an end-state like terminated. If it's \"ignored\" then it should be an in-progress state.\nThe FAILED states should be handled in SdxClusterStatusCheckerJob too.", "author": "bbihari", "createdAt": "2020-06-29T11:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMjc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk3MTU4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446971584", "bodyText": "Handled in what way? It looks like only a handful of states from Status are explicitly handled in SdxClusterStatusCheckerJob.", "author": "hreeve-cloudera", "createdAt": "2020-06-29T13:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExNjc3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446116775", "bodyText": "these should be final", "author": "lacikaaa", "createdAt": "2020-06-26T11:03:42Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreContext.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.dr;\n+\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.flow.core.CommonContext;\n+import com.sequenceiq.flow.core.FlowParameters;\n+\n+public class BackupRestoreContext extends CommonContext {\n+\n+    private Long stackId;\n+\n+    private String backupLocation;\n+\n+    private String backupId;", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExNzc5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446117796", "bodyText": "should be final", "author": "lacikaaa", "createdAt": "2020-06-26T11:06:05Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/dr/BackupRestoreEvent.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr;\n+\n+import com.sequenceiq.cloudbreak.common.event.AcceptResult;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import reactor.rx.Promise;\n+\n+public class BackupRestoreEvent extends StackEvent {\n+\n+    private String backupLocation;\n+\n+    private String backupId;", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyMDA2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446120067", "bodyText": "please use Cluster#hasGateway", "author": "lacikaaa", "createdAt": "2020-06-26T11:11:33Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/backup/DatabaseBackupHandler.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.BackupRestoreSaltConfigGenerator;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseBackupHandler extends ExceptionCatcherEventHandler<DatabaseBackupRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseBackupHandler.class);\n+\n+    @Inject\n+    private BackupRestoreSaltConfigGenerator saltConfigGenerator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(DatabaseBackupRequest.class);\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseBackupFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database backup event...\");\n+        DatabaseBackupRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyMDE3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446120176", "bodyText": "please use Cluster#hasGateway", "author": "lacikaaa", "createdAt": "2020-06-26T11:11:49Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/restore/DatabaseRestoreHandler.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.restore;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.restore.DatabaseRestoreSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.BackupRestoreSaltConfigGenerator;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseRestoreHandler extends ExceptionCatcherEventHandler<DatabaseRestoreRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseRestoreHandler.class);\n+\n+    @Inject\n+    private BackupRestoreSaltConfigGenerator saltConfigGenerator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(DatabaseRestoreRequest.class);\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseRestoreFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_RESTORE_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database restore event...\");\n+        DatabaseRestoreRequest request = event.getData();\n+        Selectable result;\n+        Long stackId = request.getResourceId();\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+            Cluster cluster = stack.getCluster();\n+            InstanceMetaData gatewayInstance = stack.getPrimaryGatewayInstance();\n+            GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, gatewayInstance, cluster.getGateway() != null);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyMjE4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446122182", "bodyText": "this is strange. we should log de event or event data here to make it a bit meaningful. same for the other handler\nalso for receiving the event there should be already a log provided by LogContextAspects", "author": "lacikaaa", "createdAt": "2020-06-26T11:16:23Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/dr/backup/DatabaseBackupHandler.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.backup;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.ClusterDeletionBasedExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceMetaData;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.SaltConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.state.ExitCriteriaModel;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupFailedEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.dr.backup.DatabaseBackupSuccess;\n+import com.sequenceiq.cloudbreak.reactor.handler.cluster.dr.BackupRestoreSaltConfigGenerator;\n+import com.sequenceiq.cloudbreak.service.GatewayConfigService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.util.StackUtil;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import java.util.Collections;\n+import java.util.Set;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class DatabaseBackupHandler extends ExceptionCatcherEventHandler<DatabaseBackupRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseBackupHandler.class);\n+\n+    @Inject\n+    private BackupRestoreSaltConfigGenerator saltConfigGenerator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackUtil stackUtil;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(DatabaseBackupRequest.class);\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new DatabaseBackupFailedEvent(resourceId, e, DetailedStackStatus.DATABASE_BACKUP_FAILED);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"Accepting Database backup event...\");", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyMzM3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446123370", "bodyText": "it would be nice to have a line of log here after MDCContext is build. same for restore method", "author": "lacikaaa", "createdAt": "2020-06-26T11:19:09Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/DatabaseBackupRestoreService.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.controller.validation.dr.BackupRestoreV4RequestValidator;\n+import com.sequenceiq.cloudbreak.core.flow2.service.ReactorFlowManager;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.core.FlowLogService;\n+import com.sequenceiq.flow.domain.FlowLog;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class DatabaseBackupRestoreService {\n+\n+    private static final String DATALAKE_DATABASE_BACKUP = \"DATALAKE_DATABASE_BACKUP\";\n+\n+    private static final String DATALAKE_DATABASE_RESTORE = \"DATALAKE_DATABASE_RESTORE\";\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FlowLogService flowLogService;\n+\n+    @Inject\n+    private ReactorFlowManager flowManager;\n+\n+    @Inject\n+    private CloudbreakEventService eventService;\n+\n+    @Inject\n+    private BackupRestoreV4RequestValidator requestValidator;\n+\n+    public void validate(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        ValidationResult validationResult = requestValidator.validate(stack, location, backupId);\n+        if (validationResult.hasError()) {\n+            throw new BadRequestException(validationResult.getFormattedErrors());\n+        }\n+    }\n+\n+    public FlowIdentifier backupDatabase(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        List<FlowLog> flowLogs = flowLogService.findAllByResourceIdAndFinalizedIsFalseOrderByCreatedDesc(stack.getId());\n+        if (!CollectionUtils.isEmpty(flowLogs)) {\n+            String errorMsg = String.format(\"Database backup cannot be performed because there is an active flow running: %s\",\n+                flowLogs.stream().map(FlowLog::toString));\n+            eventService.fireCloudbreakEvent(\n+                stack.getId(),\n+                DATALAKE_DATABASE_BACKUP,\n+                ResourceEvent.DATALAKE_DATABASE_BACKUP_COULD_NOT_START,\n+                List.of(errorMsg));\n+            throw new BadRequestException(errorMsg);\n+        } else {\n+            return flowManager.triggerDatalakeDatabaseBackup(stack.getId(), location, backupId);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNDkwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446124901", "bodyText": "this should be error level, shouldn't it?", "author": "lacikaaa", "createdAt": "2020-06-26T11:22:36Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -934,6 +934,37 @@ public String name() {\n         }\n     }\n \n+    @Override\n+    public void backupDatabase(GatewayConfig primaryGateway, Set<String> target, Set<Node> allNodes, SaltConfig saltConfig,\n+            ExitCriteriaModel exitModel) throws CloudbreakOrchestratorFailedException {\n+        callBackupRestore(primaryGateway, target, allNodes, saltConfig, exitModel, DATABASE_BACKUP);\n+    }\n+\n+    @Override\n+    public void restoreDatabase(GatewayConfig primaryGateway, Set<String> target, Set<Node> allNodes, SaltConfig saltConfig,\n+                                ExitCriteriaModel exitModel) throws CloudbreakOrchestratorFailedException {\n+        callBackupRestore(primaryGateway, target, allNodes, saltConfig, exitModel, DATABASE_RESTORE);\n+    }\n+\n+    private void callBackupRestore(GatewayConfig primaryGateway, Set<String> target, Set<Node> allNodes, SaltConfig saltConfig,\n+            ExitCriteriaModel exitModel, String state) throws CloudbreakOrchestratorFailedException {\n+        try (SaltConnector sc = createSaltConnector(primaryGateway)) {\n+            for (Entry<String, SaltPillarProperties> propertiesEntry : saltConfig.getServicePillarConfig().entrySet()) {\n+                OrchestratorBootstrap pillarSave = new PillarSave(sc, Sets.newHashSet(primaryGateway.getPrivateAddress()), propertiesEntry.getValue());\n+                Callable<Boolean> saltPillarRunner = saltRunner.runner(pillarSave, exitCriteria, exitModel, maxRetry, true);\n+                saltPillarRunner.call();\n+            }\n+\n+            StateRunner stateRunner = new StateRunner(target, allNodes, state);\n+            OrchestratorBootstrap saltJobIdTracker = new SaltJobIdTracker(sc, stateRunner);\n+            Callable<Boolean> saltJobRunBootstrapRunner = saltRunner.runner(saltJobIdTracker, exitCriteria, exitModel, maxRetry, true);\n+            saltJobRunBootstrapRunner.call();\n+        } catch (Exception e) {\n+            LOGGER.info(\"Error occurred during database backup/restore\", e);", "originalCommit": "90e7f337c3e3f79431a40e1c0ad391735ca3fb57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42495418b95d9c47c713b572df285368650f01ff", "url": "https://github.com/hortonworks/cloudbreak/commit/42495418b95d9c47c713b572df285368650f01ff", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-26T14:50:42Z", "type": "forcePushed"}, {"oid": "586153e6e1e9581bfb549159f7da07cb6fdb9edf", "url": "https://github.com/hortonworks/cloudbreak/commit/586153e6e1e9581bfb549159f7da07cb6fdb9edf", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-26T14:57:52Z", "type": "forcePushed"}, {"oid": "70dd6848d1c074624b120889e7c1533a982135c9", "url": "https://github.com/hortonworks/cloudbreak/commit/70dd6848d1c074624b120889e7c1533a982135c9", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-26T16:00:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg4MDYwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8284#discussion_r446880608", "bodyText": "RESTORE_IN_PROGRESS", "author": "lacikaaa", "createdAt": "2020-06-29T09:45:55Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/common/Status.java", "diffHunk": "@@ -97,6 +97,10 @@ public Status mapToFailedIfInProgress() {\n                 return START_FAILED;\n             case STOP_IN_PROGRESS:\n                 return STOP_FAILED;\n+            case BACKUP_IN_PROGRESS:\n+                return BACKUP_FAILED;\n+            case RESTORE_FAILED:", "originalCommit": "70dd6848d1c074624b120889e7c1533a982135c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85a5818a151ada2f3439ee195b8fa98d9e593da0", "url": "https://github.com/hortonworks/cloudbreak/commit/85a5818a151ada2f3439ee195b8fa98d9e593da0", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-29T13:29:28Z", "type": "commit"}, {"oid": "85a5818a151ada2f3439ee195b8fa98d9e593da0", "url": "https://github.com/hortonworks/cloudbreak/commit/85a5818a151ada2f3439ee195b8fa98d9e593da0", "message": "CB-7215 Add CB service changes to perform database backup/restore\n\nAdds new cloudbreak API methods backupDatabaseByName and restoreDatabaseByName.\nThese methods trigger new flows that will invoke salt on datalake master node\nto run the backup_db.sh and restore_db.sh scripts.\n\nTested with unit tests and by running cloudbreak locally and making new API\ncalls.", "committedDate": "2020-06-29T13:29:28Z", "type": "forcePushed"}]}