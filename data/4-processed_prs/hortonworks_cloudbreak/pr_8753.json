{"pr_number": 8753, "pr_title": "CB-8040 Parcels are activated without distribution in replaced VM", "pr_createdAt": "2020-08-07T14:55:28Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8753", "timeline": [{"oid": "86afa4d8d2ac8317791a77fe95ba46a5b4075374", "url": "https://github.com/hortonworks/cloudbreak/commit/86afa4d8d2ac8317791a77fe95ba46a5b4075374", "message": "CB-8040 Parcels are activated without distribution in replaced VM", "committedDate": "2020-08-09T22:18:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxMTMyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r467811324", "bodyText": "Add logs", "author": "keyki", "createdAt": "2020-08-10T10:20:56Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/parcel/ParcelService.java", "diffHunk": "@@ -34,6 +44,33 @@\n     @Inject\n     private RestClientFactory restClientFactory;\n \n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n+    public Set<ClusterComponent> getParcelComponentsByBlueprint(Stack stack) {\n+        Cluster cluster = stack.getCluster();\n+        Set<ClusterComponent> components = getParcelComponents(cluster);\n+        if (stack.isDatalake()) {", "originalCommit": "86afa4d8d2ac8317791a77fe95ba46a5b4075374", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxMTUwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r467811508", "bodyText": "Add logs", "author": "keyki", "createdAt": "2020-08-10T10:21:19Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeAvailabilityService.java", "diffHunk": "@@ -169,6 +175,24 @@ private UpgradeV4Response checkForUpgrades(Stack stack, boolean lockComponents)\n         return upgradeOptions;\n     }\n \n+    private Map<String, String> getActivatedParcels(Stack stack) {\n+        if (stack.isDatalake()) {", "originalCommit": "86afa4d8d2ac8317791a77fe95ba46a5b4075374", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxMTczMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r467811732", "bodyText": "During upgrade, if DATALAKE\n\ndeactivate ALL except CDH\nundistribute them\ndelete them", "author": "keyki", "createdAt": "2020-08-10T10:21:48Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -510,15 +512,41 @@ public String getStackRepositoryJson(StackRepoDetails repoDetails, String stackR\n     }\n \n     @Override\n-    public Map<String, String> gatherInstalledComponents(String stackName) {\n+    public Map<String, String> gatherInstalledParcels(String stackName) {\n         try {\n-        return clouderaManagerParcelService.getActivatedParcels(apiClient, stackName);\n+            return clouderaManagerParcelService.getActivatedParcels(apiClient, stackName);\n         } catch (ApiException e) {\n             LOGGER.info(\"Unable to fetch the list of activated parcels\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n+    @Override\n+    public void deactivateUnusedParcels(Set<ClusterComponent> usedParcelComponents) {\n+        ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n+        Map<String, ClouderaManagerProduct> cmProducts = new HashMap<>();\n+        for (ClusterComponent clusterComponent : usedParcelComponents) {\n+            ClouderaManagerProduct product = clusterComponent.getAttributes().getSilent(ClouderaManagerProduct.class);\n+            cmProducts.put(product.getName(), product);\n+        }\n+        Map<String, String> installedComponents = gatherInstalledParcels(stack.getName());\n+        Set<String> failedDeactivations = new HashSet<>();\n+        for (Map.Entry<String, String> installedComp : installedComponents.entrySet()) {\n+            if (!cmProducts.containsKey(installedComp.getKey())) {\n+                try {\n+                    parcelResourceApi.deactivateCommand(stack.getName(), installedComp.getKey(), installedComp.getValue());", "originalCommit": "86afa4d8d2ac8317791a77fe95ba46a5b4075374", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f679deddc61346cce7486ec305f7c028d0daa04", "url": "https://github.com/hortonworks/cloudbreak/commit/3f679deddc61346cce7486ec305f7c028d0daa04", "message": "CB-8040 Parcels are activated without distribution in replaced VM", "committedDate": "2020-08-12T20:39:14Z", "type": "forcePushed"}, {"oid": "2ff265537ec5e68f58aa3f3a2671c217322334e3", "url": "https://github.com/hortonworks/cloudbreak/commit/2ff265537ec5e68f58aa3f3a2671c217322334e3", "message": "CB-8040 Parcels are activated without distribution in replaced VM", "committedDate": "2020-08-13T13:12:26Z", "type": "forcePushed"}, {"oid": "2c9186ae3e309e2bcd1bc1c836aa6c07b777a717", "url": "https://github.com/hortonworks/cloudbreak/commit/2c9186ae3e309e2bcd1bc1c836aa6c07b777a717", "message": "CB-8040 Parcels are activated without distribution in replaced VM", "committedDate": "2020-08-13T13:16:27Z", "type": "forcePushed"}, {"oid": "b789e4ae7af1bae4222cca44e72684574beab78d", "url": "https://github.com/hortonworks/cloudbreak/commit/b789e4ae7af1bae4222cca44e72684574beab78d", "message": "CB-8040 Parcels are activated without distribution in replaced VM", "committedDate": "2020-08-14T08:06:23Z", "type": "forcePushed"}, {"oid": "bd31e6a4069f7e00b7a15dcf80ea324a4fc7dbe3", "url": "https://github.com/hortonworks/cloudbreak/commit/bd31e6a4069f7e00b7a15dcf80ea324a4fc7dbe3", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-14T08:34:50Z", "type": "forcePushed"}, {"oid": "15fe4b12cea2783698c5ee21783ff68f2d40154b", "url": "https://github.com/hortonworks/cloudbreak/commit/15fe4b12cea2783698c5ee21783ff68f2d40154b", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-14T09:02:01Z", "type": "forcePushed"}, {"oid": "85704d5acb1671747c88980408301bc453c92122", "url": "https://github.com/hortonworks/cloudbreak/commit/85704d5acb1671747c88980408301bc453c92122", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-14T11:43:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNzA1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470627059", "bodyText": "3 param is required, but only 2 is provided", "author": "keyki", "createdAt": "2020-08-14T13:35:16Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/ClouderaManagerPollingServiceProvider.java", "diffHunk": "@@ -106,6 +110,21 @@ public PollingResult startPollingCmParcelActivation(Stack stack, ApiClient apiCl\n                 new ClouderaManagerParcelActivationListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n+    public PollingResult startPollingCmParcelStatus(Stack stack, ApiClient apiClient, Map<String, String> parcelVersions,\n+            ParcelStatus parcelStatus) {\n+        LOGGER.debug(\"Waiting for Cloudera Manager parcels {} to become to status [{}]. [Server address: {}]\", parcelVersions, parcelStatus,\n+                stack.getClusterManagerIp());\n+        return pollCommandWithTimeListener(stack, apiClient, BigDecimal.ZERO, POLL_FOR_ONE_HOUR,\n+                new ClouderaManagerParcelStatusListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService, parcelVersions, parcelStatus));\n+    }\n+\n+    public PollingResult startPollingCmParcelDelete(Stack stack, ApiClient apiClient, Map<String, String> parcelVersions) {\n+        LOGGER.debug(\"Waiting for Cloudera Manager parcels {} to become to status [{}]. [Server address: {}]\", parcelVersions,", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODU5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470638591", "bodyText": "The second upgrade stuck for me at checking the deleted parcels\nSome parcels are not yet deleted: [(CDH 7.2.1-1.cdh7.2.1.p0.4763198 : AVAILABLE_REMOTELY)].\n\nWe're checking if it's empty, but for me, it shows AVAILABLE_REMOTELY on the UI. We can consider this one as deleted as well.", "author": "keyki", "createdAt": "2020-08-14T13:55:24Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelDeletedListenerTask.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelDeletedListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelDeletedListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    public ClouderaManagerParcelDeletedListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;\n+    }\n+\n+    @Override\n+    protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, CommandsResourceApi commandsResourceApi) throws ApiException {\n+        ApiClient apiClient = pollerObject.getApiClient();\n+        Stack stack = pollerObject.getStack();\n+        ApiParcelList parcels = getClouderaManagerParcels(apiClient, stack.getName());\n+        List<ApiParcel> existedParcels = getExistedParcels(parcelVersion, parcels);\n+        if (existedParcels.isEmpty()) {\n+            LOGGER.debug(\"Parcels are deleted succesfully.\");\n+            return true;\n+        } else {\n+            LOGGER.debug(\"Some parcels are not yet deleted: [{}].\", getJoinedParcelStages(existedParcels));", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDM4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470660383", "bodyText": "This should be another method after filtering like undistributeParcels and removeParcels to be uniform", "author": "pdarvasi", "createdAt": "2020-08-14T14:32:41Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelService.java", "diffHunk": "@@ -12,39 +17,146 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n+import com.cloudera.api.swagger.ParcelResourceApi;\n import com.cloudera.api.swagger.ParcelsResourceApi;\n import com.cloudera.api.swagger.client.ApiClient;\n import com.cloudera.api.swagger.client.ApiException;\n import com.cloudera.api.swagger.model.ApiParcel;\n import com.cloudera.api.swagger.model.ApiParcelList;\n-import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n \n @Service\n class ClouderaManagerParcelService {\n-\n     private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelService.class);\n \n     @Inject\n-    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n \n-    public Map<String, String> getActivatedParcels(ApiClient client, String stackName) throws ApiException {\n-        return getClouderaManagerParcelsByStatus(client, stackName, ParcelStatus.ACTIVATED)\n-                .stream()\n-                .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+    public Map<String, String> getParcelsInStatus(ParcelsResourceApi parcelsResourceApi, String stackName, ParcelStatus parcelStatus) {\n+        try {\n+            return getClouderaManagerParcelsByStatus(parcelsResourceApi, stackName, parcelStatus)\n+                    .stream()\n+                    .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to fetch the list of activated parcels\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void deactivateUnusedParcels(ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, String stackName, Map<String,\n+            ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> installedComponents = getParcelsInStatus(parcelsResourceApi, stackName, ParcelStatus.ACTIVATED);\n+        Set<String> failedDeactivations = new HashSet<>();\n+        for (Map.Entry<String, String> installedComp : installedComponents.entrySet()) {\n+            if (!cmProducts.containsKey(installedComp.getKey())) {\n+                try {\n+                    parcelResourceApi.deactivateCommand(stackName, installedComp.getKey(), installedComp.getValue());\n+                } catch (ApiException e) {\n+                    String product = \"[\" + installedComp.getKey() + \":\" + installedComp.getValue() + \"]\";\n+                    LOGGER.info(String.format(\"Unable to deactivate product: %s\", product), e);\n+                    failedDeactivations.add(product);\n+                }\n+            }\n+        }\n+        if (!failedDeactivations.isEmpty()) {\n+            throw new ClouderaManagerOperationFailedException(String.format(\"Deactivation failed on the following products: %s\", failedDeactivations));", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NDg1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470664850", "bodyText": "are you sure this is needed? Since 7.0.0 I see only name=CDH, componenttype=CDH_PRODUCT_DETAILS duplets", "author": "pdarvasi", "createdAt": "2020-08-14T14:40:44Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelActivationListenerTask.java", "diffHunk": "@@ -68,10 +70,12 @@ protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, Comman\n     }\n \n     private List<ClouderaManagerProduct> getClouderaManagerProductsFromStack(Stack stack) {\n-        return Optional.ofNullable(stack).map(Stack::getCluster).map(Cluster::getComponents)\n-                .orElse(Set.of())\n-                .stream()\n-                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+        Stream<ClusterComponent> clusterCompStream = Optional.ofNullable(stack).map(Stack::getCluster).map(Cluster::getComponents).orElse(Set.of()).stream();\n+        boolean datalake = stack == null ? false : stack.isDatalake();\n+        Stream<ClusterComponent> cmProductStream = datalake ?\n+                clusterCompStream.filter(clusterComponent -> clusterComponent.getName().equals(StackType.CDH.name())) :", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5MDU5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470690595", "bodyText": "typo: existed -> existing", "author": "pdarvasi", "createdAt": "2020-08-14T15:20:50Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelDeletedListenerTask.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelDeletedListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelDeletedListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    public ClouderaManagerParcelDeletedListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;\n+    }\n+\n+    @Override\n+    protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, CommandsResourceApi commandsResourceApi) throws ApiException {\n+        ApiClient apiClient = pollerObject.getApiClient();\n+        Stack stack = pollerObject.getStack();\n+        ApiParcelList parcels = getClouderaManagerParcels(apiClient, stack.getName());\n+        List<ApiParcel> existedParcels = getExistedParcels(parcelVersion, parcels);\n+        if (existedParcels.isEmpty()) {\n+            LOGGER.debug(\"Parcels are deleted succesfully.\");\n+            return true;\n+        } else {\n+            LOGGER.debug(\"Some parcels are not yet deleted: [{}].\", getJoinedParcelStages(existedParcels));\n+            return false;\n+        }\n+    }\n+\n+    private ApiParcelList getClouderaManagerParcels(ApiClient apiClient, String stackName) throws ApiException {\n+        ParcelsResourceApi parcelsResourceApi = clouderaManagerApiPojoFactory.getParcelsResourceApi(apiClient);\n+        return parcelsResourceApi.readParcels(stackName, \"summary\");\n+    }\n+\n+    private List<ApiParcel> getExistedParcels(Map<String, String> parcelsVersions, ApiParcelList parcels) {", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMDc4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470620787", "bodyText": "unnecessary default implementation", "author": "lacikaaa", "createdAt": "2020-08-14T13:23:59Z", "path": "cluster-api/src/main/java/com/sequenceiq/cloudbreak/cluster/api/ClusterModificationService.java", "diffHunk": "@@ -29,7 +29,11 @@\n \n     void upgradeClusterRuntime(Set<ClusterComponent> components) throws CloudbreakException;\n \n-    default Map<String, String> gatherInstalledComponents(String hostname) {\n+    default Map<String, String> gatherInstalledParcels(String stackName) {", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNTg1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470625854", "bodyText": "I think we should log what we are deactivating", "author": "lacikaaa", "createdAt": "2020-08-14T13:33:09Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelService.java", "diffHunk": "@@ -12,39 +17,146 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n+import com.cloudera.api.swagger.ParcelResourceApi;\n import com.cloudera.api.swagger.ParcelsResourceApi;\n import com.cloudera.api.swagger.client.ApiClient;\n import com.cloudera.api.swagger.client.ApiException;\n import com.cloudera.api.swagger.model.ApiParcel;\n import com.cloudera.api.swagger.model.ApiParcelList;\n-import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n \n @Service\n class ClouderaManagerParcelService {\n-\n     private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelService.class);\n \n     @Inject\n-    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n \n-    public Map<String, String> getActivatedParcels(ApiClient client, String stackName) throws ApiException {\n-        return getClouderaManagerParcelsByStatus(client, stackName, ParcelStatus.ACTIVATED)\n-                .stream()\n-                .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+    public Map<String, String> getParcelsInStatus(ParcelsResourceApi parcelsResourceApi, String stackName, ParcelStatus parcelStatus) {\n+        try {\n+            return getClouderaManagerParcelsByStatus(parcelsResourceApi, stackName, parcelStatus)\n+                    .stream()\n+                    .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to fetch the list of activated parcels\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void deactivateUnusedParcels(ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, String stackName, Map<String,\n+            ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> installedComponents = getParcelsInStatus(parcelsResourceApi, stackName, ParcelStatus.ACTIVATED);\n+        Set<String> failedDeactivations = new HashSet<>();\n+        for (Map.Entry<String, String> installedComp : installedComponents.entrySet()) {\n+            if (!cmProducts.containsKey(installedComp.getKey())) {\n+                try {\n+                    parcelResourceApi.deactivateCommand(stackName, installedComp.getKey(), installedComp.getValue());", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMjEwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470632100", "bodyText": "it would be nice if we could get rid of these Map<String, String> in a followup task because it's actually a <product, version> map, but it's hard to figure out", "author": "lacikaaa", "createdAt": "2020-08-14T13:44:29Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelService.java", "diffHunk": "@@ -12,39 +17,146 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n+import com.cloudera.api.swagger.ParcelResourceApi;\n import com.cloudera.api.swagger.ParcelsResourceApi;\n import com.cloudera.api.swagger.client.ApiClient;\n import com.cloudera.api.swagger.client.ApiException;\n import com.cloudera.api.swagger.model.ApiParcel;\n import com.cloudera.api.swagger.model.ApiParcelList;\n-import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n \n @Service\n class ClouderaManagerParcelService {\n-\n     private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelService.class);\n \n     @Inject\n-    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n \n-    public Map<String, String> getActivatedParcels(ApiClient client, String stackName) throws ApiException {\n-        return getClouderaManagerParcelsByStatus(client, stackName, ParcelStatus.ACTIVATED)\n-                .stream()\n-                .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+    public Map<String, String> getParcelsInStatus(ParcelsResourceApi parcelsResourceApi, String stackName, ParcelStatus parcelStatus) {\n+        try {\n+            return getClouderaManagerParcelsByStatus(parcelsResourceApi, stackName, parcelStatus)\n+                    .stream()\n+                    .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to fetch the list of activated parcels\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void deactivateUnusedParcels(ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, String stackName, Map<String,\n+            ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> installedComponents = getParcelsInStatus(parcelsResourceApi, stackName, ParcelStatus.ACTIVATED);\n+        Set<String> failedDeactivations = new HashSet<>();\n+        for (Map.Entry<String, String> installedComp : installedComponents.entrySet()) {\n+            if (!cmProducts.containsKey(installedComp.getKey())) {\n+                try {\n+                    parcelResourceApi.deactivateCommand(stackName, installedComp.getKey(), installedComp.getValue());\n+                } catch (ApiException e) {\n+                    String product = \"[\" + installedComp.getKey() + \":\" + installedComp.getValue() + \"]\";\n+                    LOGGER.info(String.format(\"Unable to deactivate product: %s\", product), e);\n+                    failedDeactivations.add(product);\n+                }\n+            }\n+        }\n+        if (!failedDeactivations.isEmpty()) {\n+            throw new ClouderaManagerOperationFailedException(String.format(\"Deactivation failed on the following products: %s\", failedDeactivations));\n+        }\n+    }\n+\n+    public void undistributeUnusedParcels(ApiClient apiClient, ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, Stack stack,\n+            Map<String, ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> distributedComponents = getParcelsInStatus(parcelsResourceApi, stack.getName(), ParcelStatus.DISTRIBUTED);", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEyOTYxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r471129617", "bodyText": "Followup task: https://jira.cloudera.com/browse/CB-8485", "author": "schfeca75", "createdAt": "2020-08-16T16:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMjEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMjc0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470632746", "bodyText": "log would be nice", "author": "lacikaaa", "createdAt": "2020-08-14T13:45:34Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelService.java", "diffHunk": "@@ -12,39 +17,146 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n+import com.cloudera.api.swagger.ParcelResourceApi;\n import com.cloudera.api.swagger.ParcelsResourceApi;\n import com.cloudera.api.swagger.client.ApiClient;\n import com.cloudera.api.swagger.client.ApiException;\n import com.cloudera.api.swagger.model.ApiParcel;\n import com.cloudera.api.swagger.model.ApiParcelList;\n-import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n \n @Service\n class ClouderaManagerParcelService {\n-\n     private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelService.class);\n \n     @Inject\n-    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n \n-    public Map<String, String> getActivatedParcels(ApiClient client, String stackName) throws ApiException {\n-        return getClouderaManagerParcelsByStatus(client, stackName, ParcelStatus.ACTIVATED)\n-                .stream()\n-                .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+    public Map<String, String> getParcelsInStatus(ParcelsResourceApi parcelsResourceApi, String stackName, ParcelStatus parcelStatus) {\n+        try {\n+            return getClouderaManagerParcelsByStatus(parcelsResourceApi, stackName, parcelStatus)\n+                    .stream()\n+                    .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to fetch the list of activated parcels\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void deactivateUnusedParcels(ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, String stackName, Map<String,\n+            ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> installedComponents = getParcelsInStatus(parcelsResourceApi, stackName, ParcelStatus.ACTIVATED);\n+        Set<String> failedDeactivations = new HashSet<>();\n+        for (Map.Entry<String, String> installedComp : installedComponents.entrySet()) {\n+            if (!cmProducts.containsKey(installedComp.getKey())) {\n+                try {\n+                    parcelResourceApi.deactivateCommand(stackName, installedComp.getKey(), installedComp.getValue());\n+                } catch (ApiException e) {\n+                    String product = \"[\" + installedComp.getKey() + \":\" + installedComp.getValue() + \"]\";\n+                    LOGGER.info(String.format(\"Unable to deactivate product: %s\", product), e);\n+                    failedDeactivations.add(product);\n+                }\n+            }\n+        }\n+        if (!failedDeactivations.isEmpty()) {\n+            throw new ClouderaManagerOperationFailedException(String.format(\"Deactivation failed on the following products: %s\", failedDeactivations));\n+        }\n+    }\n+\n+    public void undistributeUnusedParcels(ApiClient apiClient, ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, Stack stack,\n+            Map<String, ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> distributedComponents = getParcelsInStatus(parcelsResourceApi, stack.getName(), ParcelStatus.DISTRIBUTED);\n+        Map<String, String> filteredParcels = distributedComponents.entrySet().stream()\n+                .filter(entry -> !cmProducts.containsKey(entry.getKey()))\n+                .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+        undistributeParcels(apiClient, parcelResourceApi, stack, filteredParcels);\n+    }\n+\n+    public void removeUnusedParcels(ApiClient apiClient, ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, Stack stack,\n+            Map<String, ClouderaManagerProduct> cmProducts) {\n+        Map<String, String> downloadedParcels = getParcelsInStatus(parcelsResourceApi, stack.getName(), ParcelStatus.DOWNLOADED);\n+        Map<String, String> filteredParcels = downloadedParcels.entrySet().stream()\n+                .filter(entry -> !cmProducts.containsKey(entry.getKey()))\n+                .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+        removeParcels(apiClient, parcelResourceApi, stack, filteredParcels);\n+    }\n+\n+    public void removeUnusedParcelVersions(ApiClient apiClient, ParcelsResourceApi parcelsResourceApi, ParcelResourceApi parcelResourceApi, Stack stack,\n+            String parcel, String usedVersion) throws ApiException {\n+        Map<String, String> unusedDistributedParcelVersions =\n+                getClouderaManagerParcelsByStatus(parcelsResourceApi, stack.getName(), ParcelStatus.DISTRIBUTED).stream()\n+                        .filter(apiParcel -> apiParcel.getProduct().equals(parcel) && !apiParcel.getVersion().equals(usedVersion))\n+                        .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        undistributeParcels(apiClient, parcelResourceApi, stack, unusedDistributedParcelVersions);\n+\n+        Map<String, String> unusedDownloadedParcelVersions =\n+                getClouderaManagerParcelsByStatus(parcelsResourceApi, stack.getName(), ParcelStatus.DOWNLOADED).stream()\n+                        .filter(apiParcel -> apiParcel.getProduct().equals(parcel) && !apiParcel.getVersion().equals(usedVersion))\n+                        .collect(Collectors.toMap(ApiParcel::getProduct, ApiParcel::getVersion));\n+        removeParcels(apiClient, parcelResourceApi, stack, unusedDownloadedParcelVersions);\n+    }\n+\n+    private void undistributeParcels(ApiClient apiClient, ParcelResourceApi parcelResourceApi, Stack stack, Map<String, String> parcels) {\n+        Set<String> failedDistribution = new HashSet<>();\n+        for (Map.Entry<String, String> distributedComponent : parcels.entrySet()) {\n+            try {\n+                parcelResourceApi.startRemovalOfDistributionCommand(stack.getName(), distributedComponent.getKey(), distributedComponent.getValue());", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNDM0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470634342", "bodyText": "simplify: boolean datalake = stack != null && stack.isDatalake();", "author": "lacikaaa", "createdAt": "2020-08-14T13:48:20Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelActivationListenerTask.java", "diffHunk": "@@ -68,10 +70,12 @@ protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, Comman\n     }\n \n     private List<ClouderaManagerProduct> getClouderaManagerProductsFromStack(Stack stack) {\n-        return Optional.ofNullable(stack).map(Stack::getCluster).map(Cluster::getComponents)\n-                .orElse(Set.of())\n-                .stream()\n-                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+        Stream<ClusterComponent> clusterCompStream = Optional.ofNullable(stack).map(Stack::getCluster).map(Cluster::getComponents).orElse(Set.of()).stream();\n+        boolean datalake = stack == null ? false : stack.isDatalake();", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY0NjAyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470646028", "bodyText": "I would suggest:\n    private List<ClouderaManagerProduct> getClouderaManagerProductsFromStack(Stack stack) {\n        return getClusterComponents(stack).stream()\n                .filter(createClusterComponentFilter(stack))\n                .map(ClusterComponent::getAttributes)\n                .map(toAttributeClass(ClouderaManagerProduct.class))\n                .collect(Collectors.toList());\n    }\n\n    private Set<ClusterComponent> getClusterComponents(Stack stack) {\n        return Optional.ofNullable(stack)\n                .map(Stack::getCluster)\n                .map(Cluster::getComponents).orElse(Set.of());\n    }\n\n    private Predicate<ClusterComponent> createClusterComponentFilter(Stack stack) {\n        boolean datalake = stack != null && stack.isDatalake();\n        Predicate<ClusterComponent> datalakeClusterComponentFilter = \n                clusterComponent -> clusterComponent.getName().equals(StackType.CDH.name());\n        Predicate<ClusterComponent> distroxClusterComponentFilter = \n                clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType());\n        return datalake ? datalakeClusterComponentFilter : distroxClusterComponentFilter;\n    }", "author": "lacikaaa", "createdAt": "2020-08-14T14:08:28Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelActivationListenerTask.java", "diffHunk": "@@ -68,10 +70,12 @@ protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, Comman\n     }\n \n     private List<ClouderaManagerProduct> getClouderaManagerProductsFromStack(Stack stack) {", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY0NzY1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470647656", "bodyText": "this could be omitted as the field and parameter name are different", "author": "lacikaaa", "createdAt": "2020-08-14T14:11:20Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelDeletedListenerTask.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelDeletedListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelDeletedListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    public ClouderaManagerParcelDeletedListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1MDg1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470650853", "bodyText": "Map<String, String> parcelsVersions is an unnecessary parameter as it's a field in the class", "author": "lacikaaa", "createdAt": "2020-08-14T14:16:42Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelDeletedListenerTask.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelDeletedListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelDeletedListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    public ClouderaManagerParcelDeletedListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;\n+    }\n+\n+    @Override\n+    protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, CommandsResourceApi commandsResourceApi) throws ApiException {\n+        ApiClient apiClient = pollerObject.getApiClient();\n+        Stack stack = pollerObject.getStack();\n+        ApiParcelList parcels = getClouderaManagerParcels(apiClient, stack.getName());\n+        List<ApiParcel> existedParcels = getExistedParcels(parcelVersion, parcels);\n+        if (existedParcels.isEmpty()) {\n+            LOGGER.debug(\"Parcels are deleted succesfully.\");\n+            return true;\n+        } else {\n+            LOGGER.debug(\"Some parcels are not yet deleted: [{}].\", getJoinedParcelStages(existedParcels));\n+            return false;\n+        }\n+    }\n+\n+    private ApiParcelList getClouderaManagerParcels(ApiClient apiClient, String stackName) throws ApiException {\n+        ParcelsResourceApi parcelsResourceApi = clouderaManagerApiPojoFactory.getParcelsResourceApi(apiClient);\n+        return parcelsResourceApi.readParcels(stackName, \"summary\");\n+    }\n+\n+    private List<ApiParcel> getExistedParcels(Map<String, String> parcelsVersions, ApiParcelList parcels) {", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1NzI3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470657279", "bodyText": "I would simplify:\n    private List<ApiParcel> collectExistingParcels(ApiParcelList parcelsFromCM) {\n        return parcelsFromCM.getItems().stream()\n                .filter(this::isMatchingParcel)\n                .collect(Collectors.toList());\n    }\n\n    private boolean isMatchingParcel(ApiParcel parcel) {\n        return parcelVersion.containsKey(parcel.getProduct()) && parcelVersion.get(parcel.getProduct()).equals(parcel.getVersion());\n    }", "author": "lacikaaa", "createdAt": "2020-08-14T14:27:22Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelDeletedListenerTask.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelDeletedListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelDeletedListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    public ClouderaManagerParcelDeletedListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;\n+    }\n+\n+    @Override\n+    protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, CommandsResourceApi commandsResourceApi) throws ApiException {\n+        ApiClient apiClient = pollerObject.getApiClient();\n+        Stack stack = pollerObject.getStack();\n+        ApiParcelList parcels = getClouderaManagerParcels(apiClient, stack.getName());\n+        List<ApiParcel> existedParcels = getExistedParcels(parcelVersion, parcels);\n+        if (existedParcels.isEmpty()) {\n+            LOGGER.debug(\"Parcels are deleted succesfully.\");\n+            return true;\n+        } else {\n+            LOGGER.debug(\"Some parcels are not yet deleted: [{}].\", getJoinedParcelStages(existedParcels));\n+            return false;\n+        }\n+    }\n+\n+    private ApiParcelList getClouderaManagerParcels(ApiClient apiClient, String stackName) throws ApiException {\n+        ParcelsResourceApi parcelsResourceApi = clouderaManagerApiPojoFactory.getParcelsResourceApi(apiClient);\n+        return parcelsResourceApi.readParcels(stackName, \"summary\");\n+    }\n+\n+    private List<ApiParcel> getExistedParcels(Map<String, String> parcelsVersions, ApiParcelList parcels) {\n+        List<ApiParcel> existedParcels = new ArrayList<>();\n+        for (Map.Entry<String, String> parcelVersion : parcelsVersions.entrySet()) {\n+            Optional<ApiParcel> apiParcel = parcels.getItems().stream()\n+                    .filter(parcel -> isParcelMatching(parcelVersion.getKey(), parcelVersion.getValue(), parcel))\n+                    .findFirst();\n+            apiParcel.ifPresent(p -> existedParcels.add(p));\n+        }\n+        return existedParcels;\n+    }\n+\n+    private boolean isParcelMatching(String parcel, String version, ApiParcel apiParcel) {\n+        return parcel.equals(apiParcel.getProduct())\n+                && version.equals(apiParcel.getVersion());\n+    }", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1ODYyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470658628", "bodyText": "same here, rename the field or omit this.", "author": "lacikaaa", "createdAt": "2020-08-14T14:29:37Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelStatusListenerTask.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelStatusListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelStatusListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    private ParcelStatus parcelStatus;\n+\n+    public ClouderaManagerParcelStatusListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions, ParcelStatus parcelStatus) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NDYxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470664617", "bodyText": "the first parameter a field also.\nI would simplify this with:\n    private List<ApiParcel> getNotInProperStateParcels(ApiParcelList parcels) {\n        return parcels.getItems().stream()\n                .filter(parcel -> parcelVersion.containsKey(parcel.getProduct()))\n                .filter(parcel -> parcelVersion.get(parcel.getProduct()).equals(parcel.getVersion()))\n                .filter(parcel -> !parcelStatus.name().equals(parcel.getStage()))\n                .collect(Collectors.toList());\n    }", "author": "lacikaaa", "createdAt": "2020-08-14T14:40:21Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/task/ClouderaManagerParcelStatusListenerTask.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.sequenceiq.cloudbreak.cm.polling.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.api.swagger.CommandsResourceApi;\n+import com.cloudera.api.swagger.ParcelsResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiParcel;\n+import com.cloudera.api.swagger.model.ApiParcelList;\n+import com.sequenceiq.cloudbreak.cm.ClouderaManagerOperationFailedException;\n+import com.sequenceiq.cloudbreak.cm.client.ClouderaManagerApiPojoFactory;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelStatus;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollerObject;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.structuredevent.event.CloudbreakEventService;\n+\n+public class ClouderaManagerParcelStatusListenerTask extends AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelStatusListenerTask.class);\n+\n+    private Map<String, String> parcelVersion;\n+\n+    private ParcelStatus parcelStatus;\n+\n+    public ClouderaManagerParcelStatusListenerTask(ClouderaManagerApiPojoFactory clouderaManagerApiPojoFactory,\n+            CloudbreakEventService cloudbreakEventService, Map<String, String> parcelVersions, ParcelStatus parcelStatus) {\n+        super(clouderaManagerApiPojoFactory, cloudbreakEventService);\n+        this.parcelVersion = parcelVersions;\n+        this.parcelStatus = parcelStatus;\n+    }\n+\n+    @Override\n+    protected boolean doStatusCheck(ClouderaManagerPollerObject pollerObject, CommandsResourceApi commandsResourceApi) throws ApiException {\n+        ApiClient apiClient = pollerObject.getApiClient();\n+        Stack stack = pollerObject.getStack();\n+        ApiParcelList parcels = getClouderaManagerParcels(apiClient, stack.getName());\n+        List<ApiParcel> notInProperStateParcels = getNotInProperStateParcels(parcelVersion, parcels);\n+        if (notInProperStateParcels.isEmpty()) {\n+            LOGGER.debug(\"Parcels are in the proper statuses: {}\", parcelStatus);\n+            return true;\n+        } else {\n+            LOGGER.debug(\"Some parcels are not yet in the proper status: [{}].\", getJoinedParcelStages(notInProperStateParcels));\n+            return false;\n+        }\n+    }\n+\n+    private ApiParcelList getClouderaManagerParcels(ApiClient apiClient, String stackName) throws ApiException {\n+        ParcelsResourceApi parcelsResourceApi = clouderaManagerApiPojoFactory.getParcelsResourceApi(apiClient);\n+        return parcelsResourceApi.readParcels(stackName, \"summary\");\n+    }\n+\n+    private List<ApiParcel> getNotInProperStateParcels(Map<String, String> parcelsVersions, ApiParcelList parcels) {", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MjE3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470672170", "bodyText": "I think you shouldn't override the default implementation here", "author": "lacikaaa", "createdAt": "2020-08-14T14:48:55Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeInitRequest.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.sequenceiq.cloudbreak.reactor.api.event.cluster.upgrade;\n+\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+\n+public class ClusterUpgradeInitRequest extends StackEvent {\n+    public ClusterUpgradeInitRequest(Long stackId) {\n+        super(stackId);\n+    }\n+\n+    @Override\n+    public String selector() {\n+        return \"ClusterUpgradeInitRequest\";", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MjY5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470672691", "bodyText": "use EventSelectorUtil.selector(ClusterUpgradeInitRequest.class)", "author": "lacikaaa", "createdAt": "2020-08-14T14:49:49Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/upgrade/ClusterUpgradeEvent.java", "diffHunk": "@@ -3,7 +3,9 @@\n import com.sequenceiq.flow.core.FlowEvent;\n \n public enum ClusterUpgradeEvent implements FlowEvent {\n-    CLUSTER_MANAGER_UPGRADE_EVENT(\"CLUSTER_MANAGER_UPGRADE_EVENT\"),\n+    CLUSTER_UPGRADE_INIT_EVENT(\"CLUSTER_UPGRADE_INIT_EVENT\"),", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzMxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470673315", "bodyText": "this should be: CLUSTER_UPGRADE_INIT_EVENT.event() or CLUSTER_UPGRADE_INIT_EVENT.selector()", "author": "lacikaaa", "createdAt": "2020-08-14T14:50:48Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/cluster/upgrade/ClusterUpgradeInitHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.reactor.handler.cluster.upgrade;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.cluster.ClusterManagerUpgradeService;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.upgrade.ClusterUpgradeInitRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.upgrade.ClusterUpgradeInitSuccess;\n+import com.sequenceiq.cloudbreak.reactor.api.event.cluster.upgrade.ClusterUpgradeFailedEvent;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+\n+@Component\n+public class ClusterUpgradeInitHandler extends ExceptionCatcherEventHandler<ClusterUpgradeInitRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClusterUpgradeInitHandler.class);\n+\n+    @Inject\n+    private ClusterManagerUpgradeService clusterManagerUpgradeService;\n+\n+    @Override\n+    public String selector() {\n+        return \"ClusterUpgradeInitRequest\";", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcwODU3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470708574", "bodyText": ".orElseThrow() would spare us the next line for null check", "author": "lacikaaa", "createdAt": "2020-08-14T15:49:57Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/parcel/ParcelService.java", "diffHunk": "@@ -35,6 +45,35 @@\n     @Inject\n     private RestClientFactory restClientFactory;\n \n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n+    public Set<ClusterComponent> getParcelComponentsByBlueprint(Stack stack) {\n+        Cluster cluster = stack.getCluster();\n+        Set<ClusterComponent> components = getParcelComponents(cluster);\n+        if (stack.isDatalake()) {\n+            ClusterComponent stackComponent = components.stream()\n+                    .filter(clusterComponent -> clusterComponent.getName().equals(StackType.CDH.name()))\n+                    .findFirst().orElse(null);", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxMDk0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8753#discussion_r470710944", "bodyText": "same here, orElseThrow", "author": "lacikaaa", "createdAt": "2020-08-14T15:54:23Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeAvailabilityService.java", "diffHunk": "@@ -169,6 +175,26 @@ private UpgradeV4Response checkForUpgrades(Stack stack, boolean lockComponents)\n         return upgradeOptions;\n     }\n \n+    private Map<String, String> getActivatedParcels(Stack stack) {\n+        if (stack.isDatalake()) {\n+            Set<ClusterComponent> components = clusterComponentConfigProvider.getComponentsByClusterId(stack.getCluster().getId());\n+            ClusterComponent stackComponent = components.stream()\n+                    .filter(clusterComponent -> clusterComponent.getName().equals(StackType.CDH.name()))\n+                    .findFirst().orElse(null);", "originalCommit": "85704d5acb1671747c88980408301bc453c92122", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c34e3f84316c177a0863faa208e3c5dba37c4dc1", "url": "https://github.com/hortonworks/cloudbreak/commit/c34e3f84316c177a0863faa208e3c5dba37c4dc1", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-16T15:49:29Z", "type": "forcePushed"}, {"oid": "19c69f851d2f79020308cf27a7e56b5f2ba5c860", "url": "https://github.com/hortonworks/cloudbreak/commit/19c69f851d2f79020308cf27a7e56b5f2ba5c860", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-24T15:39:33Z", "type": "commit"}, {"oid": "19c69f851d2f79020308cf27a7e56b5f2ba5c860", "url": "https://github.com/hortonworks/cloudbreak/commit/19c69f851d2f79020308cf27a7e56b5f2ba5c860", "message": "CB-8040 Parcels are activated without distribution in replaced VM\n\nCluster upgrade flow modifications:\n1. Determine used parcels:\n  - in case of Datalake the only used parcel is CDH\n  - in case of Datahub, the used parcels are collected from the blueprint.\n2. New step in Cluster upgrade flow: Remove all unused parcels from CM.\n3. After cluster runtime upgrade remove all the CDH parcels with different version than the actual one\n4. During parcel activation in case of datalake only waiting for the CDH parcel to be activated", "committedDate": "2020-08-24T15:39:33Z", "type": "forcePushed"}]}