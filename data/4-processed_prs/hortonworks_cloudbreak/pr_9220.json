{"pr_number": 9220, "pr_title": "CB-8639 Stop RDS when stopping DistroX cluster", "pr_createdAt": "2020-10-14T12:16:08Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9220", "timeline": [{"oid": "ee39e0f18c129f3cbdcc73cdc0ee0d25849db101", "url": "https://github.com/hortonworks/cloudbreak/commit/ee39e0f18c129f3cbdcc73cdc0ee0d25849db101", "message": "CB-8639 Stop RDS when stopping DistroX cluster\n\nAdding new flows into the the stop/start flow chains, new\nstates for stack.\nChallenge was to find the extra condition that checks the\nproper status for stopping.\nNOTE: the cert pre-validation flag is now set to Ignored in\nthe 'core' module!", "committedDate": "2020-10-14T12:14:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNTAxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9220#discussion_r504805011", "bodyText": "should we just redbeams and if redbeams say it is not supported than we just ignore the start stop on the DB ?", "author": "doktoric", "createdAt": "2020-10-14T16:14:56Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/externaldatabase/start/handler/StartExternalDatabaseHandler.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.handler;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.config.ExternalDatabaseStartEvent.EXTERNAL_DATABASE_STARTED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.config.ExternalDatabaseStartEvent.EXTERNAL_DATABASE_START_FAILED_EVENT;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.dyngr.exception.PollerException;\n+import com.dyngr.exception.PollerStoppedException;\n+import com.dyngr.exception.UserBreakException;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.database.DatabaseAvailabilityType;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.cloudbreak.conf.ExternalDatabaseConfig;\n+import com.sequenceiq.cloudbreak.core.flow2.externaldatabase.ExternalDatabaseService;\n+import com.sequenceiq.cloudbreak.core.flow2.externaldatabase.StackUpdaterService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseFailed;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseResult;\n+import com.sequenceiq.cloudbreak.service.environment.EnvironmentClientService;\n+import com.sequenceiq.environment.api.v1.environment.model.response.DetailedEnvironmentResponse;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+\n+import reactor.bus.Event;\n+\n+@Component\n+public class StartExternalDatabaseHandler extends ExceptionCatcherEventHandler<StartExternalDatabaseRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartExternalDatabaseHandler.class);\n+\n+    @Inject\n+    private ExternalDatabaseService startService;\n+\n+    @Inject\n+    private StackUpdaterService stackUpdaterService;\n+\n+    @Inject\n+    private EnvironmentClientService environmentClientService;\n+\n+    @Inject\n+    private ExternalDatabaseConfig externalDatabaseConfig;\n+\n+    @Override\n+    public String selector() {\n+        return \"StartExternalDatabaseRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e, Event<StartExternalDatabaseRequest> event) {\n+        Stack stack = event.getData().getStack();\n+        LOGGER.error(String.format(\"Exception during DB 'start' for stack/cluster: %s\", stack.getName()), e);\n+        return startFailedEvent(stack, e);\n+    }\n+\n+    @Override\n+    protected Selectable doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"In StartExternalDatabaseHandler.doAccept\");\n+        StartExternalDatabaseRequest request = event.getData();\n+        Stack stack = request.getStack();\n+        DatabaseAvailabilityType externalDatabase = ObjectUtils.defaultIfNull(stack.getExternalDatabaseCreationType(), DatabaseAvailabilityType.NONE);\n+        LOGGER.debug(\"External database: {} for stack {}\", externalDatabase.name(), stack.getName());\n+        LOGGER.debug(\"Getting environment CRN for stack {}\", stack.getName());\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+        Selectable result;\n+        try {\n+            if (StackType.WORKLOAD != stack.getType()) {\n+                LOGGER.debug(\"External database start in Cloudbreak service is required for WORKLOAD stacks only.\");\n+                result = new StartExternalDatabaseResult(stack.getId(), EXTERNAL_DATABASE_STARTED_EVENT.event(),\n+                        stack.getName(), null);\n+            } else if (externalDatabase == DatabaseAvailabilityType.NONE) {\n+                LOGGER.info(\"External database for stack {} is not requested. Start is not possible.\", stack.getName());\n+                result = new StartExternalDatabaseResult(stack.getId(), EXTERNAL_DATABASE_STARTED_EVENT.event(),\n+                        stack.getName(), null);\n+            } else if (!externalDatabaseConfig.isExternalDatabasePauseSupportedFor(CloudPlatform.valueOf(environment.getCloudPlatform()))) {", "originalCommit": "ee39e0f18c129f3cbdcc73cdc0ee0d25849db101", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}