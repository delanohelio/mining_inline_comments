{"pr_number": 9294, "pr_title": "CB-9109 Freeipa launch crippled by missing storage account", "pr_createdAt": "2020-10-27T08:20:22Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9294", "timeline": [{"oid": "e5946d60d2767dd422ab629acc7b5ca586702a51", "url": "https://github.com/hortonworks/cloudbreak/commit/e5946d60d2767dd422ab629acc7b5ca586702a51", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nIn this commit the bug is fixed by refactoring.", "committedDate": "2020-10-27T18:26:33Z", "type": "forcePushed"}, {"oid": "64f657e88470b9298b2c96357a0c03de93bb60ae", "url": "https://github.com/hortonworks/cloudbreak/commit/64f657e88470b9298b2c96357a0c03de93bb60ae", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nBeyond the bugfix some refactoring:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-10-27T21:25:33Z", "type": "forcePushed"}, {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "url": "https://github.com/hortonworks/cloudbreak/commit/3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-10-28T07:17:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520390343", "bodyText": "Why haven't you extended AzureImage? It has multiple common fields, seems like it has the same purpose.", "author": "pdarvasi", "createdAt": "2020-11-10T08:53:46Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MTQ4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520461488", "bodyText": "While it's true they have common fields but there are some not in common, as well. They also serve slightly different purposes.\nI view it as:\ninput: AzureImageDetails. Grouping all the needed input parameters into one class\noutput: AzureImage. Tells, for example, if an image exists.\nI would keep it.", "author": "gergopapi2", "createdAt": "2020-11-10T10:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3ODQ4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520478489", "bodyText": "I renamed it to AzureImageInfo in hope to give it a better name.", "author": "gergopapi2", "createdAt": "2020-11-10T11:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMTA3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520421075", "bodyText": "I'd still prefer isRequested as it check for current status \"REQUESTED\"", "author": "pdarvasi", "createdAt": "2020-11-10T09:39:54Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -135,7 +106,7 @@ public CloudResource buildCloudResource(String name, String id, CommonStatus sta\n                 .build();\n     }\n \n-    private boolean isRequested(String imageId) {\n-        return resourcePersistenceRetriever.notifyRetrieve(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n+    private boolean wasCreateRequested(AzureImageDetails azureImageDetails) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426272", "bodyText": "Generally, I don't like the image --> customImage renames, as it is an Azure Java SDK only term, the object type is \"type\": \"Microsoft.Compute/images\" and in Portal, it is called \"Image\" in Azure Portal, too.\nFurthermore, the custom image term in Cloudbreak is used for a completely different concept. Pls. undo the renames.\nIt would be best to rename all occurrences, regardless of this PR.", "author": "pdarvasi", "createdAt": "2020-11-10T09:47:31Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2OTg5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520469895", "bodyText": "You mean in AzureClient as well? Doing it.", "author": "gergopapi2", "createdAt": "2020-11-10T10:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjg5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426894", "bodyText": "same: pls. rename the rename", "author": "pdarvasi", "createdAt": "2020-11-10T09:48:30Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjk0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426943", "bodyText": "same: pls. rename the rename", "author": "pdarvasi", "createdAt": "2020-11-10T09:48:36Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n-        LOGGER.debug(\"Updating image status to {}: {}\", commonStatus.toString(), imageId);\n+    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {", "originalCommit": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a17775ddb155fd268caded09f35a807c89e4c311", "url": "https://github.com/hortonworks/cloudbreak/commit/a17775ddb155fd268caded09f35a807c89e4c311", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-10T11:37:18Z", "type": "forcePushed"}, {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-17T20:57:17Z", "type": "commit"}, {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class", "committedDate": "2020-11-17T20:57:17Z", "type": "forcePushed"}]}