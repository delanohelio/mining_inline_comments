{"pr_number": 9674, "pr_title": "CB-9182 Add Support for CCMV2", "pr_createdAt": "2020-12-21T15:15:20Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9674", "timeline": [{"oid": "8ae8085c2193cdabce84b24a418ac004d4d462eb", "url": "https://github.com/hortonworks/cloudbreak/commit/8ae8085c2193cdabce84b24a418ac004d4d462eb", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2020-12-22T16:52:15Z", "type": "forcePushed"}, {"oid": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "url": "https://github.com/hortonworks/cloudbreak/commit/e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-04T04:34:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjAxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551216010", "bodyText": "while this is a compact form I would prefer if you could split this into multiple lines and log the value of grpcCcmV2Client.getOrCreateInvertingProxy. This way we would be able to tell if it is null or the state is wrong", "author": "lacikaaa", "createdAt": "2021-01-04T09:57:21Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmV2ManagementClient.class);\n+\n+    @Inject\n+    private GrpcCcmV2Client grpcCcmV2Client;\n+\n+    @Inject\n+    private GrpcCcmV2Config grpcCcmV2Config;\n+\n+    public InvertingProxy awaitReadyInvertingProxyForAccount(String requestId, String accountId) {\n+        return getRetryTemplate().execute(\n+                retryContext -> {\n+                    LOGGER.debug(\"Retrieving InvertingProxy Config for accountId '{}'\", accountId);\n+                    return Optional.ofNullable(grpcCcmV2Client.getOrCreateInvertingProxy(requestId, accountId, ThreadBasedUserCrnProvider.getUserCrn()))\n+                            .filter(invertingProxy -> InvertingProxy.Status.READY.equals(invertingProxy.getStatus()))", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwNzY0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552507641", "bodyText": "I used the compact form but proto3 does not return null. To support logging returned state I split it into multiple lines as suggested.", "author": "smaniraju", "createdAt": "2021-01-06T10:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjI5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551216298", "bodyText": "could you introduce a new exception for this? (and the others)\nalso I'm not sure if RuntimeException is the right way to go here. Shouldn't we enforce the handling of these expected exception on the callers side?", "author": "lacikaaa", "createdAt": "2021-01-04T09:57:58Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmV2ManagementClient.class);\n+\n+    @Inject\n+    private GrpcCcmV2Client grpcCcmV2Client;\n+\n+    @Inject\n+    private GrpcCcmV2Config grpcCcmV2Config;\n+\n+    public InvertingProxy awaitReadyInvertingProxyForAccount(String requestId, String accountId) {\n+        return getRetryTemplate().execute(\n+                retryContext -> {\n+                    LOGGER.debug(\"Retrieving InvertingProxy Config for accountId '{}'\", accountId);\n+                    return Optional.ofNullable(grpcCcmV2Client.getOrCreateInvertingProxy(requestId, accountId, ThreadBasedUserCrnProvider.getUserCrn()))\n+                            .filter(invertingProxy -> InvertingProxy.Status.READY.equals(invertingProxy.getStatus()))\n+                            .orElseThrow(() -> new RuntimeException(String.format(\"InvertingProxy not found in ready state for accountId '%s'\", accountId)));", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODI0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508245", "bodyText": "Ok introduced new exception. But there is not much handling the caller can do after ccm retry fails, the caller just rethrows the exception and stack creation is marked failure because of CCM issue. This behaviour is consistent with CCMV1.", "author": "smaniraju", "createdAt": "2021-01-06T11:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMjc5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551222796", "bodyText": "please add unit test", "author": "lacikaaa", "createdAt": "2021-01-04T10:10:33Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/CcmV2ManagementClient.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.backoff.FixedBackOffPolicy;\n+import org.springframework.retry.policy.TimeoutRetryPolicy;\n+import org.springframework.retry.support.RetryTemplate;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+\n+@Component\n+public class CcmV2ManagementClient {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODU2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508562", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMjc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNjkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551226933", "bodyText": "shall we log the requests here before calling the service?", "author": "lacikaaa", "createdAt": "2021-01-04T10:18:19Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/GrpcCcmV2Client.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2;\n+\n+import static io.grpc.internal.GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE;\n+\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Grpc.ClusterConnectivityManagementV2BlockingStub;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.CreateOrGetInvertingProxyResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RegisterAgentResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyResponse;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.RemoveInvertingProxyRequest;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.UnregisterAgentRequest;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config.GrpcCcmV2Config;\n+import com.sequenceiq.cloudbreak.grpc.ManagedChannelWrapper;\n+import com.sequenceiq.cloudbreak.grpc.altus.AltusMetadataInterceptor;\n+import com.sequenceiq.cloudbreak.grpc.util.GrpcUtil;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentracing.Tracer;\n+\n+@Component\n+public class GrpcCcmV2Client {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODc0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508743", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNzk0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551227949", "bodyText": "the intent of @Configuration annotation is to define beans. You should use @Component here", "author": "lacikaaa", "createdAt": "2021-01-04T10:20:16Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/ccmv2/config/GrpcCcmV2Config.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.ccmv2.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwODgyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552508827", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNzk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDI4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551234283", "bodyText": "could you move these validations to a separate method? thanks", "author": "lacikaaa", "createdAt": "2021-01-04T10:32:02Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/cloudinit/DefaultCcmV2ParameterSupplier.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.cloudinit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxy;\n+import com.cloudera.thunderhead.service.clusterconnectivitymanagementv2.ClusterConnectivityManagementV2Proto.InvertingProxyAgent;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.DefaultCcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.CcmV2ManagementClient;\n+import com.sequenceiq.cloudbreak.logger.LoggerContextKey;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+\n+@Component\n+public class DefaultCcmV2ParameterSupplier implements CcmV2ParameterSupplier {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultCcmV2ParameterSupplier.class);\n+\n+    @Inject\n+    private CcmV2ManagementClient ccmV2Client;\n+\n+    public CcmV2Parameters getCcmV2Parameters(@Nonnull String accountId, @Nonnull String clusterGatewayDomain, @Nonnull String agentKeyId) {\n+        String requestId = Optional.ofNullable(MDCBuilder.getMdcContextMap().get(LoggerContextKey.REQUEST_ID.toString())).orElse(UUID.randomUUID().toString());\n+        MDCBuilder.addRequestId(requestId);\n+\n+        InvertingProxy invertingProxy = ccmV2Client.awaitReadyInvertingProxyForAccount(requestId, accountId);\n+        InvertingProxyAgent invertingProxyAgent = ccmV2Client.registerInvertingProxyAgent(requestId, accountId, clusterGatewayDomain, agentKeyId);\n+\n+        checkArgument(StringUtils.isNotEmpty(invertingProxy.getHostname()), \"InvertingProxy Hostname is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxy.getCertificate()), \"InvertingProxy Certificate is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getAgentCrn()), \"InvertingProxyAgent Crn is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getEncipheredPrivateKey()), \"InvertingProxyAgent Enciphered Key is not initialized.\");\n+        checkArgument(StringUtils.isNotEmpty(invertingProxyAgent.getCertificate()), \"InvertingProxyAgent Certificate is not initialized.\");", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509322", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTM4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551235388", "bodyText": "this seems to be a duplication of the code already in DefaultCcmV2ParameterSupplier. I think this could be moved to MDCBuilder", "author": "lacikaaa", "createdAt": "2021-01-04T10:34:13Z", "path": "ccm-connector/src/main/java/com/sequenceiq/cloudbreak/ccmimpl/termination/DefaultCcmV2AgentTerminationListener.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.ccmimpl.termination;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.ccm.termination.CcmV2AgentTerminationListener;\n+import com.sequenceiq.cloudbreak.ccmimpl.ccmv2.CcmV2ManagementClient;\n+import com.sequenceiq.cloudbreak.logger.LoggerContextKey;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+\n+@Component\n+public class DefaultCcmV2AgentTerminationListener implements CcmV2AgentTerminationListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultCcmV2AgentTerminationListener.class);\n+\n+    @Inject\n+    private CcmV2ManagementClient ccmV2Client;\n+\n+    @Override\n+    public void deregisterInvertingProxyAgent(String ccmV2AgentCrn) {\n+        if (ccmV2AgentCrn != null) {\n+            String requestId = Optional.ofNullable(MDCBuilder.getMdcContextMap()\n+                    .get(LoggerContextKey.REQUEST_ID.toString())).orElse(UUID.randomUUID().toString());\n+            MDCBuilder.addRequestId(requestId);", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTI3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509273", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MzEwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551243106", "bodyText": "domain is a bit misleading here, as it's actually the gateway node's FQDN", "author": "lacikaaa", "createdAt": "2021-01-04T10:48:22Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/HostDiscoveryService.java", "diffHunk": "@@ -48,6 +50,10 @@ public String generateHostname(String customHostnamePrefix, String instanceGroup\n         return getHostname(customHostnamePrefix, instanceGroupName).replaceAll(\"_\", \"\") + privateId;\n     }\n \n+    public String determineDefaultDomainForStack(String gatewayHostName, String stackDomain) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTczMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552509732", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NDc0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551244742", "bodyText": "is there any particular reason the json field name is different from the java field name?", "author": "lacikaaa", "createdAt": "2021-01-04T10:51:39Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/CcmV2Config.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.sequenceiq.cloudbreak.clusterproxy;\n+\n+import java.util.Objects;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public class CcmV2Config {\n+\n+    @JsonProperty(\"agentCrn\")\n+    private String agentCrn;\n+\n+    @JsonProperty(\"backendId\")\n+    private String backendId;\n+\n+    @JsonProperty(\"host\")\n+    private String gatewayHost;\n+\n+    @JsonProperty(\"port\")\n+    private int gatewayPort;", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510183", "bodyText": "ccmv2 team wants these fieldnames as host and port. But in CB just host and port does not give any context, hence the java field name is as per CB context.", "author": "smaniraju", "createdAt": "2021-01-06T11:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NDc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0Nzc2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551247766", "bodyText": "instead of instanceof it should be handled by catching this type of exception and add the logic there", "author": "lacikaaa", "createdAt": "2021-01-04T10:57:25Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java", "diffHunk": "@@ -115,4 +116,11 @@ public ReadConfigResponse readConfig(String clusterIdentifier) {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n+\n+    private void logErrorWithResponseBody(String message, Exception ex) {\n+        if (ex instanceof RestClientResponseException) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDIyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510220", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0Nzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0ODM1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551248355", "bodyText": "modifying a method parameter is usually a bad practice and should be avoided if possible", "author": "lacikaaa", "createdAt": "2021-01-04T10:58:41Z", "path": "cluster-proxy/src/main/java/com/sequenceiq/cloudbreak/clusterproxy/ClusterProxyRegistrationClient.java", "diffHunk": "@@ -115,4 +116,11 @@ public ReadConfigResponse readConfig(String clusterIdentifier) {\n         headers.setContentType(MediaType.APPLICATION_JSON);\n         return new HttpEntity<>(JsonUtil.writeValueAsString(proxyConfigRequest), headers);\n     }\n+\n+    private void logErrorWithResponseBody(String message, Exception ex) {\n+        if (ex instanceof RestClientResponseException) {\n+            message += \" ,Error Response Body : \" + ((RestClientResponseException) ex).getResponseBodyAsString();", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDc2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552510760", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0ODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NDY4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551254685", "bodyText": "I think this should be replaced with the default constructor, without parameter and that should set connectivity mode to NONE. So it would be obvious you can't define CCMv2 mode without passing the related parameters.", "author": "lacikaaa", "createdAt": "2021-01-04T11:12:39Z", "path": "common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.ccm.cloudinit;\n+\n+public class CcmConnectivityParameters {\n+\n+    private CcmParameters ccmParameters;\n+\n+    private CcmV2Parameters ccmV2Parameters;\n+\n+    private CcmConnectivityMode connectivityMode;\n+\n+    public CcmConnectivityParameters(CcmParameters ccmParameters) {\n+        this.ccmParameters = ccmParameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV1;\n+    }\n+\n+    public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n+        this.ccmV2Parameters = ccmV2Parameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV2;\n+    }\n+\n+    public CcmConnectivityParameters(CcmConnectivityMode connectivityMode) {\n+        this.connectivityMode = connectivityMode;\n+    }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMTMwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552511308", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NDY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MDE2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551260168", "bodyText": "I think the tunnel should have a new value, CCMv2 and only if that is chosen should we go with CCMv2. This would ensure that old envs with CCMv1 would still start datahubs with it, even if the account has v2 enabled. It would be a bad idea to mix CCM versions in environments on the first run", "author": "lacikaaa", "createdAt": "2021-01-04T11:24:35Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -99,7 +106,9 @@ public boolean isCreateConfigForClusterProxy(Stack stack) {\n     }\n \n     private void registerGateway(Stack stack) {\n-        ConfigUpdateRequest request = new ConfigUpdateRequest(stack.getResourceCrn(), knoxUrl(stack));\n+        String knoxUrl = stack.getTunnel().useCcm() && entitlementService.ccmV2Enabled(getAccountId(stack)) ?", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMjQwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552512404", "bodyText": "agree . have made this change throughout. only while creating environment if \"enableTunnel\" is chosen, based on account entitlement CCMV1 or CCMV2 is initialized for environment. In all other places only tunnel value CCMV1 or CCMV2 is used.", "author": "smaniraju", "createdAt": "2021-01-06T11:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MDE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MTkxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551261912", "bodyText": "CcmKeyDeregisterRequest should have Tunnel field instead of the boolean as it's already deprecated. The logic should depend on this value here", "author": "lacikaaa", "createdAt": "2021-01-04T11:28:20Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/recipe/CcmKeyDeregisterHandler.java", "diffHunk": "@@ -34,24 +36,32 @@\n     @Inject\n     private CcmResourceTerminationListener ccmResourceTerminationListener;\n \n+    @Inject\n+    private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n+\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n     @Override\n     public void accept(Event<CcmKeyDeregisterRequest> requestEvent) {\n         CcmKeyDeregisterRequest request = requestEvent.getData();\n         Selectable result;\n         try {\n             Stack stack = stackService.getByIdWithListsInTransaction(request.getResourceId());\n             if (Boolean.TRUE.equals(request.getUseCcm())) {\n-                LOGGER.debug(\"De-registering key from CCM. Cluster CRN: {}\",\n-                        stack.getResourceCrn());\n+                LOGGER.debug(\"De-registering key from CCM. Cluster CRN: {}\", stack.getResourceCrn());\n                 try {\n-                    ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                            stack.getMinaSshdServiceId());\n+                    if (!entitlementService.ccmV2Enabled(request.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MzUyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551263526", "bodyText": "this would change the current behavior, as we set CcmParameterConstants.CCM_ENABLED_KEY to false if CCM is not enabled, but with this change we won't set it anymore. Are you sure it won't break anything?", "author": "lacikaaa", "createdAt": "2021-01-04T11:32:04Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataBuilder.java", "diffHunk": "@@ -61,11 +64,19 @@ private String build(InstanceGroupType type, Platform cloudPlatform, byte[] cbSs\n         model.put(\"customUserData\", userDataBuilderParams.getCustomData());\n         model.put(\"saltBootPassword\", saltBootPassword);\n         model.put(\"cbCert\", cbCert);\n-        CcmParameters.addToTemplateModel(type, ccmParameters, model);\n+        extendModelWithCcmConnectivity(type, ccmConnectivityParameters, model);\n         extendModelWithProxyParams(type, proxyConfig, model);\n         return build(model);\n     }\n \n+    private void extendModelWithCcmConnectivity(InstanceGroupType type, CcmConnectivityParameters ccmConnectivityParameters, Map<String, Object> model) {\n+        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())) {\n+            CcmParameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmParameters(), model);\n+        } else if (CcmConnectivityMode.CCMV2.equals(ccmConnectivityParameters.getConnectivityMode())) {\n+            CcmV2Parameters.addToTemplateModel(type, ccmConnectivityParameters.getCcmV2Parameters(), model);\n+        }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMzg0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552513842", "bodyText": "Yes the ftl templates only initialize CCM variables if CCM_ENABLED_KEY is initialized to true and not null. There is already a unit test in UserDataBuilder for this. But for clarity I also added CCM_ENABLED_KEY and CCM_V2_ENABLED_KEY as false when CCM is not enabled.", "author": "smaniraju", "createdAt": "2021-01-06T11:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NzA5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551267094", "bodyText": "these should ensure that the parameters are not null so we can be sure later if we have eg CCMV1 set, then ccmParameters can't be null. The other way around, if we don't store CcmConnectivityMode, but the getter would calculate it from the fields. If none set then it's NONE, etc.", "author": "lacikaaa", "createdAt": "2021-01-04T11:39:56Z", "path": "common/src/main/java/com/sequenceiq/cloudbreak/ccm/cloudinit/CcmConnectivityParameters.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.sequenceiq.cloudbreak.ccm.cloudinit;\n+\n+public class CcmConnectivityParameters {\n+\n+    private CcmParameters ccmParameters;\n+\n+    private CcmV2Parameters ccmV2Parameters;\n+\n+    private CcmConnectivityMode connectivityMode;\n+\n+    public CcmConnectivityParameters(CcmParameters ccmParameters) {\n+        this.ccmParameters = ccmParameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV1;\n+    }\n+\n+    public CcmConnectivityParameters(CcmV2Parameters ccmV2Parameters) {\n+        this.ccmV2Parameters = ccmV2Parameters;\n+        this.connectivityMode = CcmConnectivityMode.CCMV2;\n+    }", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMTIzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552511237", "bodyText": "ok updated code to not store CcmConnectivityMode and calculate it from fields", "author": "smaniraju", "createdAt": "2021-01-06T11:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551268391", "bodyText": "this method should be moved to a separate class and refactored into smaller ones, as it's pretty big, and already needs the @VisibleForTesting annotation", "author": "lacikaaa", "createdAt": "2021-01-04T11:43:13Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNDAxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552514013", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODcwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551268708", "bodyText": "logic should be handled here by tunnel type and not by entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:43:56Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNTk1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552515953", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2ODcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551269197", "bodyText": "stack id should be enough here as that's the only part you use. Crn is already should be added to MdcContext, logging it again is not necessary.", "author": "lacikaaa", "createdAt": "2021-01-04T11:45:04Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {\n+                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+                // Optionally configure a tunnel for (nginx fronting) Knox\n+                if (stack.getCluster().getGateway() != null) {\n+                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+                }\n+\n+                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            } else {\n+                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n+                        stack.isClusterNameAsSubdomain());\n+                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n+                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n+\n+                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n+            }\n+        }\n+        return ccmConnectivityParameters;\n+    }\n+\n+    @VisibleForTesting\n+    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNjExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552516114", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTY5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551269698", "bodyText": "if you modify the CcmConnectivityParameters implementation (and ensure it via unit tests) you could skip null check here", "author": "lacikaaa", "createdAt": "2021-01-04T11:46:10Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n-            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n-            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n-            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n-\n-            // Optionally configure a tunnel for (nginx fronting) Knox\n-            if (stack.getCluster().getGateway() != null) {\n-                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n-                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n-            }\n-\n-            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n-\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters(CcmConnectivityMode.NONE);\n+        if (stack.getTunnel().useCcm()) {\n             String accountId = ThreadBasedUserCrnProvider.getAccountId();\n             String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n             String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n             String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n-            ccmParameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+\n+            if (!entitlementService.ccmV2Enabled(accountId)) {\n+                ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+                int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+                builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+                // Optionally configure a tunnel for (nginx fronting) Knox\n+                if (stack.getCluster().getGateway() != null) {\n+                    // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                    builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+                }\n+\n+                Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+                CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, accountId, keyId, tunneledServicePorts).orElse(null);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            } else {\n+                String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                        stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,\n+                        stack.isClusterNameAsSubdomain());\n+                String stackDomain = hostDiscoveryService.determineDomain(stack.getCustomDomain(), stack.getName(), stack.isClusterNameAsSubdomain());\n+                String generatedClusterDomain = hostDiscoveryService.determineDefaultDomainForStack(gatewayHostName, stackDomain);\n+\n+                CcmV2Parameters ccmV2Parameters = ccmV2ParameterSupplier.getCcmV2Parameters(accountId, generatedClusterDomain, keyId);\n+                ccmConnectivityParameters = new CcmConnectivityParameters(ccmV2Parameters);\n+            }\n+        }\n+        return ccmConnectivityParameters;\n+    }\n+\n+    @VisibleForTesting\n+    void saveStackCCMParameters(Stack stack, CcmConnectivityParameters ccmConnectivityParameters) {\n+        long stackId = stack.getId();\n+        if (CcmConnectivityMode.CCMV1.equals(ccmConnectivityParameters.getConnectivityMode())\n+                && ccmConnectivityParameters.getCcmParameters() != null) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNzA3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552517074", "bodyText": "removed null check and added unit tests", "author": "smaniraju", "createdAt": "2021-01-06T11:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2OTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MTMxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551271317", "bodyText": "if you move the save next to the fetch, they might be moved out together and handled together. Also you might save some if condition regarding checking if it's CCMv1 or v2", "author": "lacikaaa", "createdAt": "2021-01-04T11:49:53Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,45 +105,71 @@ public void createUserData(Long stackId) throws CloudbreakImageNotFoundException\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             Map<InstanceGroupType, String> userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer,\n                     sshUser, platformParameters, saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stackService.setMinaSshdServiceIdByStackId(stackId, minaSshdServiceId);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMzk2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552513964", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzQyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273421", "bodyText": "the same for this request, include tunnel instead if boolean", "author": "lacikaaa", "createdAt": "2021-01-04T11:54:44Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/event/ccm/CcmKeyDeregistrationRequest.java", "diffHunk": "@@ -17,14 +17,18 @@\n \n     private final String minaSshdServiceId;\n \n+    private final String ccmV2AgentCrn;\n+\n+    @SuppressWarnings(\"ExecutableStatementCount\")\n     public CcmKeyDeregistrationRequest(Long stackId, Boolean forced, String actorCrn, String accountId, String keyId, Boolean useCcm,\n-            String minaSshdServiceId) {\n+            String minaSshdServiceId, String ccmV2AgentCrn) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjQxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522417", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzU3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273575", "bodyText": "same for this handler. depend on tunnel, not on the entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:55:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/stack/termination/handler/CcmKeyDeregistrationHandler.java", "diffHunk": "@@ -27,15 +29,25 @@\n     @Inject\n     private EventBus eventBus;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Inject\n+    private CcmV2AgentTerminationListener ccmV2AgentTerminationListener;\n+\n     @Override\n     public void accept(Event<CcmKeyDeregistrationRequest> requestEvent) {\n \n         CcmKeyDeregistrationRequest request = requestEvent.getData();\n         if (Boolean.TRUE.equals(request.getUseCcm())) {\n             LOGGER.debug(\"De-registering CCM key for freeipa stack {}\", request.getResourceId());\n             try {\n-                ccmResourceTerminationListener.deregisterCcmSshTunnelingKey(request.getActorCrn(), request.getAccountId(), request.getKeyId(),\n-                        request.getMinaSshdServiceId());\n+                if (!entitlementService.ccmV2Enabled(request.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMTUxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552521517", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3Mzk3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551273977", "bodyText": "the same question, would it break anything if you don't add CCMv1 false to the model?", "author": "lacikaaa", "createdAt": "2021-01-04T11:56:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataBuilder.java", "diffHunk": "@@ -56,11 +60,19 @@ private String build(Platform cloudPlatform, byte[] cbSshKeyDer, String sshUser,\n         model.put(\"customUserData\", userDataBuilderParams.getCustomData());\n         model.put(\"saltBootPassword\", saltBootPassword);\n         model.put(\"cbCert\", cbCert);\n-        CcmParameters.addToTemplateModel(InstanceGroupType.GATEWAY, ccmParameters, model);\n+        extendModelWithCcmConnectivity(InstanceGroupType.GATEWAY, ccmConnectivityParameters, model);\n         extendModelWithProxyParams(proxyConfig, model);\n         return build(model);\n     }\n \n+    private void extendModelWithCcmConnectivity(InstanceGroupType type, CcmConnectivityParameters ccmConnectivityParameters, Map<String, Object> model) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522593", "bodyText": "answered above and made same change here.", "author": "smaniraju", "createdAt": "2021-01-06T11:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3Mzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDQyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551274423", "bodyText": "just a note to keep this in sync with the other after refactor", "author": "lacikaaa", "createdAt": "2021-01-04T11:56:59Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/UserDataService.java", "diffHunk": "@@ -88,34 +109,62 @@ public void createUserData(Long stackId) {\n         String saltBootPassword = saltSecurityConfig.getSaltBootPassword();\n         try {\n             PlatformParameters platformParameters = platformParametersFuture.get();\n-            CcmParameters ccmParameters = fetchCcmParameters(stack);\n+            CcmConnectivityParameters ccmParameters = fetchCcmParameters(stack);\n             Optional<ProxyConfig> proxyConfig = proxyConfigDtoService.getByEnvironmentCrn(stack.getEnvironmentCrn());\n             String userData = userDataBuilder.buildUserData(Platform.platform(stack.getCloudPlatform()), cbSshKeyDer, sshUser, platformParameters,\n                     saltBootPassword, cbCert, ccmParameters, proxyConfig.orElse(null));\n             imageService.decorateImageWithUserDataForStack(stack, userData);\n-            if (ccmParameters != null) {\n-                String minaSshdServiceId = ccmParameters.getServerParameters().getMinaSshdServiceId();\n-                if (StringUtils.isNotBlank(minaSshdServiceId)) {\n-                    LOGGER.debug(\"Add Minasshdserviceid [{}] to stack [{}]\", minaSshdServiceId, stack.getResourceCrn());\n-                    stack.setMinaSshdServiceId(minaSshdServiceId);\n-                    stackService.save(stack);\n-                }\n-            }\n+            saveStackCCMParameters(stack, ccmParameters);\n         } catch (InterruptedException | ExecutionException e) {\n             LOGGER.error(\"Failed to get Platform parmaters\", e);\n             throw new GetCloudParameterException(\"Failed to get Platform parmaters\", e);\n         }\n     }\n \n-    private CcmParameters fetchCcmParameters(Stack stack) {\n-        CcmParameters ccmParameters = null;\n-        if ((ccmParameterSupplier != null) && stack.getTunnel().useCcm()) {\n+    @VisibleForTesting\n+    CcmConnectivityParameters fetchCcmParameters(Stack stack) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjgyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522821", "bodyText": "refactored here as done in other place.", "author": "smaniraju", "createdAt": "2021-01-06T11:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDY2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r551274662", "bodyText": "depend on tunnel instead of entitlement", "author": "lacikaaa", "createdAt": "2021-01-04T11:57:33Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -174,8 +181,14 @@\n \n         ConfigRegistrationRequestBuilder requestBuilder = new ConfigRegistrationRequestBuilder(stack.getResourceCrn())\n                 .withServices(serviceConfigs)\n-                .withTunnelEntries(createTunnelEntries(stack, tunnelGatewayConfigs))\n                 .withAccountId(stack.getAccountId());\n+        if (stack.getTunnel().useCcm()) {\n+            if (!entitlementService.ccmV2Enabled(stack.getAccountId())) {", "originalCommit": "e7e0393c64b29de6ef8d72dc182ec08e349b40ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyMjg4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r552522880", "bodyText": "ok", "author": "smaniraju", "createdAt": "2021-01-06T11:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3NDY2Mg=="}], "type": "inlineReview"}, {"oid": "83e02a0069712a0d654c35d8020a277a65847256", "url": "https://github.com/hortonworks/cloudbreak/commit/83e02a0069712a0d654c35d8020a277a65847256", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T11:48:26Z", "type": "forcePushed"}, {"oid": "8ff0cca20c3ba25f80a737a2d8b829f5a7e91676", "url": "https://github.com/hortonworks/cloudbreak/commit/8ff0cca20c3ba25f80a737a2d8b829f5a7e91676", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T13:03:07Z", "type": "forcePushed"}, {"oid": "ccabf23d50823f81579a2cf07267c19b3f532c32", "url": "https://github.com/hortonworks/cloudbreak/commit/ccabf23d50823f81579a2cf07267c19b3f532c32", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-06T14:13:12Z", "type": "forcePushed"}, {"oid": "8fdb7b0364b984679eef912b35ed1f25d533c7da", "url": "https://github.com/hortonworks/cloudbreak/commit/8fdb7b0364b984679eef912b35ed1f25d533c7da", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-07T03:22:50Z", "type": "forcePushed"}, {"oid": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "url": "https://github.com/hortonworks/cloudbreak/commit/5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-07T07:55:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553321639", "bodyText": "for reregistration you add knox url to the request. Is it missing here on purpose?", "author": "lacikaaa", "createdAt": "2021-01-07T13:19:07Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -111,17 +115,22 @@ public void deregisterCluster(Stack stack) {\n     private ConfigRegistrationRequest createProxyConfigRequest(Stack stack) {\n         ConfigRegistrationRequestBuilder requestBuilder = new ConfigRegistrationRequestBuilder(stack.getResourceCrn())\n                 .withAliases(singletonList(clusterId(stack.getCluster()))).withServices(serviceConfigs(stack));\n-        if (stack.getTunnel().useCcm()) {\n+        if (stack.getTunnel().useCcmV1()) {\n             requestBuilder.withAccountId(getAccountId(stack)).withTunnelEntries(tunnelEntries(stack));\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            requestBuilder.withAccountId(getAccountId(stack)).withCcmV2Entries(ccmV2Configs(stack));", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMTY5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553331699", "bodyText": "I have not made any changes in this flow, first createProxyConfigRequest is sent. then knoxUrl is registered with registerGateway call. But for createProxyConfigReRegisterRequest knoxUrl was always passed.", "author": "smaniraju", "createdAt": "2021-01-07T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MjA1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553342053", "bodyText": "ok, I see that now. thanks for clarification", "author": "lacikaaa", "createdAt": "2021-01-07T13:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553322933", "bodyText": "If I remember well the decision was that there will be only one agent running of inverting proxy which would pass everything through nginx and it would mean we have to add a new context for knox in nginx. But in that case I don't think you need KNOX here.", "author": "lacikaaa", "createdAt": "2021-01-07T13:21:49Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -147,6 +156,16 @@ private String getAccountId(Stack stack) {\n         return asList(gatewayTunnel, knoxTunnel);\n     }\n \n+    private List<CcmV2Config> ccmV2Configs(Stack stack) {\n+        InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+        return List.of(ServiceFamilies.GATEWAY.getDefaultPort(), ServiceFamilies.KNOX.getDefaultPort()).stream()", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNDM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553334377", "bodyText": "yes that was the approach decided. But I have not made any changes to serviceConfig which was generated and it is being commonly generated for ccmv1 and ccmv2.  For ccmv1 there is a service config entry cmServiceConfig(stack, null, \"cloudera-manager\", clusterManagerUrl(stack)) , I was not sure if this is really not used for ccmv1.   Also ccmv2 is validating service host port against ccmv2 config entry so I have not removed KNOX", "author": "smaniraju", "createdAt": "2021-01-07T13:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1MzUzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553353532", "bodyText": "still, I think this won't work this way, as cluster proxy would try to connect to port 443, and that won't be available through CCMv2.\nI don't how cluster proxy matches service configs with tunnel entries / ccmv2 configs, but I suspect you would need only one ccmv2 config while multiple service config, but a different one then for ccmv1", "author": "lacikaaa", "createdAt": "2021-01-07T14:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1NzM0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553357341", "bodyText": "while connecting to cluster CB uses cb-internal service endpoint which is mapped to 9443 port, so this doesnt break anything. For clarity I will create different service config for ccmv2.", "author": "smaniraju", "createdAt": "2021-01-07T14:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM2MDcwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553360705", "bodyText": "that's right, but other services depend on the other endpoint. Like ClouderaManagerProxiedClientFactory uses that connection inside CB.", "author": "lacikaaa", "createdAt": "2021-01-07T14:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjExNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553782115", "bodyText": "Removed KNOX from the config.", "author": "smaniraju", "createdAt": "2021-01-08T07:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyOTYzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553329635", "bodyText": "when could this happen: .orElse(\"\")? shouldn't we fail instead?\nI'm not sure how HA for SDX works, maybe with a single gateway, but would that 0L cause any problem?", "author": "lacikaaa", "createdAt": "2021-01-07T13:35:03Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/userdata/CcmUserDataService.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.sequenceiq.cloudbreak.service.image.userdata;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmConnectivityParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.KnownServiceIdentifier;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.ServiceFamilies;\n+import com.sequenceiq.cloudbreak.ccm.key.CcmResourceUtil;\n+import com.sequenceiq.cloudbreak.common.service.HostDiscoveryService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+\n+@Service\n+public class CcmUserDataService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmUserDataService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostDiscoveryService hostDiscoveryService;\n+\n+    @Autowired\n+    private CcmParameterSupplier ccmParameterSupplier;\n+\n+    @Autowired\n+    private CcmV2ParameterSupplier ccmV2ParameterSupplier;\n+\n+    public CcmConnectivityParameters fetchAndSaveCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters();\n+        if (stack.getTunnel().useCcmV1()) {\n+            String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+            String actorCrn = Objects.requireNonNull(userCrn, \"userCrn is null\");\n+\n+            ImmutableMap.Builder<KnownServiceIdentifier, Integer> builder = ImmutableMap.builder();\n+            int gatewayPort = Optional.ofNullable(stack.getGatewayPort()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+            builder.put(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+            // Optionally configure a tunnel for (nginx fronting) Knox\n+            if (stack.getCluster().getGateway() != null) {\n+                // JSA TODO Do we support a non-default port for the nginx that fronts Knox?\n+                builder.put(KnownServiceIdentifier.KNOX, ServiceFamilies.KNOX.getDefaultPort());\n+            }\n+\n+            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = builder.build();\n+            CcmParameters ccmV1Parameters = ccmParameterSupplier.getCcmParameters(actorCrn, ThreadBasedUserCrnProvider.getAccountId(),\n+                    CcmResourceUtil.getKeyId(stack.getResourceCrn()), tunneledServicePorts).orElse(null);\n+            ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+\n+            saveCcmV1Config(stack.getId(), ccmV1Parameters);\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            String gatewayHostName = hostDiscoveryService.generateHostname(stack.getCustomHostname(),\n+                    stack.getGatewayHostGroup().map(InstanceGroup::getGroupName).orElse(\"\"), 0L,", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNzQzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553337430", "bodyText": "all the gateway nodes share the same mTLS cert so 0L would not cause any problem because mTLS doesnt validate client fqdn.\norElse(\"\")? would never happen because there are validations that atleast one hostGroup should be gatewayHostGroup.", "author": "smaniraju", "createdAt": "2021-01-07T13:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyOTYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553333480", "bodyText": "won't this fix 0 cause problems for freeipa HA?", "author": "lacikaaa", "createdAt": "2021-01-07T13:42:26Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/image/userdata/CcmUserDataService.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.sequenceiq.freeipa.service.image.userdata;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmConnectivityParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmParameters;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2ParameterSupplier;\n+import com.sequenceiq.cloudbreak.ccm.cloudinit.CcmV2Parameters;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.KnownServiceIdentifier;\n+import com.sequenceiq.cloudbreak.ccm.endpoint.ServiceFamilies;\n+import com.sequenceiq.cloudbreak.ccm.key.CcmResourceUtil;\n+import com.sequenceiq.cloudbreak.common.service.HostDiscoveryService;\n+import com.sequenceiq.freeipa.entity.FreeIpa;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.util.CrnService;\n+\n+@Service\n+public class CcmUserDataService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CcmUserDataService.class);\n+\n+    @Inject\n+    private CrnService crnService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostDiscoveryService hostDiscoveryService;\n+\n+    @Inject\n+    private FreeIpaService freeIpaService;\n+\n+    @Autowired\n+    private CcmParameterSupplier ccmParameterSupplier;\n+\n+    @Autowired\n+    private CcmV2ParameterSupplier ccmV2ParameterSupplier;\n+\n+    public CcmConnectivityParameters fetchAndSaveCcmParameters(Stack stack) {\n+        CcmConnectivityParameters ccmConnectivityParameters = new CcmConnectivityParameters();\n+        String keyId = CcmResourceUtil.getKeyId(stack.getResourceCrn());\n+\n+        if (stack.getTunnel().useCcmV1()) {\n+            String actorCrn = Objects.requireNonNull(crnService.getUserCrn(), \"userCrn is null\");\n+            int gatewayPort = Optional.ofNullable(stack.getGatewayport()).orElse(ServiceFamilies.GATEWAY.getDefaultPort());\n+            Map<KnownServiceIdentifier, Integer> tunneledServicePorts = Collections.singletonMap(KnownServiceIdentifier.GATEWAY, gatewayPort);\n+\n+            CcmParameters ccmV1Parameters = ccmParameterSupplier\n+                    .getCcmParameters(actorCrn, stack.getAccountId(), keyId, tunneledServicePorts)\n+                    .orElse(null);\n+            ccmConnectivityParameters = new CcmConnectivityParameters(ccmV1Parameters);\n+            saveCcmV1Config(stack.getId(), ccmV1Parameters);\n+        } else if (stack.getTunnel().useCcmV2()) {\n+            FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+            String gatewayHostName = hostDiscoveryService.generateHostname(freeIpa.getHostname(), null, 0, false);", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNzQ5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553337497", "bodyText": "all the gateway nodes share the same mTLS cert so 0L would not cause any problem because mTLS doesnt validate client fqdn.", "author": "smaniraju", "createdAt": "2021-01-07T13:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553338581", "bodyText": "So you shouldn't overwrite CCM with CCMv2. You should check the request, if it contains CCMv2 but the entitlement is disabled you must throw a badrequestexception with a reason.\nIf CCM is sent in the request,it should be used, even if the entitlement is enabled. We don't want to force users with enabled entitlement to use CCMv2, do we?", "author": "lacikaaa", "createdAt": "2021-01-07T13:51:34Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -123,6 +126,15 @@ private Environment initializeEnvironment(EnvironmentCreationDto creationDto) {\n         return environment;\n     }\n \n+    private void initializeEnvironmentTunnel(Environment environment) {\n+        Tunnel tunnel = environment.getExperimentalFeaturesJson().getTunnel();\n+        if (Tunnel.CCM == tunnel && entitlementService.ccmV2Enabled(environment.getAccountId())) {\n+            ExperimentalFeatures experimentalFeaturesJson = environment.getExperimentalFeaturesJson();\n+            experimentalFeaturesJson.setTunnel(Tunnel.CCMV2);\n+            environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n+        }\n+    }", "originalCommit": "5b702838fc560ff0d73abc4f6fdad5db9eeff6e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MDAwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553340006", "bodyText": "yes I think that is expectation when entitlement is enabled only CCMv2 is to be used. Also CDP CLI only passes enableTunnel option there is no CCM or DIRECT option exposed to customers.", "author": "smaniraju", "createdAt": "2021-01-07T13:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1OTYyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553359624", "bodyText": "ok, I get it, but still, you should check that you accept CCMv2 only when the entitlement enabled. We can't rely on the logic present in other component. I think the UI eg communicates directly and sends CCM.", "author": "lacikaaa", "createdAt": "2021-01-07T14:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM2MDk4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553360981", "bodyText": "But that would mean we will not able to create CCMv2 clusters via CDP CLI because it just as \"enableTunnel\", I think that would be a bigger issue.", "author": "smaniraju", "createdAt": "2021-01-07T14:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4MDQ2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553380469", "bodyText": "I mean you can leave this part, if CCM is received and entitlement enabled, turn it into CCMv2. so this part of the code is fine.\nBut you should add a validation before this, if CCMv2 is received and the entitlement is disabled then return a badrequest.", "author": "lacikaaa", "createdAt": "2021-01-07T14:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MTk4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553781983", "bodyText": "Added validation if tunnel is CCMV2 and not entitled, badrequestexception is thrown.", "author": "smaniraju", "createdAt": "2021-01-08T07:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODU4MQ=="}], "type": "inlineReview"}, {"oid": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "url": "https://github.com/hortonworks/cloudbreak/commit/a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T07:24:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553873674", "bodyText": "that's not true, it could be cluster proxied. although customer won't start that kind of cluster", "author": "lacikaaa", "createdAt": "2021-01-08T10:49:11Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -123,6 +126,21 @@ private Environment initializeEnvironment(EnvironmentCreationDto creationDto) {\n         return environment;\n     }\n \n+    private void initializeEnvironmentTunnel(Environment environment) {\n+        Tunnel tunnel = environment.getExperimentalFeaturesJson().getTunnel();\n+        boolean ccmV2Enabled = entitlementService.ccmV2Enabled(environment.getAccountId());\n+        if (Tunnel.CCMV2 == tunnel && !ccmV2Enabled) {\n+            throw new BadRequestException(\"CCMV2 not enabled for account.\");\n+        } else if (Tunnel.CCM == tunnel && ccmV2Enabled) {\n+            ExperimentalFeatures experimentalFeaturesJson = environment.getExperimentalFeaturesJson();\n+            experimentalFeaturesJson.setTunnel(Tunnel.CCMV2);\n+            environment.setExperimentalFeaturesJson(experimentalFeaturesJson);\n+            LOGGER.info(\"Environment is initialized with CCMV2 tunnel.\");\n+        } else {\n+            LOGGER.info(\"Environment is initialized with Direct tunnel.\");", "originalCommit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3Mzg0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553873843", "bodyText": "you could fix this in a followup pr", "author": "lacikaaa", "createdAt": "2021-01-08T10:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NTM4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553875387", "bodyText": "ccm is different from cluster proxy right ? I mean all requests go through clusterproxy but which tunnel used would be diffferent.", "author": "smaniraju", "createdAt": "2021-01-08T10:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NTI2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553885269", "bodyText": "talked about in private, but to have it here also. CB can connect with:\n\nDIRECT (no cluster proxy)\ncluster proxy, but without initializing tunnel via CCM, which means cluster proxy is connecting directly\nCCM, which means CB will initialize, configure cluster proxy with tunnel, and then use cluster proxy for communication", "author": "lacikaaa", "createdAt": "2021-01-08T11:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NjA3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553886074", "bodyText": "Updated log statement.", "author": "smaniraju", "createdAt": "2021-01-08T11:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3MzY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553874133", "bodyText": "as this is a single item, the stream and list is an overkill here", "author": "lacikaaa", "createdAt": "2021-01-08T10:50:15Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/provision/clusterproxy/ClusterProxyService.java", "diffHunk": "@@ -147,6 +156,16 @@ private String getAccountId(Stack stack) {\n         return asList(gatewayTunnel, knoxTunnel);\n     }\n \n+    private List<CcmV2Config> ccmV2Configs(Stack stack) {\n+        InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+        return List.of(ServiceFamilies.GATEWAY.getDefaultPort()).stream()", "originalCommit": "a7e2e1bb1a7f368910b2cb9080d1b11955056a93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3ODg1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553878850", "bodyText": "CcmV2 Api expects List of CCMV2 Config, I will remove stream though in a follow up PR.", "author": "smaniraju", "createdAt": "2021-01-08T11:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NjE1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9674#discussion_r553886152", "bodyText": "Removed stream.", "author": "smaniraju", "createdAt": "2021-01-08T11:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NDEzMw=="}], "type": "inlineReview"}, {"oid": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "url": "https://github.com/hortonworks/cloudbreak/commit/7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T11:14:03Z", "type": "commit"}, {"oid": "7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "url": "https://github.com/hortonworks/cloudbreak/commit/7d9c1e6db3780f3138e89e4a64d9745ce174f35c", "message": "CB-9182 Add Support for CCMV2\n\n1. Support for CB,FREEIPA Integration with CCMV2 Service behind an entitlement.\n2. DH, DL, FREEIPA Image User Data Generation enhanced to store CCMV2 config as user data variables.\n3. Support for CB,FREEIPA Integration with Cluster-Proxy for CCMV2 configs", "committedDate": "2021-01-08T11:14:03Z", "type": "forcePushed"}]}