{"pr_number": 9675, "pr_title": "CB-10095 Subnet selection for public gateway endpoint", "pr_createdAt": "2020-12-21T23:47:03Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9675", "timeline": [{"oid": "059e461b7a4e550635e316eddb90853c232c00a8", "url": "https://github.com/hortonworks/cloudbreak/commit/059e461b7a4e550635e316eddb90853c232c00a8", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2020-12-22T00:06:03Z", "type": "forcePushed"}, {"oid": "84311f8b118428de0e8120c3088cce8dc98a861e", "url": "https://github.com/hortonworks/cloudbreak/commit/84311f8b118428de0e8120c3088cce8dc98a861e", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2020-12-23T23:59:02Z", "type": "forcePushed"}, {"oid": "86fce65d30118a698058bfe0b0fad279f08ab906", "url": "https://github.com/hortonworks/cloudbreak/commit/86fce65d30118a698058bfe0b0fad279f08ab906", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2020-12-28T16:07:59Z", "type": "forcePushed"}, {"oid": "82bd813aa921bf95bd3e7d35c70361758008ca16", "url": "https://github.com/hortonworks/cloudbreak/commit/82bd813aa921bf95bd3e7d35c70361758008ca16", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2020-12-28T16:51:02Z", "type": "forcePushed"}, {"oid": "66f7ee10ce9f979d6ed405f75c9948b801f3c87b", "url": "https://github.com/hortonworks/cloudbreak/commit/66f7ee10ce9f979d6ed405f75c9948b801f3c87b", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-04T02:08:04Z", "type": "forcePushed"}, {"oid": "58e0ab92047b01966b79b86db80641eda0b3f4a9", "url": "https://github.com/hortonworks/cloudbreak/commit/58e0ab92047b01966b79b86db80641eda0b3f4a9", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-04T23:59:18Z", "type": "forcePushed"}, {"oid": "304d954c377a49f67d16755a0c51c8a7e39413e7", "url": "https://github.com/hortonworks/cloudbreak/commit/304d954c377a49f67d16755a0c51c8a7e39413e7", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T16:27:04Z", "type": "forcePushed"}, {"oid": "ca415af38e9f9a39840f412c8a80b5bbe08fb319", "url": "https://github.com/hortonworks/cloudbreak/commit/ca415af38e9f9a39840f412c8a80b5bbe08fb319", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T17:27:20Z", "type": "forcePushed"}, {"oid": "b9ecc8ee55c11d5fa3503111021258b804843891", "url": "https://github.com/hortonworks/cloudbreak/commit/b9ecc8ee55c11d5fa3503111021258b804843891", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T20:19:57Z", "type": "forcePushed"}, {"oid": "80848f03b62b2b1570dd1cbf40bb4902b2a00aa9", "url": "https://github.com/hortonworks/cloudbreak/commit/80848f03b62b2b1570dd1cbf40bb4902b2a00aa9", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T21:55:17Z", "type": "forcePushed"}, {"oid": "d7a3d9ecd1254859556f3b4943c50541d42b2d33", "url": "https://github.com/hortonworks/cloudbreak/commit/d7a3d9ecd1254859556f3b4943c50541d42b2d33", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T22:04:33Z", "type": "forcePushed"}, {"oid": "98018745ad6e55ee24466adcdb3619ba7056e6db", "url": "https://github.com/hortonworks/cloudbreak/commit/98018745ad6e55ee24466adcdb3619ba7056e6db", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T23:09:04Z", "type": "forcePushed"}, {"oid": "4429d212e728db962f968afc9113ff8bfae2204d", "url": "https://github.com/hortonworks/cloudbreak/commit/4429d212e728db962f968afc9113ff8bfae2204d", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-05T23:27:08Z", "type": "forcePushed"}, {"oid": "0aa94ac29a4722ed9600436b22024bae268d2264", "url": "https://github.com/hortonworks/cloudbreak/commit/0aa94ac29a4722ed9600436b22024bae268d2264", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T00:36:21Z", "type": "forcePushed"}, {"oid": "6acba4cb038d8fa86d920b1ef4f7b2f606e29807", "url": "https://github.com/hortonworks/cloudbreak/commit/6acba4cb038d8fa86d920b1ef4f7b2f606e29807", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T01:24:25Z", "type": "forcePushed"}, {"oid": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "url": "https://github.com/hortonworks/cloudbreak/commit/6cd2ebe8438779c7148555fae81e3c07b87782fd", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T01:42:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyMzk1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552323958", "bodyText": "Should we still use the selectedAZ here? The selectedAZ can be coming from the network request, but the user maybe explicitly specifying the subnet to use for the endpoint gateway anyways if provided. I was thinking that the provided getGatewayEndpointSubnetMetas will always take precedence.", "author": "enis", "createdAt": "2021-01-06T02:08:08Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/environment/network/EnvironmentBaseNetworkConverter.java", "diffHunk": "@@ -32,34 +34,37 @@ public Network convertToLegacyNetwork(EnvironmentNetworkResponse source, String\n         result.setOutboundInternetTraffic(source.getOutboundInternetTraffic());\n         result.setNetworkCidrs(source.getNetworkCidrs());\n         Map<String, Object> attributes = new HashMap<>();\n-        Optional<CloudSubnet> cloudSubnet;\n-        if (StringUtils.isNotBlank(source.getPreferedSubnetId())) {\n-            LOGGER.debug(\"Choosing subnet by prefered subnet Id {}\", source.getPreferedSubnetId());\n-            CloudSubnet cloudSubnetById = source.getSubnetMetas().get(source.getPreferedSubnetId());\n-            if (cloudSubnetById == null) {\n-                cloudSubnetById = source.getSubnetMetas().values()\n-                        .stream()\n-                        .filter(e -> e.getId().equals(source.getPreferedSubnetId()))\n-                        .findFirst().orElse(null);\n-            }\n-            cloudSubnet = Optional.of(cloudSubnetById);\n-        } else if (StringUtils.isNotEmpty(availabilityZone)) {\n-            LOGGER.debug(\"Choosing subnet by availability zone {}\", availabilityZone);\n-            cloudSubnet = source.getSubnetMetas().values().stream()\n-                    .filter(s -> StringUtils.isNotEmpty(s.getAvailabilityZone()) &&\n-                            s.getAvailabilityZone().equals(availabilityZone))\n-                    .findFirst();\n-        } else {\n-            LOGGER.debug(\"Fallback to choose random subnet\");\n-            cloudSubnet = source.getSubnetMetas().values().stream().findFirst();\n-        }\n+        Optional<CloudSubnet> cloudSubnet = chooseSubnet(source.getPreferedSubnetId(), source.getSubnetMetas(), availabilityZone, true);\n         if (cloudSubnet.isEmpty()) {\n             throw new BadRequestException(\"No subnet for the given availability zone: \" + availabilityZone);\n         }\n         LOGGER.debug(\"Chosen subnet: {}\", cloudSubnet.get());\n+\n+        if (source.getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED) {\n+            String selectedAZ = cloudSubnet.get().getAvailabilityZone();\n+            Map<String, CloudSubnet> subnetsToParse;\n+            if (source.getGatewayEndpointSubnetMetas() == null || source.getGatewayEndpointSubnetMetas().isEmpty()) {\n+                subnetsToParse = source.getSubnetMetas();\n+            } else {\n+                subnetsToParse = source.getGatewayEndpointSubnetMetas();\n+            }\n+            Map<String, CloudSubnet> publicSubnetMetas = subnetsToParse.entrySet().stream()\n+                .filter(entry -> !entry.getValue().isPrivateSubnet())\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Optional<CloudSubnet> endpointGatewayCloudSubnet = chooseSubnet(null,\n+                publicSubnetMetas, selectedAZ, false);", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMjQ3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552332472", "bodyText": "I'd argue against the getGatewayEndpointSubnetMetas taking precedence, since their use case is very limited vs. the private subnets which are used more widely. But we do need to include the selected AZ, because the private and public subnets needs to be in the same AZ for the load balancer to work.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T02:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyMzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNjE3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552326179", "bodyText": "Seeing the name of this function together with the one below, I was just confused why we are having a check for both a Set (as in HashSet) and a List check. It turns out it is a check for existence.\nMaybe we can merge the List vs non-list cases to simplify. If there is only 1 subnet, then it is a list of 1.", "author": "enis", "createdAt": "2021-01-06T02:16:20Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/view/AwsNetworkView.java", "diffHunk": "@@ -55,6 +57,23 @@ public boolean isSubnetList() {\n         return isSubnetList() ? List.of(getExistingSubnet().split(\",\")) : (isExistingSubnet() ? List.of(getExistingSubnet()) : List.of());\n     }\n \n+    private String getEndpointGatewaySubnet() {\n+        return network.getStringParameter(ENDPOINT_GATEWAY_SUBNET_ID);\n+    }\n+\n+    public boolean isEndpointGatewaySubnetSet() {", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMjE1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552332154", "bodyText": "I can rename the function to make it more clear. I don't really want to change the methods themselves because they were written following the same pattern as is used for the environment subnet list.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T02:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNjE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzMDYyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552930623", "bodyText": "Changed this method name to containsEndpointGatewaySubnet.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T19:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNjE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNzkzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552327937", "bodyText": "Should this check be a subset check rather than equals() check? We can have env with 3 subnets, but endpoint gateway with 1 subnet, no?", "author": "enis", "createdAt": "2021-01-06T02:22:48Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/creation/handler/NetworkCreationHandler.java", "diffHunk": "@@ -114,6 +126,50 @@ private void setChildEnvironmentNetworkIfItHasParentWithTheSameCloudProvider(Env\n         }\n     }\n \n+    private Map<String, CloudSubnet> removePrivateSubnets(Map<String, CloudSubnet> endpointGatewaySubnetMetas) {\n+        LOGGER.debug(\"Removing any private subnets from the provided endpoint gateway list because they won't be used.\");\n+        if (endpointGatewaySubnetMetas == null || endpointGatewaySubnetMetas.isEmpty()) {\n+            return Map.of();\n+        }\n+        return endpointGatewaySubnetMetas.entrySet().stream()\n+            .filter(entry -> !entry.getValue().isPrivateSubnet())\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private void validateSubnetsIfProvided(Environment environment, Map<String, CloudSubnet> subnetMetas,\n+            Map<String, CloudSubnet> endpointGatewaySubnetMetas) {\n+        if (hasNetwork(environment) && environment.getNetwork().getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED &&\n+                environment.getNetwork().getRegistrationType() != RegistrationType.CREATE_NEW) {\n+            if (subnetMetas != null && !subnetMetas.isEmpty()) {\n+                if (endpointGatewaySubnetMetas != null && !endpointGatewaySubnetMetas.isEmpty()) {\n+                    LOGGER.debug(\"Verifying that provided endpoint gateway subnets share availability zones with provided environment subnets.\");\n+                    Set<String> subnetAZs = subnetMetas.values().stream()\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    Set<String> endpointGatewaySubnetAZs = endpointGatewaySubnetMetas.values().stream()\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    if (!subnetAZs.equals(endpointGatewaySubnetAZs)) {", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMzAxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552333018", "bodyText": "No, we can't. The load balancer needs subnets in the same AZs as all the EC2 instances it's routing to. So if our private subnets are in az-1, az-2, and az-3, and our public subnets are in az-1 and az-2, then if an EC2 instance is created in az-3 it's completely inaccessible to the load balancer. In order to prevent that possibility, we require the users to provide both private and public subnets in all the same AZs, which is what this check is doing here.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T02:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzNTgxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552335818", "bodyText": "My understanding is that the initial set of subnets given at the time of the env creation can contain more subnets than actually gets used for DL/DH instances (like subnets for dwx, liftie, etc). In DH you can select which subnet to use, but apparently not for DL?\nMaybe this is fine, as long as somebody from CB who knows the subnet selection logic takes a look at it.", "author": "enis", "createdAt": "2021-01-06T02:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM0ODYxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552348618", "bodyText": "That's true. Not every subnet in the lists being processed here will be used. Which is really why I have this logic. At this stage I don't know which of the subnets will be selected, so to make sure there won't be any hiccups in the eventual subnet selection logic I just make sure that we have subnets with matching AZs here and fail immediately if not.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T03:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyNzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyODMxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552328312", "bodyText": "same here.", "author": "enis", "createdAt": "2021-01-06T02:24:11Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/creation/handler/NetworkCreationHandler.java", "diffHunk": "@@ -114,6 +126,50 @@ private void setChildEnvironmentNetworkIfItHasParentWithTheSameCloudProvider(Env\n         }\n     }\n \n+    private Map<String, CloudSubnet> removePrivateSubnets(Map<String, CloudSubnet> endpointGatewaySubnetMetas) {\n+        LOGGER.debug(\"Removing any private subnets from the provided endpoint gateway list because they won't be used.\");\n+        if (endpointGatewaySubnetMetas == null || endpointGatewaySubnetMetas.isEmpty()) {\n+            return Map.of();\n+        }\n+        return endpointGatewaySubnetMetas.entrySet().stream()\n+            .filter(entry -> !entry.getValue().isPrivateSubnet())\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private void validateSubnetsIfProvided(Environment environment, Map<String, CloudSubnet> subnetMetas,\n+            Map<String, CloudSubnet> endpointGatewaySubnetMetas) {\n+        if (hasNetwork(environment) && environment.getNetwork().getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED &&\n+                environment.getNetwork().getRegistrationType() != RegistrationType.CREATE_NEW) {\n+            if (subnetMetas != null && !subnetMetas.isEmpty()) {\n+                if (endpointGatewaySubnetMetas != null && !endpointGatewaySubnetMetas.isEmpty()) {\n+                    LOGGER.debug(\"Verifying that provided endpoint gateway subnets share availability zones with provided environment subnets.\");\n+                    Set<String> subnetAZs = subnetMetas.values().stream()\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    Set<String> endpointGatewaySubnetAZs = endpointGatewaySubnetMetas.values().stream()\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    if (!subnetAZs.equals(endpointGatewaySubnetAZs)) {\n+                        throw new BadRequestException(String.format(UNMATCHED_AZ, subnetAZs));\n+                    }\n+                } else {\n+                    LOGGER.debug(\"Verifying that public subnets in availability zones that match the private subnets were provided.\");\n+                    Set<String> privateAZs = subnetMetas.values().stream()\n+                        .filter(CloudSubnet::isPrivateSubnet)\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    Set<String> publicAZs = subnetMetas.values().stream()\n+                        .filter(subnet -> !subnet.isPrivateSubnet())\n+                        .map(CloudSubnet::getAvailabilityZone)\n+                        .collect(Collectors.toSet());\n+                    if (!privateAZs.equals(publicAZs)) {", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY1NTIzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552655235", "bodyText": "so it doesn't a converter anymore as it creates loadbalancers. I liked it when it returned the loadbalancer instead of adding to a list in the parameters.", "author": "lacikaaa", "createdAt": "2021-01-06T14:20:00Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -256,32 +254,59 @@ private void updateCloudformationWithLoadBalancers(AuthenticatedContext ac, Clou\n         }\n     }\n \n-    private AwsLoadBalancerScheme determinePublicVsPrivateSchema(AwsNetworkView awsNetworkView, AmazonEC2Client amazonEC2Client) {\n-        String subnetId = awsNetworkView.getExistingSubnet();\n-        String vpcId = awsNetworkView.getExistingVpc();\n+    private void convertLoadBalancer(CloudLoadBalancer cloudLoadBalancer, List<CloudResource> instances,", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMDkyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552920925", "bodyText": "It converting from CloudLoadBalancer to AwsLoadBalancer. So in that sense it was always creating an instance of AwsLoadBalancer and setting its properties based on the properties of CloudLoadBalancer. That piece of the logic hasn't really changed. I will update it to return the AwsLoadBalancer and add it to the list in the parent method instead of here.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T19:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY1NTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY2NjM2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552666369", "bodyText": "I would prefer utilizing the power of Optional:\n    public AwsListener getOrCreateListener(int port) {\n        return listeners.stream()\n            .filter(l -> l.getPort() == port)\n            .findFirst().orElseGet(() -> createListener(port));\n    }\n\n    private AwsListener createListener(int port) {\n        AwsListener listener = new AwsListener(scheme, port);\n        listeners.add(listener);\n        return listener;\n    }", "author": "lacikaaa", "createdAt": "2021-01-06T14:33:16Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -36,6 +41,19 @@ public AwsLoadBalancerScheme getScheme() {\n         return listeners;\n     }\n \n+    public AwsListener getOrCreateListener(int port) {\n+        Optional<AwsListener> listenerOptional = listeners.stream()\n+            .filter(l -> l.getPort() == port)\n+            .findFirst();\n+        if (listenerOptional.isPresent()) {\n+            return listenerOptional.get();\n+        } else {\n+            AwsListener listener = new AwsListener(scheme, port);\n+            listeners.add(listener);\n+            return listener;\n+        }", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY3NTIxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552675216", "bodyText": "this could be moved to field level (practical reason next to one line less is we don't have to take care of it if we introduce a new constructor)", "author": "lacikaaa", "createdAt": "2021-01-06T14:43:26Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -1,28 +1,24 @@\n package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n \n-import java.util.List;\n-\n-import org.apache.commons.lang3.StringUtils;\n+import java.util.HashSet;\n+import java.util.Set;\n \n public class AwsTargetGroup {\n \n     private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n \n+    private final Set<String> instanceIds;\n+\n     private final int port;\n \n     private final String name;\n \n-    private final int order;\n-\n-    private final List<String> instanceIds;\n-\n     private String arn;\n \n-    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+    public AwsTargetGroup(AwsLoadBalancerScheme scheme, int port) {\n         this.port = port;\n-        this.order = order;\n-        this.instanceIds = instanceIds;\n-        name = getTargetGroupName(port, scheme);\n+        this.name = getTargetGroupName(port, scheme);\n+        this.instanceIds = new HashSet<>();", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMzE4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552923185", "bodyText": "By field level, do you mean:\nprivate final Set<String> instanceIds = new HashSet<>();", "author": "hreeve-cloudera", "createdAt": "2021-01-06T19:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY3NTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY5NzIxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552697217", "bodyText": "can't we just remove these fields from the entity and leave them in the database. As you wrote somewhere these are not really used in any environment yet. If we can't remove them please create a followup jira to remove them in the next release, if you haven't created one already. thanks", "author": "lacikaaa", "createdAt": "2021-01-06T15:07:48Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -39,9 +41,16 @@\n \n     private String endpoint;\n \n+    /**\n+     * @deprecated Use {@link #targetGroupSet} instead.\n+     */\n+    @Deprecated\n     @OneToMany(mappedBy = \"loadBalancer\", cascade = CascadeType.REMOVE, orphanRemoval = true)\n     private Set<TargetGroup> targetGroups = new HashSet<>();", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg0NDcyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552844722", "bodyText": "because of continuous deployment, we need to keep backward and forward compatibility\nso a follow-up jira is indeed needed to remove these (there is another field, below).", "author": "bergerdenes", "createdAt": "2021-01-06T17:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY5NzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNDAzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552924031", "bodyText": "Right. Originally I had deleted them, but I had a talk with Arpad about the compatibility requirements and that led me to adding them back and marking them deprecated. I'll open another JIRA to clean these methods up once this PR is in.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T19:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY5NzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjcxMTkwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552711909", "bodyText": "could you move it to a new method called sth like chooseSubnetForEndpointGateway?", "author": "lacikaaa", "createdAt": "2021-01-06T15:24:27Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/environment/network/EnvironmentBaseNetworkConverter.java", "diffHunk": "@@ -32,34 +34,37 @@ public Network convertToLegacyNetwork(EnvironmentNetworkResponse source, String\n         result.setOutboundInternetTraffic(source.getOutboundInternetTraffic());\n         result.setNetworkCidrs(source.getNetworkCidrs());\n         Map<String, Object> attributes = new HashMap<>();\n-        Optional<CloudSubnet> cloudSubnet;\n-        if (StringUtils.isNotBlank(source.getPreferedSubnetId())) {\n-            LOGGER.debug(\"Choosing subnet by prefered subnet Id {}\", source.getPreferedSubnetId());\n-            CloudSubnet cloudSubnetById = source.getSubnetMetas().get(source.getPreferedSubnetId());\n-            if (cloudSubnetById == null) {\n-                cloudSubnetById = source.getSubnetMetas().values()\n-                        .stream()\n-                        .filter(e -> e.getId().equals(source.getPreferedSubnetId()))\n-                        .findFirst().orElse(null);\n-            }\n-            cloudSubnet = Optional.of(cloudSubnetById);\n-        } else if (StringUtils.isNotEmpty(availabilityZone)) {\n-            LOGGER.debug(\"Choosing subnet by availability zone {}\", availabilityZone);\n-            cloudSubnet = source.getSubnetMetas().values().stream()\n-                    .filter(s -> StringUtils.isNotEmpty(s.getAvailabilityZone()) &&\n-                            s.getAvailabilityZone().equals(availabilityZone))\n-                    .findFirst();\n-        } else {\n-            LOGGER.debug(\"Fallback to choose random subnet\");\n-            cloudSubnet = source.getSubnetMetas().values().stream().findFirst();\n-        }\n+        Optional<CloudSubnet> cloudSubnet = chooseSubnet(source.getPreferedSubnetId(), source.getSubnetMetas(), availabilityZone, true);\n         if (cloudSubnet.isEmpty()) {\n             throw new BadRequestException(\"No subnet for the given availability zone: \" + availabilityZone);\n         }\n         LOGGER.debug(\"Chosen subnet: {}\", cloudSubnet.get());\n+\n+        if (source.getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED) {\n+            String selectedAZ = cloudSubnet.get().getAvailabilityZone();\n+            Map<String, CloudSubnet> subnetsToParse;\n+            if (source.getGatewayEndpointSubnetMetas() == null || source.getGatewayEndpointSubnetMetas().isEmpty()) {\n+                subnetsToParse = source.getSubnetMetas();\n+            } else {\n+                subnetsToParse = source.getGatewayEndpointSubnetMetas();\n+            }\n+            Map<String, CloudSubnet> publicSubnetMetas = subnetsToParse.entrySet().stream()\n+                .filter(entry -> !entry.getValue().isPrivateSubnet())\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Optional<CloudSubnet> endpointGatewayCloudSubnet = chooseSubnet(null,\n+                publicSubnetMetas, selectedAZ, false);\n+            if (endpointGatewayCloudSubnet.isEmpty()) {\n+                throw new BadRequestException(\"Could not find public subnet in availability zone: \" + availabilityZone);\n+            }\n+            LOGGER.debug(\"Chosen endpoint gateway subnet: {}\", endpointGatewayCloudSubnet.get());\n+            attributes.put(\"endpointGatewaySubnetId\", endpointGatewayCloudSubnet.get().getId());\n+        }", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjcxNzM4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552717383", "bodyText": "I think it would be useful to add some extra log lines, as there are a several if and it would help us investigate later", "author": "lacikaaa", "createdAt": "2021-01-06T15:30:46Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -349,39 +350,79 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n-    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack, DetailedEnvironmentResponse environment) {", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNjk2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552926965", "bodyText": "Please review this method again and let me know if the new log statements cover everything you think we'll need.", "author": "hreeve-cloudera", "createdAt": "2021-01-06T19:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjcxNzM4Mw=="}], "type": "inlineReview"}, {"oid": "8fe1ddbfe659a08c934dc3ec02d3ba515fca40bc", "url": "https://github.com/hortonworks/cloudbreak/commit/8fe1ddbfe659a08c934dc3ec02d3ba515fca40bc", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T19:51:28Z", "type": "forcePushed"}, {"oid": "525c662ae37d23c6b985b8e4571c4edd46ea9e03", "url": "https://github.com/hortonworks/cloudbreak/commit/525c662ae37d23c6b985b8e4571c4edd46ea9e03", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T19:53:11Z", "type": "forcePushed"}, {"oid": "8b0ea1fd3c2035bb485c5b1633956af7b1112e9d", "url": "https://github.com/hortonworks/cloudbreak/commit/8b0ea1fd3c2035bb485c5b1633956af7b1112e9d", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-06T20:48:34Z", "type": "forcePushed"}, {"oid": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "url": "https://github.com/hortonworks/cloudbreak/commit/7350f8f95c59441478aa883ee09d68ee4d7489ab", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-07T00:52:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MDEyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552850123", "bodyText": "Set.of()", "author": "bergerdenes", "createdAt": "2021-01-06T17:44:09Z", "path": "core/src/test/java/com/sequenceiq/cloudbreak/converter/spi/StackToCloudStackConverterTest.java", "diffHunk": "@@ -986,4 +986,48 @@ public void testConvertWithKnoxLoadBalancer() {\n         assertEquals(Set.of(\"group1\", \"group2\"), groupNames);\n     }\n \n+    @Test\n+    public void testConvertWithMultipleKnoxLoadBalancers() {\n+        Set<InstanceGroup> instanceGroups = new LinkedHashSet<>();\n+        InstanceGroup instanceGroup1 = mock(InstanceGroup.class);\n+        InstanceGroup instanceGroup2 = mock(InstanceGroup.class);\n+        when(instanceGroup1.getGroupName()).thenReturn(\"group1\");\n+        when(instanceGroup2.getGroupName()).thenReturn(\"group2\");\n+        instanceGroups.add(instanceGroup1);\n+        instanceGroups.add(instanceGroup2);\n+        when(stack.getInstanceGroupsAsList()).thenReturn(new ArrayList<>(instanceGroups));\n+        Template template = new Template();\n+        template.setVolumeTemplates(Sets.newHashSet());", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MDc5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552850791", "bodyText": "Set.of()", "author": "bergerdenes", "createdAt": "2021-01-06T17:44:52Z", "path": "core/src/test/java/com/sequenceiq/cloudbreak/converter/spi/StackToCloudStackConverterTest.java", "diffHunk": "@@ -986,4 +986,48 @@ public void testConvertWithKnoxLoadBalancer() {\n         assertEquals(Set.of(\"group1\", \"group2\"), groupNames);\n     }\n \n+    @Test\n+    public void testConvertWithMultipleKnoxLoadBalancers() {\n+        Set<InstanceGroup> instanceGroups = new LinkedHashSet<>();\n+        InstanceGroup instanceGroup1 = mock(InstanceGroup.class);\n+        InstanceGroup instanceGroup2 = mock(InstanceGroup.class);\n+        when(instanceGroup1.getGroupName()).thenReturn(\"group1\");\n+        when(instanceGroup2.getGroupName()).thenReturn(\"group2\");\n+        instanceGroups.add(instanceGroup1);\n+        instanceGroups.add(instanceGroup2);\n+        when(stack.getInstanceGroupsAsList()).thenReturn(new ArrayList<>(instanceGroups));\n+        Template template = new Template();\n+        template.setVolumeTemplates(Sets.newHashSet());\n+        when(instanceGroup1.getTemplate()).thenReturn(template);\n+        when(instanceGroup1.getNotDeletedInstanceMetaDataSet()).thenReturn(Collections.emptySet());", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MDkwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552850901", "bodyText": "Set.of()", "author": "bergerdenes", "createdAt": "2021-01-06T17:45:05Z", "path": "core/src/test/java/com/sequenceiq/cloudbreak/converter/spi/StackToCloudStackConverterTest.java", "diffHunk": "@@ -986,4 +986,48 @@ public void testConvertWithKnoxLoadBalancer() {\n         assertEquals(Set.of(\"group1\", \"group2\"), groupNames);\n     }\n \n+    @Test\n+    public void testConvertWithMultipleKnoxLoadBalancers() {\n+        Set<InstanceGroup> instanceGroups = new LinkedHashSet<>();\n+        InstanceGroup instanceGroup1 = mock(InstanceGroup.class);\n+        InstanceGroup instanceGroup2 = mock(InstanceGroup.class);\n+        when(instanceGroup1.getGroupName()).thenReturn(\"group1\");\n+        when(instanceGroup2.getGroupName()).thenReturn(\"group2\");\n+        instanceGroups.add(instanceGroup1);\n+        instanceGroups.add(instanceGroup2);\n+        when(stack.getInstanceGroupsAsList()).thenReturn(new ArrayList<>(instanceGroups));\n+        Template template = new Template();\n+        template.setVolumeTemplates(Sets.newHashSet());\n+        when(instanceGroup1.getTemplate()).thenReturn(template);\n+        when(instanceGroup1.getNotDeletedInstanceMetaDataSet()).thenReturn(Collections.emptySet());\n+        when(instanceGroup1.getStack()).thenReturn(stack);\n+        when(instanceGroup2.getTemplate()).thenReturn(template);\n+        when(instanceGroup2.getNotDeletedInstanceMetaDataSet()).thenReturn(Collections.emptySet());", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MzQ3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552853476", "bodyText": "I assume that asserting equality for all of the stack properties would be overkill", "author": "bergerdenes", "createdAt": "2021-01-06T17:47:41Z", "path": "core/src/test/java/com/sequenceiq/cloudbreak/converter/spi/StackToCloudStackConverterTest.java", "diffHunk": "@@ -986,4 +986,48 @@ public void testConvertWithKnoxLoadBalancer() {\n         assertEquals(Set.of(\"group1\", \"group2\"), groupNames);\n     }\n \n+    @Test\n+    public void testConvertWithMultipleKnoxLoadBalancers() {\n+        Set<InstanceGroup> instanceGroups = new LinkedHashSet<>();\n+        InstanceGroup instanceGroup1 = mock(InstanceGroup.class);\n+        InstanceGroup instanceGroup2 = mock(InstanceGroup.class);\n+        when(instanceGroup1.getGroupName()).thenReturn(\"group1\");\n+        when(instanceGroup2.getGroupName()).thenReturn(\"group2\");\n+        instanceGroups.add(instanceGroup1);\n+        instanceGroups.add(instanceGroup2);\n+        when(stack.getInstanceGroupsAsList()).thenReturn(new ArrayList<>(instanceGroups));\n+        Template template = new Template();\n+        template.setVolumeTemplates(Sets.newHashSet());\n+        when(instanceGroup1.getTemplate()).thenReturn(template);\n+        when(instanceGroup1.getNotDeletedInstanceMetaDataSet()).thenReturn(Collections.emptySet());\n+        when(instanceGroup1.getStack()).thenReturn(stack);\n+        when(instanceGroup2.getTemplate()).thenReturn(template);\n+        when(instanceGroup2.getNotDeletedInstanceMetaDataSet()).thenReturn(Collections.emptySet());\n+        when(instanceGroup2.getStack()).thenReturn(stack);\n+        TargetGroup targetGroup = mock(TargetGroup.class);\n+        when(targetGroup.getType()).thenReturn(TargetGroupType.KNOX);\n+        LoadBalancer internalLoadBalancer = mock(LoadBalancer.class);\n+        when(internalLoadBalancer.getType()).thenReturn(LoadBalancerType.DEFAULT_GATEWAY);\n+        when(internalLoadBalancer.getId()).thenReturn(1L);\n+        LoadBalancer externalLoadBalancer = mock(LoadBalancer.class);\n+        when(externalLoadBalancer.getType()).thenReturn(LoadBalancerType.ENDPOINT_ACCESS_GATEWAY);\n+        when(externalLoadBalancer.getId()).thenReturn(2L);\n+        when(loadBalancerPersistenceService.findByStackId(anyLong())).thenReturn(Set.of(internalLoadBalancer, externalLoadBalancer));\n+        when(targetGroupPersistenceService.findByLoadBalancerId(anyLong())).thenReturn(Set.of(targetGroup));\n+        when(instanceGroupService.findByTargetGroupId(anyLong())).thenReturn(Set.of(instanceGroup1, instanceGroup2));\n+        when(loadBalancerConfigService.getPortsForTargetGroup(any(TargetGroup.class))).thenReturn(Set.of(443));\n+\n+        CloudStack result = underTest.convert(stack);\n+\n+        assertEquals(2, result.getLoadBalancers().size());\n+        Optional<CloudLoadBalancer> internalCloudLoadBalancer = result.getLoadBalancers().stream()\n+            .filter(lb -> lb.getType() == LoadBalancerType.DEFAULT_GATEWAY)\n+            .findFirst();\n+        assertTrue(internalCloudLoadBalancer.isPresent());", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzODkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553438933", "bodyText": "I assume the other properties are being testing in their respective unit tests. For this test I'm just looking at the properties that are set when the load balancer exists.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2NzI4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r552867282", "bodyText": "you could use \"${subnetId}\"<#sep>,", "author": "bergerdenes", "createdAt": "2021-01-06T18:02:52Z", "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -279,7 +279,11 @@\n       \"Properties\" : {\n         \"IpAddressType\" : \"ipv4\",\n         \"Scheme\" : \"${loadBalancer.awsScheme}\",\n-        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],\n+        \"Subnets\" : [\n+          <#list loadBalancer.subnetIds as subnetId>\n+          \"${subnetId}\"<#if (subnetId_index + 1) != loadBalancer.subnetIds?size>,</#if>", "originalCommit": "6cd2ebe8438779c7148555fae81e3c07b87782fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMzAzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553323038", "bodyText": "\u203c\ufe0f This change is not backward compatible\ni.e. changing enum values that are stored in the database is generally a wrong idea\nYou need to maintain backward(and forward) compatibility\nThis enum's values are stored int Cloudbreak database, in loadbalancer.type", "author": "bergerdenes", "createdAt": "2021-01-07T13:22:03Z", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -1,6 +1,6 @@\n package com.sequenceiq.common.api.type;\n \n public enum LoadBalancerType {\n-    PUBLIC,\n-    PRIVATE\n+    ENDPOINT_ACCESS_GATEWAY,", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMjYyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553422626", "bodyText": "Reverted.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyNjQ3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553326471", "bodyText": "As Arpad suggested please follow the Database schema changes with zero downtime guideline and provide compatibility with deprecated fields. e.g. return the previous targetgroup if the new column is null.", "author": "bergerdenes", "createdAt": "2021-01-07T13:28:41Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -94,14 +103,34 @@ public void setEndpoint(String endpoint) {\n         this.endpoint = endpoint;\n     }\n \n+    /**\n+     * @deprecated Use {@link #getTargetGroupSet()} instead.\n+     */\n+    @Deprecated\n     public Set<TargetGroup> getTargetGroups() {\n         return targetGroups;\n     }\n \n+    /**\n+     * @deprecated Use {@link #setTargetGroupSet()} instead.\n+     */\n+    @Deprecated\n     public void setTargetGroups(Set<TargetGroup> targetGroups) {\n         this.targetGroups = targetGroups;\n     }\n \n+    public Set<TargetGroup> getTargetGroupSet() {\n+        return targetGroupSet;", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyODkwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553428905", "bodyText": "How should I handle the setter then? Checking for a null value or empty set there seems counter productive, since those seem like valid beginning states where the new columns should be set.\nShould I give the new fields a default value of an empty set? Then we could differentiate an empty set, which means the column exists, vs. a null, which means it doesn't.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyNjQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUzMTk5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553531991", "bodyText": "I've handled this by setting both the new and the old values in the new setter methods. For example:\n    public void setTargetGroupSet(Set<TargetGroup> targetGroups) {\n        this.targetGroupSet = targetGroups;\n        this.targetGroups = targetGroups;\n    }\n\nI think that'll work, but let me know if that's incorrect.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T19:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyNjQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyNzAyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553327029", "bodyText": "please be backward compatible\nremember, the older version of the service will still read the previous column only!", "author": "bergerdenes", "createdAt": "2021-01-07T13:29:50Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -45,14 +53,34 @@ public void setType(TargetGroupType type) {\n         this.type = type;\n     }\n \n+    /**\n+     * @deprecated Use {@link #getLoadBalancerSet()} instead.\n+     */\n+    @Deprecated\n     public LoadBalancer getLoadBalancer() {\n         return loadBalancer;\n     }\n \n+    public Set<LoadBalancer> getLoadBalancerSet() {\n+        return loadBalancerSet;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setLoadBalancerSet()} instead.\n+     */\n+    @Deprecated\n     public void setLoadBalancer(LoadBalancer loadBalancer) {\n         this.loadBalancer = loadBalancer;\n     }\n \n+    public void setLoadBalancerSet(Set<LoadBalancer> loadBalancerSet) {", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyODA3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553328079", "bodyText": "environment might be null in case of stacktype==TEMPLATE", "author": "bergerdenes", "createdAt": "2021-01-07T13:31:58Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -187,7 +188,7 @@ public Stack convert(StackV4Request source) {\n         stack.setExternalDatabaseCreationType(getIfNotNull(source.getExternalDatabase(), DatabaseRequest::getAvailabilityType));\n         determineServiceTypeTag(stack, source.getTags());\n         determineServiceFeatureTag(stack, source.getTags());\n-        stack.setLoadBalancers(createLoadBalancers(source, stack));\n+        stack.setLoadBalancers(createLoadBalancers(source, stack, environment));", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMDA3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553430075", "bodyText": "Added null check for environment before doing anything with the load balancers.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyODA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyODgwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553328809", "bodyText": "environment might be null here", "author": "bergerdenes", "createdAt": "2021-01-07T13:33:27Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -349,39 +350,83 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n-    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack, DetailedEnvironmentResponse environment) {", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMDIyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553430225", "bodyText": "Added null check.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyODgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553330593", "bodyText": "is the duplicate reference needed?", "author": "bergerdenes", "createdAt": "2021-01-07T13:36:54Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -349,39 +350,83 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n-    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack, DetailedEnvironmentResponse environment) {\n+        LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n         Set<LoadBalancer> loadBalancers = new HashSet<>();\n-        Set<TargetGroup> targetGroups = new HashSet<>();\n-        // TODO expand this to data hubs\n-        if (StackType.DATALAKE.equals(source.getType()) &&\n-            entitlementService.datalakeLoadBalancerEnabled(ThreadBasedUserCrnProvider.getAccountId())) {\n-            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n-            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n-            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n-                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n-                .collect(Collectors.toSet());\n-            if (!knoxGatewayGroups.isEmpty()) {\n-                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n-                TargetGroup targetGroup = new TargetGroup();\n-                targetGroup.setType(TargetGroupType.KNOX);\n-                targetGroup.setInstanceGroups(knoxGatewayGroups);\n-                targetGroups.add(targetGroup);\n-                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+\n+        Optional<TargetGroup> knoxTargetGroup = setupKnoxTargetGroup(stack);\n+        if (knoxTargetGroup.isPresent()) {\n+            if (shouldCreateInternalKnoxLoadBalancer(source.getType())) {\n+                LOGGER.debug(\"Found Knox enabled instance groups in stack. Setting up internal Knox load balancer\");\n+                setupKnoxLoadBalancer(\n+                    createLoadBalancerIfNotExists(loadBalancers, LoadBalancerType.DEFAULT_GATEWAY, stack),\n+                    knoxTargetGroup.get());\n+            }\n+            if (shouldCreateExternalKnoxLoadBalancer(source.getType(), environment.getNetwork())) {\n+                LOGGER.debug(\"Public endpoint access gateway is enabled. Setting up public Knox load balancer\");\n+                setupKnoxLoadBalancer(\n+                    createLoadBalancerIfNotExists(loadBalancers, LoadBalancerType.ENDPOINT_ACCESS_GATEWAY, stack),\n+                    knoxTargetGroup.get());\n             }\n-            // TODO CB-9368 - create target group for CM instances\n+        } else {\n+            LOGGER.debug(\"No Knox instance groups found. If load balancer creation is enabled, Knox routing in the load balancer will be skipped.\");\n+        }\n+\n+        // TODO CB-9368 - create target group for CM instances\n+\n+        return loadBalancers;\n+    }\n+\n+    private boolean shouldCreateInternalKnoxLoadBalancer(StackType type) {\n+        // TODO expand this to data hubs\n+        return StackType.DATALAKE.equals(type) &&\n+            (entitlementService.datalakeLoadBalancerEnabled(ThreadBasedUserCrnProvider.getAccountId())\n+            || entitlementService.publicEndpointAccessGatewayEnabled(ThreadBasedUserCrnProvider.getAccountId()));\n+    }\n+\n+    private boolean shouldCreateExternalKnoxLoadBalancer(StackType type, EnvironmentNetworkResponse network) {\n+        // TODO expand this to data hubs\n+        return network != null && network.getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED\n+            && StackType.DATALAKE.equals(type)\n+            && entitlementService.publicEndpointAccessGatewayEnabled(ThreadBasedUserCrnProvider.getAccountId());\n+    }\n+\n+    private Optional<TargetGroup> setupKnoxTargetGroup(Stack stack) {\n+        TargetGroup knoxTargetGroup = null;\n+        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+            .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+            .collect(Collectors.toSet());\n+        if (!knoxGatewayGroups.isEmpty()) {\n+            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+            knoxTargetGroup = new TargetGroup();\n+            knoxTargetGroup.setType(TargetGroupType.KNOX);\n+            knoxTargetGroup.setInstanceGroups(knoxGatewayGroups);\n+            TargetGroup finalKnoxTargetGroup = knoxTargetGroup;", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMTY1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553431652", "bodyText": "I need an effectively final variable to by able to use this in the lamba in the next line. That's what finalKnoxTargetGroup is.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDg2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553330869", "bodyText": "seems a circular reference, is that intended?", "author": "bergerdenes", "createdAt": "2021-01-07T13:37:24Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -349,39 +350,83 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n-    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack, DetailedEnvironmentResponse environment) {\n+        LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n         Set<LoadBalancer> loadBalancers = new HashSet<>();\n-        Set<TargetGroup> targetGroups = new HashSet<>();\n-        // TODO expand this to data hubs\n-        if (StackType.DATALAKE.equals(source.getType()) &&\n-            entitlementService.datalakeLoadBalancerEnabled(ThreadBasedUserCrnProvider.getAccountId())) {\n-            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n-            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n-            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n-                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n-                .collect(Collectors.toSet());\n-            if (!knoxGatewayGroups.isEmpty()) {\n-                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n-                TargetGroup targetGroup = new TargetGroup();\n-                targetGroup.setType(TargetGroupType.KNOX);\n-                targetGroup.setInstanceGroups(knoxGatewayGroups);\n-                targetGroups.add(targetGroup);\n-                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+\n+        Optional<TargetGroup> knoxTargetGroup = setupKnoxTargetGroup(stack);\n+        if (knoxTargetGroup.isPresent()) {\n+            if (shouldCreateInternalKnoxLoadBalancer(source.getType())) {\n+                LOGGER.debug(\"Found Knox enabled instance groups in stack. Setting up internal Knox load balancer\");\n+                setupKnoxLoadBalancer(\n+                    createLoadBalancerIfNotExists(loadBalancers, LoadBalancerType.DEFAULT_GATEWAY, stack),\n+                    knoxTargetGroup.get());\n+            }\n+            if (shouldCreateExternalKnoxLoadBalancer(source.getType(), environment.getNetwork())) {\n+                LOGGER.debug(\"Public endpoint access gateway is enabled. Setting up public Knox load balancer\");\n+                setupKnoxLoadBalancer(\n+                    createLoadBalancerIfNotExists(loadBalancers, LoadBalancerType.ENDPOINT_ACCESS_GATEWAY, stack),\n+                    knoxTargetGroup.get());\n             }\n-            // TODO CB-9368 - create target group for CM instances\n+        } else {\n+            LOGGER.debug(\"No Knox instance groups found. If load balancer creation is enabled, Knox routing in the load balancer will be skipped.\");\n+        }\n+\n+        // TODO CB-9368 - create target group for CM instances\n+\n+        return loadBalancers;\n+    }\n+\n+    private boolean shouldCreateInternalKnoxLoadBalancer(StackType type) {\n+        // TODO expand this to data hubs\n+        return StackType.DATALAKE.equals(type) &&\n+            (entitlementService.datalakeLoadBalancerEnabled(ThreadBasedUserCrnProvider.getAccountId())\n+            || entitlementService.publicEndpointAccessGatewayEnabled(ThreadBasedUserCrnProvider.getAccountId()));\n+    }\n+\n+    private boolean shouldCreateExternalKnoxLoadBalancer(StackType type, EnvironmentNetworkResponse network) {\n+        // TODO expand this to data hubs\n+        return network != null && network.getPublicEndpointAccessGateway() == PublicEndpointAccessGateway.ENABLED\n+            && StackType.DATALAKE.equals(type)\n+            && entitlementService.publicEndpointAccessGatewayEnabled(ThreadBasedUserCrnProvider.getAccountId());\n+    }\n+\n+    private Optional<TargetGroup> setupKnoxTargetGroup(Stack stack) {\n+        TargetGroup knoxTargetGroup = null;\n+        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+            .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+            .collect(Collectors.toSet());\n+        if (!knoxGatewayGroups.isEmpty()) {\n+            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+            knoxTargetGroup = new TargetGroup();\n+            knoxTargetGroup.setType(TargetGroupType.KNOX);\n+            knoxTargetGroup.setInstanceGroups(knoxGatewayGroups);\n+            TargetGroup finalKnoxTargetGroup = knoxTargetGroup;\n+            knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(finalKnoxTargetGroup));", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMjM4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553432386", "bodyText": "The InstanceGroup and TargetGroup entities have a many-to-many relationship to each other. So the reference is built into the database, and I'm just filling out the entities with that reference here.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMjUyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553332527", "bodyText": "what if the joining table does not contain anything? please maintain backward compatibility.\neven if you insert all records into the new targetgroup_loadbalancer table from the existing targetgroup table, a race condition might cause not migrated rows!", "author": "bergerdenes", "createdAt": "2021-01-07T13:40:36Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/repository/TargetGroupRepository.java", "diffHunk": "@@ -15,5 +15,6 @@\n     @Query(\"SELECT t FROM TargetGroup t INNER JOIN t.instanceGroups ig WHERE ig.id= :instanceGroupId\")\n     Set<TargetGroup> findByInstanceGroupId(@Param(\"instanceGroupId\") Long instanceGroupId);\n \n+    @Query(\"SELECT t FROM TargetGroup t INNER JOIN t.loadBalancerSet lb WHERE lb.id= :loadBalancerId\")", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzNTk1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553435958", "bodyText": "I've reverted this and and created a new method with this query called findTargetGroupsByLoadBalancerId. The logic that calls these query now looks like:\n    public Set<TargetGroup> findByLoadBalancerId(Long loadBalancerId) {\n        Set<TargetGroup> targetGroups = repository.findTargetGroupsByLoadBalancerId(loadBalancerId);\n        if (targetGroups == null || targetGroups.isEmpty()) {\n            targetGroups = repository.findByLoadBalancerId(loadBalancerId);\n        }\n        return targetGroups;\n    }\n\nWill that cover all the migration cases?", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzIyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553333220", "bodyText": "this migration should happen at the second phase of the Database schema changes with zero downtime process (or at least repeated)", "author": "bergerdenes", "createdAt": "2021-01-07T13:41:58Z", "path": "core/src/main/resources/schema/app/20201210210553_CB-10095_Add_multiple_load_balancers_to_target_group.sql", "diffHunk": "@@ -0,0 +1,18 @@\n+-- // CB-10095 Add multiple load balancers to target group\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE TABLE IF NOT EXISTS targetgroup_loadbalancer (\n+    targetgroupset_id     bigint NOT NULL,\n+    loadbalancerset_id    bigint NOT NULL\n+);\n+\n+ALTER TABLE ONLY targetgroup_loadbalancer ADD CONSTRAINT targetgroup_loadbalancer_pkey PRIMARY KEY (targetgroupset_id, loadbalancerset_id);\n+ALTER TABLE ONLY targetgroup_loadbalancer ADD CONSTRAINT fk_targetgroup_loadbalancer_targetgroup_id FOREIGN KEY (targetgroupset_id) REFERENCES targetgroup(id);\n+ALTER TABLE ONLY targetgroup_loadbalancer ADD CONSTRAINT fk_targetgroup_loadbalancer_loadbalancer_id FOREIGN KEY (loadbalancerset_id) REFERENCES loadbalancer(id);\n+\n+INSERT INTO targetgroup_loadbalancer (SELECT id, loadbalancer_id FROM targetgroup);", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzNzM2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553437369", "bodyText": "I'll remove this and create a separate JIRA for it.\nI asked Arpad but he didn't answer: When should the subsequent JIRAs to populate the new table and then remove the old columns be done? Do we need to delay each step so that it's in its own CB build? Or is there another process to schedule the changes?", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1NjExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553856114", "bodyText": "We need to do them in separate release versions (like if you this PR will be incorporated into 2.37 then the second phase is 2.38 and the column removal is 2.39).\nAs far as I know, for zero downtime migration, this is the only way.", "author": "bergerdenes", "createdAt": "2021-01-08T10:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NjM5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r554076399", "bodyText": "Noted. I'll create the JIRAs and target them for the appropriate releases.", "author": "hreeve-cloudera", "createdAt": "2021-01-08T17:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNTA1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553335055", "bodyText": "this method seems too complex", "author": "bergerdenes", "createdAt": "2021-01-07T13:45:22Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/flow/creation/handler/NetworkCreationHandler.java", "diffHunk": "@@ -114,6 +126,50 @@ private void setChildEnvironmentNetworkIfItHasParentWithTheSameCloudProvider(Env\n         }\n     }\n \n+    private Map<String, CloudSubnet> removePrivateSubnets(Map<String, CloudSubnet> endpointGatewaySubnetMetas) {\n+        LOGGER.debug(\"Removing any private subnets from the provided endpoint gateway list because they won't be used.\");\n+        if (endpointGatewaySubnetMetas == null || endpointGatewaySubnetMetas.isEmpty()) {\n+            return Map.of();\n+        }\n+        return endpointGatewaySubnetMetas.entrySet().stream()\n+            .filter(entry -> !entry.getValue().isPrivateSubnet())\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private void validateSubnetsIfProvided(Environment environment, Map<String, CloudSubnet> subnetMetas,", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ0MTU1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553441552", "bodyText": "I've broken this into four methods instead.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzNTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0Njg3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553346878", "bodyText": "<#sep>,", "author": "bergerdenes", "createdAt": "2021-01-07T14:05:15Z", "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -305,28 +307,26 @@\n         }\n       </#if>\n \n-        <#list listener.targetGroups as targetGroup>\n-        ,\"${targetGroup.name}\" : {\n-          \"Type\" : \"AWS::ElasticLoadBalancingV2::TargetGroup\",\n-          \"Properties\" : {\n-            \"Port\" : ${targetGroup.port},\n-            \"Protocol\" : \"TCP\",\n-            \"TargetType\" : \"instance\",\n-            <#if existingVPC>\n-            \"VpcId\" : { \"Ref\" : \"VPCId\" }\n-            <#else>\n-            \"VpcId\" : { \"Ref\" : \"VPC\" }\n-            </#if>\n-            <#if targetGroup.instanceIds?size != 0 >\n-            ,\"Targets\" : [\n-              <#list targetGroup.instanceIds as i>\n-                { \"Id\" : \"${i}\" }<#if (i_index + 1) != targetGroup.instanceIds?size>,</#if>\n-              </#list>\n-            ]\n-            </#if>\n-          }\n+      ,\"${listener.targetGroup.name}\" : {\n+        \"Type\" : \"AWS::ElasticLoadBalancingV2::TargetGroup\",\n+        \"Properties\" : {\n+          \"Port\" : ${listener.targetGroup.port},\n+          \"Protocol\" : \"TCP\",\n+          \"TargetType\" : \"instance\",\n+          <#if existingVPC>\n+          \"VpcId\" : { \"Ref\" : \"VPCId\" }\n+          <#else>\n+          \"VpcId\" : { \"Ref\" : \"VPC\" }\n+          </#if>\n+          <#if listener.targetGroup.instanceIds?size != 0 >\n+          ,\"Targets\" : [\n+            <#list listener.targetGroup.instanceIds as i>\n+              { \"Id\" : \"${i}\" }<#if (i_index + 1) != listener.targetGroup.instanceIds?size>,</#if>", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0ODEwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553348105", "bodyText": "minor: use string constants instead and reuse them in assertions", "author": "bergerdenes", "createdAt": "2021-01-07T14:07:24Z", "path": "cloud-aws/src/test/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetaDataCollectorTest.java", "diffHunk": "@@ -323,4 +389,18 @@ private AuthenticatedContext authenticatedContext() {\n         authenticatedContext.putParameter(AmazonEC2Client.class, amazonEC2Client);\n         return authenticatedContext;\n     }\n+\n+    private void setupMethodsForLoadBalancer() {\n+        LoadBalancer internalLoadBalancer = new LoadBalancer()\n+            .withDNSName(\"internal-lb.aws.dns\")", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0ODc5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553348791", "bodyText": "observation: the entitlement flag is not used extensively, that is, a lot of changed functionality cannot be switched off as-is", "author": "bergerdenes", "createdAt": "2021-01-07T14:08:31Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/EntitlementService.java", "diffHunk": "@@ -183,6 +184,10 @@ public boolean datalakeLoadBalancerEnabled(String accountId) {\n         return isEntitlementRegistered(accountId, CDP_DATA_LAKE_LOAD_BALANCER);\n     }\n \n+    public boolean publicEndpointAccessGatewayEnabled(String accountId) {", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQwNzI2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553407267", "bodyText": "I had the idea that the network settings that are triggering the new logic wouldn't be set unless the entitlement is enabled. So we can check for the existence of those settings as an implicit check to see if the entitlement is enabled.\nThinking on it now, I realize I don't think we're checking the entitlement when setting those settings for CLI requests. (It will be checked for the UI changes to toggle these settings, which are in progress.) I can add some new logic to check the entitlement when both the environment and stack creation requests are received, and make sure to unset those fields if the entitlement isn't enabled. That should prevent any of the subsequent logic from triggering. I'll go ahead and do a check whenever we're setting the feature related fields in the various objects as well.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T15:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0ODc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYyNjQ4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553626487", "bodyText": "I've added the entitlement check anywhere we're setting the endpoint gateway related fields. If the original environment request has those fields set but the entitlement is disabled, then it will unset them before processing the request. I also added a lot of unit tests to verify the behavior when the entitlement is disabled and enabled.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T22:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0ODc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0OTEzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553349137", "bodyText": "minor: please use constants", "author": "bergerdenes", "createdAt": "2021-01-07T14:09:03Z", "path": "cloud-aws/src/test/java/com/sequenceiq/cloudbreak/cloud/aws/view/AwsNetworkViewTest.java", "diffHunk": "@@ -121,4 +122,20 @@ public void testMultipleSubnetCidrEmpty() {\n         assertTrue(underTest.getExistingVpcCidrs().contains(\"1.1.1.1\"));\n     }\n \n+    @Test\n+    public void testSingleEndpointGatewaySubnet() {\n+        when(network.getStringParameter(ENDPOINT_GATEWAY_SUBNET_ID)).thenReturn(\"subnet-123\");", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1MjA2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553352063", "bodyText": "missing assertions", "author": "bergerdenes", "createdAt": "2021-01-07T14:14:09Z", "path": "environment/src/test/java/com/sequenceiq/environment/environment/flow/creation/handler/NetworkCreationHandlerTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package com.sequenceiq.environment.environment.flow.creation.handler;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.ws.rs.BadRequestException;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.springframework.util.ReflectionUtils;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.SubnetType;\n+import com.sequenceiq.common.api.type.PublicEndpointAccessGateway;\n+import com.sequenceiq.environment.environment.domain.Environment;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.flow.creation.event.EnvCreationFailureEvent;\n+import com.sequenceiq.environment.environment.service.EnvironmentResourceService;\n+import com.sequenceiq.environment.environment.service.EnvironmentService;\n+import com.sequenceiq.environment.network.CloudNetworkService;\n+import com.sequenceiq.environment.network.dao.domain.AwsNetwork;\n+import com.sequenceiq.environment.network.dao.domain.BaseNetwork;\n+import com.sequenceiq.environment.network.dao.domain.RegistrationType;\n+import com.sequenceiq.environment.network.dto.NetworkDto;\n+import com.sequenceiq.flow.reactor.api.event.EventSender;\n+\n+public class NetworkCreationHandlerTest {\n+\n+    private static final String UNMATCHED_AZ_MSG = \"Please provide public subnets in each of the following availability zones:\";\n+\n+    @InjectMocks\n+    private NetworkCreationHandler underTest;\n+\n+    @Mock\n+    private EnvironmentService environmentService;\n+\n+    @Mock\n+    private EnvironmentResourceService environmentResourceService;\n+\n+    @Mock\n+    private CloudNetworkService cloudNetworkService;\n+\n+    @Mock\n+    private EventBus eventBus;\n+\n+    @Mock\n+    private EventSender eventSender;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+\n+        Field enabledPlatformsField = ReflectionUtils.findField(NetworkCreationHandler.class, \"enabledPlatforms\");\n+        ReflectionUtils.makeAccessible(enabledPlatformsField);\n+        ReflectionUtils.setField(enabledPlatformsField, underTest, Set.of(\"AWS\", \"AZURE\"));\n+\n+        doNothing().when(eventSender).sendEvent(any(), any());\n+        when(eventBus.notify(any(Object.class), any(Event.class))).thenReturn(null);\n+    }\n+\n+    @Test\n+    public void testWithEndpointGatewayAndProvidedSubnets() {\n+        EnvironmentDto environmentDto = createEnvironmentDto();\n+        Event<EnvironmentDto> environmentDtoEvent = Event.wrap(environmentDto);\n+        AwsNetwork network = createNetwork();\n+        Environment environment = createEnvironment(network);\n+        Optional<Environment> environmentOptional = Optional.of(environment);\n+\n+        Map<String, CloudSubnet> subnets = createDefaultPrivateSubnets();\n+        Map<String, CloudSubnet> endpointGatewaySubnets = createDefaultPublicSubnets();\n+\n+        when(environmentService.findEnvironmentById(any())).thenReturn(environmentOptional);\n+        when(cloudNetworkService.retrieveSubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(subnets);\n+        when(cloudNetworkService.retrieveEndpointGatewaySubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(endpointGatewaySubnets);\n+        when(environmentResourceService.createAndSetNetwork(any(), any(), any(), any(), any())).thenReturn(network);\n+\n+        underTest.accept(environmentDtoEvent);\n+\n+        assertEquals(2, environmentDto.getNetwork().getEndpointGatewaySubnetMetas().size());\n+        assertEquals(Set.of(\"public-id1\", \"public-id2\"), environmentDto.getNetwork().getEndpointGatewaySubnetIds());\n+    }\n+\n+    @Test\n+    public void testWithEndpointGatewayRemovePrivateSubnets() {\n+        EnvironmentDto environmentDto = createEnvironmentDto();\n+        Event<EnvironmentDto> environmentDtoEvent = Event.wrap(environmentDto);\n+        AwsNetwork network = createNetwork();\n+        Environment environment = createEnvironment(network);\n+        Optional<Environment> environmentOptional = Optional.of(environment);\n+\n+        Map<String, CloudSubnet> subnets = createDefaultPrivateSubnets();\n+        Map<String, CloudSubnet> endpointGatewaySubnets = createDefaultPublicSubnets();\n+        endpointGatewaySubnets.putAll(createDefaultPrivateSubnets());\n+\n+        when(environmentService.findEnvironmentById(any())).thenReturn(environmentOptional);\n+        when(cloudNetworkService.retrieveSubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(subnets);\n+        when(cloudNetworkService.retrieveEndpointGatewaySubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(endpointGatewaySubnets);\n+        when(environmentResourceService.createAndSetNetwork(any(), any(), any(), any(), any())).thenReturn(network);\n+\n+        underTest.accept(environmentDtoEvent);\n+\n+        assertEquals(2, environmentDto.getNetwork().getEndpointGatewaySubnetMetas().size());\n+        assertEquals(Set.of(\"public-id1\", \"public-id2\"), environmentDto.getNetwork().getEndpointGatewaySubnetIds());\n+    }\n+\n+    @Test\n+    public void testWithEndpointGatewayAndEnvironmentSubnets() {\n+        EnvironmentDto environmentDto = createEnvironmentDto();\n+        Event<EnvironmentDto> environmentDtoEvent = Event.wrap(environmentDto);\n+        AwsNetwork network = createNetwork();\n+        Environment environment = createEnvironment(network);\n+        Optional<Environment> environmentOptional = Optional.of(environment);\n+\n+        Map<String, CloudSubnet> subnets = createDefaultPrivateSubnets();\n+        subnets.putAll(createDefaultPublicSubnets());\n+\n+        when(environmentService.findEnvironmentById(any())).thenReturn(environmentOptional);\n+        when(cloudNetworkService.retrieveSubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(subnets);\n+        when(cloudNetworkService.retrieveEndpointGatewaySubnetMetadata(any(EnvironmentDto.class), any())).thenReturn(Map.of());\n+        when(environmentResourceService.createAndSetNetwork(any(), any(), any(), any(), any())).thenReturn(network);\n+\n+        underTest.accept(environmentDtoEvent);\n+    }", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ0ODE0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553448149", "bodyText": "I've added an assert to make sure the endpoint gateway subnets aren't being set in this case. But the main thing I'm testing is that underTest.accept(environmentDtoEvent); doesn't throw an BadRequestionException. I've wrapped this call in a try/catch to make what's being tested more explicit.", "author": "hreeve-cloudera", "createdAt": "2021-01-07T16:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1MjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM1MzgxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9675#discussion_r553353817", "bodyText": "assert on actual values?\nsame for all tests below", "author": "bergerdenes", "createdAt": "2021-01-07T14:16:58Z", "path": "environment/src/test/java/com/sequenceiq/environment/network/service/SubnetIdProviderTest.java", "diffHunk": "@@ -161,6 +163,82 @@ public void shouldReturnNullInCaseOfNonSupportedCloudPlatform() {\n         Assertions.assertNull(actual);\n     }\n \n+    @Test\n+    public void testSelectSubnetForEndpointAccessGatewayWithProvidedSubnets() {\n+        setupConnectorWithSelectionResult(List.of(\n+            new CloudSubnet(\"public-id-2\", \"name-2\", \"AZ-b\", \"\")));\n+        Map<String, CloudSubnet> subnets = new HashMap<>();\n+        subnets.putAll(createPrivateSubnetEntry(\"id-1\", \"name-1\", \"AZ-a\"));\n+        subnets.putAll(createPrivateSubnetEntry(\"id-2\", \"name-2\", \"AZ-b\"));\n+        Map<String, CloudSubnet> publicSubnets = new HashMap<>();\n+        publicSubnets.putAll(createPublicSubnetEntry(\"public-id-1\", \"name-1\", \"AZ-a\"));\n+        publicSubnets.putAll(createPublicSubnetEntry(\"public-id-2\", \"name-2\", \"AZ-b\"));\n+        NetworkDto networkDto = NetworkDto.builder()\n+            .withSubnetMetas(subnets)\n+            .withCbSubnets(subnets)\n+            .withEndpointGatewaySubnetMetas(publicSubnets)\n+            .build();\n+\n+        String actual = underTest.provideEndpointGateway(networkDto, CloudPlatform.AWS, \"id-2\");\n+\n+        Assertions.assertNotNull(actual);\n+    }", "originalCommit": "7350f8f95c59441478aa883ee09d68ee4d7489ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eecce917a289941d2c5b0514aa9c157fce82db95", "url": "https://github.com/hortonworks/cloudbreak/commit/eecce917a289941d2c5b0514aa9c157fce82db95", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-07T22:22:50Z", "type": "forcePushed"}, {"oid": "41df1a140fc75b8a6b42a284bfcf1067877e29ec", "url": "https://github.com/hortonworks/cloudbreak/commit/41df1a140fc75b8a6b42a284bfcf1067877e29ec", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-07T22:44:43Z", "type": "forcePushed"}, {"oid": "a4f7fc74452d11e1ef2ea2e86f431241edf6a4d7", "url": "https://github.com/hortonworks/cloudbreak/commit/a4f7fc74452d11e1ef2ea2e86f431241edf6a4d7", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-11T17:41:19Z", "type": "commit"}, {"oid": "a4f7fc74452d11e1ef2ea2e86f431241edf6a4d7", "url": "https://github.com/hortonworks/cloudbreak/commit/a4f7fc74452d11e1ef2ea2e86f431241edf6a4d7", "message": "CB-10095 Subnet selection for public gateway endpoint\n\nAdds new logic to create a public load balancer to act as a public gateway to\nthe Knox endpoints in an otherwise private system. Logic will be triggered if\nthe \"publicEndpointAccessGateway\" flag in the environment request is set to\nENABLED, and the tenant has the new CDP_PUBLIC_ENDPOINT_ACCESS_GATEWAY\nentitlement.\n\nA list of subnets to use for the public LB can optionally be provided as part\nof the environment creation request. If provided, any private subnets in the\nlist will be discarded, and a public subnet in the same AZ as the selected stack\nsubnet will be used. If the endpoint subnets aren't explicitly provided, the\nsubnets provided for environment creation are used instead. If public subnets in\nthe appropriate availability zones are not provided, creation will fail\nimmediately.\n\nTested with unit tests and by running CB locally with hardcoded API fields to\nverify cloud resources were created and configured appropriately.", "committedDate": "2021-01-11T17:41:19Z", "type": "forcePushed"}]}