{"pr_number": 8515, "pr_title": "CB-6364: Create CB core api and flow which updates salt config", "pr_createdAt": "2020-07-08T22:03:01Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8515", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNjI4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452106287", "bodyText": "I think this should be ClusterDeletionBasedExitCriteriaModel", "author": "lacikaaa", "createdAt": "2020-07-09T10:01:41Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java", "diffHunk": "@@ -223,6 +224,20 @@ public void runClusterServices(@Nonnull Stack stack, @Nonnull Cluster cluster, L\n         }\n     }\n \n+    public void updateClusterConfigs(@Nonnull Stack stack, @Nonnull Cluster cluster, List<String> candidateAddresses) {\n+        try {\n+            Set<Node> nodes = stackUtil.collectReachableNodes(stack);\n+            GatewayConfig primaryGatewayConfig = gatewayConfigService.getPrimaryGatewayConfig(stack);\n+            List<GatewayConfig> gatewayConfigs = gatewayConfigService.getAllGatewayConfigs(stack);\n+            SaltConfig saltConfig = createSaltConfig(stack, cluster, primaryGatewayConfig, gatewayConfigs, nodes);\n+            ExitCriteriaModel exitCriteriaModel = nonCancellableModel();", "originalCommit": "2fab989c6900b089f978ed980460ffdc1a0eadc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMzUxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452403516", "bodyText": "Ok didn't quite understand the distinction", "author": "wonderslug", "createdAt": "2020-07-09T18:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNjI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODcxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r453008714", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-10T18:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNjI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNzY5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452107699", "bodyText": "why not AbstractClusterAction?", "author": "lacikaaa", "createdAt": "2020-07-09T10:04:19Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/ConfigUpdateActions.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.ConfigUpdateEvent.CONFIG_UPDATE_FINALIZE_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.AbstractClusterAction;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.ClusterViewContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.ConfigUpdateRequest;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.ConfigUpdateSuccess;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationState;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.AbstractStackFailureAction;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.StackContext;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.StackFailureContext;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.provision.action.AbstractStackCreationAction;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackFailureEvent;\n+import java.util.Map;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.statemachine.action.Action;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ConfigUpdateActions {\n+\n+    @Inject\n+    private ConfigUpdateService configUpdateService;\n+\n+    @Bean(name = \"CONFIG_UPDATE_START_STATE\")\n+    public Action<?, ?> configUpdateStartAction() {\n+        return new AbstractStackCreationAction<>(StackEvent.class) {", "originalCommit": "2fab989c6900b089f978ed980460ffdc1a0eadc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI5NjE0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452296148", "bodyText": "Cause I copied and altered and missed one :)", "author": "wonderslug", "createdAt": "2020-07-09T15:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNzY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MTk3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r453041974", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-10T19:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwNzY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwOTQxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452109413", "bodyText": "I think this should be outside of the transaction, but inside the try-catch. so it won't run if the transaction fails, but we should release the lock as soon as possible", "author": "lacikaaa", "createdAt": "2020-07-09T10:07:19Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/ConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_STARTED;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.host.ClusterHostServiceRunner;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationService;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ConfigUpdateService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    @Inject\n+    private ClusterCreationService clusterCreationService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private ClusterHostServiceRunner clusterHostServiceRunner;\n+\n+    public void doConfigUpdate(Long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService\n+            .fireEventAndLog(stackId, UPDATE_IN_PROGRESS.name(), CLUSTER_CONFIG_UPDATE_STARTED);\n+        Stack stack = stackService.getByIdWithClusterInTransaction(stackId);\n+        clusterHostServiceRunner.updateClusterConfigs(stack, stack.getCluster(), List.of());\n+    }\n+\n+    public void configUpdateFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE,\n+                    \"Config update finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(),", "originalCommit": "2fab989c6900b089f978ed980460ffdc1a0eadc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODc5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r453008799", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-10T18:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwOTQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMDQxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452110410", "bodyText": "if the above was in transaction, shouldn't this be in one?", "author": "lacikaaa", "createdAt": "2020-07-09T10:09:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/ConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CONFIG_UPDATE_STARTED;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.host.ClusterHostServiceRunner;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationService;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ConfigUpdateService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    @Inject\n+    private ClusterCreationService clusterCreationService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private ClusterHostServiceRunner clusterHostServiceRunner;\n+\n+    public void doConfigUpdate(Long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService\n+            .fireEventAndLog(stackId, UPDATE_IN_PROGRESS.name(), CLUSTER_CONFIG_UPDATE_STARTED);\n+        Stack stack = stackService.getByIdWithClusterInTransaction(stackId);\n+        clusterHostServiceRunner.updateClusterConfigs(stack, stack.getCluster(), List.of());\n+    }\n+\n+    public void configUpdateFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE,\n+                    \"Config update finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(),\n+                    CLUSTER_CONFIG_UPDATE_FINISHED);\n+            });\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleConfigUpdateFailure(StackView stackView, Exception exception) {\n+        if (stackView.getClusterView() != null) {\n+            String errorMessage = clusterCreationService.getErrorMessageFromException(exception);\n+            clusterService\n+                .updateClusterStatusByStackId(stackView.getId(), UPDATE_FAILED, errorMessage);\n+            stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE);", "originalCommit": "2fab989c6900b089f978ed980460ffdc1a0eadc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODg0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r453008848", "bodyText": "fixed", "author": "wonderslug", "createdAt": "2020-07-10T18:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMDQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMTQ4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r452111482", "bodyText": "From EventHandler:\n@deprecated Please use ExceptionCatcherEventHandler", "author": "lacikaaa", "createdAt": "2020-07-09T10:11:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/handler/ConfigUpdateHandler.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.handler;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.ConfigUpdateService;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.ConfigUpdateFailed;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.ConfigUpdateRequest;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.ConfigUpdateSuccess;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Component;\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class ConfigUpdateHandler implements EventHandler<ConfigUpdateRequest> {", "originalCommit": "2fab989c6900b089f978ed980460ffdc1a0eadc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MjAwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r453042000", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-10T19:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMTQ4Mg=="}], "type": "inlineReview"}, {"oid": "8e264b664ac16d16eea358a4a791153b870a4e92", "url": "https://github.com/hortonworks/cloudbreak/commit/8e264b664ac16d16eea358a4a791153b870a4e92", "message": "CB-6364: Create CB core api and flow which updates salt config\n\nThis commit adds support for a flow and api call that updates\nthe salt config on a cluster and then runs the highstate to\napply the config.  Primarily this is to allow for the DNS\nserver IPs to be updated when they change with a FreeIPA node\nchange.  Since those IPs are pulled from the FreeIPA service\ndynamically when a salt config is created it was felt that a\ngeneral salt config update flow and api call would allow for\nany change the affects the salt config to be updated and\nconfigured on a cluster.", "committedDate": "2020-07-10T19:35:46Z", "type": "forcePushed"}, {"oid": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "url": "https://github.com/hortonworks/cloudbreak/commit/e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "message": "CB-6364: Create CB core api and flow which updates salt config\n\nThis commit adds support for a flow and api call that updates\nthe salt config on a cluster and then runs the highstate to\napply the config.  Primarily this is to allow for the DNS\nserver IPs to be updated when they change with a FreeIPA node\nchange.  Since those IPs are pulled from the FreeIPA service\ndynamically when a salt config is created it was felt that a\ngeneral salt config update flow and api call would allow for\nany change the affects the salt config to be updated and\nconfigured on a cluster.", "committedDate": "2020-07-10T21:17:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0ODQzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454148434", "bodyText": "import reordering doesn't seem necessary", "author": "lacikaaa", "createdAt": "2020-07-14T07:08:28Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java", "diffHunk": "@@ -101,6 +75,29 @@\n import com.sequenceiq.cloudbreak.util.StackUtil;\n import com.sequenceiq.common.api.tag.model.Tags;\n import com.sequenceiq.common.api.telemetry.model.Telemetry;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.CollectionUtils;", "originalCommit": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5ODkwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454598907", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-14T19:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0ODQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0OTMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454149322", "bodyText": "should be @Configuration", "author": "lacikaaa", "createdAt": "2020-07-14T07:10:26Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/PillarConfigUpdateActions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.PillarConfigurationUpdateEvent.PILLAR_CONFIG_UPDATE_FINALIZE_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.AbstractClusterAction;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.ClusterViewContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateRequest;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateSuccess;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationState;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.AbstractStackFailureAction;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.StackFailureContext;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackFailureEvent;\n+import java.util.Map;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.statemachine.action.Action;\n+import org.springframework.stereotype.Component;\n+\n+@Component", "originalCommit": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTIwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454599209", "bodyText": "Changed", "author": "wonderslug", "createdAt": "2020-07-14T19:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0OTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0OTg1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454149859", "bodyText": "log would be nice here", "author": "lacikaaa", "createdAt": "2020-07-14T07:11:32Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/PillarConfigUpdateActions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.PillarConfigurationUpdateEvent.PILLAR_CONFIG_UPDATE_FINALIZE_EVENT;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.AbstractClusterAction;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.ClusterViewContext;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateRequest;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateSuccess;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationState;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.AbstractStackFailureAction;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.StackFailureContext;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackFailureEvent;\n+import java.util.Map;\n+import javax.inject.Inject;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.statemachine.action.Action;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class PillarConfigUpdateActions {\n+\n+    @Inject\n+    private PillarConfigUpdateService pillarConfigUpdateService;\n+\n+    @Bean(name = \"PILLAR_CONFIG_UPDATE_START_STATE\")\n+    public Action<?, ?> configUpdateStartAction() {\n+        return new AbstractClusterAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(ClusterViewContext context, StackEvent payload,\n+                Map<Object, Object> variables) {\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(ClusterViewContext context) {\n+                return new PillarConfigUpdateRequest(context.getStack().getId());\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"PILLAR_CONFIG_UPDATE_FINISHED_STATE\")\n+    public Action<?, ?> configUpdateFinishedAction() {\n+        return new AbstractClusterAction<>(PillarConfigUpdateSuccess.class) {\n+            @Override\n+            protected void doExecute(ClusterViewContext context, PillarConfigUpdateSuccess payload,\n+                Map<Object, Object> variables) {\n+                pillarConfigUpdateService.configUpdateFinished(context.getStack());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(ClusterViewContext context) {\n+                return new StackEvent(PILLAR_CONFIG_UPDATE_FINALIZE_EVENT.event(), context.getStackId());\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"PILLAR_CONFIG_UPDATE_FAILED_STATE\")\n+    public Action<?, ?> configUpdateFailedAction() {\n+        return new AbstractStackFailureAction<ClusterCreationState, ClusterCreationEvent>() {\n+            @Override\n+            protected void doExecute(StackFailureContext context, StackFailureEvent payload,\n+                Map<Object, Object> variables) {\n+                pillarConfigUpdateService", "originalCommit": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTEwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454599100", "bodyText": "Added", "author": "wonderslug", "createdAt": "2020-07-14T19:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0OTg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1NzY2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454157666", "bodyText": "it's not ideal to throw any exception in the failure handling part", "author": "lacikaaa", "createdAt": "2020-07-14T07:27:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/PillarConfigUpdateService.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_PILLAR_CONFIG_UPDATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_PILLAR_CONFIG_UPDATE_FINISHED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_PILLAR_CONFIG_UPDATE_STARTED;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.bootstrap.service.host.ClusterHostServiceRunner;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.provision.ClusterCreationService;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import java.util.List;\n+import javax.inject.Inject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class PillarConfigUpdateService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PillarConfigUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    @Inject\n+    private ClusterCreationService clusterCreationService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private ClusterHostServiceRunner clusterHostServiceRunner;\n+\n+    public void doConfigUpdate(Long stackId) {\n+        stackUpdater.updateStackStatus(stackId, DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService\n+            .fireEventAndLog(stackId, UPDATE_IN_PROGRESS.name(),\n+                CLUSTER_PILLAR_CONFIG_UPDATE_STARTED);\n+        Stack stack = stackService.getByIdWithClusterInTransaction(stackId);\n+        clusterHostServiceRunner.updateClusterConfigs(stack, stack.getCluster(), List.of());\n+    }\n+\n+    public void configUpdateFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE,\n+                    \"Config update finished.\");\n+            });\n+            flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(),\n+                CLUSTER_PILLAR_CONFIG_UPDATE_FINISHED);\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleConfigUpdateFailure(StackView stackView, Exception exception) {\n+        try {\n+            if (stackView.getClusterView() != null) {\n+                String errorMessage = clusterCreationService\n+                    .getErrorMessageFromException(exception);\n+                transactionService.required(() -> {\n+                    clusterService\n+                        .updateClusterStatusByStackId(stackView.getId(), UPDATE_FAILED,\n+                            errorMessage);\n+                    stackUpdater\n+                        .updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE);\n+                });\n+                flowMessageService.fireEventAndLog(stackView.getId(), UPDATE_FAILED.name(),\n+                    CLUSTER_PILLAR_CONFIG_UPDATE_FAILED, errorMessage);\n+            } else {\n+                LOGGER.info(\"Cluster was null. Flow action was not required.\");\n+            }\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);", "originalCommit": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5ODk5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454598990", "bodyText": "Fixed", "author": "wonderslug", "createdAt": "2020-07-14T19:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1NzY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1ODI1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454158253", "bodyText": "please add a log line here", "author": "lacikaaa", "createdAt": "2020-07-14T07:28:08Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/config/update/handler/PillarConfigUpdateHandler.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.handler;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.PillarConfigUpdateService;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateFailed;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateRequest;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.config.update.event.PillarConfigUpdateSuccess;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+import javax.inject.Inject;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class PillarConfigUpdateHandler extends ExceptionCatcherEventHandler<PillarConfigUpdateRequest> {\n+\n+    @Inject\n+    private PillarConfigUpdateService pillarConfigUpdateService;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(PillarConfigUpdateRequest.class);\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e) {\n+        return new PillarConfigUpdateFailed(resourceId, e);\n+    }\n+\n+    @Override\n+    protected void doAccept(HandlerEvent event) {\n+        PillarConfigUpdateRequest request = event.getData();\n+        Selectable response;\n+        try {\n+            pillarConfigUpdateService.doConfigUpdate(request.getResourceId());\n+            response = new PillarConfigUpdateSuccess(request.getResourceId());\n+        } catch (Exception e) {\n+            response = new PillarConfigUpdateFailed(request.getResourceId(), e);", "originalCommit": "e6edcea4f42a9936062c01f4971ee6cc5e3f8d1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTA2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454599061", "bodyText": "Added", "author": "wonderslug", "createdAt": "2020-07-14T19:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1ODI1Mw=="}], "type": "inlineReview"}, {"oid": "11099f39195d0193fa3939ad413848df195888a5", "url": "https://github.com/hortonworks/cloudbreak/commit/11099f39195d0193fa3939ad413848df195888a5", "message": "CB-6364: Create CB core api and flow which updates salt config\n\nThis commit adds support for a flow and api call that updates\nthe salt config on a cluster and then runs the highstate to\napply the config.  Primarily this is to allow for the DNS\nserver IPs to be updated when they change with a FreeIPA node\nchange.  Since those IPs are pulled from the FreeIPA service\ndynamically when a salt config is created it was felt that a\ngeneral salt config update flow and api call would allow for\nany change the affects the salt config to be updated and\nconfigured on a cluster.", "committedDate": "2020-07-14T19:40:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2ODE1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r454868151", "bodyText": "please add MDCBuilder.buildMdcContext(stack); after this line. I missed it in case of updateSalt, I'm going to add it", "author": "lacikaaa", "createdAt": "2020-07-15T08:05:40Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/ClusterCommonService.java", "diffHunk": "@@ -258,4 +258,9 @@ public FlowIdentifier updateSalt(NameOrCrn nameOrCrn, Long workspaceId) {\n         Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n         return clusterOperationService.updateSalt(stack);\n     }\n+\n+    public FlowIdentifier updatePillarConfiguration(NameOrCrn nameOrCrn, Long workspaceId) {\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);", "originalCommit": "11099f39195d0193fa3939ad413848df195888a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNjIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8515#discussion_r455316238", "bodyText": "Added", "author": "wonderslug", "createdAt": "2020-07-15T20:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2ODE1MQ=="}], "type": "inlineReview"}, {"oid": "b2585833e86a0c5c3ad0d4ecf59c42b7db3f91e8", "url": "https://github.com/hortonworks/cloudbreak/commit/b2585833e86a0c5c3ad0d4ecf59c42b7db3f91e8", "message": "CB-6364: Create CB core api and flow which updates salt config\n\nThis commit adds support for a flow and api call that updates\nthe salt config on a cluster and then runs the highstate to\napply the config.  Primarily this is to allow for the DNS\nserver IPs to be updated when they change with a FreeIPA node\nchange.  Since those IPs are pulled from the FreeIPA service\ndynamically when a salt config is created it was felt that a\ngeneral salt config update flow and api call would allow for\nany change the affects the salt config to be updated and\nconfigured on a cluster.", "committedDate": "2020-07-15T20:13:19Z", "type": "commit"}, {"oid": "b2585833e86a0c5c3ad0d4ecf59c42b7db3f91e8", "url": "https://github.com/hortonworks/cloudbreak/commit/b2585833e86a0c5c3ad0d4ecf59c42b7db3f91e8", "message": "CB-6364: Create CB core api and flow which updates salt config\n\nThis commit adds support for a flow and api call that updates\nthe salt config on a cluster and then runs the highstate to\napply the config.  Primarily this is to allow for the DNS\nserver IPs to be updated when they change with a FreeIPA node\nchange.  Since those IPs are pulled from the FreeIPA service\ndynamically when a salt config is created it was felt that a\ngeneral salt config update flow and api call would allow for\nany change the affects the salt config to be updated and\nconfigured on a cluster.", "committedDate": "2020-07-15T20:13:19Z", "type": "forcePushed"}]}