{"pr_number": 7400, "pr_title": "CDPCP-1113 Determine environment access using rights", "pr_createdAt": "2020-02-26T20:58:36Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7400", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMjUwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385032501", "bodyText": "could you move this to a method called sth like addEligibleUserToInnternalGroup so we can drop  the comment", "author": "lacikaaa", "createdAt": "2020-02-27T10:17:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -129,95 +133,38 @@ private WorkloadCredential getCredentials(String userCrn, Optional<String> reque\n         return new WorkloadCredential(hashedPassword, keys, expirationInstant);\n     }\n \n-    private boolean isEnvironmentUser(String enviromentCrn, GetRightsResponse rightsResponse) {\n-\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-                // admins are also users\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\") ||\n-                (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentUser\"))) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private boolean isEnvironmentAdmin(String enviromentCrn, GetRightsResponse rightsResponse) {\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n     @SuppressWarnings(\"ParameterNumber\")\n     private void handleUser(UmsUsersState.Builder umsUsersStateBuilder, UsersState.Builder usersStateBuilder, Map<String, FmsGroup> crnToFmsGroup,\n-                            String actorCrn, String memberCrn, FmsUser fmsUser, String environmentCrn, Optional<String> requestId) {\n-        try {\n-            GetRightsResponse rightsResponse = grpcUmsClient.getRightsForUser(actorCrn, memberCrn, environmentCrn, requestId);\n-            if (isEnvironmentUser(environmentCrn, rightsResponse)) {\n-                usersStateBuilder.addUser(fmsUser);\n-                rightsResponse.getGroupCrnList().stream().forEach(gcrn -> {\n-                    FmsGroup group = crnToFmsGroup.get(gcrn);\n-                    // If the group is null, then there has been a group membership change after we started the sync\n-                    // the group and group membership will be updated on the next sync\n-                    if (group != null) {\n-                        usersStateBuilder.addMemberToGroup(group.getName(), fmsUser.getName());\n-                    }\n-                });\n-\n-                // Since this user is eligible, add this user to internal group\n-                usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, fmsUser.getName());\n+                            String memberCrn, FmsUser fmsUser, EnvironmentAccessRights environmentAccessRights, Optional<String> requestId) {\n+        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n+            usersStateBuilder.addUser(fmsUser);\n+            String username = fmsUser.getName();\n+            String accountId = Crn.safeFromString(memberCrn).getAccountId();\n+            grpcUmsClient.listGroupsForMember(IAM_INTERNAL_ACTOR_CRN, accountId, memberCrn, requestId).forEach(gcrn -> {\n+                FmsGroup group = crnToFmsGroup.get(gcrn);\n+                // If the group is null, then there has been a group membership change after we started the sync\n+                // the group and group membership will be updated on the next sync\n+                if (group != null) {\n+                    usersStateBuilder.addMemberToGroup(group.getName(), username);\n+                }\n+            });\n \n-                List<String> workloadAdministrationGroupNames = rightsResponse.getWorkloadAdministrationGroupNameList();\n-                LOGGER.debug(\"workloadAdministrationGroupNameList = {}\", workloadAdministrationGroupNames);\n-                workloadAdministrationGroupNames.forEach(groupName -> {\n-                    usersStateBuilder.addGroup(nameToGroup(groupName));\n-                    usersStateBuilder.addMemberToGroup(groupName, fmsUser.getName());\n-                });\n+            // Since this user is eligible, add this user to internal group\n+            usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, username);", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMDY5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385410697", "bodyText": "moved", "author": "handavid", "createdAt": "2020-02-27T22:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNDM4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385034382", "bodyText": "I think you can drop this command or move this to a method with a self explaining name", "author": "lacikaaa", "createdAt": "2020-02-27T10:20:54Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -129,95 +133,38 @@ private WorkloadCredential getCredentials(String userCrn, Optional<String> reque\n         return new WorkloadCredential(hashedPassword, keys, expirationInstant);\n     }\n \n-    private boolean isEnvironmentUser(String enviromentCrn, GetRightsResponse rightsResponse) {\n-\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-                // admins are also users\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\") ||\n-                (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentUser\"))) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private boolean isEnvironmentAdmin(String enviromentCrn, GetRightsResponse rightsResponse) {\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n     @SuppressWarnings(\"ParameterNumber\")\n     private void handleUser(UmsUsersState.Builder umsUsersStateBuilder, UsersState.Builder usersStateBuilder, Map<String, FmsGroup> crnToFmsGroup,\n-                            String actorCrn, String memberCrn, FmsUser fmsUser, String environmentCrn, Optional<String> requestId) {\n-        try {\n-            GetRightsResponse rightsResponse = grpcUmsClient.getRightsForUser(actorCrn, memberCrn, environmentCrn, requestId);\n-            if (isEnvironmentUser(environmentCrn, rightsResponse)) {\n-                usersStateBuilder.addUser(fmsUser);\n-                rightsResponse.getGroupCrnList().stream().forEach(gcrn -> {\n-                    FmsGroup group = crnToFmsGroup.get(gcrn);\n-                    // If the group is null, then there has been a group membership change after we started the sync\n-                    // the group and group membership will be updated on the next sync\n-                    if (group != null) {\n-                        usersStateBuilder.addMemberToGroup(group.getName(), fmsUser.getName());\n-                    }\n-                });\n-\n-                // Since this user is eligible, add this user to internal group\n-                usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, fmsUser.getName());\n+                            String memberCrn, FmsUser fmsUser, EnvironmentAccessRights environmentAccessRights, Optional<String> requestId) {\n+        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n+            usersStateBuilder.addUser(fmsUser);\n+            String username = fmsUser.getName();\n+            String accountId = Crn.safeFromString(memberCrn).getAccountId();\n+            grpcUmsClient.listGroupsForMember(IAM_INTERNAL_ACTOR_CRN, accountId, memberCrn, requestId).forEach(gcrn -> {\n+                FmsGroup group = crnToFmsGroup.get(gcrn);\n+                // If the group is null, then there has been a group membership change after we started the sync\n+                // the group and group membership will be updated on the next sync\n+                if (group != null) {\n+                    usersStateBuilder.addMemberToGroup(group.getName(), username);\n+                }\n+            });\n \n-                List<String> workloadAdministrationGroupNames = rightsResponse.getWorkloadAdministrationGroupNameList();\n-                LOGGER.debug(\"workloadAdministrationGroupNameList = {}\", workloadAdministrationGroupNames);\n-                workloadAdministrationGroupNames.forEach(groupName -> {\n-                    usersStateBuilder.addGroup(nameToGroup(groupName));\n-                    usersStateBuilder.addMemberToGroup(groupName, fmsUser.getName());\n-                });\n+            // Since this user is eligible, add this user to internal group\n+            usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n \n-                if (isEnvironmentAdmin(environmentCrn, rightsResponse)) {\n-                    // TODO: introduce a flag for adding admin\n-                    usersStateBuilder.addMemberToGroup(\"admins\", fmsUser.getName());\n-                }\n+            UserManagementProto.ListWorkloadAdministrationGroupsForMemberResponse workloadAdministrationGroups =\n+                    grpcUmsClient.listWorkloadAdministrationGroupsForMember(IAM_INTERNAL_ACTOR_CRN, memberCrn, requestId);\n+            workloadAdministrationGroups.getWorkloadAdministrationGroupNameList().forEach(groupName -> {\n+                usersStateBuilder.addGroup(nameToGroup(groupName));\n+                usersStateBuilder.addMemberToGroup(groupName, username);\n+            });\n \n-                // get credentials\n-                umsUsersStateBuilder.addWorkloadCredentials(fmsUser.getName(), getCredentials(memberCrn, requestId));\n-            }\n-        } catch (StatusRuntimeException e) {\n-            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n-            // retrieved the list of users/machineUsers from the UMS. Treat these users as if\n-            // they do not have the right to access this environment and belong to no groups.\n-            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {\n-                LOGGER.warn(\"CRN {} not found in UMS. Treating as if CRN has no rights to environment {}: {}\",\n-                        memberCrn, environmentCrn, e.getLocalizedMessage());\n-            } else {\n-                throw e;\n+            if (environmentAccessRights.hasAdminFreeIPARight()) {\n+                usersStateBuilder.addMemberToGroup(ADMIN_FREEIPA_GROUP, username);\n             }\n+\n+            // get credentials", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMDc2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385410762", "bodyText": "removed", "author": "handavid", "createdAt": "2020-02-27T22:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385037156", "bodyText": "I would annotate this class with @Service or @Component and inject it into the proper class or make it static (maybe @Service is better because you can write mockito tests for it), instead of instantiate it every time", "author": "horadla23", "createdAt": "2020-02-27T10:25:53Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4MDc0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385180741", "bodyText": "I instantiate this each time I sync an environment so I can re-use the resource-dependent right check \"environments/accessEnvironment\".\nIf you prefer, I can try to swap this out for a Prototype bean and BeanFactory.", "author": "handavid", "createdAt": "2020-02-27T15:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwMzE1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385203150", "bodyText": "If @keyki or @lacikaaa thinks it is ok, then you can leave this as-is, but you can reuse the result of hasAccess anywhere in UmsUsersStateProvider class as a local variable or parameter", "author": "horadla23", "createdAt": "2020-02-27T16:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNzIyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385207226", "bodyText": "I'm not re-using the result because I'm calling hasAccess only once for each user and machineUser.", "author": "handavid", "createdAt": "2020-02-27T16:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxMjY3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385212675", "bodyText": "this should be ok", "author": "horadla23", "createdAt": "2020-02-27T16:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTA0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385039048", "bodyText": "Since this is Freeipa service, then I would create internal CRN for freeipa service (or environment because freeipa service is not a public service afaik), not for IAM service", "author": "horadla23", "createdAt": "2020-02-27T10:29:13Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentAccessChecker.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4MTY5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385181695", "bodyText": "The internal CRN needs to specify IAM.\nSee https://github.com/hortonworks/cloudbreak/blob/master/auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/security/InternalCrnBuilder.java#L12-L15\nSee https://github.infra.cloudera.com/thunderhead/thunderhead/blob/master/services/libs/protocols/src/main/java/com/cloudera/thunderhead/service/common/crn/Crns.java#L712-L724", "author": "handavid", "createdAt": "2020-02-27T15:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385039573", "bodyText": "please check checkRight method and add caching to this method similarly", "author": "horadla23", "createdAt": "2020-02-27T10:30:10Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -329,6 +348,22 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4NDIyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385184224", "bodyText": "Caching is not a good idea for my use case. Here's a bad scenario that may occur with caching.\n\nUser access is removed\nFMS checks event generation ids, sees that they have changed, and runs user sync\nuser sync gets the cached value for hasRights that still grants user access to environment\nFMS saves the event generation ids for successful sync and thinks that all users are up-to-date\nIn this case, a user may retain access to an environment that they should not have access to.", "author": "handavid", "createdAt": "2020-02-27T15:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwMTExMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385201111", "bodyText": "Our caches have small expiration time (1 sec afaik), so if permissions change, then it will turn out quickly and it prevents cb to overload network with ums calls, that is the reason why we have caches. If you think 1 sec expiration time still can cause issue, then we can skip cache here, but we had performance issues with UMS on mow-dev and/or mow-int.", "author": "horadla23", "createdAt": "2020-02-27T15:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxMjE3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385212171", "bodyText": "I think the performance issues you had/have w/ checkRight is because the authorization layer is down at the database access level. From my reading, each database access, either read or write, requires a checkRight call.\nThe use-case here is different from protecting database access. Load here is determined by the application layer. I'm explicitly calling hasRights once per user/machineUser per user sync. The problem with caching isn't the expiration time, but that the rights check has been decoupled from other activities in the UMS or AuthorizationService. Decoupling can result in incorrect behavior and lead to a security hole. I think this is especially dangerous because the caching is invisible to the caller of hasRights and changes to the caching behavior may be made behind the scenes without understanding the callers.", "author": "handavid", "createdAt": "2020-02-27T16:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxNTg4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385215889", "bodyText": "I see your point, alright, then we should go with this.", "author": "horadla23", "createdAt": "2020-02-27T16:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385040293", "bodyText": "we are currently not making call to UMS in case of internal CRN because right now everything allowed witn internalCRN afaik, there is an if (InternalCrnBuilder.isInternalCrn(actorCrn)) in checkRight call for it, I think we should use that here also", "author": "horadla23", "createdAt": "2020-02-27T10:31:22Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -329,6 +348,22 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {\n+        try (ManagedChannelWrapper channelWrapper = makeWrapper()) {\n+            AuthorizationClient client = new AuthorizationClient(channelWrapper.getChannel(), actorCrn);\n+            return client.hasRights(requestId.orElse(UUID.randomUUID().toString()), memberCrn, rightChecks);", "originalCommit": "757d41b2063bb45434ab9ee948c59433f7712e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4NTMwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385185304", "bodyText": "Also, many of the UMS calls fail with internal CRN.", "author": "keyki", "createdAt": "2020-02-27T15:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNjM4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385206387", "bodyText": "Not to mention that we are overloading network with internalCrn requests to UMS, while we know that everything is allowed with internalCrn", "author": "horadla23", "createdAt": "2020-02-27T16:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxNDYyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385214620", "bodyText": "I just looked at the checkRights code and it's wrong. You should check if the InternalCrnBuilder.isInternalCrn(userCrn) instead of actorCrn. I think that the only caller right now calls checkRight with actorCrn == userCrn, so we've been lucky so far.\n@keyki Can you give an example of a UMS call that fails with the internal CRN? Do you mean internal CRN as the actor (grpc context) or as the member (part of request)? I'd like to understand the issue because it doesn't make sense to me. Could it be that you are creating internal CRNs with a service other than IAM?", "author": "handavid", "createdAt": "2020-02-27T16:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxNTkwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385215906", "bodyText": "Not to mention that we are overloading network with internalCrn requests to UMS, while we know that everything is allowed with internalCrn\n\nI'm setting the actorCrn (grpc context) to internal Crn, but requesting whether the memberCrn has rights. I should never repeat a request within a user sync operation.", "author": "handavid", "createdAt": "2020-02-27T16:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw=="}], "type": "inlineReview"}, {"oid": "86094cd572d83921733de093049e3fc939cca0e3", "url": "https://github.com/hortonworks/cloudbreak/commit/86094cd572d83921733de093049e3fc939cca0e3", "message": "CDPCP-1113. Update UMS for retrieving WAGs for a member\n\nThe usermanagementservice.proto has been updated to include a new\nrequest ListWorkloadAdministrationGroupsForMember. This request\nreturns the workload administration groups for the specified member\n(i.e., user or machine user) and must be called by the internal actor.\n\nThe Grpc and MockUserManagementService have been updated to match.", "committedDate": "2020-02-27T18:43:55Z", "type": "commit"}, {"oid": "dba5d33ded6214d6983c811ff5aa96b119c09363", "url": "https://github.com/hortonworks/cloudbreak/commit/dba5d33ded6214d6983c811ff5aa96b119c09363", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN.", "committedDate": "2020-02-27T22:31:45Z", "type": "forcePushed"}, {"oid": "e89d2294a7f6ceca349be2b4231657cb579cf15c", "url": "https://github.com/hortonworks/cloudbreak/commit/e89d2294a7f6ceca349be2b4231657cb579cf15c", "message": "CDPCP-1113. Sync users based on accessEnvironment right\n\nUsers are now granted access to an environment based on the\nenvironments/accessEnvironment right instead of the EnvironmentUser,\nEnvironmentAdmin, or PowerUser role.\n\nAdditionally, users are now added to the ipa \"admins\" group if they\nhave the environments/adminFreeIPA right. This right is not granted\nto the EnvironmentAdmin role, so EnvironmentAdmins will be removed\nfrom the \"admins\" group. PowerUsers will still have this right.\n\nAs part of this change, a hasRights method is added to the GrpcUmsClient.\nUmsUsersStateProvider has been modified to use the hasRights method and\ngetWorkloadAdministrationGroups instead of getRights.", "committedDate": "2020-02-28T03:54:19Z", "type": "commit"}, {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b", "url": "https://github.com/hortonworks/cloudbreak/commit/cd180ef48452078c772f0d1f9f38279fc8c2347b", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN.", "committedDate": "2020-02-28T03:54:19Z", "type": "commit"}, {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b", "url": "https://github.com/hortonworks/cloudbreak/commit/cd180ef48452078c772f0d1f9f38279fc8c2347b", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN.", "committedDate": "2020-02-28T03:54:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzQ0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385957446", "bodyText": "So I prefer not to do the right check here, in the grpc ums client. Let's not optimize this right now. I think that the right way to optimize this is to have distributed policies that have ttl on them. The policy for an internal actor can be \"forever\" so that the clients will never go to the authorization service. But I do not want to copy the authorization checks all over the place.", "author": "giladwolff", "createdAt": "2020-02-28T22:48:00Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -347,6 +350,33 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {\n+        LOGGER.info(\"Checking whether member [] has rights [{}]\",\n+                memberCrn,\n+                rightChecks.stream().map(AuthorizationProto.RightCheck::getRight).collect(Collectors.toList()));\n+        if (InternalCrnBuilder.isInternalCrn(memberCrn)) {\n+            LOGGER.info(\"InternalCrn has all rights\");\n+            Boolean[] values = new Boolean[rightChecks.size()];\n+            Arrays.fill(values, Boolean.TRUE);\n+            return Arrays.asList(values);\n+        }\n+        try (ManagedChannelWrapper channelWrapper = makeWrapper()) {\n+            AuthorizationClient client = new AuthorizationClient(channelWrapper.getChannel(), actorCrn);\n+            List<Boolean> retVal = client.hasRights(requestId.orElse(UUID.randomUUID().toString()), memberCrn, rightChecks);\n+            LOGGER.info(\"member {} has rights {}\", memberCrn, retVal);\n+            return retVal;\n+        }\n+    }\n+", "originalCommit": "e89d2294a7f6ceca349be2b4231657cb579cf15c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385958322", "bodyText": "So this is fine for now, but maybe add the jira number tracking deletion of users from the FreeIPA here? Or is there an explicit check for the existence of users somewhere else?", "author": "giladwolff", "createdAt": "2020-02-28T22:51:14Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentAccessChecker.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    private static final String ACCESS_ENVIRONMENT_RIGHT = RightUtils.getRight(AuthorizationResource.ENVIRONMENT, ResourceAction.ACCESS_ENVIRONMENT);\n+\n+    private static final String ADMIN_FREEIPA_RIGHT = RightUtils.getRight(AuthorizationResource.ENVIRONMENT, ResourceAction.ADMIN_FREEIPA);\n+\n+    private final GrpcUmsClient grpcUmsClient;\n+\n+    private final String environmentCrn;\n+\n+    private final List<AuthorizationProto.RightCheck> rightChecks;\n+\n+    /**\n+     * Creates an EnvironmentAccessChecker instance.\n+     * @param grpcUmsClient a GrpcUmsClient\n+     * @param environmentCrn a environment CRN\n+     * @throws NullPointerException if the environmentCrn is null\n+     * @throws CrnParseException    if the environmentCrn does not match the CRN pattern or cannot be parsed\n+     */\n+    public EnvironmentAccessChecker(GrpcUmsClient grpcUmsClient, String environmentCrn) {\n+        this.grpcUmsClient = requireNonNull(grpcUmsClient, \"grpcUmsClient is null\");\n+        Crn.safeFromString(environmentCrn);\n+        this.environmentCrn = environmentCrn;\n+\n+        this.rightChecks = List.of(\n+                AuthorizationProto.RightCheck.newBuilder()\n+                        .setRight(ACCESS_ENVIRONMENT_RIGHT)\n+                        .setResource(environmentCrn)\n+                        .build(),\n+                AuthorizationProto.RightCheck.newBuilder()\n+                        .setRight(ADMIN_FREEIPA_RIGHT)\n+                        .build());\n+    }\n+\n+    public EnvironmentAccessRights hasAccess(String memberCrn, Optional<String> requestId) {\n+        requireNonNull(memberCrn, \"memberCrn is null\");\n+        requireNonNull(requestId, \"requestId is null\");\n+\n+        try {\n+            List<Boolean> hasRights = grpcUmsClient.hasRights(IAM_INTERNAL_ACTOR_CRN, memberCrn, rightChecks, requestId);\n+            return new EnvironmentAccessRights(hasRights.get(0), hasRights.get(1));\n+        } catch (StatusRuntimeException e) {\n+            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n+            // retrieved the list of users/machineUsers from the UMS. Treat these users as if\n+            // they do not have the right to access this environment and belong to no groups.\n+            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {", "originalCommit": "e89d2294a7f6ceca349be2b4231657cb579cf15c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}