{"pr_number": 8595, "pr_title": "CB-7923 MetricEvaluator should send alerts in batch", "pr_createdAt": "2020-07-20T13:05:29Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8595", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTY1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457851650", "bodyText": "The log message could be enhanced and contain the name of the alert/scaling action pair for the sake of easier debugging in the future.", "author": "biharitomi", "createdAt": "2020-07-21T05:49:35Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));\n+        }\n     }\n \n     private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+            loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+            rejectedThreadService.remove(cluster.getId());\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+        } else {\n+            LOGGER.info(\"No scaling activity required\");", "originalCommit": "f6dc8c71166753b383661cd51cfeddd52704b03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NDcxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457854712", "bodyText": "this information is available in MDC context. But if it is not enough, I can update the message", "author": "topolyai5", "createdAt": "2020-07-21T05:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457852437", "bodyText": "Do we really want to trigger multiple scaling actions at the same time?", "author": "biharitomi", "createdAt": "2020-07-21T05:51:44Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "originalCommit": "f6dc8c71166753b383661cd51cfeddd52704b03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NDk2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457854964", "bodyText": "Yes, this is the main problem.", "author": "topolyai5", "createdAt": "2020-07-21T05:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1ODAxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457858012", "bodyText": "Hm, I need more investigation. The second request will be denied because the cluster is under operation.", "author": "topolyai5", "createdAt": "2020-07-21T06:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2NDEzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457864131", "bodyText": "I am not sure about that, triggering multiple scaling on the CB APIs is not so safe. @keyki ?", "author": "biharitomi", "createdAt": "2020-07-21T06:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}], "type": "inlineReview"}, {"oid": "b96f814f54afc0d9c0dea05ee83f870657fac97b", "url": "https://github.com/hortonworks/cloudbreak/commit/b96f814f54afc0d9c0dea05ee83f870657fac97b", "message": "adf", "committedDate": "2020-07-21T11:35:55Z", "type": "forcePushed"}, {"oid": "d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "url": "https://github.com/hortonworks/cloudbreak/commit/d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "message": "CB-7923 MetricEvaluator should send alerts in batch", "committedDate": "2020-07-21T18:45:15Z", "type": "forcePushed"}, {"oid": "8f56659e03c675a34085dea1c72c020898c0e048", "url": "https://github.com/hortonworks/cloudbreak/commit/8f56659e03c675a34085dea1c72c020898c0e048", "message": "CB-7923 MetricEvaluator should send alerts in batch", "committedDate": "2020-07-21T19:52:46Z", "type": "commit"}, {"oid": "8f56659e03c675a34085dea1c72c020898c0e048", "url": "https://github.com/hortonworks/cloudbreak/commit/8f56659e03c675a34085dea1c72c020898c0e048", "message": "CB-7923 MetricEvaluator should send alerts in batch", "committedDate": "2020-07-21T19:52:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDkzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458660937", "bodyText": "pls add some extra logging to this if clause, too", "author": "pdarvasi", "createdAt": "2020-07-22T09:28:50Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {", "originalCommit": "8f56659e03c675a34085dea1c72c020898c0e048", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MTAzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458661032", "bodyText": "pls add some extra logging to this if clause, too", "author": "pdarvasi", "createdAt": "2020-07-22T09:29:00Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {", "originalCommit": "8f56659e03c675a34085dea1c72c020898c0e048", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MjIzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458662231", "bodyText": "pls add some extra logging to this including minSize, maxSize and calculated desiredNodeCount", "author": "pdarvasi", "createdAt": "2020-07-22T09:31:07Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {\n+            return true;\n+        }\n+        LOGGER.info(\"Cluster cannot be scaled for {} min(s)\",\n+                ClusterUtils.TIME_FORMAT.format((double) remainingTime / TimeUtil.MIN_IN_MS));\n+        return false;\n+    }\n+\n+    private long getRemainingCooldownTime(Cluster cluster) {\n+        long coolDown = cluster.getCoolDown();\n+        long lastScalingActivity = cluster.getLastScalingActivity();\n+        return lastScalingActivity == 0L ? 0L : (coolDown * TimeUtil.MIN_IN_MS) - (clock.getCurrentTime() - lastScalingActivity);\n+    }\n+\n+    @VisibleForTesting\n+    protected int getDesiredNodeCount(Cluster cluster, ScalingPolicy policy, int totalNodes) {\n+        int scalingAdjustment = policy.getScalingAdjustment();\n+        int desiredNodeCount;\n+        switch (policy.getAdjustmentType()) {\n+            case NODE_COUNT:\n+                desiredNodeCount = totalNodes + scalingAdjustment;\n+                break;\n+            case PERCENTAGE:\n+                desiredNodeCount = totalNodes\n+                        + (int) (ceil(totalNodes * ((double) scalingAdjustment / ClusterUtils.MAX_CAPACITY)));\n+                break;\n+            case EXACT:\n+                desiredNodeCount = policy.getScalingAdjustment();\n+                break;\n+            default:\n+                desiredNodeCount = totalNodes;\n+        }\n+        int minSize = cluster.getMinSize();\n+        int maxSize = cluster.getMaxSize();\n+        return desiredNodeCount < minSize ? minSize : Math.min(desiredNodeCount, maxSize);", "originalCommit": "8f56659e03c675a34085dea1c72c020898c0e048", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2NTgwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458665802", "bodyText": "Are you sure this won't cause any race conditions? I mean two or more possible subsequent \"true\" answers for isCooldownElapsed..", "author": "pdarvasi", "createdAt": "2020-07-22T09:37:08Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -1,105 +1,38 @@\n package com.sequenceiq.periscope.monitor.handler;\n \n-import static java.lang.Math.ceil;\n+import java.util.List;\n \n import javax.inject.Inject;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n \n-import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n-import com.sequenceiq.periscope.aspects.AmbariRequestLogging;\n import com.sequenceiq.periscope.domain.BaseAlert;\n import com.sequenceiq.periscope.domain.Cluster;\n-import com.sequenceiq.periscope.domain.ScalingPolicy;\n import com.sequenceiq.periscope.log.MDCBuilder;\n+import com.sequenceiq.periscope.monitor.ScalingHandlerUtil;\n import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n-import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n import com.sequenceiq.periscope.service.ClusterService;\n-import com.sequenceiq.periscope.service.RejectedThreadService;\n-import com.sequenceiq.periscope.utils.ClusterUtils;\n-import com.sequenceiq.periscope.utils.TimeUtil;\n \n @Component\n public class ScalingHandler implements ApplicationListener<ScalingEvent> {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandler.class);\n-\n-    @Inject\n-    private LoggedExecutorService loggedExecutorService;\n-\n     @Inject\n     private ClusterService clusterService;\n \n     @Inject\n-    private ApplicationContext applicationContext;\n-\n-    @Inject\n-    private RejectedThreadService rejectedThreadService;\n-\n-    @Inject\n-    private AmbariRequestLogging ambariRequestLogging;\n-\n-    @Inject\n-    private CloudbreakClient cloudbreakClient;\n+    private ScalingHandlerUtil scalingHandlerUtil;\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        List<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n-    }\n-\n-    private void scale(Cluster cluster, ScalingPolicy policy) {\n-        long remainingTime = getRemainingCooldownTime(cluster);\n-        if (remainingTime <= 0) {\n-            int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n-            int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n-            if (totalNodes != desiredNodeCount) {\n-                Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n-                loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n-                rejectedThreadService.remove(cluster.getId());\n-                cluster.setLastScalingActivityCurrent();\n-                clusterService.save(cluster);\n-            } else {\n-                LOGGER.info(\"No scaling activity required\");\n+        alerts.forEach(alert -> {\n+            if (scalingHandlerUtil.isCooldownElapsed(cluster)) {", "originalCommit": "8f56659e03c675a34085dea1c72c020898c0e048", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}