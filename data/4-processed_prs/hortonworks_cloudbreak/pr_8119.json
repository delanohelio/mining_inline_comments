{"pr_number": 8119, "pr_title": "CDPCP-2094. Add API to retrieve user sync state for an environment", "pr_createdAt": "2020-05-20T22:49:54Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8119", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyMDc3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428520772", "bodyText": "missing @JsonIgnoreProperties(ignoreUnknown = true)", "author": "lacikaaa", "createdAt": "2020-05-21T08:36:44Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/model/EnvironmentUserSyncState.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.sequenceiq.freeipa.api.v1.freeipa.user.model;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.doc.UserModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"EnvironmentUserSyncV1State\")\n+public class EnvironmentUserSyncState {", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyMTM2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428521366", "bodyText": "missing @NotNull", "author": "lacikaaa", "createdAt": "2020-05-21T08:38:01Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/model/EnvironmentUserSyncState.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.sequenceiq.freeipa.api.v1.freeipa.user.model;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.doc.UserModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"EnvironmentUserSyncV1State\")\n+public class EnvironmentUserSyncState {\n+    @ApiModelProperty(value = UserModelDescriptions.USERSYNC_STATE, required = true)\n+    private UserSyncState state;", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyMzk4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428523988", "bodyText": "can we rename these to be a bit more obvious?\nlike: IN_SYNC -> UP_TO_DATE\nSYNCING -> SYNC_IN_PROGRESS\nI'm open to other values, but IN_SYNC is a bit ambiguous for me.", "author": "lacikaaa", "createdAt": "2020-05-21T08:43:11Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/model/UserSyncState.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.sequenceiq.freeipa.api.v1.freeipa.user.model;\n+\n+public enum UserSyncState {\n+    IN_SYNC,\n+    STALE,\n+    SYNCING", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNjYwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428526609", "bodyText": "@NotNull -> @NotEmpty", "author": "lacikaaa", "createdAt": "2020-05-21T08:48:35Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -109,6 +114,14 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.ENVIRONMENT_READ)\n+    public EnvironmentUserSyncState getUserSyncState(@NotNull String environmentCrn) {", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNjk2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428526968", "bodyText": "actually ControllerLogContextAspects should log this", "author": "lacikaaa", "createdAt": "2020-05-21T08:49:26Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -109,6 +114,14 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.ENVIRONMENT_READ)\n+    public EnvironmentUserSyncState getUserSyncState(@NotNull String environmentCrn) {\n+        LOGGER.debug(\"getUserSyncState() requested for environment '{}'\", environmentCrn);", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428529212", "bodyText": "we should pass the accountId here from ThreadBasedUserCrnProvider", "author": "lacikaaa", "createdAt": "2020-05-21T08:54:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -109,6 +114,14 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.ENVIRONMENT_READ)\n+    public EnvironmentUserSyncState getUserSyncState(@NotNull String environmentCrn) {\n+        LOGGER.debug(\"getUserSyncState() requested for environment '{}'\", environmentCrn);\n+\n+        return environmentUserSyncStateCalculator.calculateEnvironmentUserSyncState(Crn.safeFromString(environmentCrn));", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzNDExMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428934110", "bodyText": "I disagree with your suggestion here. I've updated the PR to match current behavior of the other APIs, but will start an email discussion about the API usage of the actor crn since this issue is larger than this PR.", "author": "handavid", "createdAt": "2020-05-21T21:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA5MjYzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429092638", "bodyText": "sure, @horadla23 knows this stuff better", "author": "lacikaaa", "createdAt": "2020-05-22T07:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA5NjAxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429096013", "bodyText": "@handavid as i mentioned in my mail, with @TenantAwareParam annotation, you can get the actual account id from ThreadBasedUserCrnProvider", "author": "horadla23", "createdAt": "2020-05-22T07:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxMTM1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429411355", "bodyText": "@horadla23  I looked at the code to the InternalCrnModifier and I find it strange that it changes the CRN stored in the ThreadBasedUserCrnProvider into a mixture of the original user crn and the account from the annotated field. I don't think this is desirable because you may end up with an invalid actor that would fail authz on subsequent API calls.\nInstead, I think I need the changes you have in CB-7104 and to use the @CheckPermissionByResourceCrn annotation instead since the request includes an environment crn.", "author": "handavid", "createdAt": "2020-05-22T19:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxMzQzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429413437", "bodyText": "@handavid we are doing that only in case of internal actpr and we do not call ums with internal actor since everything is allowed with that, so it is working, other team:s service can call environment service this way without problem. You can still use @CheckPermissionByResourceCrn, as you can see from example from my email", "author": "horadla23", "createdAt": "2020-05-22T19:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTkzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428529930", "bodyText": "accountId shouldn't come from the env crn, we might check if it is the same", "author": "lacikaaa", "createdAt": "2020-05-21T08:55:28Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA5NTA1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429095052", "bodyText": "i guess it is called with internal crn, thus we need to find out account id differently", "author": "horadla23", "createdAt": "2020-05-22T07:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA5NjMwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r429096300", "bodyText": "but @handavid you can use @TenantAwareParam as described", "author": "horadla23", "createdAt": "2020-05-22T07:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyOTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMTI1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428531254", "bodyText": "build MdcContext from Stack", "author": "lacikaaa", "createdAt": "2020-05-21T08:58:13Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNTM4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428535382", "bodyText": "move this to a method/variable", "author": "lacikaaa", "createdAt": "2020-05-21T09:07:02Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);\n+        UserSyncStatus userSyncStatus = userSyncStatusService.findByStack(stack);\n+\n+        return internalCalculateEnvironmentUserSyncState(accountId, envCrnString, userSyncStatus);\n+    }\n+\n+    @VisibleForTesting\n+    EnvironmentUserSyncState internalCalculateEnvironmentUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        EnvironmentUserSyncState environmentUserSyncState = new EnvironmentUserSyncState();\n+        if (null == userSyncStatus || null == userSyncStatus.getLastStartedFullSync()) {\n+            environmentUserSyncState.setState(UserSyncState.STALE);\n+        } else {\n+            environmentUserSyncState.setLastUserSyncOperationId(userSyncStatus.getLastStartedFullSync().getOperationId());\n+            environmentUserSyncState.setState(calculateUserSyncState(accountId, envCrnString, userSyncStatus));\n+        }\n+\n+        return environmentUserSyncState;\n+    }\n+\n+    private UserSyncState calculateUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        Operation lastSync = userSyncStatus.getLastStartedFullSync();\n+        UserSyncState state = UserSyncState.STALE;\n+        switch (lastSync.getStatus()) {\n+            case RUNNING:\n+                state = UserSyncState.SYNCING;\n+                break;\n+            case COMPLETED:\n+                if (lastSync.getSuccessList().stream()\n+                        .anyMatch(details -> envCrnString.equals(details.getEnvironment()))) {", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNjI0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428536247", "bodyText": "move the whole to a method", "author": "lacikaaa", "createdAt": "2020-05-21T09:08:49Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);\n+        UserSyncStatus userSyncStatus = userSyncStatusService.findByStack(stack);\n+\n+        return internalCalculateEnvironmentUserSyncState(accountId, envCrnString, userSyncStatus);\n+    }\n+\n+    @VisibleForTesting\n+    EnvironmentUserSyncState internalCalculateEnvironmentUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        EnvironmentUserSyncState environmentUserSyncState = new EnvironmentUserSyncState();\n+        if (null == userSyncStatus || null == userSyncStatus.getLastStartedFullSync()) {\n+            environmentUserSyncState.setState(UserSyncState.STALE);\n+        } else {\n+            environmentUserSyncState.setLastUserSyncOperationId(userSyncStatus.getLastStartedFullSync().getOperationId());\n+            environmentUserSyncState.setState(calculateUserSyncState(accountId, envCrnString, userSyncStatus));\n+        }\n+\n+        return environmentUserSyncState;\n+    }\n+\n+    private UserSyncState calculateUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        Operation lastSync = userSyncStatus.getLastStartedFullSync();\n+        UserSyncState state = UserSyncState.STALE;\n+        switch (lastSync.getStatus()) {\n+            case RUNNING:\n+                state = UserSyncState.SYNCING;\n+                break;\n+            case COMPLETED:\n+                if (lastSync.getSuccessList().stream()\n+                        .anyMatch(details -> envCrnString.equals(details.getEnvironment()))) {\n+                    UmsEventGenerationIds currentEventGenerationIds = umsEventGenerationIdsProvider.getEventGenerationIds(accountId, MDCUtils.getRequestId());\n+                    if (eventGenerationIdsChecker.isInSync(userSyncStatus, currentEventGenerationIds)) {\n+                        state = UserSyncState.IN_SYNC;\n+                    }\n+                }", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNjM2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428536361", "bodyText": "move to a method", "author": "lacikaaa", "createdAt": "2020-05-21T09:09:07Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);\n+        UserSyncStatus userSyncStatus = userSyncStatusService.findByStack(stack);\n+\n+        return internalCalculateEnvironmentUserSyncState(accountId, envCrnString, userSyncStatus);\n+    }\n+\n+    @VisibleForTesting\n+    EnvironmentUserSyncState internalCalculateEnvironmentUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        EnvironmentUserSyncState environmentUserSyncState = new EnvironmentUserSyncState();\n+        if (null == userSyncStatus || null == userSyncStatus.getLastStartedFullSync()) {\n+            environmentUserSyncState.setState(UserSyncState.STALE);\n+        } else {\n+            environmentUserSyncState.setLastUserSyncOperationId(userSyncStatus.getLastStartedFullSync().getOperationId());\n+            environmentUserSyncState.setState(calculateUserSyncState(accountId, envCrnString, userSyncStatus));\n+        }\n+\n+        return environmentUserSyncState;\n+    }\n+\n+    private UserSyncState calculateUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        Operation lastSync = userSyncStatus.getLastStartedFullSync();\n+        UserSyncState state = UserSyncState.STALE;\n+        switch (lastSync.getStatus()) {\n+            case RUNNING:\n+                state = UserSyncState.SYNCING;\n+                break;\n+            case COMPLETED:\n+                if (lastSync.getSuccessList().stream()\n+                        .anyMatch(details -> envCrnString.equals(details.getEnvironment()))) {\n+                    UmsEventGenerationIds currentEventGenerationIds = umsEventGenerationIdsProvider.getEventGenerationIds(accountId, MDCUtils.getRequestId());\n+                    if (eventGenerationIdsChecker.isInSync(userSyncStatus, currentEventGenerationIds)) {\n+                        state = UserSyncState.IN_SYNC;\n+                    }\n+                }\n+                break;\n+            case REQUESTED:\n+            case REJECTED:\n+                // REQUESTED or REJECTED operations will never be saved as part of the UserSyncStatus\n+                LOGGER.error(\"UserSyncStatus.lastStartedFullSync '{}' in unexpected state {} for environment '{}'\",\n+                        lastSync, lastSync.getStatus(), envCrnString);\n+                throw new IllegalStateException(\n+                        String.format(\"Last sync operation [%s] for environment '%s' is in unexpected state %s\",\n+                                lastSync.getOperationId(), envCrnString, lastSync.getStatus()));", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNjk1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r428536957", "bodyText": "it would be easier to read if every case would set the state instead of we initialize with a value and we have to go through all case to check if it's overridden", "author": "lacikaaa", "createdAt": "2020-05-21T09:10:26Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(Crn environmentCrn) {\n+        String accountId = environmentCrn.getAccountId();\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);\n+        UserSyncStatus userSyncStatus = userSyncStatusService.findByStack(stack);\n+\n+        return internalCalculateEnvironmentUserSyncState(accountId, envCrnString, userSyncStatus);\n+    }\n+\n+    @VisibleForTesting\n+    EnvironmentUserSyncState internalCalculateEnvironmentUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        EnvironmentUserSyncState environmentUserSyncState = new EnvironmentUserSyncState();\n+        if (null == userSyncStatus || null == userSyncStatus.getLastStartedFullSync()) {\n+            environmentUserSyncState.setState(UserSyncState.STALE);\n+        } else {\n+            environmentUserSyncState.setLastUserSyncOperationId(userSyncStatus.getLastStartedFullSync().getOperationId());\n+            environmentUserSyncState.setState(calculateUserSyncState(accountId, envCrnString, userSyncStatus));\n+        }\n+\n+        return environmentUserSyncState;\n+    }\n+\n+    private UserSyncState calculateUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        Operation lastSync = userSyncStatus.getLastStartedFullSync();\n+        UserSyncState state = UserSyncState.STALE;\n+        switch (lastSync.getStatus()) {\n+            case RUNNING:\n+                state = UserSyncState.SYNCING;\n+                break;\n+            case COMPLETED:\n+                if (lastSync.getSuccessList().stream()\n+                        .anyMatch(details -> envCrnString.equals(details.getEnvironment()))) {\n+                    UmsEventGenerationIds currentEventGenerationIds = umsEventGenerationIdsProvider.getEventGenerationIds(accountId, MDCUtils.getRequestId());\n+                    if (eventGenerationIdsChecker.isInSync(userSyncStatus, currentEventGenerationIds)) {\n+                        state = UserSyncState.IN_SYNC;\n+                    }\n+                }\n+                break;\n+            case REQUESTED:\n+            case REJECTED:\n+                // REQUESTED or REJECTED operations will never be saved as part of the UserSyncStatus\n+                LOGGER.error(\"UserSyncStatus.lastStartedFullSync '{}' in unexpected state {} for environment '{}'\",\n+                        lastSync, lastSync.getStatus(), envCrnString);\n+                throw new IllegalStateException(\n+                        String.format(\"Last sync operation [%s] for environment '%s' is in unexpected state %s\",\n+                                lastSync.getOperationId(), envCrnString, lastSync.getStatus()));\n+            case TIMEDOUT:\n+                LOGGER.warn(\"UserSyncStatus.lastStartedFullSync '{}' is timed out for environment '{}'\", lastSync.getOperationId(), envCrnString);\n+                break;\n+            case FAILED:\n+            default:\n+                // state already set to STALE", "originalCommit": "bef06f1a1cf8fd23c35d4a4f33e8cae3deb2142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e34bce09418822500b931c519266e00e599195d", "url": "https://github.com/hortonworks/cloudbreak/commit/3e34bce09418822500b931c519266e00e599195d", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-21T20:23:05Z", "type": "forcePushed"}, {"oid": "a2c7f074a944a4486953fc205eaca294373cf46b", "url": "https://github.com/hortonworks/cloudbreak/commit/a2c7f074a944a4486953fc205eaca294373cf46b", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-21T21:42:18Z", "type": "forcePushed"}, {"oid": "072797b43fc9eeebc55c98d1b4a1e7b9ceb58571", "url": "https://github.com/hortonworks/cloudbreak/commit/072797b43fc9eeebc55c98d1b4a1e7b9ceb58571", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-22T20:46:01Z", "type": "forcePushed"}, {"oid": "ccd239a255401283530b582b2c1875e24b5b2857", "url": "https://github.com/hortonworks/cloudbreak/commit/ccd239a255401283530b582b2c1875e24b5b2857", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-22T21:41:26Z", "type": "forcePushed"}, {"oid": "5eeb08aafadff3e44d022c5de532330c4c19b887", "url": "https://github.com/hortonworks/cloudbreak/commit/5eeb08aafadff3e44d022c5de532330c4c19b887", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-22T22:11:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNzM3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r430917371", "bodyText": "this name is a bit misleading as I would expect it would set the state, but instead it will throw an exception. also this method should be void as it won't return anything ever.", "author": "lacikaaa", "createdAt": "2020-05-27T07:40:41Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentUserSyncStateCalculator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.EnvironmentUserSyncState;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.UserSyncState;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.entity.UserSyncStatus;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsEventGenerationIds;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+@Service\n+public class EnvironmentUserSyncStateCalculator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentUserSyncStateCalculator.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private UserSyncStatusService userSyncStatusService;\n+\n+    @Inject\n+    private UmsEventGenerationIdsProvider umsEventGenerationIdsProvider;\n+\n+    @Inject\n+    private EventGenerationIdsChecker eventGenerationIdsChecker;\n+\n+    public EnvironmentUserSyncState calculateEnvironmentUserSyncState(String accountId, Crn environmentCrn) {\n+        checkArgument(accountId.equals(environmentCrn.getAccountId()), \"environmentCrn does not match account id\");\n+        String envCrnString = environmentCrn.toString();\n+\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(envCrnString, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+\n+        UserSyncStatus userSyncStatus = userSyncStatusService.findByStack(stack);\n+\n+        return internalCalculateEnvironmentUserSyncState(accountId, envCrnString, userSyncStatus);\n+    }\n+\n+    @VisibleForTesting\n+    EnvironmentUserSyncState internalCalculateEnvironmentUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        EnvironmentUserSyncState environmentUserSyncState = new EnvironmentUserSyncState();\n+        if (null == userSyncStatus || null == userSyncStatus.getLastStartedFullSync()) {\n+            environmentUserSyncState.setState(UserSyncState.STALE);\n+        } else {\n+            environmentUserSyncState.setLastUserSyncOperationId(userSyncStatus.getLastStartedFullSync().getOperationId());\n+            environmentUserSyncState.setState(calculateUserSyncState(accountId, envCrnString, userSyncStatus));\n+        }\n+\n+        return environmentUserSyncState;\n+    }\n+\n+    private UserSyncState calculateUserSyncState(String accountId, String envCrnString, UserSyncStatus userSyncStatus) {\n+        Operation lastSync = userSyncStatus.getLastStartedFullSync();\n+        UserSyncState state;\n+        switch (lastSync.getStatus()) {\n+            case RUNNING:\n+                state = UserSyncState.SYNC_IN_PROGRESS;\n+                break;\n+            case COMPLETED:\n+                state = calculateStateForCompletedOperation(accountId, envCrnString, userSyncStatus);\n+                break;\n+            case REQUESTED:\n+            case REJECTED:\n+                // REQUESTED or REJECTED operations will never be saved as part of the UserSyncStatus\n+                state = calculateStateForUnexpectedOperationStatus(envCrnString, userSyncStatus);", "originalCommit": "5eeb08aafadff3e44d022c5de532330c4c19b887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwODkyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r432108924", "bodyText": "I renamed the method but I also changed it to return the. the case statement needs to throw the exception instead of the method. Otherwise, the compiler can't tell that the method will always throw and will complain about some codepaths not setting the state variable.", "author": "handavid", "createdAt": "2020-05-28T20:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNzM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjY3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r432282674", "bodyText": "thanks for the change!", "author": "lacikaaa", "createdAt": "2020-05-29T06:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxNzM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyMzcyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r430923727", "bodyText": "I think you should use @CheckPermissionByAccount here (similarly to other methods), now every permission check on API methods happens on account level in freeipa (resource based checks are happening explicitly in service layer as i have seen), internal calls ( with @TenantAwareParam) still will work, resource based authz implementation is in progress in other PR", "author": "horadla23", "createdAt": "2020-05-27T07:51:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -102,13 +113,22 @@ public SyncOperationStatus setPassword(SetPasswordRequest request) {\n     @Override\n     @CheckPermissionByAccount(action = AuthorizationResourceAction.ENVIRONMENT_WRITE)\n     public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n-        checkUserCrn();\n+        checkActorCrn();\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         LOGGER.debug(\"getSyncOperationStatus() requested for operation '{}' in account '{}'\", operationId, accountId);\n         return operationToSyncOperationStatus.convert(\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    @CheckPermissionByResourceCrn(action = AuthorizationResourceAction.ENVIRONMENT_READ)", "originalCommit": "5eeb08aafadff3e44d022c5de532330c4c19b887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwODA1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8119#discussion_r432108058", "bodyText": "done", "author": "handavid", "createdAt": "2020-05-28T20:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyMzcyNw=="}], "type": "inlineReview"}, {"oid": "a7433fdbfde669e5333f5a19aeb1c0dae67597d2", "url": "https://github.com/hortonworks/cloudbreak/commit/a7433fdbfde669e5333f5a19aeb1c0dae67597d2", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-28T19:11:34Z", "type": "commit"}, {"oid": "a7433fdbfde669e5333f5a19aeb1c0dae67597d2", "url": "https://github.com/hortonworks/cloudbreak/commit/a7433fdbfde669e5333f5a19aeb1c0dae67597d2", "message": "CDPCP-2094. Add API to retrieve user sync state for an environment\n\nThis commit adds a new endpoint for retrieving user sync state for an environment.\nThe state is calculated by looking at the last started full user sync. If the last\nstarted full user sync completed successfully, then the event generation ids for\nthat sync are compared against the current event generation ids from the UMS.", "committedDate": "2020-05-28T19:11:34Z", "type": "forcePushed"}]}