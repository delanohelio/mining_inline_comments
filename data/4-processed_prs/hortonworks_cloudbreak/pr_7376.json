{"pr_number": 7376, "pr_title": "CB-5254: Add ability to reboot a single FreeIPA instance.", "pr_createdAt": "2020-02-25T05:28:32Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7376", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzQ0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383773440", "bodyText": "throw an error here", "author": "lacikaaa", "createdAt": "2020-02-25T09:58:30Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpInstanceConnector.java", "diffHunk": "@@ -32,6 +32,11 @@\n     @Value(\"${cb.gcp.hostkey.verify:}\")\n     private boolean verifyHostKey;\n \n+    @Override\n+    public List<CloudVmInstanceStatus> reboot(AuthenticatedContext authenticatedContext, List<CloudInstance> vms) {\n+        return null;", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NjE1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383896150", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDAwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383774005", "bodyText": "throw an error here", "author": "lacikaaa", "createdAt": "2020-02-25T09:59:23Z", "path": "cloud-openstack/src/main/java/com/sequenceiq/cloudbreak/cloud/openstack/nativ/OpenStackNativeInstanceConnector.java", "diffHunk": "@@ -28,6 +28,11 @@\n     @Inject\n     private OpenStackClient openStackClient;\n \n+    @Override\n+    public List<CloudVmInstanceStatus> reboot(AuthenticatedContext authenticatedContext, List<CloudInstance> vms) {\n+        return null;", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NjQwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383896406", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NzQ3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383777476", "bodyText": "Stringbuilder is overkill here I think. I know there is some class where it's implemented that way, but I don't think that's a good pattern. Also inherited classes should include super.toString() or we can loose useful data", "author": "lacikaaa", "createdAt": "2020-02-25T10:05:37Z", "path": "cloud-reactor-api/src/main/java/com/sequenceiq/cloudbreak/cloud/event/instance/RebootInstancesRequest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.sequenceiq.cloudbreak.cloud.event.instance;\n+\n+import java.util.List;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.event.CloudPlatformRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+\n+public class RebootInstancesRequest<T> extends CloudPlatformRequest<T> {\n+\n+    private final List<CloudInstance> cloudInstances;\n+\n+    public RebootInstancesRequest(CloudContext cloudContext, CloudCredential cloudCredential,\n+            List<CloudInstance> cloudInstances) {\n+        super(cloudContext, cloudCredential);\n+        this.cloudInstances = cloudInstances;\n+    }\n+\n+    public List<CloudInstance> getCloudInstances() {\n+        return cloudInstances;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"RebootInstancesRequest{\");", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5ODA4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383898084", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3ODM5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383778395", "bodyText": "extra empty line", "author": "lacikaaa", "createdAt": "2020-02-25T10:07:11Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/doc/FreeIpaOperationDescriptions.java", "diffHunk": "@@ -14,6 +14,8 @@\n     public static final String REGISTER_WITH_CLUSTER_PROXY = \"Registers FreeIPA stack with given environment CRN with cluster proxy\";\n     public static final String DEREGISTER_WITH_CLUSTER_PROXY = \"Deregisters FreeIPA stack with given environment CRN with cluster proxy\";\n     public static final String HEALTH = \"Provides a detailed health of the FreeIPA stack\";\n+    public static final String REBOOT = \"Reboot one or more instances\";\n+", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5ODUxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383898516", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3ODM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MTI1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383781259", "bodyText": "maybe @NotEmpty is better here", "author": "lacikaaa", "createdAt": "2020-02-25T10:12:28Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/model/reboot/RebootInstancesRequest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot;\n+\n+import java.util.List;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"RebootInstancesV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class RebootInstancesRequest {\n+    @NotNull", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5OTM4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383899387", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NDc5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383784798", "bodyText": "if we need these comments please convert this into a javadoc for the method", "author": "lacikaaa", "createdAt": "2020-02-25T10:19:00Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());\n+            }\n+        };\n+        return allInstances.entrySet().stream()\n+                .peek(logit)\n+                .filter(entry -> instanceIds == null || instanceIds.isEmpty() || instanceIds.contains(entry.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesMap(Stack stack) {\n+        return stack.getInstanceGroups().stream().flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    public void rebootInstances(String accountId, RebootInstancesRequest request) {\n+        // If no instance passed in request, reboot all bad instances\n+        // If instances passed in request, reboot all valid passed bad instances\n+        // If force and instances passed in request, reboot all valid passed instances\n+        // If force and no instances passed in request, reboot all instances", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMDE0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383900141", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T14:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NDc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NTc3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383785775", "bodyText": "please move into a validate method", "author": "lacikaaa", "createdAt": "2020-02-25T10:20:41Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());\n+            }\n+        };\n+        return allInstances.entrySet().stream()\n+                .peek(logit)\n+                .filter(entry -> instanceIds == null || instanceIds.isEmpty() || instanceIds.contains(entry.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesMap(Stack stack) {\n+        return stack.getInstanceGroups().stream().flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    public void rebootInstances(String accountId, RebootInstancesRequest request) {\n+        // If no instance passed in request, reboot all bad instances\n+        // If instances passed in request, reboot all valid passed bad instances\n+        // If force and instances passed in request, reboot all valid passed instances\n+        // If force and no instances passed in request, reboot all instances\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountIdWithLists(request.getEnvironmentCrn(), accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        Map<String, InstanceMetaData> allInstances = getAllInstancesMap(stack);\n+        Set<String> invalidInstanceIds = getInvalidInstances(allInstances.keySet(), request);\n+        if (!invalidInstanceIds.isEmpty()) {\n+            String msg = MessageFormat.format(\"Invalid instanceIds are present in request: {0}.\", String.join(\", \", invalidInstanceIds));\n+            LOGGER.error(msg);\n+            throw new BadRequestException(msg);\n+        }", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NzM1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383787350", "bodyText": "why do we start a new flow for every instance? I think we should start 1 flow with all the instance IDs which we would like to restart.", "author": "lacikaaa", "createdAt": "2020-02-25T10:23:14Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());\n+            }\n+        };\n+        return allInstances.entrySet().stream()\n+                .peek(logit)\n+                .filter(entry -> instanceIds == null || instanceIds.isEmpty() || instanceIds.contains(entry.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesMap(Stack stack) {\n+        return stack.getInstanceGroups().stream().flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    public void rebootInstances(String accountId, RebootInstancesRequest request) {\n+        // If no instance passed in request, reboot all bad instances\n+        // If instances passed in request, reboot all valid passed bad instances\n+        // If force and instances passed in request, reboot all valid passed instances\n+        // If force and no instances passed in request, reboot all instances\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountIdWithLists(request.getEnvironmentCrn(), accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        Map<String, InstanceMetaData> allInstances = getAllInstancesMap(stack);\n+        Set<String> invalidInstanceIds = getInvalidInstances(allInstances.keySet(), request);\n+        if (!invalidInstanceIds.isEmpty()) {\n+            String msg = MessageFormat.format(\"Invalid instanceIds are present in request: {0}.\", String.join(\", \", invalidInstanceIds));\n+            LOGGER.error(msg);\n+            throw new BadRequestException(msg);\n+        }\n+\n+        Map<String, InstanceStatus> health = getInstanceHealth(accountId, request);\n+\n+        Map<String, InstanceMetaData> instancesToReboot = getInstancesToReboot(allInstances, request.getInstanceIds(), health);\n+        for (Map.Entry<String, InstanceMetaData> instance: instancesToReboot.entrySet()) {\n+            instanceMetaDataService.updateStatus(stack, instance.getKey(), InstanceStatus.REBOOTING);\n+            flowManager.notify(REBOOT_EVENT.event(), new InstanceEvent(REBOOT_EVENT.event(), instance.getValue().getId()));\n+        }", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk2ODIzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383968233", "bodyText": "We eventually want the ability to do a rolling reboot of the servers instead of rebooting all at the same time.  My understanding is the way to accomplish this is by implementing a custom FlowEventChainFactory that can dynamically tie the events together so we'd need separate events to achieve that.", "author": "holleyism", "createdAt": "2020-02-25T15:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NzM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM3MTQxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384371414", "bodyText": "I think we should have the flow capable of restarting multiple instance at a time. If we have 2 unhealthy node from 5 we should restart them together. If we would like to restart all, we can still do it in 2 batch.\nIf all node is in a bad state does it have any benefit to reboot them in a rolling mode?", "author": "lacikaaa", "createdAt": "2020-02-26T09:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NzM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5NDE3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384794173", "bodyText": "This had been refactored.  However, we will be adding rolling reboot later.  One of the uniqueness here is that we're running multiple services per instance.  If one service, say DNS, is down on one node, and PKI is down on another, both would be considered bad, but we'd want to rolling reboot these so we don't have total loss of service.", "author": "holleyism", "createdAt": "2020-02-26T22:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NzM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4OTUyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383789520", "bodyText": "something definitely wrong here, you use the payload.getResourceId() for fetching the stack and the instance. It should be the stack, and I would rewrite this to fetch all instancemetadata you need. And if you need the instanceMetadata in only 1 flow step, maybe you should fetch it only in that step.", "author": "lacikaaa", "createdAt": "2020-02-25T10:26:47Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/AbstractRebootAction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.dto.Credential;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootState;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+public abstract class AbstractRebootAction<P extends Payload>\n+        extends AbstractStackAction<RebootState, RebootEvent, RebootContext, P>  {\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    protected AbstractRebootAction(Class<P> payloadClass) {\n+        super(payloadClass);\n+    }\n+\n+    @Override\n+    protected RebootContext createFlowContext(FlowParameters flowParameters, StateContext<RebootState, RebootEvent> stateContext, P payload) {\n+        Long stackId = payload.getResourceId();\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        MDCBuilder.buildMdcContext(stack);\n+\n+        Optional<InstanceMetaData> instance = instanceMetaDataService.getById(payload.getResourceId());", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0OTMzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384149334", "bodyText": "Think I refactored this correctly.", "author": "holleyism", "createdAt": "2020-02-25T21:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4OTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MDE2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383790167", "bodyText": "if the instance.get() failes here is pretty strange, I think we should fail earlier", "author": "lacikaaa", "createdAt": "2020-02-25T10:27:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/AbstractRebootAction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.dto.Credential;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootState;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+public abstract class AbstractRebootAction<P extends Payload>\n+        extends AbstractStackAction<RebootState, RebootEvent, RebootContext, P>  {\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    protected AbstractRebootAction(Class<P> payloadClass) {\n+        super(payloadClass);\n+    }\n+\n+    @Override\n+    protected RebootContext createFlowContext(FlowParameters flowParameters, StateContext<RebootState, RebootEvent> stateContext, P payload) {\n+        Long stackId = payload.getResourceId();\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        MDCBuilder.buildMdcContext(stack);\n+\n+        Optional<InstanceMetaData> instance = instanceMetaDataService.getById(payload.getResourceId());\n+        Location location = location(region(stack.getRegion()), availabilityZone(stack.getAvailabilityZone()));\n+        CloudContext cloudContext = new CloudContext(stack.getId(), stack.getName(), stack.getCloudPlatform(), stack.getCloudPlatform(),\n+                location, stack.getOwner(), stack.getAccountId());\n+        Credential credential = credentialService.getCredentialByEnvCrn(stack.getEnvironmentCrn());\n+        CloudCredential cloudCredential = credentialConverter.convert(credential);\n+\n+        return new RebootContext(flowParameters, stack, instance.get(), cloudContext, cloudCredential);", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExNzE1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384117156", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T20:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MTM1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383791358", "bodyText": "please add instanceids to the log, makes investigation easier", "author": "lacikaaa", "createdAt": "2020-02-25T10:30:02Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/RebootActions.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.api.util.ConverterUtil;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootService;\n+\n+@Configuration\n+public class RebootActions {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootActions.class);\n+\n+    @Inject\n+    private ConverterUtil converterUtil;\n+\n+    @Inject\n+    private RebootService rebootService;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter metadataConverter;\n+\n+    @Bean(name = \"REBOOT_STATE\")\n+    public Action<?, ?> rebootAction() {\n+        return new AbstractRebootAction<>(InstanceEvent.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, InstanceEvent payload, Map<Object, Object> variables) {\n+                rebootService.startInstanceReboot(context);\n+                sendEvent(context);\n+                LOGGER.info(\"Starting reboot for {}\", context.getInstanceMetaData().getInstanceId());\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                List<CloudInstance> cloudInstances = converterUtil.convertAll(List.of(context.getInstanceMetaData()), CloudInstance.class);\n+                return new RebootInstancesRequest<>(context.getCloudContext(), context.getCloudCredential(), cloudInstances);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"REBOOT_FINISHED_STATE\")\n+    public Action<?, ?> rebootFinishedAction() {\n+        return new AbstractRebootAction<>(RebootInstancesResult.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, RebootInstancesResult payload, Map<Object, Object> variables) {\n+                rebootService.finishInstanceReboot(context, payload);\n+                LOGGER.info(\"Finished rebooting.\");", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExNzI0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384117245", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T20:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MzAzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383793033", "bodyText": "stream usage seems reasonable here", "author": "lacikaaa", "createdAt": "2020-02-25T10:32:58Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/instance/InstanceMetaDataService.java", "diffHunk": "@@ -42,6 +43,19 @@ public void saveInstanceRequests(Stack stack, List<Group> groups) {\n         }\n     }\n \n+    public void updateStatus(Stack stack, String instanceId, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus status) {\n+        Set<InstanceGroup> instanceGroups = stack.getInstanceGroups();\n+        for (InstanceGroup group : instanceGroups) {\n+            for (InstanceMetaData instanceMetaData : group.getInstanceMetaData()) {\n+                if (instanceId.equals(instanceMetaData.getInstanceId())) {\n+                    instanceMetaData.setInstanceStatus(status);\n+                    instanceMetaDataRepository.save(instanceMetaData);\n+                    return;\n+                }\n+            }\n+        }", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5Mzg5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383793897", "bodyText": "also a log for changing the status. and unit test please", "author": "lacikaaa", "createdAt": "2020-02-25T10:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MzAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzOTA4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384239089", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-26T02:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NzM5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383797398", "bodyText": "please replace AVAILABLE string with the actual value", "author": "lacikaaa", "createdAt": "2020-02-25T10:40:54Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExODYwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384118601", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T20:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NzM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMTQzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383801432", "bodyText": "I think something is wrong here. You used the heath to filter what to log, but you don't use it to filter. In my opinion peek should just log and don't have any logic at all, this could be misleading", "author": "lacikaaa", "createdAt": "2020-02-25T10:48:07Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());\n+            }\n+        };\n+        return allInstances.entrySet().stream()\n+                .peek(logit)\n+                .filter(entry -> instanceIds == null || instanceIds.isEmpty() || instanceIds.contains(entry.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MDE3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384240179", "bodyText": "refactored to for loops instead of streams because of the split nature of logging the items to be filtered out.", "author": "holleyism", "createdAt": "2020-02-26T02:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMjY3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383802678", "bodyText": "similarly as in the other log, I don't think having logic in peek is a good idea, or at least move out the logic, so it's not duplicated. If somebody touches the filter and not the logit logic it will differ", "author": "lacikaaa", "createdAt": "2020-02-25T10:50:23Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MzM4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384173389", "bodyText": "refactored to move logic out.", "author": "holleyism", "createdAt": "2020-02-25T22:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMjY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMzcyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383803723", "bodyText": "it's misleading you don't return health if it's forced. you should ignore health where you filter for instances to restart if it's forced, but this method doesn't exactly do what you expect by it's name", "author": "lacikaaa", "createdAt": "2020-02-25T10:52:08Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMjI4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384032282", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T18:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMzcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNDMxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383804311", "bodyText": "could you rename the variable? like allInstanceByInstanceId, because I had to lookup the code to know what is in this map", "author": "lacikaaa", "createdAt": "2020-02-25T10:53:11Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealth(String accountId, RebootInstancesRequest request) {\n+        if (!request.isForceReboot()) {\n+            return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                    .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private Set<String> getInvalidInstances(Collection<String> allInstances, RebootInstancesRequest request) {\n+        Consumer<String> logit = id -> {\n+            if (!allInstances.contains(id)) {\n+                LOGGER.info(\"Unknown instance ID {} in request\", id);\n+            }\n+        };\n+        return Stream.ofNullable(request.getInstanceIds()).flatMap(Collection::stream)\n+                .peek(logit)\n+                .filter(id -> !allInstances.contains(id))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToReboot(Map<String, InstanceMetaData> allInstances,\n+            List<String> instanceIds, Map<String, InstanceStatus> health) {\n+        Consumer<Map.Entry> logit = entry -> {\n+            if (health.get(entry.getKey()) != null && health.get(entry.getKey()).isAvailable()) {\n+                LOGGER.info(\"Not rebooting AVAILABLE instance {} because force reboot was not selected.\", entry.getKey());\n+            }\n+        };\n+        return allInstances.entrySet().stream()\n+                .peek(logit)\n+                .filter(entry -> instanceIds == null || instanceIds.isEmpty() || instanceIds.contains(entry.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesMap(Stack stack) {\n+        return stack.getInstanceGroups().stream().flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    public void rebootInstances(String accountId, RebootInstancesRequest request) {\n+        // If no instance passed in request, reboot all bad instances\n+        // If instances passed in request, reboot all valid passed bad instances\n+        // If force and instances passed in request, reboot all valid passed instances\n+        // If force and no instances passed in request, reboot all instances\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountIdWithLists(request.getEnvironmentCrn(), accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        Map<String, InstanceMetaData> allInstances = getAllInstancesMap(stack);", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMjIyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384032223", "bodyText": "fixed", "author": "holleyism", "createdAt": "2020-02-25T18:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTY3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383805671", "bodyText": "it looks like only 1 instance scenario is tested, I think more complex cases needs to be tested", "author": "lacikaaa", "createdAt": "2020-02-25T10:55:30Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/service/instance/RebootInstanceServiceTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.sequenceiq.freeipa.service.instance;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.google.common.collect.Sets;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceGroupType;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.HealthDetailsFreeIpaResponse;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.FreeIpaHealthDetailsService;\n+import com.sequenceiq.freeipa.service.stack.RebootInstancesService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class RebootInstanceServiceTest {", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NzgwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384277804", "bodyText": "Added additional tests.", "author": "holleyism", "createdAt": "2020-02-26T05:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwOTk4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383809988", "bodyText": "where is this used?", "author": "lacikaaa", "createdAt": "2020-02-25T11:03:56Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/operation/model/OperationType.java", "diffHunk": "@@ -5,6 +5,7 @@\n public enum OperationType {\n     USER_SYNC,\n     SET_PASSWORD,\n+    REBOOT,", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyNzU2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384027564", "bodyText": "removed.", "author": "holleyism", "createdAt": "2020-02-25T17:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwOTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMDcwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r383810704", "bodyText": "I don't think this is used anywhere", "author": "lacikaaa", "createdAt": "2020-02-25T11:05:31Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstanceAcceptor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.freeipa.api.v1.operation.model.OperationType;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.repository.OperationRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.AcceptResult;\n+import com.sequenceiq.freeipa.service.operation.OperationAcceptor;\n+\n+@Component\n+public class RebootInstanceAcceptor extends OperationAcceptor {", "originalCommit": "7bedab08331049d704829df0b1a6bfc9c9e6f5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyODA3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384028079", "bodyText": "removed.", "author": "holleyism", "createdAt": "2020-02-25T17:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMDcwNA=="}], "type": "inlineReview"}, {"oid": "2712377bef5b56b758fcab13fb4f85cd75e0d46a", "url": "https://github.com/hortonworks/cloudbreak/commit/2712377bef5b56b758fcab13fb4f85cd75e0d46a", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-02-26T05:18:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4OTEyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384389127", "bodyText": "ok, so it's still a bit confusing here, so let me explain what I would do:\n\nInstanceEvent would contain stackId as resourceId as you need that to create the cloudcreadentials etc\nInstanceEvent would contain a set of instanceIds selected for reboot\nI would use findAllInStack for fetching instancemetadatas and filter in a stream, or have a separate repository query which contains stackId and instanceids too. Shouldn't make a big difference as freeipa won't have hundreds of instances\nYou have to decide what happens if one/more/all instancemetadata is missing. I think this should not happen as it had been validated earlier, but maybe you should fail the flow with a message so it would be obvious that something is pretty wrong. Maybe you let in the force flag here and restart anyway the found instances and just log an error in that case\nif you really need these cloud stuff and real instancemetadata here then this override should be ok, so we wont make unnecessary db load for other steps.\nas this step is getting a big one, maybe you should move it a separate file\nif we send this event the restart will begin, but if we kill that service which is running this flow another will pick up from here and will send the reboot command again. Is it ok?", "author": "lacikaaa", "createdAt": "2020-02-26T10:02:55Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/RebootActions.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.api.util.ConverterUtil;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.dto.Credential;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootService;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootState;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Configuration\n+public class RebootActions {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootActions.class);\n+\n+    @Inject\n+    private ConverterUtil converterUtil;\n+\n+    @Inject\n+    private RebootService rebootService;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter metadataConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Bean(name = \"REBOOT_STATE\")\n+    public Action<?, ?> rebootAction() {\n+        return new AbstractRebootAction<>(InstanceEvent.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, InstanceEvent payload, Map<Object, Object> variables) {\n+                rebootService.startInstanceReboot(context);\n+                sendEvent(context);\n+                LOGGER.info(\"Starting reboot for {}\", context.getInstanceMetaData().getInstanceId());\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                List<CloudInstance> cloudInstances = converterUtil.convertAll(List.of(context.getInstanceMetaData()), CloudInstance.class);\n+                return new RebootInstancesRequest<>(context.getCloudContext(), context.getCloudCredential(), cloudInstances);\n+            }\n+\n+            @Override\n+            protected RebootContext createFlowContext(FlowParameters flowParameters, StateContext<RebootState, RebootEvent> stateContext,", "originalCommit": "2712377bef5b56b758fcab13fb4f85cd75e0d46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMjQ3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384622473", "bodyText": "refactored to have one event.  It is ok to reboot twice.", "author": "holleyism", "createdAt": "2020-02-26T16:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4OTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MDY1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384390653", "bodyText": "please use an else here, so the indentation would reflect a logic too", "author": "lacikaaa", "createdAt": "2020-02-26T10:05:34Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealthMap(String accountId, RebootInstancesRequest request) {\n+        return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+    }\n+\n+    private Collection<String> getValidInstanceIds(Collection<String> allInstances, Collection<String> instanceIds) {\n+        if (instanceIds == null || instanceIds.isEmpty()) {\n+            return allInstances;\n+        }", "originalCommit": "2712377bef5b56b758fcab13fb4f85cd75e0d46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384784377", "bodyText": "done", "author": "holleyism", "createdAt": "2020-02-26T21:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NjMwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384396305", "bodyText": "so we could say here if(instanceIds.size() != validInstanceIds.size()) and just calculate the difference of the 2 collection and log at once and add it to the message.\nthis way the for could be a stream:\nCollection<String> validInstanceIds = instanceIds.stream().filter(allInstances.contains).collect()\nand you could drop the badIds flag", "author": "lacikaaa", "createdAt": "2020-02-26T10:15:38Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealthMap(String accountId, RebootInstancesRequest request) {\n+        return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+    }\n+\n+    private Collection<String> getValidInstanceIds(Collection<String> allInstances, Collection<String> instanceIds) {\n+        if (instanceIds == null || instanceIds.isEmpty()) {\n+            return allInstances;\n+        }\n+        boolean badIds = false;\n+        Collection<String> validInstanceIds = new HashSet<>();\n+        for (String instanceId: instanceIds) {\n+            if (allInstances.contains(instanceId)) {\n+                validInstanceIds.add(instanceId);\n+            } else {\n+                LOGGER.error(\"{} is an invalid instanceId.\", instanceId);\n+                badIds = true;\n+            }\n+        }\n+        if (badIds) {\n+            String msg = \"Invalid instanceIds are present in request.\";\n+            LOGGER.error(msg);\n+            throw new BadRequestException(msg);\n+        }", "originalCommit": "2712377bef5b56b758fcab13fb4f85cd75e0d46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzA2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r384793069", "bodyText": "changed.", "author": "holleyism", "createdAt": "2020-02-26T21:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NjMwNQ=="}], "type": "inlineReview"}, {"oid": "33add6f52514fe649cd9210d0a770cd35d33ed25", "url": "https://github.com/hortonworks/cloudbreak/commit/33add6f52514fe649cd9210d0a770cd35d33ed25", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-02-26T22:45:49Z", "type": "forcePushed"}, {"oid": "075df1f8410a590cac49760102705b7e23d2d823", "url": "https://github.com/hortonworks/cloudbreak/commit/075df1f8410a590cac49760102705b7e23d2d823", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-02-26T23:22:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzE1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385013157", "bodyText": "could you add a description here, so it would be documented on the API what's the difference. thanks", "author": "lacikaaa", "createdAt": "2020-02-27T09:43:37Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/model/reboot/RebootInstancesRequest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot;\n+\n+import java.util.List;\n+\n+import javax.validation.constraints.NotEmpty;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"RebootInstancesV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class RebootInstancesRequest {\n+    @NotEmpty\n+    @ApiModelProperty(value = ModelDescriptions.ENVIRONMENT_CRN, required = true)\n+    private String environmentCrn;\n+\n+    private boolean forceReboot;", "originalCommit": "075df1f8410a590cac49760102705b7e23d2d823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxNDM0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385514346", "bodyText": "added", "author": "holleyism", "createdAt": "2020-02-28T05:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxNTE1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385015155", "bodyText": "please add the actual converter, and if necessary add a method for collections. it makes navigating through code easier. I know we used this ConverterUtil a lot, but I don't think it's worth it. thanks", "author": "lacikaaa", "createdAt": "2020-02-27T09:47:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/RebootActions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.api.util.ConverterUtil;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.dto.Credential;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootService;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootState;\n+import com.sequenceiq.freeipa.repository.InstanceMetaDataRepository;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Configuration\n+public class RebootActions {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootActions.class);\n+\n+    @Inject\n+    private ConverterUtil converterUtil;\n+\n+    @Inject\n+    private RebootService rebootService;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter metadataConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Bean(name = \"REBOOT_STATE\")\n+    public Action<?, ?> rebootAction() {\n+        return new AbstractRebootAction<>(InstanceEvent.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, InstanceEvent payload, Map<Object, Object> variables) {\n+                rebootService.startInstanceReboot(context);\n+                sendEvent(context);\n+                LOGGER.info(\"Starting reboot for {}\", context.getInstanceIds());\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                List<CloudInstance> cloudInstances = converterUtil.convertAll(context.getInstanceMetaDataList(), CloudInstance.class);", "originalCommit": "075df1f8410a590cac49760102705b7e23d2d823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODMwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385508302", "bodyText": "changed.", "author": "holleyism", "createdAt": "2020-02-28T05:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxNTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMjk0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385022949", "bodyText": "context.getInstanceIdList() will be null here. I don't think you need an ovveride of createRequest. You could send the event directly from doExecute", "author": "lacikaaa", "createdAt": "2020-02-27T09:59:41Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/action/RebootActions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.api.util.ConverterUtil;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.dto.Credential;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.flow.instance.InstanceFailureEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootContext;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootService;\n+import com.sequenceiq.freeipa.flow.instance.reboot.RebootState;\n+import com.sequenceiq.freeipa.repository.InstanceMetaDataRepository;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Configuration\n+public class RebootActions {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootActions.class);\n+\n+    @Inject\n+    private ConverterUtil converterUtil;\n+\n+    @Inject\n+    private RebootService rebootService;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter metadataConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Bean(name = \"REBOOT_STATE\")\n+    public Action<?, ?> rebootAction() {\n+        return new AbstractRebootAction<>(InstanceEvent.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, InstanceEvent payload, Map<Object, Object> variables) {\n+                rebootService.startInstanceReboot(context);\n+                sendEvent(context);\n+                LOGGER.info(\"Starting reboot for {}\", context.getInstanceIds());\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                List<CloudInstance> cloudInstances = converterUtil.convertAll(context.getInstanceMetaDataList(), CloudInstance.class);\n+                return new RebootInstancesRequest<>(context.getCloudContext(), context.getCloudCredential(), cloudInstances);\n+            }\n+\n+            @Override\n+            protected RebootContext createFlowContext(FlowParameters flowParameters, StateContext<RebootState, RebootEvent> stateContext,\n+                    InstanceEvent payload) {\n+                Long stackId = payload.getResourceId();\n+                Stack stack = stackService.getStackById(stackId);\n+                Set<InstanceMetaData> instances = instanceMetaDataRepository.findAllInStack(stackId).stream()\n+                        .filter(instanceMetaData -> payload.getInstanceIds().contains(instanceMetaData.getInstanceId())).collect(Collectors.toSet());\n+                MDCBuilder.buildMdcContext(stack);\n+\n+                Location location = location(region(stack.getRegion()), availabilityZone(stack.getAvailabilityZone()));\n+                CloudContext cloudContext = new CloudContext(stack.getId(), stack.getName(), stack.getCloudPlatform(), stack.getCloudPlatform(),\n+                        location, stack.getOwner(), stack.getAccountId());\n+                Credential credential = credentialService.getCredentialByEnvCrn(stack.getEnvironmentCrn());\n+                CloudCredential cloudCredential = credentialConverter.convert(credential);\n+                return new RebootContext(flowParameters, stack, instances, cloudContext, cloudCredential);\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"REBOOT_FINISHED_STATE\")\n+    public Action<?, ?> rebootFinishedAction() {\n+        return new AbstractRebootAction<>(RebootInstancesResult.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, RebootInstancesResult payload, Map<Object, Object> variables) {\n+                rebootService.finishInstanceReboot(context, payload);\n+                LOGGER.info(\"Finished rebooting {}.\", context.getInstanceIds());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                return new InstanceEvent(RebootEvent.REBOOT_FINALIZED_EVENT.event(), context.getStack().getId(), context.getInstanceIdList());\n+            }\n+\n+            @Override\n+            protected RebootContext createFlowContext(FlowParameters flowParameters, StateContext<RebootState,\n+                    RebootEvent> stateContext, RebootInstancesResult payload) {\n+                Set<InstanceMetaData> instances = payload.getResults().getResults().stream().map(instance -> {\n+                    InstanceMetaData md = new InstanceMetaData();\n+                    md.setInstanceId(instance.getCloudInstance().getInstanceId());\n+                    return md;\n+                }).collect(Collectors.toSet());\n+                Long stackId = payload.getResourceId();\n+                Stack stack = stackService.getStackById(stackId);\n+                return new RebootContext(flowParameters, stack, instances, null, null);\n+                }\n+\n+        };\n+    }\n+\n+    @Bean(name = \"REBOOT_FAILED_STATE\")\n+    public Action<?, ?> rebootFailureAction() {\n+        return new AbstractRebootAction<>(InstanceFailureEvent.class) {\n+            @Override\n+            protected void doExecute(RebootContext context, InstanceFailureEvent payload, Map<Object, Object> variables) {\n+                rebootService.handleInstanceRebootError(String.join(\",\", payload.getInstanceIds()));\n+                LOGGER.error(\"Rebooting failed for {}.\", context.getInstanceIds());\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(RebootContext context) {\n+                return new InstanceEvent(RebootEvent.REBOOT_FAIL_HANDLED_EVENT.event(), context.getStack().getId(), context.getInstanceIdList());", "originalCommit": "075df1f8410a590cac49760102705b7e23d2d823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODI3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385508279", "bodyText": "fixed.", "author": "holleyism", "createdAt": "2020-02-28T05:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMjk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMzUxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385023512", "bodyText": "so we would leave the instances in rebooting state in case of an error?", "author": "lacikaaa", "createdAt": "2020-02-27T10:00:42Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/instance/reboot/RebootService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.sequenceiq.freeipa.flow.instance.reboot;\n+\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.RebootInstancesResult;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.service.stack.RebootInstancesService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Component\n+public class RebootService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootService.class);\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private RebootInstancesService rebootInstancesService;\n+\n+    public void startInstanceReboot(RebootContext context) {\n+        instanceMetaDataService.updateStatus(context.getStack(), context.getInstanceIdList(), InstanceStatus.REBOOTING);\n+    }\n+\n+    public void handleInstanceRebootError(String instanceIds) {", "originalCommit": "075df1f8410a590cac49760102705b7e23d2d823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTUyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385509528", "bodyText": "fixed.", "author": "holleyism", "createdAt": "2020-02-28T05:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMzUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyNTY5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385025699", "bodyText": "this if seems unnecessary. badIds can't be empty if we are in this part of the code", "author": "lacikaaa", "createdAt": "2020-02-27T10:04:34Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RebootInstancesService.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.instance.reboot.RebootEvent.REBOOT_EVENT;\n+import static java.util.function.Predicate.not;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.reboot.RebootInstancesRequest;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.controller.exception.NotFoundException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.instance.InstanceEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+\n+@Service\n+public class RebootInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RebootInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealthMap(String accountId, RebootInstancesRequest request) {\n+        return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+    }\n+\n+    private Collection<String> getValidInstanceIds(Collection<String> allInstances, Collection<String> instanceIds) {\n+        if (instanceIds == null || instanceIds.isEmpty()) {\n+            return allInstances;\n+        } else {\n+            Collection<String> validInstanceIds = instanceIds.stream().filter(allInstances::contains).collect(Collectors.toSet());\n+            if (validInstanceIds.size() != allInstances.size()) {\n+                String badIds = instanceIds.stream()\n+                        .filter(not(allInstances::contains)).collect(Collectors.joining(\",\"));\n+                if (badIds.length() > 0) {", "originalCommit": "075df1f8410a590cac49760102705b7e23d2d823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODMzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7376#discussion_r385508338", "bodyText": "removed", "author": "holleyism", "createdAt": "2020-02-28T05:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyNTY5OQ=="}], "type": "inlineReview"}, {"oid": "8e179c1e3bee847aac33c93950cfc670c95f1144", "url": "https://github.com/hortonworks/cloudbreak/commit/8e179c1e3bee847aac33c93950cfc670c95f1144", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-02-28T05:10:42Z", "type": "forcePushed"}, {"oid": "a10be42f472bfbdec48d8aae6c9d78bc60692b91", "url": "https://github.com/hortonworks/cloudbreak/commit/a10be42f472bfbdec48d8aae6c9d78bc60692b91", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-03-02T20:53:25Z", "type": "forcePushed"}, {"oid": "841b0bc9ed9aff5c7df99b18d067bb03b6c87699", "url": "https://github.com/hortonworks/cloudbreak/commit/841b0bc9ed9aff5c7df99b18d067bb03b6c87699", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-03-02T22:29:14Z", "type": "commit"}, {"oid": "841b0bc9ed9aff5c7df99b18d067bb03b6c87699", "url": "https://github.com/hortonworks/cloudbreak/commit/841b0bc9ed9aff5c7df99b18d067bb03b6c87699", "message": "CB-5254: Add ability to reboot a single FreeIPA instance.\n\nThis patch adds the APIs and flows to support requesting\na reboot of a single instance of a FreeIPA cluster.", "committedDate": "2020-03-02T22:29:14Z", "type": "forcePushed"}]}