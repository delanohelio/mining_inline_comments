{"pr_number": 9334, "pr_title": "CB-9127 refactor the current cluster template logic and separate it i\u2026", "pr_createdAt": "2020-10-29T16:04:36Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9334", "timeline": [{"oid": "f0a1876a507f6b0b820c7709a709dd5cb300bf67", "url": "https://github.com/hortonworks/cloudbreak/commit/f0a1876a507f6b0b820c7709a709dd5cb300bf67", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-10-30T09:08:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4ODMyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r514988324", "bodyText": "please add some logs here", "author": "topolyai5", "createdAt": "2020-10-30T10:04:41Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/clustertemplate/ClusterTemplateToClusterTemplateV4ResponseConverter.java", "diffHunk": "@@ -32,9 +39,21 @@ public ClusterTemplateV4Response convert(ClusterTemplate source) {\n         ClusterTemplateV4Response clusterTemplateV4Response = new ClusterTemplateV4Response();\n         clusterTemplateV4Response.setName(source.getName());\n         clusterTemplateV4Response.setDescription(source.getDescription());\n-        Stack stack = stackTemplateService.getByIdWithLists(source.getStackTemplate().getId()).orElse(null);\n-        StackV4Request stackV4Request = converterUtil.convert(stack, StackV4Request.class);\n-        clusterTemplateV4Response.setDistroXTemplate(getIfNotNull(stackV4Request, stackV4RequestConverter::convert));\n+        if (source.getStatus().isNonDefault()) {\n+            Stack stack = stackTemplateService.getByIdWithLists(source.getStackTemplate().getId()).orElse(null);\n+            StackV4Request stackV4Request = converterUtil.convert(stack, StackV4Request.class);\n+            clusterTemplateV4Response.setDistroXTemplate(getIfNotNull(stackV4Request, stackV4RequestConverter::convert));\n+            clusterTemplateV4Response.setNodeCount(stack.getFullNodeCount());\n+        } else {\n+            try {\n+                DefaultClusterTemplateV4Request clusterTemplateV4Request = new Json(getTemplateString(source))\n+                        .get(DefaultClusterTemplateV4Request.class);\n+                clusterTemplateV4Response.setDistroXTemplate(clusterTemplateV4Request.getDistroXTemplate());\n+                clusterTemplateV4Response.setNodeCount(getFullNodeCount(clusterTemplateV4Request.getDistroXTemplate()));\n+            } catch (IOException e) {\n+                clusterTemplateV4Response.setDistroXTemplate(null);", "originalCommit": "f0a1876a507f6b0b820c7709a709dd5cb300bf67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbd4fa70db892314f605420cc9d860ea464e037a", "url": "https://github.com/hortonworks/cloudbreak/commit/bbd4fa70db892314f605420cc9d860ea464e037a", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-10-30T10:13:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMTk2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515021965", "bodyText": "Do we need this? It is going to break during CB upgrade.", "author": "akanto", "createdAt": "2020-10-30T11:10:41Z", "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/common/ResourceStatus.java", "diffHunk": "@@ -4,5 +4,13 @@\n     DEFAULT,\n     DEFAULT_DELETED,\n     USER_MANAGED,\n-    OUTDATED\n+    OUTDATED;", "originalCommit": "bbd4fa70db892314f605420cc9d860ea464e037a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0ODA4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515048080", "bodyText": "I just put a ; sign at the end", "author": "doktoric", "createdAt": "2020-10-30T11:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzA3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515023072", "bodyText": "Do we need an IP in the template?", "author": "akanto", "createdAt": "2020-10-30T11:12:57Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/view/ClusterTemplateClusterApiView.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.sequenceiq.cloudbreak.domain.view;\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Table;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.converter.CertExpirationStateConverter;\n+import com.sequenceiq.cloudbreak.domain.converter.StatusConverter;\n+import com.sequenceiq.common.api.type.CertExpirationState;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+@Entity\n+@SuppressFBWarnings(\"UWF_UNWRITTEN_FIELD\")\n+@Table(name = \"Cluster\")\n+public class ClusterTemplateClusterApiView extends CompactView {\n+    @OneToOne(fetch = FetchType.LAZY)\n+    private ClusterTemplateStackApiView stack;\n+\n+    @ManyToOne(fetch = FetchType.EAGER)\n+    private BlueprintView blueprint;\n+\n+    private String clusterManagerIp;", "originalCommit": "bbd4fa70db892314f605420cc9d860ea464e037a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNDAxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515024012", "bodyText": "Do we need an Status in the template?", "author": "akanto", "createdAt": "2020-10-30T11:14:34Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/view/ClusterTemplateStackApiView.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package com.sequenceiq.cloudbreak.domain.view;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.converter.TunnelConverter;\n+import com.sequenceiq.cloudbreak.domain.converter.StackTypeConverter;\n+import com.sequenceiq.common.api.type.Tunnel;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+@Entity\n+@Table(name = \"Stack\")\n+// It's only here, because of findbugs does not know the fields will be set by JPA with Reflection\n+@SuppressFBWarnings(\"UWF_UNWRITTEN_FIELD\")\n+public class ClusterTemplateStackApiView extends CompactView {\n+\n+    @OneToOne(mappedBy = \"stack\")\n+    private ClusterTemplateClusterApiView cluster;\n+\n+    @Column(columnDefinition = \"TEXT\")\n+    private String cloudPlatform;\n+\n+    @Column(columnDefinition = \"TEXT\")\n+    private String platformVariant;\n+\n+    @OneToOne\n+    private StackStatusView stackStatus;", "originalCommit": "bbd4fa70db892314f605420cc9d860ea464e037a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNDc2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515024768", "bodyText": "I think we can eliminate a few fields/relations from this entity.", "author": "akanto", "createdAt": "2020-10-30T11:15:56Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/view/ClusterTemplateStackApiView.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package com.sequenceiq.cloudbreak.domain.view;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.converter.TunnelConverter;\n+import com.sequenceiq.cloudbreak.domain.converter.StackTypeConverter;\n+import com.sequenceiq.common.api.type.Tunnel;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+@Entity\n+@Table(name = \"Stack\")\n+// It's only here, because of findbugs does not know the fields will be set by JPA with Reflection\n+@SuppressFBWarnings(\"UWF_UNWRITTEN_FIELD\")\n+public class ClusterTemplateStackApiView extends CompactView {\n+\n+    @OneToOne(mappedBy = \"stack\")\n+    private ClusterTemplateClusterApiView cluster;\n+\n+    @Column(columnDefinition = \"TEXT\")\n+    private String cloudPlatform;\n+\n+    @Column(columnDefinition = \"TEXT\")\n+    private String platformVariant;\n+\n+    @OneToOne\n+    private StackStatusView stackStatus;\n+\n+    @OneToMany(mappedBy = \"stack\", fetch = FetchType.EAGER)\n+    private Set<ClusterTemplateInstanceGroupView> instanceGroups = new HashSet<>();\n+\n+    private Long created;", "originalCommit": "bbd4fa70db892314f605420cc9d860ea464e037a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9288dc8d5fc273bd21b51a46826d49fa541e9ecf", "url": "https://github.com/hortonworks/cloudbreak/commit/9288dc8d5fc273bd21b51a46826d49fa541e9ecf", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-10-30T12:36:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NDU4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515194588", "bodyText": "Please correct the message and also log it.", "author": "biharitomi", "createdAt": "2020-10-30T15:43:48Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateService.java", "diffHunk": "@@ -264,25 +271,42 @@ public void updateDefaultClusterTemplates(long workspaceId) {\n     }\n \n     private Optional<String> getMessageIfBlueprintIsInvalidInCluster(ClusterTemplate clusterTemplate) {\n-        if (Objects.isNull(clusterTemplate.getStackTemplate().getCluster())) {\n+        if (!clusterTemplate.getStatus().isDefault() && Objects.isNull(clusterTemplate.getStackTemplate().getCluster())) {\n             String msg = \"Stack template in cluster definition should contain a \u2013 valid \u2013 cluster request!\";\n             return Optional.of(msg);\n         }\n         String msg = null;\n-        boolean hasBlueprint = nonNull(clusterTemplate.getStackTemplate().getCluster().getBlueprint());\n-        if (!hasBlueprint) {\n-            msg = \"Cluster definition should contain a cluster template!\";\n+        String blueprintName = null;\n+        if (clusterTemplate.getStatus().isDefault()) {\n+            try {\n+                blueprintName = new Json(getTemplateString(clusterTemplate)).get(DefaultClusterTemplateV4Request.class)\n+                        .getDistroXTemplate()\n+                        .getCluster()\n+                        .getBlueprintName();\n+            } catch (IOException e) {\n+                msg = \"The cluster template in the cluster definition should be an exists!\";", "originalCommit": "9288dc8d5fc273bd21b51a46826d49fa541e9ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTYxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9334#discussion_r515239610", "bodyText": "Can we set it to false as it was? As I know it is not a very good idea to use parallal streams in a multithreaded web based application because it can cause high load for one request and the application should be able to serve many request at the same time.", "author": "sodre90", "createdAt": "2020-10-30T16:55:24Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateService.java", "diffHunk": "@@ -313,16 +337,17 @@ private void updateDefaultClusterTemplates(Workspace workspace) {\n             LOGGER.debug(\"Outdated clusterTemplates deleted: '{}'.\", outdatedTemplates.size());\n             clusterTemplates = clusterTemplateRepository.findAllByNotDeletedInWorkspace(workspace.getId());\n             LOGGER.debug(\"None deleted clusterTemplates collected: '{}'.\", clusterTemplates.size());\n-            clusterTemplateLoaderService.loadClusterTemplatesForWorkspace(clusterTemplates, this::createAll);\n+            clusterTemplateLoaderService.loadClusterTemplatesForWorkspace(clusterTemplates, workspace, this::createAll);\n             LOGGER.debug(\"ClusterTemplate modifications finished based on the defaults for '{}' workspace.\", workspace.getId());\n         }\n     }\n \n     private Collection<ClusterTemplate> createAll(Iterable<ClusterTemplate> clusterTemplates) {\n-        return StreamSupport.stream(clusterTemplates.spliterator(), false)\n+        User user = userService.getOrCreate(legacyRestRequestThreadLocalService.getCloudbreakUser());\n+        return StreamSupport.stream(clusterTemplates.spliterator(), true)", "originalCommit": "9288dc8d5fc273bd21b51a46826d49fa541e9ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b14f61093211a6f4aa1f5eb9197537992fb82230", "url": "https://github.com/hortonworks/cloudbreak/commit/b14f61093211a6f4aa1f5eb9197537992fb82230", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-10-30T18:39:59Z", "type": "forcePushed"}, {"oid": "39a1edcc5d2e2eece0810fdd63ba765e41463a10", "url": "https://github.com/hortonworks/cloudbreak/commit/39a1edcc5d2e2eece0810fdd63ba765e41463a10", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-11-01T20:10:41Z", "type": "commit"}, {"oid": "39a1edcc5d2e2eece0810fdd63ba765e41463a10", "url": "https://github.com/hortonworks/cloudbreak/commit/39a1edcc5d2e2eece0810fdd63ba765e41463a10", "message": "CB-9127 refactor the current cluster template logic and separate it into two flow. Default flow will not create stack entity and this means we only store the template. The other flow will add an original node count and the we dont need to collect instancemetadatas.", "committedDate": "2020-11-01T20:10:41Z", "type": "forcePushed"}, {"oid": "8a65a7bd964c91780d92743ba29eaf7e8fc89622", "url": "https://github.com/hortonworks/cloudbreak/commit/8a65a7bd964c91780d92743ba29eaf7e8fc89622", "message": "bump schema compatibility version to 2.31.0-b119", "committedDate": "2020-11-02T15:58:52Z", "type": "commit"}]}