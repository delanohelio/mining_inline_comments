{"pr_number": 9594, "pr_title": "CB-10066 New API methods to add and delete DNS A and CNAME records", "pr_createdAt": "2020-12-07T17:11:13Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9594", "timeline": [{"oid": "9d17732e8482011fabf73437127efddd444f1e44", "url": "https://github.com/hortonworks/cloudbreak/commit/9d17732e8482011fabf73437127efddd444f1e44", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records", "committedDate": "2020-12-07T17:50:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MTIwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538251205", "bodyText": "Typo: recorc -> record.", "author": "lajosrodek", "createdAt": "2020-12-08T11:11:56Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String DNS_RECORD = \"DNS record name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"\n+            + \"'168.192.in-addr.arpa' for a reverse record like '5.1.168.192.in-addr.arpa'\";\n+\n+    public static final String CNAME_TARGET_FQDN = \"The fully qualified domain name of the host the CNAME should point to.\";\n+\n+    public static final String CREATE_REVERSE = \"Tries to create a reverse point for the recorc (PTR). Only if reverse zone already exists\";", "originalCommit": "9d17732e8482011fabf73437127efddd444f1e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MTk3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538251971", "bodyText": "thanks, I fixed locally. For now I won't push it.", "author": "lacikaaa", "createdAt": "2020-12-08T11:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MTIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MDc2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538340765", "bodyText": "Are the zones expected to have a trailing \".\"? Technically this is what an FQDN means but I think this should be called out if it is required since its a common misconception.", "author": "jamisonbennett", "createdAt": "2020-12-08T13:00:59Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String DNS_RECORD = \"DNS record name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"\n+            + \"'168.192.in-addr.arpa' for a reverse record like '5.1.168.192.in-addr.arpa'\";\n+\n+    public static final String CNAME_TARGET_FQDN = \"The fully qualified domain name of the host the CNAME should point to.\";", "originalCommit": "9d17732e8482011fabf73437127efddd444f1e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM4MTYwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538381601", "bodyText": "I will test it with and without trailing . and if it's necessary I think I will add it on the backend side. But I have managed to create an A record with ipa cli without adding the . after the zone name or adding one before. (checked the sent request and the cli hasn't added the dot so I think we are good without it)", "author": "lacikaaa", "createdAt": "2020-12-08T13:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MjMzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538342338", "bodyText": "Should we also add an API to query the a/cname records?", "author": "jamisonbennett", "createdAt": "2020-12-08T13:02:35Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/DnsV1Endpoint.java", "diffHunk": "@@ -75,4 +77,34 @@ void deleteDnsZoneBySubnetId(@QueryParam(\"environment\") @NotEmpty String environ\n     @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n             nickname = \"deleteDnsRecordByFqdnV1\")\n     void deleteDnsRecordsByFqdn(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"fqdn\") @NotEmpty List<String> fqdns);\n+\n+    @POST\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsARecordV1\")\n+    void addDnsARecord(@Valid AddDnsARecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_A_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsARecordV1\")\n+    void deleteDnsARecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"dnsZone\") @NotEmpty String dnsZone,\n+            @QueryParam(\"record\") @NotEmpty String record);\n+\n+    @POST\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsCnameRecordV1\")\n+    void addDnsCnameRecord(@Valid AddDnsCnameRecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_CNAME_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsCnameRecordV1\")\n+    void deleteDnsCnameRecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"dnsZone\") @NotEmpty String dnsZone,\n+            @QueryParam(\"record\") @NotEmpty String record);\n }", "originalCommit": "9d17732e8482011fabf73437127efddd444f1e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQxOTg1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r539419850", "bodyText": "we might add later. it wasn't requested, so I won't implement it in this PR", "author": "lacikaaa", "createdAt": "2020-12-09T15:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0NDUzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538344539", "bodyText": "It looks like this commit just adds the API and not the implementation. Is that intended?", "author": "jamisonbennett", "createdAt": "2020-12-08T13:04:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/DnsV1Controller.java", "diffHunk": "@@ -126,4 +128,44 @@ public void deleteDnsRecordsByFqdn(@ResourceCrn @NotEmpty String environmentCrn,\n             throw new FreeIpaClientExceptionWrapper(e);\n         }\n     }\n+\n+    @Override\n+    @CheckPermissionByRequestProperty(path = \"environmentCrn\", type = CRN, action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void addDnsARecord(@RequestObject @Valid AddDnsARecordRequest request) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByResourceCrn(action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void deleteDnsARecord(@ResourceCrn @NotEmpty String environmentCrn, @NotEmpty String dnsZone, @NotEmpty String record) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByRequestProperty(path = \"environmentCrn\", type = CRN, action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void addDnsCnameRecord(@RequestObject @Valid AddDnsCnameRecordRequest request) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByResourceCrn(action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void deleteDnsCnameRecord(@ResourceCrn @NotEmpty String environmentCrn, @NotEmpty String dnsZone, @NotEmpty String record) {\n+\n+    }", "originalCommit": "9d17732e8482011fabf73437127efddd444f1e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM1NjEzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538356133", "bodyText": "yes, implementation is in progress", "author": "lacikaaa", "createdAt": "2020-12-08T13:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0NDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNjAxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538526016", "bodyText": "This is just for reviewing the API for the different teams.", "author": "keyki", "createdAt": "2020-12-08T15:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0NDUzOQ=="}], "type": "inlineReview"}, {"oid": "3f09f0fd0ede68ae26878d8db29491580ae42d22", "url": "https://github.com/hortonworks/cloudbreak/commit/3f09f0fd0ede68ae26878d8db29491580ae42d22", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records", "committedDate": "2020-12-08T16:19:52Z", "type": "forcePushed"}, {"oid": "80b24a6c8f85f0c8343c355c76eda004eb30b549", "url": "https://github.com/hortonworks/cloudbreak/commit/80b24a6c8f85f0c8343c355c76eda004eb30b549", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records", "committedDate": "2020-12-09T15:09:31Z", "type": "forcePushed"}, {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "url": "https://github.com/hortonworks/cloudbreak/commit/de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation.", "committedDate": "2020-12-14T12:30:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMTUxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543411517", "bodyText": "nit: conatin -> contain", "author": "jamisonbennett", "createdAt": "2020-12-15T14:49:51Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/AddDnsCnameRecordRequest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_PATTERN;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_PATTERN;\n+\n+import javax.validation.constraints.NotEmpty;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.freeipa.api.v1.dns.doc.DnsModelDescription;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"AddDnsCnameRecordV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class AddDnsCnameRecordRequest {\n+\n+    @NotNull\n+    @ApiModelProperty(value = ModelDescriptions.ENVIRONMENT_CRN, required = true)\n+    private String environmentCrn;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME, required = true)\n+    @Pattern(regexp = DNS_CNAME_PATTERN, message = DNS_CNAME_MSG)\n+    private String cname;\n+\n+    @ApiModelProperty(DnsModelDescription.DNS_ZONE)\n+    @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG)\n+    private String dnsZone;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME_TARGET_FQDN, required = true)\n+    @Pattern(regexp = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\",\n+            message = \"Target FQDN must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\")", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjEwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412109", "bodyText": "nit: conatin -> contain", "author": "jamisonbennett", "createdAt": "2020-12-15T14:50:33Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjI4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412282", "bodyText": "nit: conatin -> contain", "author": "jamisonbennett", "createdAt": "2020-12-15T14:50:47Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_HOSTNAME_PATTERN = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_HOSTNAME_MSG = \"Hostname must be valid. Can conatin alphanumeric characters, dash and dot.\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjUwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412507", "bodyText": "nit: conatin -> contain", "author": "jamisonbennett", "createdAt": "2020-12-15T14:51:02Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NjQwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543496404", "bodyText": "I think you might want the following regex: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"\n\n\nThe dash after the 9 is invalid. Put it at the front/end of the bracketed section so that it doesn't form a range.\n\n\nAssuming the \"-\" is removed, this regex allows \"\\\" in FQDNs:\n\n\necho www\\\\google.com | egrep \"^[a-zA-Z0-9]+[a-zA-Z0-9\\\\.]*[a-zA-Z0-9]+$\"\n\n\nnit: This regex technically doesn't allow a trailing \".\" and that technically is required to be a part of an FQDN (but it is very rare that that is actually used).", "author": "jamisonbennett", "createdAt": "2020-12-15T16:31:11Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/AddDnsCnameRecordRequest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_PATTERN;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_PATTERN;\n+\n+import javax.validation.constraints.NotEmpty;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.freeipa.api.v1.dns.doc.DnsModelDescription;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"AddDnsCnameRecordV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class AddDnsCnameRecordRequest {\n+\n+    @NotNull\n+    @ApiModelProperty(value = ModelDescriptions.ENVIRONMENT_CRN, required = true)\n+    private String environmentCrn;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME, required = true)\n+    @Pattern(regexp = DNS_CNAME_PATTERN, message = DNS_CNAME_MSG)\n+    private String cname;\n+\n+    @ApiModelProperty(DnsModelDescription.DNS_ZONE)\n+    @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG)\n+    private String dnsZone;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME_TARGET_FQDN, required = true)\n+    @Pattern(regexp = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\",", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NzczOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544257739", "bodyText": "I'm writing unit tests, and it seems valid\n\n\n\\\\ is necessary. first \\ is for escaping the dot, as by default dot matches anything, the second one is necessary for java to escape \\\n\n\nFor now I will leave it this way, we can weaken the regexp later if necessary", "author": "lacikaaa", "createdAt": "2020-12-16T12:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI4OTc4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544289784", "bodyText": "I have added unit tests to validate the regex. Could you check?", "author": "lacikaaa", "createdAt": "2020-12-16T13:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODA5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543498093", "bodyText": "I think this might be the same rules as above: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"", "author": "jamisonbennett", "createdAt": "2020-12-15T16:33:16Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODc3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543498776", "bodyText": "Same as above: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"", "author": "jamisonbennett", "createdAt": "2020-12-15T16:34:09Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_HOSTNAME_PATTERN = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY2NjU1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543666559", "bodyText": "ADD_DNS_A_RECORD_BY_FQDN -> ADD_DNS_CNAME_RECORD_BY_FQDN", "author": "pdarvasi", "createdAt": "2020-12-15T20:32:54Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/DnsV1Endpoint.java", "diffHunk": "@@ -75,4 +85,36 @@ void deleteDnsZoneBySubnetId(@QueryParam(\"environment\") @NotEmpty String environ\n     @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n             nickname = \"deleteDnsRecordByFqdnV1\")\n     void deleteDnsRecordsByFqdn(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"fqdn\") @NotEmpty List<String> fqdns);\n+\n+    @POST\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsARecordV1\")\n+    void addDnsARecord(@Valid @NotNull AddDnsARecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_A_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsARecordV1\")\n+    void deleteDnsARecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn,\n+            @QueryParam(\"dnsZone\") @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG) String dnsZone,\n+            @QueryParam(\"hostname\") @NotEmpty @Pattern(regexp = DNS_HOSTNAME_PATTERN, message = DNS_HOSTNAME_MSG) String hostname);\n+\n+    @POST\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MDE1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543670159", "bodyText": "like -> eg. to match the other descriptions format.\nclouder -> cloudera", "author": "pdarvasi", "createdAt": "2020-12-15T20:39:14Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String CNAME = \"DNS name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String HOSTNAME = \"Hostname name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String IP = \"The IP address of the host the A record should point to. Only IPv4\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MTE0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543671142", "bodyText": "Reverse pointer created -> Reverse pointer is created", "author": "pdarvasi", "createdAt": "2020-12-15T20:40:52Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsOperationDescriptions.java", "diffHunk": "@@ -7,6 +7,12 @@\n     public static final String DELETE_DNS_ZONE_BY_SUBNET = \"Deletes reverse DNS Zone entry by subnet CIDR\";\n     public static final String DELETE_DNS_ZONE_BY_SUBNET_ID = \"Deletes reverse DNS Zone entry by subnet ID\";\n     public static final String DELETE_DNS_RECORD_BY_FQDN = \"Deletes all related A and PTR DNS record\";\n+    public static final String ADD_DNS_A_RECORD_BY_FQDN = \"Creates a DNS A record with the value in the defined zone if zone exists. If zone not specified \"\n+            + \"default zone will be used. Reverse pointer created if requested and reverse zone exists.\";", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODc0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543678744", "bodyText": "question: why do you get the client 4 times here?", "author": "pdarvasi", "createdAt": "2020-12-15T20:53:57Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -35,16 +48,18 @@\n     @Inject\n     private StackService stackService;\n \n-    public void deleteDnsRecordByFqdn(String environmentCrn, String accountId,  List<String> fqdns) throws FreeIpaClientException {\n-        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n-        MDCBuilder.buildMdcContext(stack);\n-        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n-        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n-        for (DnsZone dnsZone : freeIpaClient.findAllDnsZone()) {\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void deleteDnsRecordByFqdn(String environmentCrn, String accountId, List<String> fqdns) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(environmentCrn, accountId);\n+        for (DnsZone dnsZone : freeIpaAndClient.getClient().findAllDnsZone()) {\n             LOGGER.debug(\"Looking for records in zone [{}]\", dnsZone.getIdnsname());\n-            Set<DnsRecord> allDnsRecordsInZone = freeIpaClient.findAllDnsRecordInZone(dnsZone.getIdnsname());\n-            deleteRegularRecords(freeIpaClient, dnsZone, allDnsRecordsInZone, fqdns, freeIpa.getDomain());\n-            deleteSrvRecords(freeIpaClient, dnsZone, allDnsRecordsInZone, fqdns);\n+            Set<DnsRecord> allDnsRecordsInZone = freeIpaAndClient.getClient().findAllDnsRecordInZone(dnsZone.getIdnsname());", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNzgyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544237824", "bodyText": "it's just a pojo get, shouldn't matter", "author": "lacikaaa", "createdAt": "2020-12-16T11:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5MDg0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544390847", "bodyText": "it just hurts my ocd", "author": "pdarvasi", "createdAt": "2020-12-16T15:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MTkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543681933", "bodyText": "don't you want to log srvRecords here, too?", "author": "pdarvasi", "createdAt": "2020-12-15T20:59:08Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNTkzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544235931", "bodyText": "haven't modified that part, won't touch it now", "author": "lacikaaa", "createdAt": "2020-12-16T11:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MzU1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543683551", "bodyText": "a log line would be nice here", "author": "pdarvasi", "createdAt": "2020-12-15T21:01:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTAyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685027", "bodyText": "1 string would be enough instead of 2", "author": "pdarvasi", "createdAt": "2020-12-15T21:04:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTA3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685078", "bodyText": "1 string would be enough instead of 2", "author": "pdarvasi", "createdAt": "2020-12-15T21:04:35Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTEyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544239121", "bodyText": "could you elaborate?", "author": "lacikaaa", "createdAt": "2020-12-16T11:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5Mzk2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544393963", "bodyText": "You have the same text here and in next line:\"Record already exists and the IP doesn't match\". It would be more convenient to have only 1.", "author": "pdarvasi", "createdAt": "2020-12-16T15:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwODc0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r544408744", "bodyText": "on purpose. I didn't want to add multiple extra lines just to ensure the log and exception has the same message", "author": "lacikaaa", "createdAt": "2020-12-16T15:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTg2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685868", "bodyText": "1 string would be enough instead of 2", "author": "pdarvasi", "createdAt": "2020-12-15T21:06:00Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");\n+            throw new DnsRecordConflictException(\"Record already exists and the IP doesn't match\");\n+        } else {\n+            LOGGER.info(\"A record already exists and matches with requested. Nothing to do\");\n+        }\n+    }\n+\n+    private void createDnsARecord(FreeIpaClient client, String zone, String hostname, String ip, boolean createReverse) throws FreeIpaClientException {\n+        LOGGER.info(\"Creating A record in zone [{}] with hostname [{}] with IP [{}]. Create reverse set to [{}]\",\n+                zone, hostname, ip, createReverse);\n+        DnsRecord record = client.addDnsARecord(zone, hostname, ip, createReverse);\n+        LOGGER.info(\"A record [{}] pointing to [{}] is created successfully. Created record: {}\", hostname, ip, record);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsCnameRecord(String accountId, AddDnsCnameRecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getCname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsCnameRecord(freeIpaAndClient.getClient(), zone, request.getCname(), request.getTargetFqdn());\n+        } else {\n+            validateExistingCnameRecordMatches(dnsRecord.get(), request.getTargetFqdn());\n+        }\n+    }\n+\n+    private void validateExistingCnameRecordMatches(DnsRecord record, String targetFqdn) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isCnameRecord()) {\n+            LOGGER.info(\"Record already exists and it's not a CNAME record\");", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTk1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685956", "bodyText": "1 string would be enough instead of 2", "author": "pdarvasi", "createdAt": "2020-12-15T21:06:06Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");\n+            throw new DnsRecordConflictException(\"Record already exists and the IP doesn't match\");\n+        } else {\n+            LOGGER.info(\"A record already exists and matches with requested. Nothing to do\");\n+        }\n+    }\n+\n+    private void createDnsARecord(FreeIpaClient client, String zone, String hostname, String ip, boolean createReverse) throws FreeIpaClientException {\n+        LOGGER.info(\"Creating A record in zone [{}] with hostname [{}] with IP [{}]. Create reverse set to [{}]\",\n+                zone, hostname, ip, createReverse);\n+        DnsRecord record = client.addDnsARecord(zone, hostname, ip, createReverse);\n+        LOGGER.info(\"A record [{}] pointing to [{}] is created successfully. Created record: {}\", hostname, ip, record);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsCnameRecord(String accountId, AddDnsCnameRecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getCname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsCnameRecord(freeIpaAndClient.getClient(), zone, request.getCname(), request.getTargetFqdn());\n+        } else {\n+            validateExistingCnameRecordMatches(dnsRecord.get(), request.getTargetFqdn());\n+        }\n+    }\n+\n+    private void validateExistingCnameRecordMatches(DnsRecord record, String targetFqdn) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isCnameRecord()) {\n+            LOGGER.info(\"Record already exists and it's not a CNAME record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not a CNAME record\");\n+        } else if (!record.getCnamerecord().contains(targetFqdn)) {\n+            LOGGER.info(\"Record already exists and the target doesn't match\");", "originalCommit": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "url": "https://github.com/hortonworks/cloudbreak/commit/83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation.", "committedDate": "2020-12-16T11:59:16Z", "type": "forcePushed"}, {"oid": "8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "url": "https://github.com/hortonworks/cloudbreak/commit/8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation.", "committedDate": "2020-12-16T13:15:59Z", "type": "commit"}, {"oid": "8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "url": "https://github.com/hortonworks/cloudbreak/commit/8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation.", "committedDate": "2020-12-16T13:15:59Z", "type": "forcePushed"}]}