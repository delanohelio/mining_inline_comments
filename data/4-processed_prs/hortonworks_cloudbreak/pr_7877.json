{"pr_number": 7877, "pr_title": "CB-6705: Register multiple cluster proxy service for FreeIPA HA", "pr_createdAt": "2020-04-22T22:16:08Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7877", "timeline": [{"oid": "26398f7379d5a37355376f427fa7d427d1db4e22", "url": "https://github.com/hortonworks/cloudbreak/commit/26398f7379d5a37355376f427fa7d427d1db4e22", "message": "CB-6705: Register multiple cluster proxy service for FreeIPA HA\n\nRegister one cluster proxy service for each FreeIPA instance and an\nadditional one for the primary gateway for use during provisioning.\nPrefer using the primary gateway freeipa instance but if it is\noffline, then pick an instance of freeipa that is working.\nUse the instance specific cluster proxy connections for health status,\nthat way the health status doesn't require both the checked node and\nprimary gateway node to be online.\n\nWhen reporting the health status for FreeIPA's UI status, report an\nerror if any instance is offline. That way there is an easy way for a\ncustomer to know if manual repair operation is required. In the future\nwhen the repair happens automatically, the status should only report a\nfailure when all nodes are offline.\n\nIn addition to the tests, this was manually tested by bringing\nindividual FreeIPA instances offline and validating the status is\nreported correctly. FreeIPA management service operations were also\nvalidated to work when a node was offline.", "committedDate": "2020-04-23T00:04:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3MDU2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413570567", "bodyText": "you don't have to call the close() here, try will take care of it", "author": "lacikaaa", "createdAt": "2020-04-23T07:18:11Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -138,7 +138,9 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                     .build()) {\n                 URI target = getIpaUrl(clientConfig.getApiAddress(), port, basePath, \"/session/login_password\").toURI();\n                 LOGGER.debug(\"Ping at target: {}\", target);\n-                client.execute(new HttpHead(target));\n+                HttpHead request = new HttpHead(target);\n+                additionalHeaders.forEach(request::addHeader);\n+                client.execute(request).close();", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5MzYwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413793601", "bodyText": "I think both the CloseableHttpResponse and the CloseableHttpClient should be closed.\nhttps://hc.apache.org/httpcomponents-client-ga/tutorial/html/fundamentals.html shows the following:\nCloseableHttpResponse response = httpclient.execute(httpget);\ntry {\n    <...>\n} finally {\n    response.close();\n}\n\nAlso FreeIpaClientBuilder::connect() does a close on both the CloseableHttpResponse and the CloseableHttpClient.", "author": "jamisonbennett", "createdAt": "2020-04-23T12:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3MDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MTQ3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413581477", "bodyText": "we could use StackEvent here so both the old and new event would match", "author": "lacikaaa", "createdAt": "2020-04-23T07:36:16Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/provision/action/FreeIpaProvisionActions.java", "diffHunk": "@@ -90,12 +92,29 @@ protected Selectable createRequest(StackContext context) {\n         };\n     }\n \n+    @Bean(name = \"CLUSTERPROXY_UPDATE_REGISTRATION_STATE\")\n+    public Action<?, ?> updateClusterProxyRegistrationAction() {\n+        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+            @Override\n+            protected void doExecute(StackContext context, InstallFreeIpaServicesSuccess payload, Map<Object, Object> variables) throws Exception {\n+                stackUpdater.updateStackStatus(context.getStack().getId(), DetailedStackStatus.UPDATE_CLUSTER_PROXY_REGISTRATION,\n+                        \"Updating cluster proxy registration.\");\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(StackContext context) {\n+                return new ClusterProxyUpdateRegistrationRequest(context.getStack().getId());\n+            }\n+        };\n+    }\n+\n     @Bean(name = \"FREEIPA_POST_INSTALL_STATE\")\n     public Action<?, ?> postInstallFreeIpa() {\n-        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+        return new AbstractStackProvisionAction<>(ClusterProxyUpdateRegistrationSuccess.class) {", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5ODQzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413798432", "bodyText": "The StackEvent is still used during the original bootstrapping for the StackProvisionFlowConfig. The ClusterProxyUpdateRegistrationSuccess is for the new step in the FreeIpaProvisionFlowConfig. The StackProvisionFlowConfig events remain unchanged. Does. it still make sense to have a StackEvent here? If so I will make the change.", "author": "jamisonbennett", "createdAt": "2020-04-23T13:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU5Njk4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413596983", "bodyText": "nit: create a comparator class for this", "author": "lacikaaa", "createdAt": "2020-04-23T07:58:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "diffHunk": "@@ -138,38 +139,52 @@ private boolean canTryAnotherInstance(boolean lastInstance, IOException e) {\n         return !lastInstance;\n     }\n \n-    private List<InstanceMetaData> getAllInstances(Stack stack) {\n-        return stack.getInstanceGroups().stream().flatMap(instanceGroup ->\n-                instanceGroup.getInstanceMetaData().stream()).collect(Collectors.toList());\n+    private List<InstanceMetaData> getPriorityOrderedFreeIpaInstances(Stack stack) {\n+        return instanceMetaDataRepository.findNotTerminatedForStack(stack.getId()).stream()\n+                .filter(InstanceMetaData::isAvailable)\n+                .sorted((l, r) -> {\n+                    if (l.getInstanceMetadataType() == InstanceMetadataType.GATEWAY_PRIMARY) {\n+                        return -1;\n+                    }\n+                    if (r.getInstanceMetadataType() == InstanceMetadataType.GATEWAY_PRIMARY) {\n+                        return 1;\n+                    }\n+                    return Comparator.comparing(InstanceMetaData::getDiscoveryFQDN).compare(l, r);", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYxNzI0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413617241", "bodyText": "don't include repository anywhere else than the related service", "author": "lacikaaa", "createdAt": "2020-04-23T08:28:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "diffHunk": "@@ -61,6 +63,9 @@\n     @Inject\n     private TlsSecurityService tlsSecurityService;\n \n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYyNzkwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413627905", "bodyText": "don't use repository here", "author": "lacikaaa", "createdAt": "2020-04-23T08:42:45Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -70,15 +74,25 @@\n     @Inject\n     private SecurityConfigService securityConfigService;\n \n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzNjM1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413636355", "bodyText": "is it ok to add this ServiceConfig on bootstrap and again when we are adding the other ones? It looks like to me we double add it, and I don't know if it cause any issue on CP side", "author": "lacikaaa", "createdAt": "2020-04-23T08:54:27Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -88,17 +102,27 @@\n         LOGGER.debug(\"Registering freeipa with cluster-proxy: Environment CRN = [{}], Stack CRN = [{}]\", stack.getEnvironmentCrn(), stack.getResourceCrn());\n \n         GatewayConfig primaryGatewayConfig = gatewayConfigService.getPrimaryGatewayConfig(stack);\n-        HttpClientConfig httpClientConfig = tlsSecurityService.buildTLSClientConfigForPrimaryGateway(\n-                stack, primaryGatewayConfig.getGatewayUrl());\n+        List<GatewayConfig> gatewayConfigs = gatewayConfigService.getNotTerminatedGatewayConfigs(stack);\n         ClientCertificate clientCertificate = clientCertificates(stack);\n \n-        ClusterServiceConfig serviceConfig = createServiceConfig(stack, httpClientConfig, clientCertificate);\n+        boolean usePrivateIpToTls = stack.getSecurityConfig().isUsePrivateIpToTls();\n+        List<GatewayConfig> tunnelGatewayConfigs;\n+        List<ClusterServiceConfig> serviceConfigs = new LinkedList<>();\n+        serviceConfigs.add(createServiceConfig(stack, FREEIPA_SERVICE_NAME, primaryGatewayConfig, clientCertificate, usePrivateIpToTls));", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwOTA3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413809077", "bodyText": "Yes, I confirmed this with the cluster proxy team. The registration is a \"force\" registration and it overwrites the old config.", "author": "jamisonbennett", "createdAt": "2020-04-23T13:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzNjM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTQ2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413645462", "bodyText": "protocol should come from GatewayConfig as it is used when we are building apiAddress", "author": "lacikaaa", "createdAt": "2020-04-23T09:07:12Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -183,4 +227,12 @@ private ClientCertificate clientCertificates(Stack stack) {\n         return clientCertificate;\n     }\n \n+    private String getEndpointForRegistration(Stack stack, GatewayConfig gatewayConfig, boolean usePrivateIpToTls) {\n+        String ipAddresss = gatewayConfig.getPublicAddress();\n+        if (usePrivateIpToTls) {\n+            ipAddresss = gatewayConfig.getPrivateAddress();\n+        }\n+        return String.format(\"https://%s:%d\", ipAddresss, stack.getGatewayport());", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzMDc4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413930789", "bodyText": "The gateway config is updated to use the protocol of cluster proxy. This needs to be the NGINX endpoint protocol not the protocol of cluster proxy. When registering an endpoint in cluster proxy the needs to be the final NGINX endpoint. I will rename the method to make this a little more clear.", "author": "jamisonbennett", "createdAt": "2020-04-23T16:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MzM4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413653380", "bodyText": "is this still a valid option? can we receive such exceptions?", "author": "lacikaaa", "createdAt": "2020-04-23T09:18:34Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -31,28 +34,38 @@\n     @Inject\n     private FreeIpaClientFactory freeIpaClientFactory;\n \n-    private RPCResponse<Boolean> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack), LOGGER,\n-                    \":::Auto sync::: freeipa client is created in {}ms\");\n-            String hostname = getPrimaryHostname(checkableInstances);\n-            return checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                    \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            for (InstanceMetaData instanceMetaData : checkableInstances) {\n+                String hostname = instanceMetaData.getDiscoveryFQDN();\n+                FreeIpaClient freeIpaClient = checkedMeasure(() ->\n+                                freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                        \":::Auto sync::: freeipa client is created in {}ms\");\n+                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+            }\n+            return statuses;\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            RPCResponse<Boolean> response = checkStatus(stack, checkableInstances);\n+            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n+            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            if (response.getResult()) {\n+            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n+            if (result && responses.size() == notTermiatedStackInstances.size()) {\n                 status = DetailedStackStatus.PROVISIONED;\n             } else {\n                 status = DetailedStackStatus.UNHEALTHY;\n                 postFix = \"Freeipa is unhealthy, \";\n             }\n-            return new SyncResult(postFix + getMessage(response), status, response.getResult());\n+            return new SyncResult(postFix + getMessages(responses), status, result);\n         } catch (HttpHostConnectException | ConnectTimeoutException e) {", "originalCommit": "26398f7379d5a37355376f427fa7d427d1db4e22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTA4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413959086", "bodyText": "I noticed this yesterday too. You are correct, it is impossible to receive these exceptions. I am in the process of fixing this in CB-6745. I would prefer to fix this in a separate pull request since this wasn't affected by this pull request and this PR is pretty large already.", "author": "jamisonbennett", "createdAt": "2020-04-23T16:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MzM4MA=="}], "type": "inlineReview"}, {"oid": "a6f90d48d7b515def83e4a60a994f48a86ba4da2", "url": "https://github.com/hortonworks/cloudbreak/commit/a6f90d48d7b515def83e4a60a994f48a86ba4da2", "message": "CB-6705: Register multiple cluster proxy service for FreeIPA HA\n\nRegister one cluster proxy service for each FreeIPA instance and an\nadditional one for the primary gateway for use during provisioning.\nPrefer using the primary gateway freeipa instance but if it is\noffline, then pick an instance of freeipa that is working.\nUse the instance specific cluster proxy connections for health status,\nthat way the health status doesn't require both the checked node and\nprimary gateway node to be online.\n\nWhen reporting the health status for FreeIPA's UI status, report an\nerror if any instance is offline. That way there is an easy way for a\ncustomer to know if manual repair operation is required. In the future\nwhen the repair happens automatically, the status should only report a\nfailure when all nodes are offline.\n\nIn addition to the tests, this was manually tested by bringing\nindividual FreeIPA instances offline and validating the status is\nreported correctly. FreeIPA management service operations were also\nvalidated to work when a node was offline.", "committedDate": "2020-04-23T16:41:24Z", "type": "commit"}, {"oid": "a6f90d48d7b515def83e4a60a994f48a86ba4da2", "url": "https://github.com/hortonworks/cloudbreak/commit/a6f90d48d7b515def83e4a60a994f48a86ba4da2", "message": "CB-6705: Register multiple cluster proxy service for FreeIPA HA\n\nRegister one cluster proxy service for each FreeIPA instance and an\nadditional one for the primary gateway for use during provisioning.\nPrefer using the primary gateway freeipa instance but if it is\noffline, then pick an instance of freeipa that is working.\nUse the instance specific cluster proxy connections for health status,\nthat way the health status doesn't require both the checked node and\nprimary gateway node to be online.\n\nWhen reporting the health status for FreeIPA's UI status, report an\nerror if any instance is offline. That way there is an easy way for a\ncustomer to know if manual repair operation is required. In the future\nwhen the repair happens automatically, the status should only report a\nfailure when all nodes are offline.\n\nIn addition to the tests, this was manually tested by bringing\nindividual FreeIPA instances offline and validating the status is\nreported correctly. FreeIPA management service operations were also\nvalidated to work when a node was offline.", "committedDate": "2020-04-23T16:41:24Z", "type": "forcePushed"}]}