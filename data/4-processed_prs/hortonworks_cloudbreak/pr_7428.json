{"pr_number": 7428, "pr_title": "CDPCP-1549. Fix issue where user sync failure is not recorded", "pr_createdAt": "2020-02-28T17:35:29Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7428", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r385954024", "bodyText": "I would catch Exceeption", "author": "giladwolff", "createdAt": "2020-02-28T22:35:33Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,16 +117,22 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n-                });\n+            try {\n+                boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                if (fullSync) {\n+                    long currentTime = Instant.now().toEpochMilli();\n+                    stacks.forEach(stack -> {\n+                        UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                        userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                        userSyncStatusService.save(userSyncStatus);\n+                    });\n+                }\n+                asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n+            } catch (RuntimeException e) {", "originalCommit": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyMzM1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386523357", "bodyText": "I catch RuntimeException because there isn't anything in the code that throws a checked exception. I can go either way on this one.\nCatch RuntimeException - we narrow the exceptions classes that we catch. if the try code is changed in the future to throw a checked exception then we will know at compile time that we need to handle that.\nCatch Exception - the sematics of this block are to clean up if \"anything\" goes wrong and Exception better represents \"anything\" than RuntimeException does. As a counterpoint, then what about Throwable? It may make sense here to catch Throwable because we still want to clean up if an Error occurs.", "author": "handavid", "createdAt": "2020-03-02T17:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTA1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386715059", "bodyText": "I changed these to catch Throwable and attempt to save the operation failure to the database.", "author": "handavid", "createdAt": "2020-03-02T23:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDIxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r385954218", "bodyText": "Why not Exception?", "author": "giladwolff", "createdAt": "2020-02-28T22:36:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -184,7 +190,7 @@ private void internalSynchronizeUsers(String operationId, String accountId, Stri\n             operationService.completeOperation(accountId, operationId, success, failure);\n         } catch (RuntimeException e) {", "originalCommit": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyMzc2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386523765", "bodyText": "same reasoning as above", "author": "handavid", "createdAt": "2020-03-02T17:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDIxOA=="}], "type": "inlineReview"}, {"oid": "3101f715285c912b8c3db51d219bc67019749534", "url": "https://github.com/hortonworks/cloudbreak/commit/3101f715285c912b8c3db51d219bc67019749534", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-02T21:15:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODIzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386918232", "bodyText": "this looks almost the same like in internalSynchronizeUsers, could you move these into a separate method?", "author": "lacikaaa", "createdAt": "2020-03-03T10:12:45Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,22 +121,37 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n+            try {\n+                ThreadBasedUserCrnProvider.doAs(INTERNAL_USER_CRN, () -> {\n+                    boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                    if (fullSync) {\n+                        long currentTime = Instant.now().toEpochMilli();\n+                        stacks.forEach(stack -> {\n+                            UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                            userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                            userSyncStatusService.save(userSyncStatus);\n+                        });\n+                    }\n+                    asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n                 });\n+            } catch (Throwable t) {\n+                try {\n+                    LOGGER.error(\"Failed to start operation [{}]. Attempting to mark failure in database then re-throwing\", operation, t);\n+                    operationService.failOperation(accountId, operation.getOperationId(),\n+                            \"Failed to start operation: \" + t.getLocalizedMessage());\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Failed to mark operation [{}] as failed in database.\", operation, e);\n+                } finally {\n+                    throw t;\n+                }", "originalCommit": "3101f715285c912b8c3db51d219bc67019749534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDMyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210321", "bodyText": "done", "author": "handavid", "createdAt": "2020-03-03T18:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNTMxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387135315", "bodyText": "super nit: mind making it immutablelist?", "author": "giladwolff", "createdAt": "2020-03-03T16:21:58Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;", "originalCommit": "3101f715285c912b8c3db51d219bc67019749534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDQwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210408", "bodyText": "done", "author": "handavid", "createdAt": "2020-03-03T18:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNjExMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387136113", "bodyText": "can runnable be null? assert?", "author": "giladwolff", "createdAt": "2020-03-03T16:22:56Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;\n+\n+    /**\n+     * Create a CompositeTaskDecorator from the list of task decorators.\n+     *\n+     * @param decorators a list of task decorators to apply, from innermost to outermost.\n+     */\n+    public CompositeTaskDecorator(List<TaskDecorator> decorators) {\n+        requireNonNull(decorators, \"decorators is null\");\n+        this.decorators = List.copyOf(decorators);\n+    }\n+\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        Runnable decoratedRunnable = runnable;", "originalCommit": "3101f715285c912b8c3db51d219bc67019749534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDU3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210579", "bodyText": "added requireNonNull", "author": "handavid", "createdAt": "2020-03-03T18:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDU5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387140597", "bodyText": "First, user crn should probably renamed to actor CRN. Secondly, this looks a bit weird to me. why does the ThreadBaseUserCrnProvider has both a getUserCrn, and doAs interface that gets the user crn? What does doAs do actually? What happens at the end of doAs? Do you need to reset something?\nWe have examples in our code base in thunderhead git where we have thread local contexts that we set. We basically have a list of them per context. These contexts expose attach/detach operation and keep track of the previous context that was attached. So maybe you want something similar? Or maybe this is similar but the terms are different?", "author": "giladwolff", "createdAt": "2020-03-03T16:28:42Z", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/UserCrnTaskDecorator.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+\n+/**\n+ * Task decorator that propagates the user CRN from the caller to\n+ * the running task.\n+ */\n+public class UserCrnTaskDecorator implements TaskDecorator {\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        return () -> {\n+            ThreadBasedUserCrnProvider.doAs(userCrn, runnable);\n+        };\n+    }", "originalCommit": "3101f715285c912b8c3db51d219bc67019749534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODQxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387208417", "bodyText": "ThreadBasedUserCrnProvider has a ThreadLocal to hold the actor CRN. The UserCrnTaskDecorator (to be renamed) gets the actor crn from the calling thread threadlocal and returns a runnable that sets the actor on the executor thread using doAs. doAs will save the actor crn from the executor thread threadlocal, set that threadlocal to the specified actor, and restore the threadlocal to its original actor at the end of execution.", "author": "handavid", "createdAt": "2020-03-03T18:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDU5Nw=="}], "type": "inlineReview"}, {"oid": "37d542e62669bb3ba8336bee21c117eccd1c904c", "url": "https://github.com/hortonworks/cloudbreak/commit/37d542e62669bb3ba8336bee21c117eccd1c904c", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-03T17:36:08Z", "type": "forcePushed"}, {"oid": "6e6b85215f53cd793d7e738f2859342333a53a3e", "url": "https://github.com/hortonworks/cloudbreak/commit/6e6b85215f53cd793d7e738f2859342333a53a3e", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-03T18:31:40Z", "type": "forcePushed"}, {"oid": "ac45d8c6c401ee90ebeb6f8199cd7591c196411e", "url": "https://github.com/hortonworks/cloudbreak/commit/ac45d8c6c401ee90ebeb6f8199cd7591c196411e", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-03T18:37:30Z", "type": "forcePushed"}, {"oid": "53df3682afeebc5803a4f98a7050368534f1c775", "url": "https://github.com/hortonworks/cloudbreak/commit/53df3682afeebc5803a4f98a7050368534f1c775", "message": "CDPCP-1549. Catch and fail user sync operation\n\nThere was a gap where exceptions could cause user sync to fail but\nnot be recorded in the Operation database. This would prevent another\nuser sync from being accepted even though the current user sync was\nnot actually running. Eventually, the operation would be TIMEDOUT,\nallowing another user sync to be accepted.\n\nThis commit closes the gap by catching all RuntimeExceptions and\nrecording the failure in the Operation database.", "committedDate": "2020-03-04T16:50:05Z", "type": "commit"}, {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886", "url": "https://github.com/hortonworks/cloudbreak/commit/ac4d8f16f6d26cf6b777e8b1d216487bbc7db886", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-04T16:50:05Z", "type": "commit"}, {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886", "url": "https://github.com/hortonworks/cloudbreak/commit/ac4d8f16f6d26cf6b777e8b1d216487bbc7db886", "message": "CDPCP-1549. Run user sync internals as internal user\n\nAn authorization mismatch between the Operation db and the UserSyncStatus\ndb resulted in a bug where a user sync operation can be accepted, but\nwill fail when saving the user sync status. This commit changes the\nauthorization behavior so that authoriation is only performed on acceptance\nof the sync operation. All the user sync internals are run as the internal\nuser.\n\nSince UserSyncService internals use an AsyncTaskExecutor, the UserSyncConfig\nhas been updated to add a decorator for propagating the user crn to the\nsubmitted jobs.", "committedDate": "2020-03-04T16:50:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388126443", "bodyText": "why is it IAM and not FREEIPA as this service is not IAM?", "author": "lacikaaa", "createdAt": "2020-03-05T07:54:49Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -67,6 +69,8 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserSyncService.class);\n \n+    private static final String INTERNAL_USER_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "originalCommit": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3ODg0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388278843", "bodyText": "Thunderhead only recognizes the internal user if the service is IAM.", "author": "handavid", "createdAt": "2020-03-05T13:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMwMTUyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388301529", "bodyText": "There are other places as well where we use the internal crn to talk to UMS with FREEIPA service type", "author": "keyki", "createdAt": "2020-03-05T13:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2MjI5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388462298", "bodyText": "Verified locally and it doesn't work when freeipa is used instead of iam.", "author": "keyki", "createdAt": "2020-03-05T17:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}], "type": "inlineReview"}, {"oid": "cacc52ff6083b04435bbd21bad747c4a148fd993", "url": "https://github.com/hortonworks/cloudbreak/commit/cacc52ff6083b04435bbd21bad747c4a148fd993", "message": "CDPCP-1549. Reconcile usersyncstatus permissions with operation permissions", "committedDate": "2020-03-05T13:32:55Z", "type": "commit"}]}