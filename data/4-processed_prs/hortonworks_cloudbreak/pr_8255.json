{"pr_number": 8255, "pr_title": "CB-7082 - Use multiple implementations instead of instanceOf", "pr_createdAt": "2020-06-10T15:59:33Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8255", "timeline": [{"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "url": "https://github.com/hortonworks/cloudbreak/commit/dc2bac5c66993a862f101bf9bd08791392c3bbbf", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-11T08:40:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMjQwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438732404", "bodyText": "is there a specific need for LinkedHashMap? (same question for the bean below as well)", "author": "bergerdenes", "createdAt": "2020-06-11T12:00:38Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +39,19 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, EventDataUtilizer> eventDataUtilizers() {\n+        Map<Class, EventDataUtilizer> result = new LinkedHashMap<>(eventDataUtilizerImplementations.size());", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5MDcyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438790722", "bodyText": "passing back. is there a specific reason against LinkedHashMap? \ud83d\ude42", "author": "gregito", "createdAt": "2020-06-11T13:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5NjY5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438796696", "bodyText": "nice :D", "author": "bergerdenes", "createdAt": "2020-06-11T13:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDk3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438734977", "bodyText": "Why \"D\" ? :)\nNaming: EventDataConverter (okay, it is not a traditional converter, but still)", "author": "bergerdenes", "createdAt": "2020-06-11T12:06:13Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/EventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface EventDataUtilizer<D extends EventData> {", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5MTQ0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438791443", "bodyText": "D was for Data in my mind", "author": "gregito", "createdAt": "2020-06-11T13:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwMDk3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438800976", "bodyText": "Traditionally the type parameter is T\u00a0U V W", "author": "bergerdenes", "createdAt": "2020-06-11T13:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwODU1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438808559", "bodyText": "Then I'll change it to T", "author": "gregito", "createdAt": "2020-06-11T13:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438735176", "bodyText": "modifyAuditEventBuilderWithEventData  -> convertInBuilder", "author": "bergerdenes", "createdAt": "2020-06-11T12:06:38Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/EventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface EventDataUtilizer<D extends EventData> {\n+\n+    void modifyAuditEventBuilderWithEventData(AuditProto.AuditEvent.Builder auditEventBuilder, D source);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5MjI0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438792249", "bodyText": "there is no conversion inside the method hence your choice of name would be misleading in my opinion", "author": "gregito", "createdAt": "2020-06-11T13:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwNDM2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438804367", "bodyText": "AuditEventDataUpdater ?\nand modifyAuditEventBuilderWithEventData -> updateBuilder ?\nthoughts?", "author": "bergerdenes", "createdAt": "2020-06-11T13:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMTY0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438811644", "bodyText": "It's not updating any audit event data but the builder instead.\nMaybe AuditEventBuilderUpdater..? still kinda strange", "author": "gregito", "createdAt": "2020-06-11T14:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTc5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440611791", "bodyText": "class and method renamed", "author": "gregito", "createdAt": "2020-06-16T06:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzUyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767527", "bodyText": "after renaming the template class, the field name would be like eventDataConverters", "author": "bergerdenes", "createdAt": "2020-06-11T13:07:45Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -15,6 +22,12 @@\n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<EventDataUtilizer> eventDataUtilizerImplementations;", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5MzE4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438793180", "bodyText": "still, no conversion happens there", "author": "gregito", "createdAt": "2020-06-11T13:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMDI0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438810243", "bodyText": "AuditEventDataUpdaters ? as suggested above. Thoughts?", "author": "bergerdenes", "createdAt": "2020-06-11T14:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzY4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767686", "bodyText": "after renaming the template class, the field name would be like resultEventDataConverters", "author": "bergerdenes", "createdAt": "2020-06-11T13:08:00Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -15,6 +22,12 @@\n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<EventDataUtilizer> eventDataUtilizerImplementations;\n+\n+    @Inject\n+    private List<AuditEventDataUtilizer> auditEventDataUtilizerImplementations;", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzkxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767914", "bodyText": "utilizer -> converter", "author": "bergerdenes", "createdAt": "2020-06-11T13:08:26Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +39,19 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, EventDataUtilizer> eventDataUtilizers() {\n+        Map<Class, EventDataUtilizer> result = new LinkedHashMap<>(eventDataUtilizerImplementations.size());\n+        eventDataUtilizerImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwNTQ3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438805476", "bodyText": "still no conversion happens", "author": "gregito", "createdAt": "2020-06-11T13:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MDg3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438770870", "bodyText": "why \"D\"?\nNaming: ResultEventDataConverter (okay, it is not a traditional converter, but still)", "author": "bergerdenes", "createdAt": "2020-06-11T13:13:12Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AuditEventDataUtilizer<D extends ResultEventData> {", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwMjUyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438802521", "bodyText": "ResultEventDataUpdater then?", "author": "bergerdenes", "createdAt": "2020-06-11T13:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MDg3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTQ4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440611482", "bodyText": "it's not updating the ResultEventData but the builder class of the ResultEventData class, hence this choice of name is as straightforward as possible even if it's a little bit longer than it should be", "author": "gregito", "createdAt": "2020-06-16T06:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MTA2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438771062", "bodyText": "modifyAuditEventBuilderWithEventData -> convertInBuilder\nauditEventBuilder -> attemptAuditEventResultBuilder (too long, I know. or just builder)", "author": "bergerdenes", "createdAt": "2020-06-11T13:13:29Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AuditEventDataUtilizer<D extends ResultEventData> {\n+\n+    void modifyAuditEventBuilderWithEventData(AuditProto.AttemptAuditEventResult.Builder auditEventBuilder, D source);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMjEzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438812138", "bodyText": "builder will be fine", "author": "gregito", "createdAt": "2020-06-11T14:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NDI5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438774291", "bodyText": "Is this logging needed? If you insist on this logging, please move it to the Bean definition method in the Configuration class.", "author": "bergerdenes", "createdAt": "2020-06-11T13:18:52Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,49 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, EventDataUtilizer> eventDataUtilizer;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, EventDataUtilizer> eventDataUtilizer) {\n+        if (MapUtils.isNotEmpty(eventDataUtilizer)) {\n+            List<String> utilizers = new LinkedList<>();\n+            eventDataUtilizer.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);\n+            LOGGER.debug(\"The \" + AuditEventToGrpcAuditEventConverter.class.getSimpleName() + \" has got the following \"\n+                    + EventDataUtilizer.class.getSimpleName() + \" implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventToGrpcAuditEventConverter.class.getSimpleName() + \" has not got any \"\n+                    + EventDataUtilizer.class.getSimpleName() + \" implementation!\");\n+        }", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5Njk5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438796997", "bodyText": "logging is almost always welcomed in my opinion, but yes, this may be moved to the config class", "author": "gregito", "createdAt": "2020-06-11T13:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTE1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438775158", "bodyText": "you could completely go functional and throw out the utilizers list. just map the k:v to output and use Collectors.joining", "author": "bergerdenes", "createdAt": "2020-06-11T13:20:21Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,49 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, EventDataUtilizer> eventDataUtilizer;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, EventDataUtilizer> eventDataUtilizer) {\n+        if (MapUtils.isNotEmpty(eventDataUtilizer)) {\n+            List<String> utilizers = new LinkedList<>();\n+            eventDataUtilizer.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwMTUyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438801529", "bodyText": "I wouldn't go full functional just because it wouldn't add that much readability for me at least", "author": "gregito", "createdAt": "2020-06-11T13:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMTAxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438811012", "bodyText": "well :D", "author": "bergerdenes", "createdAt": "2020-06-11T14:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMTM4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438811383", "bodyText": "just do it, it will be beautiful. trust me ;)", "author": "bergerdenes", "createdAt": "2020-06-11T14:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTQwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438775406", "bodyText": "Is this logging needed? If you insist on this logging, please move it to the Bean definition method in the Configuration class.", "author": "bergerdenes", "createdAt": "2020-06-11T13:20:46Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,22 +1,47 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AuditEventDataUtilizer> auditEventDataUtilizers;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AuditEventDataUtilizer> auditEventDataUtilizers) {\n+        if (MapUtils.isNotEmpty(auditEventDataUtilizers)) {\n+            List<String> utilizers = new LinkedList<>();\n+            auditEventDataUtilizers.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);\n+            LOGGER.debug(\"The \" + AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class.getSimpleName() + \" has got the following \"\n+                    + AuditEventDataUtilizer.class.getSimpleName() + \" implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class.getSimpleName() + \" has not got any \"\n+                    + AuditEventDataUtilizer.class.getSimpleName() + \" implementation!\");\n+        }", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTM2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781368", "bodyText": "please rename consistently with interface name", "author": "bergerdenes", "createdAt": "2020-06-11T13:30:17Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestDataUtilizer.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultApiRequestDataUtilizer implements AuditEventDataUtilizer<ResultApiRequestData> {", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTQ2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781462", "bodyText": "please rename consistently with interface name", "author": "bergerdenes", "createdAt": "2020-06-11T13:30:26Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultServiceEventDataUtilizer implements AuditEventDataUtilizer<ResultServiceEventData> {", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTgxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781813", "bodyText": "please rename consistently with base class", "author": "bergerdenes", "createdAt": "2020-06-11T13:30:58Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ServiceEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ServiceEventDataUtilizer implements EventDataUtilizer<ServiceEventData> {", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MzAzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438783039", "bodyText": "times(0) -> never() (although its just cosmetics)", "author": "bergerdenes", "createdAt": "2020-06-11T13:32:24Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -49,7 +63,18 @@ void testPreventPossibleNullValuesServiceApiRequestResult() {\n                 .withResourceCrns(CRNS)\n                 .build();\n         AttemptAuditEventResult source = makeMinimalAttemptAuditEventResult(resultServiceEventData);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n+\n         underTest.convert(source);\n+        verify(mockAuditEventDataUtilizer, times(1)).modifyAuditEventBuilderWithEventData(any(), any());\n+    }\n+\n+    @Test\n+    void testWhenResultEventDataIsNullThenNoUtilizerCallHappens() {\n+        AttemptAuditEventResult source = makeMinimalAttemptAuditEventResult(null);\n+\n+        underTest.convert(source);\n+        verify(mockAuditEventDataUtilizer, times(0)).modifyAuditEventBuilderWithEventData(any(), any());", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwNDI2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438804260", "bodyText": "oh, this never() stuff is new to me, thanks!", "author": "gregito", "createdAt": "2020-06-11T13:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4NDM3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438784373", "bodyText": "I prefer declarative @Mock but it's up to your taste.", "author": "bergerdenes", "createdAt": "2020-06-11T13:33:47Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -35,7 +41,15 @@\n \n     private static final String RESPONSE_PARAMETERS = \"responseParameters\";\n \n-    private final AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter();\n+    private AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter underTest;\n+\n+    private AuditEventDataUtilizer mockAuditEventDataUtilizer;\n+\n+    @BeforeEach\n+    void setUp() {\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(new LinkedHashMap<>());\n+        mockAuditEventDataUtilizer = mock(AuditEventDataUtilizer.class);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4Nzc4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438787789", "bodyText": "I miss these tests in for the recently refactored converter classes", "author": "bergerdenes", "createdAt": "2020-06-11T13:37:22Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -115,13 +139,20 @@ void convertWithApiRequestData() {\n                 .build();\n         AuditEvent source = makeAuditEvent(actor, eventData);\n \n+        underTest = new AuditEventToGrpcAuditEventConverter(createMockUtilizer(ApiRequestData.class));\n+\n         AuditProto.AuditEvent target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AuditEvent.EventTypeCase.APIREQUESTDATA);\n-        assertThat(target.getApiRequestData().getApiVersion()).isEqualTo(API_VERSION);\n-        assertThat(target.getApiRequestData().getMutating()).isEqualTo(MUTATING);\n-        assertThat(target.getApiRequestData().getRequestParameters()).isEqualTo(REQUEST_PARAMETERS);\n-        assertThat(target.getApiRequestData().getUserAgent()).isEqualTo(USER_AGENT);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc5Mzk2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438793963", "bodyText": "you're right, I'll make them reappear in new test cases. same goes for the other requests as well", "author": "gregito", "createdAt": "2020-06-11T13:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4Nzc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODIzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788236", "bodyText": "miss these tests in for the recently refactored converter classes", "author": "bergerdenes", "createdAt": "2020-06-11T13:37:53Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -97,11 +121,11 @@ void convertWithServiceEventData() {\n                 .build();\n         AuditEvent source = makeAuditEvent(actor, eventData);\n \n+        underTest = new AuditEventToGrpcAuditEventConverter(createMockUtilizer(ServiceEventData.class));\n+\n         AuditProto.AuditEvent target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AuditEvent.EventTypeCase.SERVICEEVENTDATA);\n-        assertThat(target.getServiceEventData().getDetailsVersion()).isEqualTo(SERVICE_EVENT_VERSION);\n-        assertThat(target.getServiceEventData().getEventDetails()).isEqualTo(SERVICE_EVENT_DETAILS);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODUwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788507", "bodyText": "I miss these tests in for the recently refactored converter classes", "author": "bergerdenes", "createdAt": "2020-06-11T13:38:09Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -68,22 +93,22 @@ void convertWithResultServiceEventData() {\n                 .withResultDetails(RESULT_DETAILS)\n                 .build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTSERVICEEVENTDATA);\n-        assertThat(target.getResultServiceEventData().getResourceCrnList()).hasSameElementsAs(CRNS);\n-        assertThat(target.getResultServiceEventData().getResultDetails()).isEqualTo(RESULT_DETAILS);\n+        verify(mockAuditEventDataUtilizer, times(1)).modifyAuditEventBuilderWithEventData(any(), any());\n     }\n \n     @Test\n     void convertWithResultApiRequestData() {\n         ResultApiRequestData rsed = ResultApiRequestData.builder().withResponseParameters(RESPONSE_PARAMETERS).build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultApiRequestData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTAPIREQUESTDATA);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MTQzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r439971433", "bodyText": "because the mock does the actual data manipulation this test case line is not relevant anymore", "author": "gregito", "createdAt": "2020-06-15T07:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODc3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788775", "bodyText": "I miss these tests in for the recently refactored converter classes", "author": "bergerdenes", "createdAt": "2020-06-11T13:38:29Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -68,22 +93,22 @@ void convertWithResultServiceEventData() {\n                 .withResultDetails(RESULT_DETAILS)\n                 .build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTSERVICEEVENTDATA);\n-        assertThat(target.getResultServiceEventData().getResourceCrnList()).hasSameElementsAs(CRNS);\n-        assertThat(target.getResultServiceEventData().getResultDetails()).isEqualTo(RESULT_DETAILS);", "originalCommit": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dda634562b104cbe877c4200a824a4182f8fe30a", "url": "https://github.com/hortonworks/cloudbreak/commit/dda634562b104cbe877c4200a824a4182f8fe30a", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-11T14:54:50Z", "type": "forcePushed"}, {"oid": "0f57740c47c2189f980b63c4087dae4a65370188", "url": "https://github.com/hortonworks/cloudbreak/commit/0f57740c47c2189f980b63c4087dae4a65370188", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-12T07:18:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NTU1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440165551", "bodyText": "auditEventBuilderUpdaters", "author": "bergerdenes", "createdAt": "2020-06-15T13:13:31Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -1,20 +1,40 @@\n package com.sequenceiq.cloudbreak.audit.config;\n \n \n+import com.sequenceiq.cloudbreak.audit.converter.AttemptAuditEventResultBuilderUpdater;\n+import com.sequenceiq.cloudbreak.audit.converter.AuditEventBuilderUpdater;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import io.netty.util.internal.StringUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n \n-import io.netty.util.internal.StringUtil;\n+import javax.inject.Inject;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n \n @Configuration\n public class AuditConfig {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditConfig.class);\n+\n     @Value(\"${altus.audit.host:}\")\n     private String endpoint;\n \n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<AuditEventBuilderUpdater> auditEventBuilderUpdaterImplementations;", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NTgwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440165806", "bodyText": "attemptAuditEventResultBuilderUpdaters\nstill long enough", "author": "bergerdenes", "createdAt": "2020-06-15T13:13:58Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -1,20 +1,40 @@\n package com.sequenceiq.cloudbreak.audit.config;\n \n \n+import com.sequenceiq.cloudbreak.audit.converter.AttemptAuditEventResultBuilderUpdater;\n+import com.sequenceiq.cloudbreak.audit.converter.AuditEventBuilderUpdater;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import io.netty.util.internal.StringUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n \n-import io.netty.util.internal.StringUtil;\n+import javax.inject.Inject;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n \n @Configuration\n public class AuditConfig {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditConfig.class);\n+\n     @Value(\"${altus.audit.host:}\")\n     private String endpoint;\n \n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<AuditEventBuilderUpdater> auditEventBuilderUpdaterImplementations;\n+\n+    @Inject\n+    private List<AttemptAuditEventResultBuilderUpdater> attemptAuditEventResultBuilderUpdaterImplementations;", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NjM5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440166390", "bodyText": "Collectors.joining(\",\")", "author": "bergerdenes", "createdAt": "2020-06-15T13:14:57Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2Njg5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440166899", "bodyText": "return is not needed, neither the {}", "author": "bergerdenes", "createdAt": "2020-06-15T13:15:42Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            String utilizerListMessage = String.join(\",\", eventDataUtilizers);\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has the following implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has no any implementation!\");\n+        }\n+        return result;\n+    }\n+\n+    @Bean\n+    public Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers() {\n+        Map<Class, AttemptAuditEventResultBuilderUpdater> result = new LinkedHashMap<>(attemptAuditEventResultBuilderUpdaterImplementations.size());\n+        attemptAuditEventResultBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> auditEventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NzI4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440167281", "bodyText": "Collectors.joining", "author": "bergerdenes", "createdAt": "2020-06-15T13:16:19Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            String utilizerListMessage = String.join(\",\", eventDataUtilizers);\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has the following implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has no any implementation!\");\n+        }\n+        return result;\n+    }\n+\n+    @Bean\n+    public Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers() {\n+        Map<Class, AttemptAuditEventResultBuilderUpdater> result = new LinkedHashMap<>(attemptAuditEventResultBuilderUpdaterImplementations.size());\n+        attemptAuditEventResultBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> auditEventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            result.forEach((type, utilizer) -> auditEventDataUtilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", auditEventDataUtilizers);", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODIzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168239", "bodyText": "it is not \"utilizer\" anymore", "author": "bergerdenes", "createdAt": "2020-06-15T13:17:47Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,22 +1,31 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers;", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODY2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168667", "bodyText": "\"WithEventData\" could be omitted\nmoreover, update would be adequate", "author": "bergerdenes", "createdAt": "2020-06-15T13:18:28Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventBuilderUpdater.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface AuditEventBuilderUpdater<T extends EventData> {\n+\n+    void updateAuditEventBuilderWithEventData(AuditProto.AuditEvent.Builder auditEventBuilder, T source);", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjA4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440602088", "bodyText": "pls see below my comment regarding to this", "author": "gregito", "createdAt": "2020-06-16T05:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODc5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168797", "bodyText": "not \"utilizer\" anymore", "author": "bergerdenes", "createdAt": "2020-06-15T13:18:40Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,33 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, AuditEventBuilderUpdater> eventDataUtilizer;", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDU5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440174594", "bodyText": "update would be adequate", "author": "bergerdenes", "createdAt": "2020-06-15T13:28:01Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultBuilderUpdater.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AttemptAuditEventResultBuilderUpdater<T extends ResultEventData> {\n+\n+    void updateAttemptAuditEventResultBuilderWithEventData(AuditProto.AttemptAuditEventResult.Builder builder, T source);", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5ODAwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440598008", "bodyText": "update tells nothing about the functionality of the method. since we're not using javadocs, the method name is the only way to indicate what would the function do when somebody calls it", "author": "gregito", "createdAt": "2020-06-16T05:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzE0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440607145", "bodyText": "well actually, your idea has gone through my head and it's not as senseless as I thought before, so I'm gonna rename it to update since the class name already contains a lot of information", "author": "gregito", "createdAt": "2020-06-16T06:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MjA5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440182096", "bodyText": "ResultApiRequestResultBuilderUpdaterAttempt is a way overcomplicated name.\nI would have still stuck to naming the interface to reflect the converter nature: AttemptAuditEventResultConverter\nand then name this class like ResultApiRequestConverter\nThoughts?", "author": "bergerdenes", "createdAt": "2020-06-15T13:39:29Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestResultBuilderUpdaterAttempt.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultApiRequestResultBuilderUpdaterAttempt implements AttemptAuditEventResultBuilderUpdater<ResultApiRequestData> {", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440597183", "bodyText": "but it's still not converting anything :D\nAnyway I've renamed the class to refer to the implemented generic class", "author": "gregito", "createdAt": "2020-06-16T05:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MjU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440182593", "bodyText": "same as above. this name is way too compex", "author": "bergerdenes", "createdAt": "2020-06-15T13:40:07Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventResultBuilderUpdaterAttempt.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultServiceEventResultBuilderUpdaterAttempt implements AttemptAuditEventResultBuilderUpdater<ResultServiceEventData> {", "originalCommit": "0f57740c47c2189f980b63c4087dae4a65370188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8f96166859b53cb860f65c9416df911da68d8916", "url": "https://github.com/hortonworks/cloudbreak/commit/8f96166859b53cb860f65c9416df911da68d8916", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-15T15:09:43Z", "type": "forcePushed"}, {"oid": "864f2277527a0b13dc29ff29cbb7c6b32de82d75", "url": "https://github.com/hortonworks/cloudbreak/commit/864f2277527a0b13dc29ff29cbb7c6b32de82d75", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-15T21:33:48Z", "type": "forcePushed"}, {"oid": "646a2b0546dc0ef0f70f536880242fc7d49ade3e", "url": "https://github.com/hortonworks/cloudbreak/commit/646a2b0546dc0ef0f70f536880242fc7d49ade3e", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T04:51:51Z", "type": "forcePushed"}, {"oid": "f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "url": "https://github.com/hortonworks/cloudbreak/commit/f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T05:11:02Z", "type": "forcePushed"}, {"oid": "af5bfc4286864634e9d039edee46aa838719db75", "url": "https://github.com/hortonworks/cloudbreak/commit/af5bfc4286864634e9d039edee46aa838719db75", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T05:39:03Z", "type": "forcePushed"}, {"oid": "eec1e40ba435f621d02548b72c14cc9cb40e3679", "url": "https://github.com/hortonworks/cloudbreak/commit/eec1e40ba435f621d02548b72c14cc9cb40e3679", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T05:44:44Z", "type": "forcePushed"}, {"oid": "e03b9634216f10311ed6f1cf62b1d81468b95508", "url": "https://github.com/hortonworks/cloudbreak/commit/e03b9634216f10311ed6f1cf62b1d81468b95508", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T05:54:02Z", "type": "forcePushed"}, {"oid": "dc440cd706536c3b143c641e39fe2350f2518311", "url": "https://github.com/hortonworks/cloudbreak/commit/dc440cd706536c3b143c641e39fe2350f2518311", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-16T06:18:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2OTE5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441769199", "bodyText": "what is the reason behind this? besides, it is not consistent with the other converter class", "author": "bergerdenes", "createdAt": "2020-06-17T19:01:49Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,51 +1,46 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.AttemptAuditEventResultBuilderProvider;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n-    public AuditProto.AttemptAuditEventResult convert(AttemptAuditEventResult source) {\n-        AuditProto.AttemptAuditEventResult.Builder attemptAuditEventResultBuilder = prepareBuilderForCreateAuditEvent(source);\n-        updatResultEventData(attemptAuditEventResultBuilder, source.getResultEventData());\n-        return attemptAuditEventResultBuilder.build();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater;\n+\n+    private final AttemptAuditEventResultBuilderProvider builderProvider;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater,\n+                    AttemptAuditEventResultBuilderProvider builderProvider) {\n+        this.builderUpdater = builderUpdater;\n+        this.builderProvider = builderProvider;", "originalCommit": "dc440cd706536c3b143c641e39fe2350f2518311", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2NjU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441866593", "bodyText": "the reason behind this is to make the testing easier by abstracting these builders - like the AttemptAuditEventResult's builder - since they're coming outside from our codebase and the earlier tests were relying on their functionality. but it's easy to acknowledge that if somebody would have changed the functionality of some these builders behind the scene, the tests would fail even if our logic would be the same", "author": "gregito", "createdAt": "2020-06-17T22:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2OTE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2OTMwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441769300", "bodyText": "should be plural", "author": "bergerdenes", "createdAt": "2020-06-17T19:02:00Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,51 +1,46 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.AttemptAuditEventResultBuilderProvider;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n-    public AuditProto.AttemptAuditEventResult convert(AttemptAuditEventResult source) {\n-        AuditProto.AttemptAuditEventResult.Builder attemptAuditEventResultBuilder = prepareBuilderForCreateAuditEvent(source);\n-        updatResultEventData(attemptAuditEventResultBuilder, source.getResultEventData());\n-        return attemptAuditEventResultBuilder.build();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater;\n+\n+    private final AttemptAuditEventResultBuilderProvider builderProvider;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater,\n+                    AttemptAuditEventResultBuilderProvider builderProvider) {\n+        this.builderUpdater = builderUpdater;", "originalCommit": "dc440cd706536c3b143c641e39fe2350f2518311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MDA5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441770092", "bodyText": "should be plural", "author": "bergerdenes", "createdAt": "2020-06-17T19:03:28Z", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,33 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, AuditEventBuilderUpdater> builderUpdater;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, AuditEventBuilderUpdater> builderUpdater) {\n+        this.builderUpdater = builderUpdater;", "originalCommit": "dc440cd706536c3b143c641e39fe2350f2518311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "url": "https://github.com/hortonworks/cloudbreak/commit/f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-17T22:54:43Z", "type": "forcePushed"}, {"oid": "e71902e2d69431fe1112ac448787b988da8f8f83", "url": "https://github.com/hortonworks/cloudbreak/commit/e71902e2d69431fe1112ac448787b988da8f8f83", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-18T17:46:20Z", "type": "forcePushed"}, {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09", "url": "https://github.com/hortonworks/cloudbreak/commit/a25557bbd45adbdffac4af1daf828119981c6b09", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-19T20:38:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMjk3Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443602973", "bodyText": "not needed", "author": "bergerdenes", "createdAt": "2020-06-22T14:32:35Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ServiceEventDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ServiceEventDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ServiceEventDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ServiceEventDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ServiceEventData.Builder mockServiceEventDataBuilder;\n+\n+    @Mock\n+    private AuditProto.ServiceEventData mockAuditProtoServiceEventData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private ServiceEventData mockServiceEventData;\n+\n+    private ServiceEventDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewServiceEventDataBuilder()).thenReturn(mockServiceEventDataBuilder);\n+        when(mockServiceEventDataBuilder.build()).thenReturn(mockAuditProtoServiceEventData);\n+\n+        underTest = new ServiceEventDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockServiceEventDataBuilder, times(1)).build();\n+        verify(mockServiceEventData, times(1)).getVersion();\n+        verify(mockServiceEventData, times(1)).getEventDetails();\n+        verify(mockBuilderProvider, times(1)).getNewServiceEventDataBuilder();\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsNull() {\n+        when(mockServiceEventData.getVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setDetailsVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsEmpty() {\n+        when(mockServiceEventData.getVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setDetailsVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsNotNull() {\n+        String version = \"someVersion\";\n+        when(mockServiceEventData.getVersion()).thenReturn(version);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, times(1)).setDetailsVersion(any());\n+        verify(mockServiceEventDataBuilder, times(1)).setDetailsVersion(version);\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsNull() {\n+        when(mockServiceEventData.getEventDetails()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setEventDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsEmpty() {\n+        when(mockServiceEventData.getEventDetails()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setEventDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsNotNull() {\n+        String details = \"someDetail\";\n+        when(mockServiceEventData.getEventDetails()).thenReturn(details);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, times(1)).setEventDetails(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMzE1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443603151", "bodyText": "\"SomeData\"", "author": "bergerdenes", "createdAt": "2020-06-22T14:32:50Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ResultServiceEventDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ResultServiceEventDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ResultServiceEventDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ResultServiceEventData.Builder mockResultServiceEventDataBuilder;\n+\n+    @Mock\n+    private AuditProto.AttemptAuditEventResult.Builder mockAttemptAuditEventResult;\n+\n+    @Mock\n+    private ResultServiceEventData mockResultServiceEventData;\n+\n+    private ResultServiceEventDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewResultServiceEventDataBuilder()).thenReturn(mockResultServiceEventDataBuilder);\n+        when(mockResultServiceEventDataBuilder.addAllResourceCrn(any())).thenReturn(mockResultServiceEventDataBuilder);\n+\n+        underTest = new ResultServiceEventDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockResultServiceEventDataBuilder, times(1)).build();\n+        verify(mockResultServiceEventData, times(1)).getResultDetails();\n+        verify(mockResultServiceEventDataBuilder, times(1)).addAllResourceCrn(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsEmpty() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(\"\");\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, never()).setResultDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsNull() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(null);\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, never()).setResultDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsNotEmpty() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(\"SomeData\");\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, times(1)).setResultDetails(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMzM4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443603384", "bodyText": "\"someValue\"", "author": "bergerdenes", "createdAt": "2020-06-22T14:33:08Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ResultApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ResultApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private AuditProto.ResultApiRequestData.Builder mockResultApiRequestDataBuilder;\n+\n+    @Mock\n+    private ResultApiRequestDataBuilderProvider builderProvider;\n+\n+    @Mock\n+    private AuditProto.ResultApiRequestData mockResultApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AttemptAuditEventResult.Builder mockAttemptAuditEventResultBuilder;\n+\n+    @Mock\n+    private ResultApiRequestData resultEventData;\n+\n+    @Mock\n+    private ResultApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+\n+        when(builderProvider.getNewResultApiRequestDataBuilder()).thenReturn(mockResultApiRequestDataBuilder);\n+        when(mockResultApiRequestDataBuilder.build()).thenReturn(mockResultApiRequestData);\n+\n+        underTest = new ResultApiRequestDataBuildUpdater(builderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(builderProvider, times(1)).getNewResultApiRequestDataBuilder();\n+        verify(mockResultApiRequestDataBuilder, times(1)).build();\n+        verify(resultEventData, times(1)).getResponseParameters();\n+        verify(mockAttemptAuditEventResultBuilder, times(1)).setResultApiRequestData(mockResultApiRequestData);\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParametersAreEmpty() {\n+        when(resultEventData.getResponseParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, never()).setResponseParameters(anyString());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParameterIsNull() {\n+        when(resultEventData.getResponseParameters()).thenReturn(null);\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, never()).setResponseParameters(anyString());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParametersAreNotEmpty() {\n+        when(resultEventData.getResponseParameters()).thenReturn(\"someValue\");\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, times(1)).setResponseParameters(anyString());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNDIyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443604222", "bodyText": "not needed. same for all other properties", "author": "bergerdenes", "createdAt": "2020-06-22T14:34:11Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -147,13 +201,26 @@ void convertUnknownActorThrows() {\n         assertThatThrownBy(() -> underTest.convert(source)).isInstanceOf(IllegalArgumentException.class);\n     }\n \n-    private void assertGeneric(AuditProto.AuditEvent target) {\n-        assertThat(target.getId()).isEqualTo(UUID_ID);\n-        assertThat(target.getAccountId()).isEqualTo(ACCOUNT_ID);\n-        assertThat(target.getRequestId()).isEqualTo(REQUEST_ID);\n-        assertThat(target.getEventName()).isEqualTo(EVENT_NAME);\n-        assertThat(target.getEventSource()).isEqualTo(EVENT_SOURCE);\n-        assertThat(target.getSourceIPAddress()).isEqualTo(SOURCE_IP);\n+    private void assertGeneric() {\n+        verify(mockAuditEventBuilder, times(1)).setId(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTEwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605105", "bodyText": "not needed", "author": "bergerdenes", "createdAt": "2020-06-22T14:35:19Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(apiVersionValue);\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNull() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsEmpty() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNotEmpty() {\n+        String requestParams = \"someRequestParamValue\";\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(requestParams);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(requestParams);\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsNull() {\n+        when(mockApiRequestData.getUserAgent()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setUserAgent(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsEmpty() {\n+        when(mockApiRequestData.getUserAgent()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setUserAgent(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsNotEmpty() {\n+        String userAgentValue = \"someUserAgentValue\";\n+        when(mockApiRequestData.getUserAgent()).thenReturn(userAgentValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setUserAgent(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTIyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605228", "bodyText": "not needed", "author": "bergerdenes", "createdAt": "2020-06-22T14:35:28Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(apiVersionValue);\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNull() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsEmpty() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNotEmpty() {\n+        String requestParams = \"someRequestParamValue\";\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(requestParams);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTM4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605389", "bodyText": "not needed", "author": "bergerdenes", "createdAt": "2020-06-22T14:35:40Z", "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());", "originalCommit": "a25557bbd45adbdffac4af1daf828119981c6b09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7201f95649449d3d1dc732b288767cb6abb5ad93", "url": "https://github.com/hortonworks/cloudbreak/commit/7201f95649449d3d1dc732b288767cb6abb5ad93", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-23T11:30:26Z", "type": "forcePushed"}, {"oid": "b970faa2727a001cf8d605a543b7e65672336550", "url": "https://github.com/hortonworks/cloudbreak/commit/b970faa2727a001cf8d605a543b7e65672336550", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-23T11:33:02Z", "type": "forcePushed"}, {"oid": "c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "url": "https://github.com/hortonworks/cloudbreak/commit/c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-24T14:10:47Z", "type": "commit"}, {"oid": "c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "url": "https://github.com/hortonworks/cloudbreak/commit/c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "message": "CB-7082 - Use multiple implementations instead of instanceOf", "committedDate": "2020-06-24T14:10:47Z", "type": "forcePushed"}]}