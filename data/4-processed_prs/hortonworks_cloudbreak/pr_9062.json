{"pr_number": 9062, "pr_title": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "pr_createdAt": "2020-09-22T20:15:10Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9062", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NzI1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496447258", "bodyText": "do we expect to have multiple resources with the same resource reference?", "author": "pdarvasi", "createdAt": "2020-09-29T06:30:38Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/notification/RetrievalNotifier.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.sequenceiq.cloudbreak.cloud.notification;\n+\n+import java.util.List;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+\n+public interface RetrievalNotifier {\n+\n+    List<CloudResource> notifyRetrieveByResourceReference(String resourceReference);", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2MDI4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496960285", "bodyText": "Yes, because every stack creates a new managed image record into the resource table. But, I think it's enough to know that is there any image in REQUESTED status.", "author": "tiborpopovics", "createdAt": "2020-09-29T18:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NzI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczNzA5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496737097", "bodyText": "We should use getByResourceGroup() here, as we have the name and RG, too", "author": "pdarvasi", "createdAt": "2020-09-29T13:54:46Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureManagedImageService.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.microsoft.azure.PagedList;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.microsoft.azure.management.resources.fluentcore.arm.Region;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+\n+@Service\n+public class AzureManagedImageService {\n+\n+    public Optional<VirtualMachineCustomImage> getVirtualMachineCustomImage(String resourceGroup, String region, String imageName, AzureClient client) {\n+        PagedList<VirtualMachineCustomImage> customImageList = getCustomImageList(resourceGroup, client);\n+        return customImageList.stream()\n+                .filter(filterCustomImage(region, imageName))\n+                .findFirst();\n+    }\n+\n+    private PagedList<VirtualMachineCustomImage> getCustomImageList(String resourceGroup, AzureClient client) {\n+        return handleAuthException(() -> client.getAzure().virtualMachineCustomImages().listByResourceGroup(resourceGroup));", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc0ODc2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496748767", "bodyText": "pls log RG creation", "author": "pdarvasi", "createdAt": "2020-09-29T14:09:30Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageClient.class);\n+\n+    @Inject\n+    private RetrievalNotifier resourceRetrievalNotifier;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdService azureImageIdService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName, region);\n+\n+        if (getCustomImage(resourceGroup, client, region, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+                    customImage = getCustomImage(resourceGroup, client, region, imageName);\n+                    if (customImage.isEmpty()) {\n+                        LOGGER.error(\"Failed to create custom image.\", e);\n+                        updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+                        throw e;\n+                    }\n+                }\n+                updateImageStatus(ac, imageName, imageId, CommonStatus.CREATED);\n+                VirtualMachineCustomImage createdImage = customImage.orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+                return new AzureImage(createdImage.id(), createdImage.name(), true);\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String region, String imageName) {\n+        return azureManagedImageService.getVirtualMachineCustomImage(resourceGroup, region, imageName, client);\n+    }\n+\n+    private String getImageName(String fromVhdUri, String region) {\n+        String vhdName = fromVhdUri.substring(fromVhdUri.lastIndexOf('/') + 1);\n+        return CustomVMImageNameProvider.get(region, vhdName);\n+    }\n+\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+        LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n+        persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n+    }\n+\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+        LOGGER.debug(\"Updating image status to CREATED: {}\", imageId);\n+        persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n+    }\n+\n+    private String getRegion(AuthenticatedContext ac) {\n+        return ac.getCloudContext()\n+                .getLocation()\n+                .getRegion()\n+                .getRegionName();\n+    }\n+\n+    private String getImageId(String resourceGroup, AzureClient client, String imageName) {\n+        return azureImageIdService.generateImageId(client.getCurrentSubscription()\n+                .subscriptionId(), resourceGroup, imageName);\n+    }\n+\n+    public CloudResource buildCloudResource(String name, String id, CommonStatus status) {\n+        return CloudResource.builder()\n+                .name(name)\n+                .status(status)\n+                .persistent(true)\n+                .reference(id)\n+                .type(ResourceType.AZURE_MANAGED_IMAGE)\n+                .build();\n+    }\n+\n+    private boolean isRequested(String imageId) {\n+        List<CloudResource> imagesFromDatabase = getImagesFromDatabase(imageId);\n+        return imagesFromDatabase.stream().anyMatch(resource -> CommonStatus.REQUESTED.equals(resource.getStatus()));\n+    }\n+\n+    private List<CloudResource> getImagesFromDatabase(String imageId) {\n+        return resourceRetrievalNotifier.notifyRetrieveByResourceReference(imageId);\n+    }\n+\n+    private VirtualMachineCustomImage createCustomImage(String imageName, String resourceGroup, String fromVhdUri, String region,\n+            AzureClient client) {\n+        return handleAuthException(() -> {\n+            Azure azure = client.getAzure();\n+            LOGGER.info(\"check the existence of resource group '{}', creating if it doesn't exist on Azure side\", resourceGroup);\n+            if (!azure.resourceGroups()\n+                    .contain(resourceGroup)) {\n+                azure.resourceGroups()", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc0OTAyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496749027", "bodyText": "this should be in the same line as previous line", "author": "pdarvasi", "createdAt": "2020-09-29T14:09:52Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageClient.class);\n+\n+    @Inject\n+    private RetrievalNotifier resourceRetrievalNotifier;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdService azureImageIdService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName, region);\n+\n+        if (getCustomImage(resourceGroup, client, region, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+                    customImage = getCustomImage(resourceGroup, client, region, imageName);\n+                    if (customImage.isEmpty()) {\n+                        LOGGER.error(\"Failed to create custom image.\", e);\n+                        updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+                        throw e;\n+                    }\n+                }\n+                updateImageStatus(ac, imageName, imageId, CommonStatus.CREATED);\n+                VirtualMachineCustomImage createdImage = customImage.orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+                return new AzureImage(createdImage.id(), createdImage.name(), true);\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String region, String imageName) {\n+        return azureManagedImageService.getVirtualMachineCustomImage(resourceGroup, region, imageName, client);\n+    }\n+\n+    private String getImageName(String fromVhdUri, String region) {\n+        String vhdName = fromVhdUri.substring(fromVhdUri.lastIndexOf('/') + 1);\n+        return CustomVMImageNameProvider.get(region, vhdName);\n+    }\n+\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+        LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n+        persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n+    }\n+\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+        LOGGER.debug(\"Updating image status to CREATED: {}\", imageId);\n+        persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n+    }\n+\n+    private String getRegion(AuthenticatedContext ac) {\n+        return ac.getCloudContext()\n+                .getLocation()\n+                .getRegion()\n+                .getRegionName();\n+    }\n+\n+    private String getImageId(String resourceGroup, AzureClient client, String imageName) {\n+        return azureImageIdService.generateImageId(client.getCurrentSubscription()\n+                .subscriptionId(), resourceGroup, imageName);\n+    }\n+\n+    public CloudResource buildCloudResource(String name, String id, CommonStatus status) {\n+        return CloudResource.builder()\n+                .name(name)\n+                .status(status)\n+                .persistent(true)\n+                .reference(id)\n+                .type(ResourceType.AZURE_MANAGED_IMAGE)\n+                .build();\n+    }\n+\n+    private boolean isRequested(String imageId) {\n+        List<CloudResource> imagesFromDatabase = getImagesFromDatabase(imageId);\n+        return imagesFromDatabase.stream().anyMatch(resource -> CommonStatus.REQUESTED.equals(resource.getStatus()));\n+    }\n+\n+    private List<CloudResource> getImagesFromDatabase(String imageId) {\n+        return resourceRetrievalNotifier.notifyRetrieveByResourceReference(imageId);\n+    }\n+\n+    private VirtualMachineCustomImage createCustomImage(String imageName, String resourceGroup, String fromVhdUri, String region,\n+            AzureClient client) {\n+        return handleAuthException(() -> {\n+            Azure azure = client.getAzure();\n+            LOGGER.info(\"check the existence of resource group '{}', creating if it doesn't exist on Azure side\", resourceGroup);\n+            if (!azure.resourceGroups()\n+                    .contain(resourceGroup)) {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MDY4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496760689", "bodyText": "shouldn't we throw this, too instead of just logging it?", "author": "pdarvasi", "createdAt": "2020-09-29T14:24:10Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/task/image/AzureManagedImageCreationPoller.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.task.image;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component\n+public class AzureManagedImageCreationPoller {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureManagedImageCreationPoller.class);\n+\n+    private static final int MANAGED_IMAGE_CREATION_CHECKING_INTERVAL = 1000;\n+\n+    private static final int MANAGED_IMAGE_CREATION_CHECKING_MAX_ATTEMPT = 100;\n+\n+    private static final int MAX_FAILURE_TOLERANT = 5;\n+\n+    @Inject\n+    private AzurePollTaskFactory azurePollTaskFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler syncPollingScheduler;\n+\n+    public void startPolling(AuthenticatedContext ac, AzureManagedImageCreationCheckerContext checkerContext) {\n+        PollTask<Boolean> managedImageCreationStatusCheckerTask = azurePollTaskFactory.managedImageCreationCheckerTask(ac, checkerContext);\n+        try {\n+            LOGGER.info(\"Start polling managed image creation: {}\", checkerContext.getImageName());\n+            syncPollingScheduler.schedule(managedImageCreationStatusCheckerTask, MANAGED_IMAGE_CREATION_CHECKING_INTERVAL,\n+                    MANAGED_IMAGE_CREATION_CHECKING_MAX_ATTEMPT, MAX_FAILURE_TOLERANT);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Managed image creation failed.\", e);", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2MTU5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496761590", "bodyText": "should be \"SyncPollingScheduler <Boolean>\"", "author": "pdarvasi", "createdAt": "2020-09-29T14:25:16Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/task/image/AzureManagedImageCreationPoller.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.task.image;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component\n+public class AzureManagedImageCreationPoller {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureManagedImageCreationPoller.class);\n+\n+    private static final int MANAGED_IMAGE_CREATION_CHECKING_INTERVAL = 1000;\n+\n+    private static final int MANAGED_IMAGE_CREATION_CHECKING_MAX_ATTEMPT = 100;\n+\n+    private static final int MAX_FAILURE_TOLERANT = 5;\n+\n+    @Inject\n+    private AzurePollTaskFactory azurePollTaskFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler syncPollingScheduler;", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3Mjg3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496772875", "bodyText": "could you pls extract this logic to a createCustomImage() method? I know it is mainly not your code, but anyways :D", "author": "pdarvasi", "createdAt": "2020-09-29T14:39:12Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageClient.class);\n+\n+    @Inject\n+    private RetrievalNotifier resourceRetrievalNotifier;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdService azureImageIdService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName, region);\n+\n+        if (getCustomImage(resourceGroup, client, region, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+                    customImage = getCustomImage(resourceGroup, client, region, imageName);\n+                    if (customImage.isEmpty()) {\n+                        LOGGER.error(\"Failed to create custom image.\", e);\n+                        updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+                        throw e;\n+                    }\n+                }\n+                updateImageStatus(ac, imageName, imageId, CommonStatus.CREATED);\n+                VirtualMachineCustomImage createdImage = customImage.orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+                return new AzureImage(createdImage.id(), createdImage.name(), true);\n+            } else {\n+                return null;\n+            }", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDgzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r498374838", "bodyText": "pls check now", "author": "tiborpopovics", "createdAt": "2020-10-01T16:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3Mjg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMTY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496811690", "bodyText": "Could you pls write a unit test for this?", "author": "pdarvasi", "createdAt": "2020-09-29T15:25:49Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageIdService.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+\n+@Component\n+public class AzureImageIdService {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNjM5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496816397", "bodyText": "pls log the result", "author": "pdarvasi", "createdAt": "2020-09-29T15:30:14Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureManagedImageService.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.microsoft.azure.PagedList;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.microsoft.azure.management.resources.fluentcore.arm.Region;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+\n+@Service\n+public class AzureManagedImageService {\n+\n+    public Optional<VirtualMachineCustomImage> getVirtualMachineCustomImage(String resourceGroup, String region, String imageName, AzureClient client) {\n+        PagedList<VirtualMachineCustomImage> customImageList = getCustomImageList(resourceGroup, client);\n+        return customImageList.stream()\n+                .filter(filterCustomImage(region, imageName))\n+                .findFirst();", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg0NDk4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496844981", "bodyText": "this is a HUGE table, could we speed up the full table scan with including resourceType in the query, with probably an index on it?", "author": "pdarvasi", "createdAt": "2020-09-29T15:56:48Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/repository/ResourceRepository.java", "diffHunk": "@@ -31,4 +31,7 @@\n     @Query(\"SELECT r FROM Resource r WHERE r.stack.id = :stackId AND (r.resourceType NOT LIKE '%INSTANCE%' OR r.resourceType NOT LIKE '%DISK%')\")\n     Set<Resource> findAllByStackIdNotInstanceOrDisk(@Param(\"stackId\") Long stackId);\n \n+    @Query(\"SELECT r FROM Resource r WHERE r.resourceReference = :resourceReference\")", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg0Nzg4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496847887", "bodyText": "maybe not a List?", "author": "pdarvasi", "createdAt": "2020-09-29T15:59:30Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/eventbus/CloudResourceRetrievalService.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.sequenceiq.cloudbreak.service.eventbus;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.core.convert.ConversionService;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.service.ResourceRetrieval;\n+import com.sequenceiq.cloudbreak.domain.Resource;\n+import com.sequenceiq.cloudbreak.service.resource.ResourceService;\n+\n+@Component\n+public class CloudResourceRetrievalService implements ResourceRetrieval {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudResourceRetrievalService.class);\n+\n+    @Inject\n+    @Qualifier(\"conversionService\")\n+    private ConversionService conversionService;\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    public List<CloudResource> getByResourceReference(String resourceReference) {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg1Nzc5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r496857795", "bodyText": "Why not throw new CloudConnectorException instead?", "author": "pdarvasi", "createdAt": "2020-09-29T16:09:09Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageClient.class);\n+\n+    @Inject\n+    private RetrievalNotifier resourceRetrievalNotifier;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdService azureImageIdService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName, region);\n+\n+        if (getCustomImage(resourceGroup, client, region, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+                    customImage = getCustomImage(resourceGroup, client, region, imageName);\n+                    if (customImage.isEmpty()) {\n+                        LOGGER.error(\"Failed to create custom image.\", e);\n+                        updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+                        throw e;", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5b69148415bcd0e149d98cee31d643df52586439", "url": "https://github.com/hortonworks/cloudbreak/commit/5b69148415bcd0e149d98cee31d643df52586439", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-09-30T07:25:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNDQxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r494424419", "bodyText": "Nuance thing: PersistenceNotifier has many javadoc comments. Just for having the same style I would add them also here.", "author": "gergopapi2", "createdAt": "2020-09-24T15:46:10Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/notification/RetrievalNotifier.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.sequenceiq.cloudbreak.cloud.notification;\n+\n+import java.util.List;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+\n+public interface RetrievalNotifier {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzMjk3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r494432971", "bodyText": "It is just my personal taste that I dislike static methods: they are harder to mock. Were these non-static methods, one could mock them the usual way.", "author": "gergopapi2", "createdAt": "2020-09-24T15:57:54Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/util/AzureAuthExceptionHandler.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.util;\n+\n+import java.util.function.Supplier;\n+\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+\n+import com.microsoft.aad.adal4j.AuthenticationException;\n+import com.sequenceiq.cloudbreak.client.ProviderAuthenticationFailedException;\n+\n+public class AzureAuthExceptionHandler {\n+\n+    private AzureAuthExceptionHandler() {\n+    }\n+\n+    public static <T> T handleAuthException(Supplier<T> function) {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MjgzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r494442831", "bodyText": "I am not convinced this is a good name for this class. I would rename it to AzureImageService or something similar.\nReason: there is a class AzureClient, containing a large amount of methods, almost all pure azure calls. The AzureImageClient class here, however, contains only one such method.", "author": "gergopapi2", "createdAt": "2020-09-24T16:12:34Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {", "originalCommit": "d606791c32693ed91acb12286c0b3f52f2f4f1f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4MDQ5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497380492", "bodyText": "I would rename it to PersistenceRetriever. The name notifier is misleading as it is not notifying, but it is used to manipulate persisted resources", "author": "gergopapi2", "createdAt": "2020-09-30T09:44:54Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/notification/RetrievalNotifier.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.cloud.notification;\n+\n+import java.util.Optional;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+public interface RetrievalNotifier {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4MzY3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497383676", "bodyText": "The spring data jpa and the stream convention for naming methods returning optionals is to name them findSomething. We do not need to follow that convention but could actually come handy.", "author": "gergopapi2", "createdAt": "2020-09-30T09:50:03Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureManagedImageService.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+\n+@Service\n+public class AzureManagedImageService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureManagedImageService.class);\n+\n+    public Optional<VirtualMachineCustomImage> getVirtualMachineCustomImage(String resourceGroup, String imageName, AzureClient client) {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NTI1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497385255", "bodyText": "It would make sense to name it findVirtual ...", "author": "gergopapi2", "createdAt": "2020-09-30T09:52:35Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -88,6 +96,10 @@ public ImageStatusResult checkImageStatus(AuthenticatedContext ac, CloudStack st\n         }\n     }\n \n+    private Optional<VirtualMachineCustomImage> getVirtualMachineCustomImage(Image image, String imageResourceGroupName, AzureClient client) {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM5NjU0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497396549", "bodyText": "I would name it as findVirtual... as it resembles more the jpa and stream method naming convention.", "author": "gergopapi2", "createdAt": "2020-09-30T10:11:50Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/task/image/AzureManagedImageCreationChecker.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.task.image;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountChecker;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.task.PollBooleanStateTask;\n+\n+@Component(AzureManagedImageCreationChecker.NAME)\n+@Scope(\"prototype\")\n+public class AzureManagedImageCreationChecker extends PollBooleanStateTask {\n+\n+    public static final String NAME = \"AzureManagedImageCreationChecker\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StorageAccountChecker.class);\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    private final AzureManagedImageCreationCheckerContext context;\n+\n+    public AzureManagedImageCreationChecker(AuthenticatedContext authenticatedContext, AzureManagedImageCreationCheckerContext context) {\n+        super(authenticatedContext, false);\n+        this.context = context;\n+    }\n+\n+    @Override\n+    protected Boolean doCall() {\n+        LOGGER.info(\"Waiting for managed image to be created: {}\", context.getImageName());\n+        Optional<VirtualMachineCustomImage> virtualMachineCustomImage = getVirtualMachineCustomImage();\n+        if (virtualMachineCustomImage.isPresent()) {\n+            LOGGER.info(\"Managed image creation has been finished.\");\n+            return true;\n+        } else {\n+            LOGGER.info(\"Managed image creation not finished yet.\");\n+            return false;\n+        }\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> getVirtualMachineCustomImage() {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM5NzIwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497397209", "bodyText": "I would name it as ...Task", "author": "gergopapi2", "createdAt": "2020-09-30T10:13:07Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/task/image/AzureManagedImageCreationChecker.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.task.image;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountChecker;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.task.PollBooleanStateTask;\n+\n+@Component(AzureManagedImageCreationChecker.NAME)\n+@Scope(\"prototype\")\n+public class AzureManagedImageCreationChecker extends PollBooleanStateTask {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyMjcyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497422721", "bodyText": "I would extract this method to AzureClient. Currently almost all of the calls made to azure are located in that class.\nA subsequent refactoring (another ticket) could be to extract thematic clients from that class.", "author": "gergopapi2", "createdAt": "2020-09-30T11:02:22Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler.handleAuthException;\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.RetrievalNotifier;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageClient.class);\n+\n+    @Inject\n+    private RetrievalNotifier resourceRetrievalNotifier;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdService azureImageIdService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n+\n+        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+                    customImage = getCustomImage(resourceGroup, client, imageName);\n+                    if (customImage.isEmpty()) {\n+                        LOGGER.error(\"Failed to create custom image.\", e);\n+                        updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+                        throw new CloudConnectorException(e);\n+                    }\n+                }\n+                updateImageStatus(ac, imageName, imageId, CommonStatus.CREATED);\n+                VirtualMachineCustomImage createdImage = customImage.orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+                return new AzureImage(createdImage.id(), createdImage.name(), true);\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n+        return azureManagedImageService.getVirtualMachineCustomImage(resourceGroup, imageName, client);\n+    }\n+\n+    private String getImageName(String fromVhdUri, String region) {\n+        String vhdName = fromVhdUri.substring(fromVhdUri.lastIndexOf('/') + 1);\n+        return CustomVMImageNameProvider.get(region, vhdName);\n+    }\n+\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+        LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n+        persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n+    }\n+\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+        LOGGER.debug(\"Updating image status to CREATED: {}\", imageId);\n+        persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n+    }\n+\n+    private String getRegion(AuthenticatedContext ac) {\n+        return ac.getCloudContext()\n+                .getLocation()\n+                .getRegion()\n+                .getRegionName();\n+    }\n+\n+    private String getImageId(String resourceGroup, AzureClient client, String imageName) {\n+        return azureImageIdService.generateImageId(client.getCurrentSubscription()\n+                .subscriptionId(), resourceGroup, imageName);\n+    }\n+\n+    public CloudResource buildCloudResource(String name, String id, CommonStatus status) {\n+        return CloudResource.builder()\n+                .name(name)\n+                .status(status)\n+                .persistent(true)\n+                .reference(id)\n+                .type(ResourceType.AZURE_MANAGED_IMAGE)\n+                .build();\n+    }\n+\n+    private boolean isRequested(String imageId) {\n+        return getImagesFromDatabase(imageId).isPresent();\n+    }\n+\n+    private Optional<CloudResource> getImagesFromDatabase(String imageId) {\n+        return resourceRetrievalNotifier.notifyRetrieveByResourceReference(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE);\n+    }\n+\n+    private VirtualMachineCustomImage createCustomImage(String imageName, String resourceGroup, String fromVhdUri, String region, AzureClient client) {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4MTExMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r498381110", "bodyText": "I will create a ticket to refactor the AzureClient.", "author": "tiborpopovics", "createdAt": "2020-10-01T16:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyMjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4NTE5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497485192", "bodyText": "The code here in the catch clause is already extracted to AzureUtils.convertToCloudConnectorException method. You could reuse that.", "author": "gergopapi2", "createdAt": "2020-09-30T12:53:49Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/connector/resource/AzureStorageAccountBuilderService.java", "diffHunk": "@@ -31,14 +32,17 @@ public StorageAccount buildStorageAccount(AzureClient client, StorageAccountPara\n         String storageAccountName = storageAccountParameters.getStorageAccountName();\n         try {\n             String template = azureStorageAccountTemplateBuilder.build(storageAccountParameters);\n-            if (client.getTemplateDeploymentStatus(resourceGroupName, storageAccountName).isPermanent()) {\n+            ResourceStatus templateDeploymentStatus = client.getTemplateDeploymentStatus(resourceGroupName, storageAccountName);\n+            LOGGER.debug(\"Template deployment status retrieved: {}.\", templateDeploymentStatus);\n+            if (templateDeploymentStatus.isPermanent()) {\n+                LOGGER.debug(\"Creating template deployment.\");\n                 String parameters = new Json(Map.of()).getValue();\n                 Deployment templateDeployment = client.createTemplateDeployment(resourceGroupName, storageAccountName, template, parameters);\n                 LOGGER.debug(\"Created template deployment for storage account: {}\", templateDeployment.exportTemplate().template());\n             }\n             return client.getStorageAccountByGroup(resourceGroupName, storageAccountName);\n         } catch (CloudException e) {\n-            LOGGER.info(\"Provisioning error, cloud exception happened: \", e);\n+            LOGGER.warn(\"Provisioning error, cloud exception happened: \", e);", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTA0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497489045", "bodyText": "I would name this interface as ResourceRetriever, similar to ResourcePersister", "author": "gergopapi2", "createdAt": "2020-09-30T12:59:28Z", "path": "cloud-reactor-api/src/main/java/com/sequenceiq/cloudbreak/cloud/service/ResourceRetrieval.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.cloud.service;\n+\n+import java.util.Optional;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+public interface ResourceRetrieval {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwMDQyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497500420", "bodyText": "In the persister class there is a persist() method. It always returns null. By introducing a retrieving mechanism it might make sense to eliminate that method.", "author": "gergopapi2", "createdAt": "2020-09-30T13:16:36Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/cloud/CloudResourceRetrievalService.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.sequenceiq.freeipa.service.cloud;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.core.convert.ConversionService;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.service.ResourceRetrieval;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+\n+@Component\n+public class CloudResourceRetrievalService implements ResourceRetrieval {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudResourceRetrievalService.class);\n+\n+    @Inject\n+    @Qualifier(\"conversionService\")\n+    private ConversionService conversionService;\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Override\n+    public Optional<CloudResource> findByResourceReferenceAndStatusAndType(String resourceReference, CommonStatus status, ResourceType resourceType) {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwODg4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497508887", "bodyText": "Also, there are 3 interfaces for some kind of manipulation. It might make sense to apply a naming structure, like ResourcePersister - ResourceNamer - ResourceRetriever. Or, add a new package named as resource and move the classes there as Persister - Namer - Retriever. This could go as a followup refactoring jira.", "author": "gergopapi2", "createdAt": "2020-09-30T13:28:36Z", "path": "cloud-reactor-api/src/main/java/com/sequenceiq/cloudbreak/cloud/service/ResourceRetrieval.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.cloud.service;\n+\n+import java.util.Optional;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+public interface ResourceRetrieval {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxMjkwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497512903", "bodyText": "The test name is strange, I guess you wanted testGetByResourceReferenceShouldReturnEmptyList", "author": "gergopapi2", "createdAt": "2020-09-30T13:33:50Z", "path": "core/src/test/java/com/sequenceiq/cloudbreak/service/eventbus/CloudResourceRetrievalServiceTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.service.eventbus;\n+\n+import static com.sequenceiq.common.api.type.CommonStatus.REQUESTED;\n+import static com.sequenceiq.common.api.type.ResourceType.AZURE_MANAGED_IMAGE;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.springframework.core.convert.ConversionService;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.domain.Resource;\n+import com.sequenceiq.cloudbreak.service.resource.ResourceService;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class CloudResourceRetrievalServiceTest {\n+\n+    private static final String RESOURCE_REFERENCE = \"resource-reference\";\n+\n+    private static final String RESOURCE = \"resource1\";\n+\n+    @InjectMocks\n+    private CloudResourceRetrievalService underTest;\n+\n+    @Mock\n+    private ConversionService conversionService;\n+\n+    @Mock\n+    private ResourceService resourceService;\n+\n+    @Test\n+    public void testGetByResourceReferenceShouldReturnCloudResource() {\n+        Resource resource = createResource();\n+        CloudResource cloudResource = createCloudResource();\n+\n+        when(resourceService.findByResourceReferenceAndStatusAndType(RESOURCE_REFERENCE, REQUESTED, AZURE_MANAGED_IMAGE)).thenReturn(Optional.of(resource));\n+        when(conversionService.convert(resource, CloudResource.class)).thenReturn(cloudResource);\n+\n+        Optional<CloudResource> actual = underTest.findByResourceReferenceAndStatusAndType(RESOURCE_REFERENCE, REQUESTED, AZURE_MANAGED_IMAGE);\n+\n+        assertTrue(actual.isPresent());\n+        assertEquals(cloudResource, actual.get());\n+        verify(resourceService).findByResourceReferenceAndStatusAndType(RESOURCE_REFERENCE, REQUESTED, AZURE_MANAGED_IMAGE);\n+        verify(conversionService).convert(resource, CloudResource.class);\n+    }\n+\n+    @Test\n+    public void testGetByResourceReferenceShouldReturnCloudResourceShouldReturnEmptyList() {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyMjE0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r497522146", "bodyText": "I would call it AzureImageIdProviderService - and rename it later to ImageIdService once there are also other methods", "author": "gergopapi2", "createdAt": "2020-09-30T13:46:22Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageIdService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.Assert;\n+\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+\n+@Component\n+public class AzureImageIdService {", "originalCommit": "5b69148415bcd0e149d98cee31d643df52586439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa404382128f0c66570b879e6ec4a5040a1d02a6", "url": "https://github.com/hortonworks/cloudbreak/commit/fa404382128f0c66570b879e6ec4a5040a1d02a6", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-09-30T18:57:03Z", "type": "forcePushed"}, {"oid": "7224438e05b97ac24127ca87a4c20cbd41878166", "url": "https://github.com/hortonworks/cloudbreak/commit/7224438e05b97ac24127ca87a4c20cbd41878166", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-10-01T12:43:53Z", "type": "forcePushed"}, {"oid": "1eefe45b68dfa06f58a5323e77f94b46026464d2", "url": "https://github.com/hortonworks/cloudbreak/commit/1eefe45b68dfa06f58a5323e77f94b46026464d2", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-10-01T16:31:10Z", "type": "forcePushed"}, {"oid": "65e1845649437e14013fd77d4d5b4053f1cd6810", "url": "https://github.com/hortonworks/cloudbreak/commit/65e1845649437e14013fd77d4d5b4053f1cd6810", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-10-01T17:03:16Z", "type": "commit"}, {"oid": "65e1845649437e14013fd77d4d5b4053f1cd6810", "url": "https://github.com/hortonworks/cloudbreak/commit/65e1845649437e14013fd77d4d5b4053f1cd6810", "message": "CB-8722: Persist managed image status changes into database to fix the paralel image creation", "committedDate": "2020-10-01T17:03:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NTgwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r498645803", "bodyText": "I would move this class to package image -- sorry I did not write this in my first review.", "author": "gergopapi2", "createdAt": "2020-10-02T06:59:24Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdProviderService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceRetriever;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageService {", "originalCommit": "65e1845649437e14013fd77d4d5b4053f1cd6810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTMzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r498649336", "bodyText": "I would move code calling azure directly into AzureClient itself. It is very useful to keep all that code in one file (maybe later on in one package), in that way we know what operations we have defined on azure.", "author": "gergopapi2", "createdAt": "2020-10-02T07:09:52Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureManagedImageService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler;\n+\n+@Service\n+public class AzureManagedImageService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureManagedImageService.class);\n+\n+    @Inject\n+    private AzureAuthExceptionHandler azureAuthExceptionHandler;\n+\n+    public Optional<VirtualMachineCustomImage> findVirtualMachineCustomImage(String resourceGroup, String imageName, AzureClient client) {\n+        VirtualMachineCustomImage image = findImage(resourceGroup, imageName, client);\n+        if (image != null) {\n+            LOGGER.debug(\"Custom image {} is present in resource group {}\", imageName, resourceGroup);\n+            return Optional.of(image);\n+        } else {\n+            LOGGER.debug(\"Custom image {} is not present in resource group {}\", imageName, resourceGroup);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private VirtualMachineCustomImage findImage(String resourceGroup, String imageName, AzureClient client) {\n+        LOGGER.debug(\"Searching custom image {} in resource group {}\", imageName, resourceGroup);\n+        return azureAuthExceptionHandler.handleAuthException(() -> client.getAzure()\n+                .virtualMachineCustomImages()\n+                .getByResourceGroup(resourceGroup, imageName));", "originalCommit": "65e1845649437e14013fd77d4d5b4053f1cd6810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY1MTg5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9062#discussion_r498651899", "bodyText": "I would move this code into AzureClient, to have all operations on azure in one place.", "author": "gergopapi2", "createdAt": "2020-10-02T07:16:34Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/client/AzureImageService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.client;\n+\n+import static com.sequenceiq.cloudbreak.util.Benchmark.measure;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.Azure;\n+import com.microsoft.azure.management.compute.OperatingSystemStateTypes;\n+import com.microsoft.azure.management.compute.VirtualMachineCustomImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureImage;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureImageIdProviderService;\n+import com.sequenceiq.cloudbreak.cloud.azure.image.AzureManagedImageService;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.image.AzureManagedImageCreationPoller;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.AzureAuthExceptionHandler;\n+import com.sequenceiq.cloudbreak.cloud.azure.util.CustomVMImageNameProvider;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceNotifier;\n+import com.sequenceiq.cloudbreak.cloud.notification.PersistenceRetriever;\n+import com.sequenceiq.common.api.type.CommonStatus;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class AzureImageService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageService.class);\n+\n+    @Inject\n+    private PersistenceRetriever resourcePersistenceRetriever;\n+\n+    @Inject\n+    private PersistenceNotifier persistenceNotifier;\n+\n+    @Inject\n+    private AzureImageIdProviderService azureImageIdProviderService;\n+\n+    @Inject\n+    private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n+\n+    @Inject\n+    private AzureManagedImageService azureManagedImageService;\n+\n+    @Inject\n+    private AzureAuthExceptionHandler azureAuthExceptionHandler;\n+\n+    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n+        String region = getRegion(ac);\n+        String imageName = getImageName(fromVhdUri, region);\n+        String imageId = getImageId(resourceGroup, client, imageName);\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n+\n+        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n+            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n+            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+            return new AzureImage(imageId, imageName, true);\n+        } else {\n+            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n+            if (createIfNotFound) {\n+                saveImage(ac, imageName, imageId);\n+                Optional<VirtualMachineCustomImage> customImage;\n+                try {\n+                    customImage = Optional.of(createCustomImage(imageName, resourceGroup, fromVhdUri, region, client));\n+                } catch (CloudException e) {\n+                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n+                }\n+                return customImage.map(image -> createNewAzureImage(ac, image))\n+                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private AzureImage createNewAzureImage(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        String imageName = customImage.id();\n+        String imageId = customImage.name();\n+        updateImageStatus(ac, imageName, imageId, CommonStatus.CREATED);\n+        return new AzureImage(imageId, imageName, true);\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n+            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+        Optional<VirtualMachineCustomImage> customImage;\n+        azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n+        customImage = getCustomImage(resourceGroup, client, imageName);\n+        if (customImage.isEmpty()) {\n+            LOGGER.error(\"Failed to create custom image.\", e);\n+            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            throw new CloudConnectorException(e);\n+        }\n+        return customImage;\n+    }\n+\n+    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n+    }\n+\n+    private String getImageName(String fromVhdUri, String region) {\n+        String vhdName = fromVhdUri.substring(fromVhdUri.lastIndexOf('/') + 1);\n+        return CustomVMImageNameProvider.get(region, vhdName);\n+    }\n+\n+    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+        LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n+        persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n+    }\n+\n+    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n+        LOGGER.debug(\"Updating image status to CREATED: {}\", imageId);\n+        persistenceNotifier.notifyUpdate(buildCloudResource(imageName, imageId, commonStatus), ac.getCloudContext());\n+    }\n+\n+    private String getRegion(AuthenticatedContext ac) {\n+        return ac.getCloudContext()\n+                .getLocation()\n+                .getRegion()\n+                .getRegionName();\n+    }\n+\n+    private String getImageId(String resourceGroup, AzureClient client, String imageName) {\n+        return azureImageIdProviderService.generateImageId(client.getCurrentSubscription()\n+                .subscriptionId(), resourceGroup, imageName);\n+    }\n+\n+    public CloudResource buildCloudResource(String name, String id, CommonStatus status) {\n+        return CloudResource.builder()\n+                .name(name)\n+                .status(status)\n+                .persistent(true)\n+                .reference(id)\n+                .type(ResourceType.AZURE_MANAGED_IMAGE)\n+                .build();\n+    }\n+\n+    private boolean isRequested(String imageId) {\n+        return getImagesFromDatabase(imageId).isPresent();\n+    }\n+\n+    private Optional<CloudResource> getImagesFromDatabase(String imageId) {\n+        return resourcePersistenceRetriever.notifyRetrieve(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE);\n+    }\n+\n+    private VirtualMachineCustomImage createCustomImage(String imageName, String resourceGroup, String fromVhdUri, String region, AzureClient client) {\n+        return handleAuthException(() -> {\n+            Azure azure = client.getAzure();\n+            LOGGER.info(\"check the existence of resource group '{}', creating if it doesn't exist on Azure side\", resourceGroup);\n+            if (!azure.resourceGroups().contain(resourceGroup)) {\n+                LOGGER.info(\"Creating resource group: {}\", resourceGroup);\n+                azure.resourceGroups()\n+                        .define(resourceGroup)\n+                        .withRegion(region)\n+                        .create();\n+            }\n+            LOGGER.debug(\"Create custom image from '{}' with name '{}' into '{}' resource group (Region: {})\",\n+                    fromVhdUri, imageName, resourceGroup, region);\n+            return measure(() -> azure.virtualMachineCustomImages()\n+                    .define(imageName)\n+                    .withRegion(region)\n+                    .withExistingResourceGroup(resourceGroup)\n+                    .withLinuxFromVhd(fromVhdUri, OperatingSystemStateTypes.GENERALIZED)\n+                    .create(),\n+                    LOGGER, \"Custom image has been created under {} ms with name {}\", imageName);\n+        });", "originalCommit": "65e1845649437e14013fd77d4d5b4053f1cd6810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}