{"pr_number": 7899, "pr_title": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "pr_createdAt": "2020-04-26T16:08:48Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7899", "timeline": [{"oid": "840efea8f244b53f100a129b8feb039f84731c2e", "url": "https://github.com/hortonworks/cloudbreak/commit/840efea8f244b53f100a129b8feb039f84731c2e", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-04-27T06:23:31Z", "type": "forcePushed"}, {"oid": "ec2bc08d26696f64470473ef0c5530fdc58180ea", "url": "https://github.com/hortonworks/cloudbreak/commit/ec2bc08d26696f64470473ef0c5530fdc58180ea", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-04-30T09:17:59Z", "type": "forcePushed"}, {"oid": "c41009fba607a6fa2aa46bce93efd9b56c67095d", "url": "https://github.com/hortonworks/cloudbreak/commit/c41009fba607a6fa2aa46bce93efd9b56c67095d", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-04-30T09:19:54Z", "type": "forcePushed"}, {"oid": "489a3b6af9951718f8ba0426a9f9a010eb725c67", "url": "https://github.com/hortonworks/cloudbreak/commit/489a3b6af9951718f8ba0426a9f9a010eb725c67", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-04-30T11:19:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MTQwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7899#discussion_r419951406", "bodyText": "Complex and duplicated logic started to appear in this monster class. I think we should separate this logic differently. I think in an ideal world the test context should have only one await method. We should stop creating more await methods in this class, it makes the situation worse. We need only one method which gets some kind of poller. We will have different implementations for this poller, but the only responsibility this TestContext class should have is to call a poll method on the poller with some context related data that the poller can only get from this class.", "author": "foldik", "createdAt": "2020-05-05T08:41:59Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/context/TestContext.java", "diffHunk": "@@ -578,77 +600,117 @@ public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1\n         return await(entity, desiredStatuses, runningParameter, -1);\n     }\n \n-    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatuses,\n+    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus,", "originalCommit": "489a3b6af9951718f8ba0426a9f9a010eb725c67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MjMyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7899#discussion_r419952321", "bodyText": "This method should be eliminated and the wait strategy should be controlled from the method parameter. Ideally a poller of some kind.", "author": "foldik", "createdAt": "2020-05-05T08:43:40Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/context/TestContext.java", "diffHunk": "@@ -578,77 +600,117 @@ public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1\n         return await(entity, desiredStatuses, runningParameter, -1);\n     }\n \n-    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatuses,\n+    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus,\n             RunningParameter runningParameter, long pollingInterval) {\n         checkShutdown();\n \n         if (!getExceptionMap().isEmpty() && runningParameter.isSkipOnFail()) {\n-            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatuses));\n+            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatus));\n             return entity;\n         }\n         String key = getKeyForAwait(entity, entity.getClass(), runningParameter);\n         FreeIPATestDto awaitEntity = get(key);\n-        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatuses));\n+        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatus));\n         try {\n             if (awaitEntity == null) {\n                 throw new RuntimeException(\"Key provided but no result in resource map, key=\" + key);\n             }\n \n             FreeIPAClient freeIPAClient = getMicroserviceClient(FreeIPAClient.class, getWho(runningParameter).getAccessKey());\n-            String environmentCrn = awaitEntity.getRequest().getEnvironmentCrn();\n-            statuses.putAll(waitUtilSingleStatus.waitAndCheckStatuses(freeIPAClient, environmentCrn, desiredStatuses, pollingInterval));\n-            if (!desiredStatuses.equals(com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED)) {\n+            String environmentCrn = awaitEntity.getResponse().getEnvironmentCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForFreeIpaStatus(freeIPAClient, environmentCrn, desiredStatus, new FreeIpaOperationChecker<>());\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForFreeIpaStatus(freeIPAClient, environmentCrn, desiredStatus, new FreeIpaTerminationChecker<>());\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired environment state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            statuses.putAll(Map.of(\"status\", awaitEntity.getResponse().getStatus().name()));\n+            if (!desiredStatus.equals(com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED)) {\n                 awaitEntity.refresh(getTestContext(), null);\n             }\n         } catch (Exception e) {\n             if (runningParameter.isLogError()) {\n-                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName());\n+                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName());\n                 Log.await(null, String.format(\"[%s] is failed for statuses %s: %s, name: %s\",\n-                        entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName()));\n+                        entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName()));\n             }\n-            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatuses, e);\n+            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatus, e);\n         }\n         return entity;\n     }\n \n+    private Result<WaitResult, Exception> waitForFreeIpaStatus(FreeIPAClient freeIPAClient, String environmentCrn,\n+            com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus, ExceptionChecker<FreeIpaWaitObject> statusChecker) {\n+        return freeIpaWaitService.waitWithTimeout(\n+                statusChecker,\n+                new FreeIpaWaitObject(freeIPAClient, environmentCrn, desiredStatus),\n+                pollingInterval, maxRetry, 1);\n+    }\n+\n     public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatuses,\n             RunningParameter runningParameter) {\n         return await(entity, desiredStatuses, runningParameter, -1);\n     }\n \n-    public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatuses,\n+    public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatus,", "originalCommit": "489a3b6af9951718f8ba0426a9f9a010eb725c67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MjYzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7899#discussion_r419952639", "bodyText": "This should be eliminated as well.", "author": "foldik", "createdAt": "2020-05-05T08:44:11Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/context/TestContext.java", "diffHunk": "@@ -578,77 +600,117 @@ public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1\n         return await(entity, desiredStatuses, runningParameter, -1);\n     }\n \n-    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatuses,\n+    public FreeIPATestDto await(FreeIPATestDto entity, com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus,\n             RunningParameter runningParameter, long pollingInterval) {\n         checkShutdown();\n \n         if (!getExceptionMap().isEmpty() && runningParameter.isSkipOnFail()) {\n-            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatuses));\n+            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatus));\n             return entity;\n         }\n         String key = getKeyForAwait(entity, entity.getClass(), runningParameter);\n         FreeIPATestDto awaitEntity = get(key);\n-        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatuses));\n+        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatus));\n         try {\n             if (awaitEntity == null) {\n                 throw new RuntimeException(\"Key provided but no result in resource map, key=\" + key);\n             }\n \n             FreeIPAClient freeIPAClient = getMicroserviceClient(FreeIPAClient.class, getWho(runningParameter).getAccessKey());\n-            String environmentCrn = awaitEntity.getRequest().getEnvironmentCrn();\n-            statuses.putAll(waitUtilSingleStatus.waitAndCheckStatuses(freeIPAClient, environmentCrn, desiredStatuses, pollingInterval));\n-            if (!desiredStatuses.equals(com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED)) {\n+            String environmentCrn = awaitEntity.getResponse().getEnvironmentCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForFreeIpaStatus(freeIPAClient, environmentCrn, desiredStatus, new FreeIpaOperationChecker<>());\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForFreeIpaStatus(freeIPAClient, environmentCrn, desiredStatus, new FreeIpaTerminationChecker<>());\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired environment state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            statuses.putAll(Map.of(\"status\", awaitEntity.getResponse().getStatus().name()));\n+            if (!desiredStatus.equals(com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status.DELETE_COMPLETED)) {\n                 awaitEntity.refresh(getTestContext(), null);\n             }\n         } catch (Exception e) {\n             if (runningParameter.isLogError()) {\n-                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName());\n+                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName());\n                 Log.await(null, String.format(\"[%s] is failed for statuses %s: %s, name: %s\",\n-                        entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName()));\n+                        entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName()));\n             }\n-            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatuses, e);\n+            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatus, e);\n         }\n         return entity;\n     }\n \n+    private Result<WaitResult, Exception> waitForFreeIpaStatus(FreeIPAClient freeIPAClient, String environmentCrn,\n+            com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.Status desiredStatus, ExceptionChecker<FreeIpaWaitObject> statusChecker) {\n+        return freeIpaWaitService.waitWithTimeout(\n+                statusChecker,\n+                new FreeIpaWaitObject(freeIPAClient, environmentCrn, desiredStatus),\n+                pollingInterval, maxRetry, 1);\n+    }\n+\n     public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatuses,\n             RunningParameter runningParameter) {\n         return await(entity, desiredStatuses, runningParameter, -1);\n     }\n \n-    public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatuses,\n+    public EnvironmentTestDto await(EnvironmentTestDto entity, EnvironmentStatus desiredStatus,\n             RunningParameter runningParameter, long pollingInterval) {\n         checkShutdown();\n \n         if (!getExceptionMap().isEmpty() && runningParameter.isSkipOnFail()) {\n-            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatuses));\n+            Log.await(LOGGER, String.format(\"Should be skipped beacause of previous error. await [%s]\", desiredStatus));\n             return entity;\n         }\n         String key = getKeyForAwait(entity, entity.getClass(), runningParameter);\n         EnvironmentTestDto awaitEntity = get(key);\n-        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatuses));\n+        Log.await(LOGGER, String.format(\"%s for %s\", key, desiredStatus));\n         try {\n             if (awaitEntity == null) {\n                 throw new RuntimeException(\"Key provided but no result in resource map, key=\" + key);\n             }\n \n             EnvironmentClient environmentClient = getMicroserviceClient(EnvironmentClient.class, getWho(runningParameter).getAccessKey());\n-            String environmentName = awaitEntity.getResponse().getName();\n-            statuses.putAll(waitUtilSingleStatus.waitAndCheckStatuses(environmentClient, environmentName, desiredStatuses, pollingInterval));\n-            if (!desiredStatuses.equals(EnvironmentStatus.ARCHIVED)) {\n+            String environmentCrn = awaitEntity.getResponse().getCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case ENV_STOPPED:\n+                    waitForEnvironmentStatus(environmentClient, environmentCrn, desiredStatus, new EnvironmentOperationChecker<>());\n+                    break;\n+                case ARCHIVED:\n+                    waitForEnvironmentStatus(environmentClient, environmentCrn, desiredStatus, new EnvironmentTerminationChecker<>());\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired environment state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            statuses.putAll(Map.of(\"status\", awaitEntity.getResponse().getEnvironmentStatus().name()));\n+            if (!desiredStatus.equals(EnvironmentStatus.ARCHIVED)) {\n                 awaitEntity.refresh(getTestContext(), null);\n             }\n         } catch (Exception e) {\n             if (runningParameter.isLogError()) {\n-                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName());\n+                LOGGER.error(\"await [{}] is failed for statuses {}: {}, name: {}\", entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName());\n                 Log.await(null, String.format(\"[%s] is failed for statuses %s: %s, name: %s\",\n-                        entity, desiredStatuses, ResponseUtil.getErrorMessage(e), entity.getName()));\n+                        entity, desiredStatus, ResponseUtil.getErrorMessage(e), entity.getName()));\n             }\n-            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatuses, e);\n+            getExceptionMap().put(\"await \" + entity + \" for desired statuses \" + desiredStatus, e);\n         }\n         return entity;\n     }\n \n+    private Result<WaitResult, Exception> waitForEnvironmentStatus(EnvironmentClient environmentClient, String environmentCrn,", "originalCommit": "489a3b6af9951718f8ba0426a9f9a010eb725c67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b26cdc508b3bd34c6d2538dd0e0a08ed9fe2e9d2", "url": "https://github.com/hortonworks/cloudbreak/commit/b26cdc508b3bd34c6d2538dd0e0a08ed9fe2e9d2", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-05-07T07:43:28Z", "type": "forcePushed"}, {"oid": "23e21175566a714fd266744ffd4f0e1ade901ec6", "url": "https://github.com/hortonworks/cloudbreak/commit/23e21175566a714fd266744ffd4f0e1ade901ec6", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-05-07T18:03:35Z", "type": "forcePushed"}, {"oid": "1c831b47ff7d5cc4b7636687d1e396fccba7b460", "url": "https://github.com/hortonworks/cloudbreak/commit/1c831b47ff7d5cc4b7636687d1e396fccba7b460", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-05-08T18:43:38Z", "type": "forcePushed"}, {"oid": "70bf3ad3fd2b9fafc5a406b04f9ffeda68b5c41b", "url": "https://github.com/hortonworks/cloudbreak/commit/70bf3ad3fd2b9fafc5a406b04f9ffeda68b5c41b", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-05-08T19:17:40Z", "type": "commit"}, {"oid": "70bf3ad3fd2b9fafc5a406b04f9ffeda68b5c41b", "url": "https://github.com/hortonworks/cloudbreak/commit/70bf3ad3fd2b9fafc5a406b04f9ffeda68b5c41b", "message": "CB-6751 Environment and FreeIPA WaitUtil and WaitForMultipleStatuses overall refactor", "committedDate": "2020-05-08T19:17:40Z", "type": "forcePushed"}]}