{"pr_number": 2280, "pr_title": "optimize: refactor InsertExecutor", "pr_createdAt": "2020-02-22T08:57:32Z", "pr_url": "https://github.com/seata/seata/pull/2280", "timeline": [{"oid": "bd73c75c986a1f47655aa71db7b37d9b1a5d1485", "url": "https://github.com/seata/seata/commit/bd73c75c986a1f47655aa71db7b37d9b1a5d1485", "message": "fix conflict", "committedDate": "2020-03-07T06:01:39Z", "type": "forcePushed"}, {"oid": "9933926870aae5978a1424f7b3742518dfb57992", "url": "https://github.com/seata/seata/commit/9933926870aae5978a1424f7b3742518dfb57992", "message": "update test", "committedDate": "2020-03-07T05:43:43Z", "type": "forcePushed"}, {"oid": "62135d24cef6807d4efefcc820e2e368c4aafbb4", "url": "https://github.com/seata/seata/commit/62135d24cef6807d4efefcc820e2e368c4aafbb4", "message": "resolve conflict", "committedDate": "2020-04-06T08:13:17Z", "type": "commit"}, {"oid": "62135d24cef6807d4efefcc820e2e368c4aafbb4", "url": "https://github.com/seata/seata/commit/62135d24cef6807d4efefcc820e2e368c4aafbb4", "message": "resolve conflict", "committedDate": "2020-04-06T08:13:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw==", "url": "https://github.com/seata/seata/pull/2280#discussion_r404851637", "bodyText": "\u6d4b\u8bd5\u7ed3\u679c\u53d6\u4e0d\u5230\u503c\u6ca1\u6709next", "author": "jaspercloud", "createdAt": "2020-04-07T14:26:13Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n+    }\n+\n+    public List<Object> getPkValuesByAuto() throws SQLException {\n+        // PK is just auto generated\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        if (pkMetaMap.size() != 1) {\n+            throw new NotSupportYetException();\n+        }\n+        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n+        List<Object> pkValues = new ArrayList<>();\n+        while (genKeys.next()) {\n+            Object v = genKeys.getObject(1);\n+            pkValues.add(v);\n+        }\n+        return pkValues;", "originalCommit": "62135d24cef6807d4efefcc820e2e368c4aafbb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTkzOQ==", "url": "https://github.com/seata/seata/pull/2280#discussion_r404851939", "bodyText": "insert into access_log (id) values (nextval('access_log_id_seq'))", "author": "jaspercloud", "createdAt": "2020-04-07T14:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4Mjk3MA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r406582970", "bodyText": "fix it.", "author": "jsbxyyx", "createdAt": "2020-04-10T03:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1MTYzNw=="}], "type": "inlineReview"}, {"oid": "b0178cc475c9f4467414450c4a13374d619e2c34", "url": "https://github.com/seata/seata/commit/b0178cc475c9f4467414450c4a13374d619e2c34", "message": "Merge branch 'develop' of https://github.com/seata/seata into refactor_executor", "committedDate": "2020-04-10T01:11:04Z", "type": "commit"}, {"oid": "692726a1911c46be2df21a19c185f28edbd0c475", "url": "https://github.com/seata/seata/commit/692726a1911c46be2df21a19c185f28edbd0c475", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-04-10T01:39:18Z", "type": "commit"}, {"oid": "6de057dcf26c08b7e183431e164b96340a2ca7f4", "url": "https://github.com/seata/seata/commit/6de057dcf26c08b7e183431e164b96340a2ca7f4", "message": "Merge branch 'refactor_executor' of https://github.com/jsbxyyx/seata into refactor_executor", "committedDate": "2020-04-10T01:40:55Z", "type": "commit"}, {"oid": "8f39ebb55ec8a988b9661510f85771aad50debe5", "url": "https://github.com/seata/seata/commit/8f39ebb55ec8a988b9661510f85771aad50debe5", "message": "fix: nextval on statement", "committedDate": "2020-04-10T03:09:42Z", "type": "commit"}, {"oid": "cdc79f351955f7ffa236cc046720b6259b3cf409", "url": "https://github.com/seata/seata/commit/cdc79f351955f7ffa236cc046720b6259b3cf409", "message": "revert serializer-seata registry.conf", "committedDate": "2020-04-10T03:23:03Z", "type": "commit"}, {"oid": "8466f3f4d17a7d0ee21ae8857d78fd11cecaf6a1", "url": "https://github.com/seata/seata/commit/8466f3f4d17a7d0ee21ae8857d78fd11cecaf6a1", "message": "resolve conflict.", "committedDate": "2020-04-21T10:14:41Z", "type": "commit"}, {"oid": "8808ea7b418e1cf6894481ed418f2c17019d43f5", "url": "https://github.com/seata/seata/commit/8808ea7b418e1cf6894481ed418f2c17019d43f5", "message": "resolve conflict.", "committedDate": "2020-04-21T10:15:41Z", "type": "commit"}, {"oid": "44589414a73d2e83b7f126e42d598b04c1d68110", "url": "https://github.com/seata/seata/commit/44589414a73d2e83b7f126e42d598b04c1d68110", "message": "Merge branch 'develop' of https://github.com/seata/seata into refactor_executor", "committedDate": "2020-04-21T10:16:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2OTAzMw==", "url": "https://github.com/seata/seata/pull/2280#discussion_r413869033", "bodyText": "recommended to use PROTOTYPE spi", "author": "zjinlei", "createdAt": "2020-04-23T14:56:34Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -69,18 +69,19 @@\n             return statementCallback.execute(statementProxy.getTargetStatement(), args);\n         }\n \n+        String dbType = statementProxy.getConnectionProxy().getDbType();\n         if (sqlRecognizer == null) {\n             sqlRecognizer = SQLVisitorFactory.get(\n                     statementProxy.getTargetSQL(),\n-                    statementProxy.getConnectionProxy().getDbType());\n+                    dbType);\n         }\n         Executor<T> executor;\n         if (sqlRecognizer == null) {\n             executor = new PlainExecutor<>(statementProxy, statementCallback);\n         } else {\n             switch (sqlRecognizer.getSQLType()) {\n                 case INSERT:\n-                    executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n+                    executor = InsertExecutorFactory.createInsertExecutor(statementProxy, statementCallback, sqlRecognizer, dbType);", "originalCommit": "cdc79f351955f7ffa236cc046720b6259b3cf409", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f0e6a96d95168982eb990e1e56f298e231beed4", "url": "https://github.com/seata/seata/commit/4f0e6a96d95168982eb990e1e56f298e231beed4", "message": "Merge branch 'develop' of https://github.com/seata/seata into refactor_executor", "committedDate": "2020-04-24T05:38:22Z", "type": "commit"}, {"oid": "e7b70a6076e3ba1721637df1c61e165ffccb1a62", "url": "https://github.com/seata/seata/commit/e7b70a6076e3ba1721637df1c61e165ffccb1a62", "message": "optimize: insert executor spi.", "committedDate": "2020-04-24T06:47:01Z", "type": "commit"}, {"oid": "670580ac7398271ae48371d300ab2844f7fc55a3", "url": "https://github.com/seata/seata/commit/670580ac7398271ae48371d300ab2844f7fc55a3", "message": "optimize: insert executor spi.", "committedDate": "2020-04-24T07:19:23Z", "type": "commit"}, {"oid": "29ef7a60e7779ded2d1823244c6429fa2f006f25", "url": "https://github.com/seata/seata/commit/29ef7a60e7779ded2d1823244c6429fa2f006f25", "message": "update author", "committedDate": "2020-04-24T07:56:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NDkxOA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r414564918", "bodyText": "?", "author": "zjinlei", "createdAt": "2020-04-24T13:12:54Z", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/SqlDefaultExpr.java", "diffHunk": "@@ -25,7 +26,7 @@\n     /**\n      * Get SqlDefaultExpr.\n      *\n-     * @return the SqlDefaultExpr\n+     * @return the sqlDefaultExpr", "originalCommit": "29ef7a60e7779ded2d1823244c6429fa2f006f25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NTAzNw==", "url": "https://github.com/seata/seata/pull/2280#discussion_r414565037", "bodyText": "can use EnhancedServiceLoader.load directly.", "author": "zjinlei", "createdAt": "2020-04-24T13:13:04Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -84,7 +85,8 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n+                        executor = InsertExecutorFactory.createInsertExecutor(statementProxy, statementCallback,", "originalCommit": "29ef7a60e7779ded2d1823244c6429fa2f006f25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk2MTg2MA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r414961860", "bodyText": "done.", "author": "jsbxyyx", "createdAt": "2020-04-25T03:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NTAzNw=="}], "type": "inlineReview"}, {"oid": "21e79346b7b820db35e0cae7bc3ed498e94110bc", "url": "https://github.com/seata/seata/commit/21e79346b7b820db35e0cae7bc3ed498e94110bc", "message": "fix reviews.", "committedDate": "2020-04-25T02:59:21Z", "type": "commit"}, {"oid": "712d97821bee2c76b2d9958d90106ba1835b4602", "url": "https://github.com/seata/seata/commit/712d97821bee2c76b2d9958d90106ba1835b4602", "message": "fix reviews.", "committedDate": "2020-04-25T03:01:24Z", "type": "commit"}, {"oid": "ecad974e0a48b1b6ca7cc658872b498f8fa4aab3", "url": "https://github.com/seata/seata/commit/ecad974e0a48b1b6ca7cc658872b498f8fa4aab3", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-04-26T02:12:37Z", "type": "commit"}, {"oid": "84ad48bb51e8715119e692ca622fc8e2d26968a3", "url": "https://github.com/seata/seata/commit/84ad48bb51e8715119e692ca622fc8e2d26968a3", "message": "update checkstyle.", "committedDate": "2020-04-26T04:36:43Z", "type": "commit"}, {"oid": "3856511ec6a4c7f3f4341b463350c9d0a7ba22cd", "url": "https://github.com/seata/seata/commit/3856511ec6a4c7f3f4341b463350c9d0a7ba22cd", "message": "fix ci.", "committedDate": "2020-04-26T09:47:36Z", "type": "commit"}, {"oid": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "url": "https://github.com/seata/seata/commit/8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-02T02:36:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzE0OQ==", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847149", "bodyText": "Defaultable  may be only use in Pg.", "author": "zjinlei", "createdAt": "2020-05-02T02:52:03Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertExecutor.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertExecutor extends BaseInsertExecutor implements Defaultable {", "originalCommit": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5NzYxNg==", "url": "https://github.com/seata/seata/pull/2280#discussion_r420497616", "bodyText": "mysql has default keyword too.", "author": "jsbxyyx", "createdAt": "2020-05-06T01:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzQyNw==", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847427", "bodyText": "add getPkValuesByDefault()", "author": "zjinlei", "createdAt": "2020-05-02T02:52:42Z", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/struct/Defaultable.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.sqlparser.struct;\n+\n+/**\n+ * The default expr able.\n+ * @author jsbxyyx\n+ */\n+public interface Defaultable {\n+}", "originalCommit": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzczMA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r418847730", "bodyText": "getPkValuesByColumn may be can as a common interface.", "author": "zjinlei", "createdAt": "2020-05-02T02:53:36Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/InsertExecutor.java", "diffHunk": "@@ -13,380 +13,22 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package io.seata.rm.datasource.exec;\n \n-import java.sql.ResultSet;\n import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import io.seata.common.exception.NotSupportYetException;\n-import io.seata.common.exception.ShouldNeverHappenException;\n-import io.seata.common.util.CollectionUtils;\n-import io.seata.common.util.StringUtils;\n-import io.seata.rm.datasource.PreparedStatementProxy;\n-import io.seata.rm.datasource.StatementProxy;\n-import io.seata.rm.datasource.sql.struct.ColumnMeta;\n-import io.seata.rm.datasource.sql.struct.TableRecords;\n-import io.seata.sqlparser.SQLInsertRecognizer;\n-import io.seata.sqlparser.SQLRecognizer;\n-import io.seata.sqlparser.struct.Null;\n-import io.seata.sqlparser.struct.SqlDefaultExpr;\n-import io.seata.sqlparser.struct.SqlMethodExpr;\n-import io.seata.sqlparser.struct.SqlSequenceExpr;\n-import io.seata.sqlparser.util.JdbcConstants;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n- * The type Insert executor.\n- *\n- * @param <T> the type parameter\n- * @param <S> the type parameter\n- * @author yuanguoyao\n+ * @author jsbxyyx\n  */\n-public class InsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(InsertExecutor.class);\n-    protected static final String ERR_SQL_STATE = \"S1009\";\n-\n-    private static final String PLACEHOLDER = \"?\";\n-\n-    /**\n-     * Instantiates a new Insert executor.\n-     *\n-     * @param statementProxy    the statement proxy\n-     * @param statementCallback the statement callback\n-     * @param sqlRecognizer     the sql recognizer\n-     */\n-    public InsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T,S> statementCallback,\n-                          SQLRecognizer sqlRecognizer) {\n-        super(statementProxy, statementCallback, sqlRecognizer);\n-    }\n-\n-    @Override\n-    protected TableRecords beforeImage() throws SQLException {\n-        return TableRecords.empty(getTableMeta());\n-    }\n-\n-    @Override\n-    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n-        //Pk column exists or PK is just auto generated\n-        List<Object> pkValues = containsPK() ? getPkValuesByColumn() :\n-                (containsColumns() ? getPkValuesByAuto() : getPkValuesByColumn());\n-\n-        TableRecords afterImage = buildTableRecords(pkValues);\n-\n-        if (afterImage == null) {\n-            throw new SQLException(\"Failed to build after-image for insert\");\n-        }\n-\n-        return afterImage;\n-    }\n-\n-    protected boolean containsPK() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        if (CollectionUtils.isEmpty(insertColumns)) {\n-            return false;\n-        }\n-        return containsPK(insertColumns);\n-    }\n-\n-    protected boolean containsColumns() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        return insertColumns != null && !insertColumns.isEmpty();\n-    }\n-\n-    protected List<Object> getPkValuesByColumn() throws SQLException {\n-        // insert values including PK\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        final int pkIndex = getPkIndex();\n-        if (pkIndex == -1) {\n-            throw new ShouldNeverHappenException(String.format(\"pkIndex is %d\", pkIndex));\n-        }\n-        List<Object> pkValues = null;\n-        if (statementProxy instanceof PreparedStatementProxy) {\n-            PreparedStatementProxy preparedStatementProxy = (PreparedStatementProxy) statementProxy;\n-\n-            List<List<Object>> insertRows = recognizer.getInsertRows();\n-            if (insertRows != null && !insertRows.isEmpty()) {\n-                ArrayList<Object>[] parameters = preparedStatementProxy.getParameters();\n-                final int rowSize = insertRows.size();\n-\n-                if (rowSize == 1) {\n-                    Object pkValue = insertRows.get(0).get(pkIndex);\n-                    if (PLACEHOLDER.equals(pkValue)) {\n-                        pkValues = parameters[pkIndex];\n-                    } else {\n-                        pkValues = insertRows.stream().map(insertRow -> insertRow.get(pkIndex)).collect(Collectors.toList());\n-                    }\n-                } else {\n-                    int totalPlaceholderNum = -1;\n-                    pkValues = new ArrayList<>(rowSize);\n-                    for (int i = 0; i < rowSize; i++) {\n-                        List<Object> row = insertRows.get(i);\n-                        // oracle insert sql statement specify RETURN_GENERATED_KEYS will append :rowid on sql end\n-                        // insert parameter count will than the actual +1\n-                        if (row.isEmpty()) {\n-                            continue;\n-                        }\n-                        Object pkValue = row.get(pkIndex);\n-                        int currentRowPlaceholderNum = -1;\n-                        for (Object r : row) {\n-                            if (PLACEHOLDER.equals(r)) {\n-                                totalPlaceholderNum += 1;\n-                                currentRowPlaceholderNum += 1;\n-                            }\n-                        }\n-                        if (PLACEHOLDER.equals(pkValue)) {\n-                            int idx = pkIndex;\n-                            if (i != 0) {\n-                                idx = totalPlaceholderNum - currentRowPlaceholderNum + pkIndex;\n-                            }\n-                            ArrayList<Object> parameter = parameters[idx];\n-                            pkValues.addAll(parameter);\n-                        } else {\n-                            pkValues.add(pkValue);\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            List<List<Object>> insertRows = recognizer.getInsertRows();\n-            pkValues = new ArrayList<>(insertRows.size());\n-            for (List<Object> row : insertRows) {\n-                pkValues.add(row.get(pkIndex));\n-            }\n-        }\n-        if (pkValues == null) {\n-            throw new ShouldNeverHappenException();\n-        }\n-        boolean b = this.checkPkValues(pkValues);\n-        if (!b) {\n-            throw new NotSupportYetException(String.format(\"not support sql [%s]\", sqlRecognizer.getOriginalSQL()));\n-        }\n-        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n-            pkValues = getPkValuesBySequence(pkValues.get(0));\n-        }\n-        else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlDefaultExpr) {\n-            pkValues = getPkValuesByDefault();\n-        }\n-        // pk auto generated while column exists and value is null\n-        else if (!pkValues.isEmpty() && pkValues.get(0) instanceof Null) {\n-            pkValues = getPkValuesByAuto();\n-        }\n-        return pkValues;\n-    }\n-\n-    /**\n-     * get primary key values by default\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<Object> getPkValuesByDefault() throws SQLException {\n-        // current version 1.2 only support postgresql.\n-        // mysql default keyword the logic not support. (sample: insert into test(id, name) values(default, 'xx'))\n-        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n-        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n-        String columnDef = pkMeta.getColumnDef();\n-        // sample: nextval('test_id_seq'::regclass)\n-        String seq = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"'\", \"'\");\n-        String function = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"\", \"(\");\n-        if (StringUtils.isBlank(seq)) {\n-            throw new ShouldNeverHappenException(\"get primary key value failed, cause columnDef is \" + columnDef);\n-        }\n-        return getPkValuesBySequence(new SqlSequenceExpr(\"'\" + seq + \"'\", function));\n-    }\n+public interface InsertExecutor<T> extends Executor<T> {\n \n     /**\n-     * get primary key values by sequence.\n-     * @param expr\n-     * @return\n+     * get primary key values.\n+     * @return The primary key value.\n      * @throws SQLException\n      */\n-    protected List<Object> getPkValuesBySequence(Object expr) throws SQLException {\n-        // priority use defaultGeneratedKeys\n-        List<Object> pkValues = null;\n-        try {\n-            pkValues = defaultGeneratedKeys();\n-        } catch (NotSupportYetException | SQLException ignore) {\n-        }\n-\n-        if (!CollectionUtils.isEmpty(pkValues)) {\n-            return pkValues;\n-        }\n-\n-        ResultSet genKeys;\n-        if (expr instanceof SqlSequenceExpr) {\n-            SqlSequenceExpr sequenceExpr = (SqlSequenceExpr) expr;\n-            String sql = \"SELECT \" + sequenceExpr.getSequence() + \".currval FROM DUAL\";\n-            if (StringUtils.equalsIgnoreCase(JdbcConstants.POSTGRESQL, getDbType())) {\n-                sql = \"SELECT currval(\" + sequenceExpr.getSequence() + \")\";\n-            }\n-            LOGGER.warn(\"Fail to get auto-generated keys, use '{}' instead. Be cautious, statement could be polluted. Recommend you set the statement to return generated keys.\", sql);\n-            genKeys = statementProxy.getConnection().createStatement().executeQuery(sql);\n-        } else {\n-            throw new NotSupportYetException(String.format(\"not support expr [%s]\", expr.getClass().getName()));\n-        }\n-        pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        return pkValues;\n-    }\n-\n-    protected List<Object> getPkValuesByAuto() throws SQLException {\n-        boolean mysql = StringUtils.equalsIgnoreCase(JdbcConstants.MYSQL, getDbType());\n-        if (mysql) {\n-            return mysqlGeneratedKeys();\n-        }\n-        return defaultGeneratedKeys();\n-    }\n-\n-    /**\n-     * get pk index\n-     * @return -1 not found pk index\n-     */\n-    protected int getPkIndex() {\n-        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n-        List<String> insertColumns = recognizer.getInsertColumns();\n-        if (CollectionUtils.isNotEmpty(insertColumns)) {\n-            final int insertColumnsSize = insertColumns.size();\n-            int pkIndex = -1;\n-            for (int paramIdx = 0; paramIdx < insertColumnsSize; paramIdx++) {\n-                if (equalsPK(insertColumns.get(paramIdx))) {\n-                    pkIndex = paramIdx;\n-                    break;\n-                }\n-            }\n-            return pkIndex;\n-        }\n-        int pkIndex = -1;\n-        Map<String, ColumnMeta> allColumns = getTableMeta().getAllColumns();\n-        for (Map.Entry<String, ColumnMeta> entry : allColumns.entrySet()) {\n-            pkIndex++;\n-            if (equalsPK(entry.getValue().getColumnName())) {\n-                break;\n-            }\n-        }\n-        return pkIndex;\n-    }\n-\n-    /**\n-     * check pk values\n-     * @param pkValues\n-     * @return true: support. false: not support.\n-     */\n-    protected boolean checkPkValues(List<Object> pkValues) {\n-        /*\n-        -----------------------------------------------\n-                  one    more\n-        null       O      O\n-        value      O      O\n-        method     X      X\n-        sequence   O      X\n-        -----------------------------------------------\n-                  null    value    method    sequence\n-        null       O        X         X         X\n-        value      X        O         X         X\n-        method     X        X         X         X\n-        sequence   X        X         X         X\n-        -----------------------------------------------\n-        */\n-        int n = 0, v = 0, m = 0, s = 0;\n-        for (Object pkValue : pkValues) {\n-            if (pkValue instanceof Null) {\n-                n++;\n-                continue;\n-            }\n-            if (pkValue instanceof SqlMethodExpr) {\n-                m++;\n-                break;\n-            }\n-            if (pkValue instanceof SqlSequenceExpr) {\n-                s++;\n-                continue;\n-            }\n-            v++;\n-        }\n-        // not support sql primary key is function.\n-        if (m > 0) {\n-            return false;\n-        }\n-        if (n > 0 && v == 0 && s == 0) {\n-            return true;\n-        }\n-        if (n == 0 && v > 0 && s == 0) {\n-            return true;\n-        }\n-        if (n == 0 && v == 0 && s == 1) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * mysql get generated keys\n-     * @return the primary key value\n-     * @throws SQLException the SQL exception\n-     */\n-    private List<Object> mysqlGeneratedKeys() throws SQLException {\n-        // PK is just auto generated\n-        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n-        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n-        if (!pkMeta.isAutoincrement()) {\n-            throw new ShouldNeverHappenException();\n-        }\n-\n-        ResultSet genKeys;\n-        try {\n-            genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n-        } catch (SQLException e) {\n-            // java.sql.SQLException: Generated keys not requested. You need to\n-            // specify Statement.RETURN_GENERATED_KEYS to\n-            // Statement.executeUpdate() or Connection.prepareStatement().\n-            if (ERR_SQL_STATE.equalsIgnoreCase(e.getSQLState())) {\n-                LOGGER.warn(\"Fail to get auto-generated keys, use 'SELECT LAST_INSERT_ID()' instead. Be cautious, statement could be polluted. Recommend you set the statement to return generated keys.\");\n-                genKeys = statementProxy.getTargetStatement().executeQuery(\"SELECT LAST_INSERT_ID()\");\n-            } else {\n-                throw e;\n-            }\n-        }\n-        List<Object> pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        try {\n-            genKeys.beforeFirst();\n-        } catch (SQLException e) {\n-            LOGGER.warn(\"Fail to reset ResultSet cursor. can not get primary key value\");\n-        }\n-        return pkValues;\n-    }\n-\n-    /**\n-     * default get generated keys\n-     * @return the primary key value\n-     * @throws SQLException the SQL exception\n-     */\n-    private List<Object> defaultGeneratedKeys() throws SQLException {\n-        ResultSet genKeys = statementProxy.getTargetStatement().getGeneratedKeys();\n-        List<Object> pkValues = new ArrayList<>();\n-        while (genKeys.next()) {\n-            Object v = genKeys.getObject(1);\n-            pkValues.add(v);\n-        }\n-        if (pkValues.isEmpty()) {\n-            throw new NotSupportYetException(String.format(\"not support sql [%s]\", sqlRecognizer.getOriginalSQL()));\n-        }\n-        return pkValues;\n-    }\n+    List<Object> getPkValues() throws SQLException;\n ", "originalCommit": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NzE0MA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r418877140", "bodyText": "Just judge that it is not empty, can simplify the implementation.", "author": "zjinlei", "createdAt": "2020-05-02T04:05:35Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Base Insert Executor.\n+ * @author jsbxyyx\n+ */\n+public abstract class BaseInsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> implements InsertExecutor<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(BaseInsertExecutor.class);\n+\n+    protected static final String PLACEHOLDER = \"?\";\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public BaseInsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n+                              SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return TableRecords.empty(getTableMeta());\n+    }\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        List<Object> pkValues = getPkValues();\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    protected boolean containsPK() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isEmpty(insertColumns)) {\n+            return false;\n+        }\n+        return containsPK(insertColumns);\n+    }\n+\n+    /**\n+     * judge sql specify column\n+     * @return true: contains column. false: not contains column.\n+     */\n+    protected boolean containsColumns() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();", "originalCommit": "8d3af79500c19848125d8bb1a3e42d9c4b9921d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1299560e5c4e51ef3dd7165cacf5385e9675b8f0", "url": "https://github.com/seata/seata/commit/1299560e5c4e51ef3dd7165cacf5385e9675b8f0", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-02T11:10:04Z", "type": "commit"}, {"oid": "8113817cd8a6a407594687a56fab87a9f9caa182", "url": "https://github.com/seata/seata/commit/8113817cd8a6a407594687a56fab87a9f9caa182", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-06T01:18:03Z", "type": "commit"}, {"oid": "dc28ae6eb11069c0b77e32489b281b355ec04f36", "url": "https://github.com/seata/seata/commit/dc28ae6eb11069c0b77e32489b281b355ec04f36", "message": "fix reviews.", "committedDate": "2020-05-06T04:04:41Z", "type": "commit"}, {"oid": "2aa6288c1c01e722eab0bb10e74f1fe4b00a5aef", "url": "https://github.com/seata/seata/commit/2aa6288c1c01e722eab0bb10e74f1fe4b00a5aef", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-06T10:04:24Z", "type": "commit"}, {"oid": "0a1d3bbf94a1c657d466d40fd510f47cd33d1589", "url": "https://github.com/seata/seata/commit/0a1d3bbf94a1c657d466d40fd510f47cd33d1589", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-07T02:03:33Z", "type": "commit"}, {"oid": "115f1ac5608a90650f986986b6d1486aa38e612c", "url": "https://github.com/seata/seata/commit/115f1ac5608a90650f986986b6d1486aa38e612c", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-08T01:12:05Z", "type": "commit"}, {"oid": "6e698eadc8821b37abc935ddb9950dc4079979b8", "url": "https://github.com/seata/seata/commit/6e698eadc8821b37abc935ddb9950dc4079979b8", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-08T04:15:24Z", "type": "commit"}, {"oid": "b0c6c45f6c866b94edb88b08a4ec8c5703a8676f", "url": "https://github.com/seata/seata/commit/b0c6c45f6c866b94edb88b08a4ec8c5703a8676f", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-10T02:44:39Z", "type": "commit"}, {"oid": "de5768dd6f338583ff49c5c5310157c55439af4d", "url": "https://github.com/seata/seata/commit/de5768dd6f338583ff49c5c5310157c55439af4d", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-13T15:27:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTI5MA==", "url": "https://github.com/seata/seata/pull/2280#discussion_r425181290", "bodyText": "Reduce coupling and implement in 3 steps\n1.getInsertRows\n2.get pkIndex list from rows\n3.get pkValue list from parameters", "author": "zjinlei", "createdAt": "2020-05-14T14:28:48Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseInsertExecutor.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Base Insert Executor.\n+ * @author jsbxyyx\n+ */\n+public abstract class BaseInsertExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> implements InsertExecutor<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(BaseInsertExecutor.class);\n+\n+    protected static final String PLACEHOLDER = \"?\";\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public BaseInsertExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n+                              SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return TableRecords.empty(getTableMeta());\n+    }\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        List<Object> pkValues = getPkValues();\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    protected boolean containsPK() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isEmpty(insertColumns)) {\n+            return false;\n+        }\n+        return containsPK(insertColumns);\n+    }\n+\n+    /**\n+     * judge sql specify column\n+     * @return true: contains column. false: not contains column.\n+     */\n+    protected boolean containsColumns() {\n+        return !((SQLInsertRecognizer) sqlRecognizer).insertColumnsIsEmpty();\n+    }\n+\n+    /**\n+     * get primary key column index.\n+     * @return -1: not found.\n+     */\n+    protected int getPkIndex() {\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        if (CollectionUtils.isNotEmpty(insertColumns)) {\n+            final int insertColumnsSize = insertColumns.size();\n+            int pkIndex = -1;\n+            for (int paramIdx = 0; paramIdx < insertColumnsSize; paramIdx++) {\n+                if (equalsPK(insertColumns.get(paramIdx))) {\n+                    pkIndex = paramIdx;\n+                    break;\n+                }\n+            }\n+            return pkIndex;\n+        }\n+        int pkIndex = -1;\n+        Map<String, ColumnMeta> allColumns = getTableMeta().getAllColumns();\n+        for (Map.Entry<String, ColumnMeta> entry : allColumns.entrySet()) {\n+            pkIndex++;\n+            if (equalsPK(entry.getValue().getColumnName())) {\n+                break;\n+            }\n+        }\n+        return pkIndex;\n+    }\n+\n+    /**\n+     * parse primary key value from statement.\n+     * @return\n+     */\n+    protected List<Object> parsePkValuesFromStatement() {\n+        // insert values including PK\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        final int pkIndex = getPkIndex();\n+        if (pkIndex == -1) {\n+            throw new ShouldNeverHappenException(String.format(\"pkIndex is %d\", pkIndex));\n+        }\n+        List<Object> pkValues = null;\n+        if (statementProxy instanceof PreparedStatementProxy) {\n+            PreparedStatementProxy preparedStatementProxy = (PreparedStatementProxy) statementProxy;\n+\n+            List<List<Object>> insertRows = recognizer.getInsertRows();\n+            if (insertRows != null && !insertRows.isEmpty()) {\n+                ArrayList<Object>[] parameters = preparedStatementProxy.getParameters();\n+                final int rowSize = insertRows.size();\n+\n+                if (rowSize == 1) {\n+                    Object pkValue = insertRows.get(0).get(pkIndex);\n+                    if (PLACEHOLDER.equals(pkValue)) {\n+                        pkValues = parameters[pkIndex];\n+                    } else {\n+                        pkValues = insertRows.stream().map(insertRow -> insertRow.get(pkIndex)).collect(Collectors.toList());\n+                    }\n+                } else {\n+                    int totalPlaceholderNum = -1;\n+                    pkValues = new ArrayList<>(rowSize);\n+                    for (int i = 0; i < rowSize; i++) {\n+                        List<Object> row = insertRows.get(i);\n+                        // oracle insert sql statement specify RETURN_GENERATED_KEYS will append :rowid on sql end\n+                        // insert parameter count will than the actual +1\n+                        if (row.isEmpty()) {\n+                            continue;\n+                        }\n+                        Object pkValue = row.get(pkIndex);\n+                        int currentRowPlaceholderNum = -1;\n+                        for (Object r : row) {\n+                            if (PLACEHOLDER.equals(r)) {\n+                                totalPlaceholderNum += 1;\n+                                currentRowPlaceholderNum += 1;\n+                            }\n+                        }\n+                        if (PLACEHOLDER.equals(pkValue)) {\n+                            int idx = pkIndex;\n+                            if (i != 0) {\n+                                idx = totalPlaceholderNum - currentRowPlaceholderNum + pkIndex;\n+                            }\n+                            ArrayList<Object> parameter = parameters[idx];\n+                            pkValues.addAll(parameter);\n+                        } else {\n+                            pkValues.add(pkValue);\n+                        }\n+                    }\n+                }\n+            }", "originalCommit": "de5768dd6f338583ff49c5c5310157c55439af4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTQ2Mg==", "url": "https://github.com/seata/seata/pull/2280#discussion_r427045462", "bodyText": "How about turn the sql into constant.", "author": "l81893521", "createdAt": "2020-05-19T05:52:37Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/oracle/OracleInsertExecutor.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.oracle;\n+\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.ORACLE, scope = Scope.PROTOTYPE)\n+public class OracleInsertExecutor extends BaseInsertExecutor implements Sequenceable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OracleInsertExecutor.class);\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public OracleInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback,\n+                                SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    public List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getGeneratedKeys() : getPkValuesByColumn());\n+    }\n+\n+    @Override\n+    public List<Object> getPkValuesByColumn() throws SQLException {\n+        List<Object> pkValues = parsePkValuesFromStatement();\n+        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n+            pkValues = getPkValuesBySequence((SqlSequenceExpr) pkValues.get(0));\n+        } else if (pkValues.size() == 1 && pkValues.get(0) instanceof SqlMethodExpr) {\n+            pkValues = getGeneratedKeys();\n+        } else if (pkValues.size() == 1 && pkValues.get(0) instanceof Null) {\n+            throw new NotSupportYetException(\"oracle not support null\");\n+        }\n+        return pkValues;\n+    }\n+\n+    @Override\n+    public String getSequenceSql(SqlSequenceExpr expr) {\n+        return \"SELECT \" + expr.getSequence() + \".currval FROM DUAL\";", "originalCommit": "de5768dd6f338583ff49c5c5310157c55439af4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTY2Nw==", "url": "https://github.com/seata/seata/pull/2280#discussion_r427045667", "bodyText": "How about turn the sql into constant.", "author": "l81893521", "createdAt": "2020-05-19T05:53:12Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/postgresql/PostgresqlInsertExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.postgresql;\n+\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.BaseInsertExecutor;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Sequenceable;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * @author jsbxyyx\n+ */\n+@LoadLevel(name = JdbcConstants.POSTGRESQL, scope = Scope.PROTOTYPE)\n+public class PostgresqlInsertExecutor extends BaseInsertExecutor implements Sequenceable, Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresqlInsertExecutor.class);\n+\n+    /**\n+     * Instantiates a new Abstract dml base executor.\n+     *\n+     * @param statementProxy    the statement proxy\n+     * @param statementCallback the statement callback\n+     * @param sqlRecognizer     the sql recognizer\n+     */\n+    public PostgresqlInsertExecutor(StatementProxy statementProxy, StatementCallback statementCallback,\n+                                    SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    @Override\n+    public List<Object> getPkValues() throws SQLException {\n+        return containsPK() ? getPkValuesByColumn() :\n+                (containsColumns() ? getGeneratedKeys() : getPkValuesByColumn());\n+    }\n+\n+    @Override\n+    public List<Object> getPkValuesByColumn() throws SQLException {\n+        List<Object> pkValues = parsePkValuesFromStatement();\n+        if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlSequenceExpr) {\n+            pkValues = getPkValuesBySequence((SqlSequenceExpr) pkValues.get(0));\n+        } else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlMethodExpr) {\n+            pkValues = getGeneratedKeys();\n+        } else if (!pkValues.isEmpty() && pkValues.get(0) instanceof SqlDefaultExpr) {\n+            pkValues = getPkValuesByDefault();\n+        }\n+        return pkValues;\n+    }\n+\n+    /**\n+     * get primary key values by default\n+     * @return\n+     * @throws SQLException\n+     */\n+    @Override\n+    public List<Object> getPkValuesByDefault() throws SQLException {\n+        // current version 1.2 only support postgresql.\n+        Map<String, ColumnMeta> pkMetaMap = getTableMeta().getPrimaryKeyMap();\n+        ColumnMeta pkMeta = pkMetaMap.values().iterator().next();\n+        String columnDef = pkMeta.getColumnDef();\n+        // sample: nextval('test_id_seq'::regclass)\n+        String seq = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"'\", \"'\");\n+        String function = org.apache.commons.lang.StringUtils.substringBetween(columnDef, \"\", \"(\");\n+        if (StringUtils.isBlank(seq)) {\n+            throw new ShouldNeverHappenException(\"get primary key value failed, cause columnDef is \" + columnDef);\n+        }\n+        return getPkValuesBySequence(new SqlSequenceExpr(\"'\" + seq + \"'\", function));\n+    }\n+\n+    @Override\n+    public String getSequenceSql(SqlSequenceExpr expr) {\n+        return \"SELECT currval(\" + expr.getSequence() + \")\";", "originalCommit": "de5768dd6f338583ff49c5c5310157c55439af4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a1c3b1f45f1d76b5a6640101a38669492acb96e", "url": "https://github.com/seata/seata/commit/1a1c3b1f45f1d76b5a6640101a38669492acb96e", "message": "Merge branch 'develop' into refactor_executor", "committedDate": "2020-05-19T06:22:51Z", "type": "commit"}]}