{"pr_number": 2135, "pr_title": "feature: support SPI scope", "pr_createdAt": "2020-01-04T10:34:57Z", "pr_url": "https://github.com/seata/seata/pull/2135", "timeline": [{"oid": "7e0d5a8363a5ce8669d4ba78bd58b2a1ed238a64", "url": "https://github.com/seata/seata/commit/7e0d5a8363a5ce8669d4ba78bd58b2a1ed238a64", "message": "adjust EnhancedServiceLoader", "committedDate": "2020-03-17T07:39:02Z", "type": "commit"}, {"oid": "f525d48690bf8c436406c50ce74487016634635b", "url": "https://github.com/seata/seata/commit/f525d48690bf8c436406c50ce74487016634635b", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-17T07:39:06Z", "type": "commit"}, {"oid": "5f5428fdeade1a760b88b0536c1fb711ade195f8", "url": "https://github.com/seata/seata/commit/5f5428fdeade1a760b88b0536c1fb711ade195f8", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-03-17T07:40:31Z", "type": "commit"}, {"oid": "846d9ec39a792431e90bc4bd271823b067b227b9", "url": "https://github.com/seata/seata/commit/846d9ec39a792431e90bc4bd271823b067b227b9", "message": "optimize createInstance and make Holder private", "committedDate": "2020-03-18T01:27:34Z", "type": "commit"}, {"oid": "93a79ab6cb410d0afd9f02aeb4860ff9cd6b9371", "url": "https://github.com/seata/seata/commit/93a79ab6cb410d0afd9f02aeb4860ff9cd6b9371", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-18T01:28:00Z", "type": "commit"}, {"oid": "2a252d5d774e3d27288aff7590dffc6449ddf149", "url": "https://github.com/seata/seata/commit/2a252d5d774e3d27288aff7590dffc6449ddf149", "message": "format code", "committedDate": "2020-03-18T02:24:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5MzY2Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394093662", "bodyText": "Since we have serviceClass, typeName is a little redundant.", "author": "ggndnn", "createdAt": "2020-03-18T03:55:24Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionDefinition.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL\n+ *\n+ * @author haozhibei\n+ */\n+class ExtensionDefinition {\n+    private String name;\n+    private String typeName;", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwMDM2MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394200361", "bodyText": "Ok,remove typeName", "author": "booogu", "createdAt": "2020-03-18T09:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5MzY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5ODE5Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394098192", "bodyText": "Format correctly.", "author": "ggndnn", "createdAt": "2020-03-18T04:15:44Z", "path": "core/src/main/java/io/seata/core/store/StoreMode.java", "diffHunk": "@@ -25,26 +25,35 @@\n     /**\n      * file store\n      */\n-    FILE,\n+    FILE(\"file\"),\n \n     /**\n      * database store\n      */\n-    DB;\n+    DB(\"db\");\n+\n+    private String name;\n+\n+    StoreMode(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n \n     /**\n-     * Valueof store mode.\n-     *\n-     * @param mode the mode\n-     * @return the store mode\n+     * get value of store mode\n+      * @param name the mode name", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MDY2MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394970661", "bodyText": "OK", "author": "booogu", "createdAt": "2020-03-19T11:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5ODE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5OTE3OQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394099179", "bodyText": "This kind modification is not necessary.", "author": "ggndnn", "createdAt": "2020-03-18T04:20:05Z", "path": "core/src/main/java/io/seata/core/serializer/SerializerFactory.java", "diffHunk": "@@ -72,4 +72,4 @@ public static Serializer getSerializer(byte serializeCode) {\n         return getSerializer(codec).deserialize(bytes);\n     }\n \n-}\n+}", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MDgxNg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394970816", "bodyText": "Got it", "author": "booogu", "createdAt": "2020-03-19T11:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA5OTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMDQ3NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394100474", "bodyText": "Just a question about this kind modification. Why not ignore case in EnhancedServiceLoader#load, keeping the original enum implementation unchanged?", "author": "ggndnn", "createdAt": "2020-03-18T04:26:25Z", "path": "metrics/seata-metrics-core/src/main/java/io/seata/metrics/exporter/ExporterType.java", "diffHunk": "@@ -26,7 +26,17 @@\n     /**\n      * Export metrics data to Prometheus\n      */\n-    PROMETHEUS;\n+    PROMETHEUS(\"prometheus\");", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MDU0Mw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394970543", "bodyText": "First, name will be used as a judgment point to distinguish whether two extensiondefinitions are the same\uff0cmore over I want users to use our spi in a more rigorous and standard way", "author": "booogu", "createdAt": "2020-03-19T11:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMDQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMTQ2OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394101468", "bodyText": "I think there is no uniform format style yet, so it's better to keep it unchanged.", "author": "ggndnn", "createdAt": "2020-03-18T04:31:12Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/undo/KeywordCheckerFactory.java", "diffHunk": "@@ -39,8 +39,9 @@ public static KeywordChecker getKeywordChecker(String dbType) {\n         if (KEYWORD_CHECKER_MAP.get(dbType) != null) {\n             return KEYWORD_CHECKER_MAP.get(dbType);\n         }\n-        KeywordChecker tableMetaCache = EnhancedServiceLoader.load(KeywordChecker.class, dbType);\n+        KeywordChecker tableMetaCache =\n+                EnhancedServiceLoader.load(KeywordChecker.class, dbType);", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MTE0OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394971148", "bodyText": "Restored", "author": "booogu", "createdAt": "2020-03-19T11:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMjIxMw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394102213", "bodyText": "Try to keep the format as original as possible and reduce modification.", "author": "ggndnn", "createdAt": "2020-03-18T04:34:56Z", "path": "server/src/main/java/io/seata/server/session/SessionHolder.java", "diffHunk": "@@ -89,15 +89,19 @@ public static void init(String mode) throws IOException {\n             mode = CONFIG.getConfig(ConfigurationKeys.STORE_MODE);\n         }\n         //the store mode\n-        StoreMode storeMode = StoreMode.valueof(mode);\n+        StoreMode storeMode = StoreMode.get(mode);\n         if (StoreMode.DB.equals(storeMode)) {\n             //database store\n-            ROOT_SESSION_MANAGER = EnhancedServiceLoader.load(SessionManager.class, StoreMode.DB.name());\n-            ASYNC_COMMITTING_SESSION_MANAGER = EnhancedServiceLoader.load(SessionManager.class, StoreMode.DB.name(),\n+            ROOT_SESSION_MANAGER =\n+                    EnhancedServiceLoader.load(SessionManager.class, StoreMode.DB.getName());", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MTY2NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394971664", "bodyText": "OK", "author": "booogu", "createdAt": "2020-03-19T11:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMjIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMjQ1Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394102456", "bodyText": "Is 200 not enough?", "author": "ggndnn", "createdAt": "2020-03-18T04:36:13Z", "path": "server/src/test/java/io/seata/server/coordinator/DefaultCoordinatorMetricsTest.java", "diffHunk": "@@ -67,7 +67,7 @@ public void test() throws IOException, TransactionException, InterruptedExceptio\n             coordinator.doGlobalCommit(commitRequest, new GlobalCommitResponse(), new RpcContext());\n \n             //we need sleep for a short while because default canBeCommittedAsync() is true\n-            Thread.sleep(200);\n+            Thread.sleep(1000);", "originalCommit": "2a252d5d774e3d27288aff7590dffc6449ddf149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3MTg4OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r394971888", "bodyText": "Restored", "author": "booogu", "createdAt": "2020-03-19T11:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwMjQ1Ng=="}], "type": "inlineReview"}, {"oid": "a232b4435388f87f69c78bf2ba22298bc64a0803", "url": "https://github.com/seata/seata/commit/a232b4435388f87f69c78bf2ba22298bc64a0803", "message": "format code", "committedDate": "2020-03-18T10:01:16Z", "type": "commit"}, {"oid": "23a6d2d720cada5cb7643ea4ea0f159d614cb8d0", "url": "https://github.com/seata/seata/commit/23a6d2d720cada5cb7643ea4ea0f159d614cb8d0", "message": "remove unused import", "committedDate": "2020-03-18T10:08:33Z", "type": "commit"}, {"oid": "6cc40951dec54ff0fad40352048ed14c285583a7", "url": "https://github.com/seata/seata/commit/6cc40951dec54ff0fad40352048ed14c285583a7", "message": "restore test case to 200ms", "committedDate": "2020-03-19T11:48:00Z", "type": "commit"}, {"oid": "c2472800ad60290786cd79abcf8f29d3c556fe25", "url": "https://github.com/seata/seata/commit/c2472800ad60290786cd79abcf8f29d3c556fe25", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-19T11:48:26Z", "type": "commit"}, {"oid": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "url": "https://github.com/seata/seata/commit/6f4fcac48fb2abb83189e531a8aba6a46e392d00", "message": "format code style", "committedDate": "2020-03-19T12:07:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODA0Mw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395428043", "bodyText": "Wrong class name.", "author": "ggndnn", "createdAt": "2020-03-20T03:47:24Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionDefinition.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMDY1OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395430658", "bodyText": "Corrected", "author": "booogu", "createdAt": "2020-03-20T04:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODQxMA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395428410", "bodyText": "Sub class is not allowed?", "author": "ggndnn", "createdAt": "2020-03-20T03:48:54Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionDefinition.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL\n+ *\n+ * @author haozhibei\n+ */\n+class ExtensionDefinition {\n+    private String name;\n+    private Class serviceClass;\n+    private Integer order;\n+    private Scope scope;\n+\n+    public Integer getOrder() {\n+        return this.order;\n+    }\n+\n+    public void setOrder(Integer order) {\n+        this.order = order;\n+    }\n+\n+    public Class getServiceClass() {\n+        return this.serviceClass;\n+    }\n+\n+    public void setServiceClass(Class clazz) {\n+        this.serviceClass = clazz;\n+    }\n+\n+    public Scope getScope() {\n+        return this.scope;\n+    }\n+\n+    public void setScope(Scope scope) {\n+        this.scope = scope;\n+    }\n+\n+    public ExtensionDefinition(String name, Integer order, Scope scope, Class clazz) {\n+        this.name = name;\n+        this.order = order;\n+        this.scope = scope;\n+        this.serviceClass = clazz;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((name == null) ? 0 : name.hashCode());\n+        result = prime * result + ((serviceClass == null) ? 0 : serviceClass.hashCode());\n+        result = prime * result + ((order == null) ? 0 : order.hashCode());\n+        result = prime * result + ((scope == null) ? 0 : scope.hashCode());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzNDU0NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395434544", "bodyText": "I think the class ExtensionDefinition should not be inherited. How about setting it to final?", "author": "booogu", "createdAt": "2020-03-20T04:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MDI2NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395440264", "bodyText": "fine.", "author": "ggndnn", "createdAt": "2020-03-20T05:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxOTE0Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r397719147", "bodyText": "issue was added 2454", "author": "booogu", "createdAt": "2020-03-25T09:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODU0Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395428547", "bodyText": "Can be optimized to return !scope.equals(other.scope.", "author": "ggndnn", "createdAt": "2020-03-20T03:49:46Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionDefinition.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL\n+ *\n+ * @author haozhibei\n+ */\n+class ExtensionDefinition {\n+    private String name;\n+    private Class serviceClass;\n+    private Integer order;\n+    private Scope scope;\n+\n+    public Integer getOrder() {\n+        return this.order;\n+    }\n+\n+    public void setOrder(Integer order) {\n+        this.order = order;\n+    }\n+\n+    public Class getServiceClass() {\n+        return this.serviceClass;\n+    }\n+\n+    public void setServiceClass(Class clazz) {\n+        this.serviceClass = clazz;\n+    }\n+\n+    public Scope getScope() {\n+        return this.scope;\n+    }\n+\n+    public void setScope(Scope scope) {\n+        this.scope = scope;\n+    }\n+\n+    public ExtensionDefinition(String name, Integer order, Scope scope, Class clazz) {\n+        this.name = name;\n+        this.order = order;\n+        this.scope = scope;\n+        this.serviceClass = clazz;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((name == null) ? 0 : name.hashCode());\n+        result = prime * result + ((serviceClass == null) ? 0 : serviceClass.hashCode());\n+        result = prime * result + ((order == null) ? 0 : order.hashCode());\n+        result = prime * result + ((scope == null) ? 0 : scope.hashCode());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        ExtensionDefinition other = (ExtensionDefinition)obj;\n+        if (!StringUtils.equals(name, other.name)) {\n+            return false;\n+        }\n+        if (!serviceClass.equals(other.serviceClass)) {\n+            return false;\n+        }\n+        if (!order.equals(other.order)) {\n+            return false;\n+        }\n+        if (!scope.equals(other.scope)) {\n+            return false;\n+        }\n+        return true;", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTI5Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395431297", "bodyText": "Ok,done", "author": "booogu", "createdAt": "2020-03-20T04:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODg3MA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395428870", "bodyText": "Wrong usage of assertThat, should be assertThat(xxxx).isTrue() or assertThat(xxxx).isFalse().", "author": "ggndnn", "createdAt": "2020-03-20T03:51:42Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -98,4 +98,32 @@ public void getAllExtensionClass1() {\n         assertThat(allExtensionClass).isNotEmpty();\n     }\n \n+    @Test\n+    public void getSingletonExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        assertThat(hello1 == hello2);\n+    }\n+\n+    @Test\n+    public void getMultipleExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        assertThat(hello1 != hello2);\n+    }\n+\n+    @Test\n+    public void getAllInstances(){\n+        List<Hello> hellows1 = EnhancedServiceLoader.loadAll(Hello.class);\n+        List<Hello> hellows2 = EnhancedServiceLoader.loadAll(Hello.class);\n+        for (Hello hello : hellows1){\n+            if(hello.say()!=\"Ol\u00e1.\"){\n+                assertThat(hellows2.contains(hello));\n+            }\n+            else{\n+                assertThat(!hellows2.contains(hello));\n+            }\n+        }\n+    }", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTAwMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395431001", "bodyText": "Changed to the right usage", "author": "booogu", "createdAt": "2020-03-20T04:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODk1NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395428954", "bodyText": "LatinHello is SINGLETON not PROTOTYPE.", "author": "ggndnn", "createdAt": "2020-03-20T03:52:20Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -98,4 +98,32 @@ public void getAllExtensionClass1() {\n         assertThat(allExtensionClass).isNotEmpty();\n     }\n \n+    @Test\n+    public void getSingletonExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        assertThat(hello1 == hello2);\n+    }\n+\n+    @Test\n+    public void getMultipleExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        assertThat(hello1 != hello2);", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTM3NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395431375", "bodyText": "My fault , add scope = prototype in LatinHello", "author": "booogu", "createdAt": "2020-03-20T04:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyODk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTMwMg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395429302", "bodyText": "I think all setters here are useless, should be removed.", "author": "ggndnn", "createdAt": "2020-03-20T03:54:17Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionDefinition.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL\n+ *\n+ * @author haozhibei\n+ */\n+class ExtensionDefinition {\n+    private String name;\n+    private Class serviceClass;\n+    private Integer order;\n+    private Scope scope;\n+\n+    public Integer getOrder() {\n+        return this.order;\n+    }\n+\n+    public void setOrder(Integer order) {\n+        this.order = order;\n+    }\n+\n+    public Class getServiceClass() {\n+        return this.serviceClass;\n+    }\n+\n+    public void setServiceClass(Class clazz) {\n+        this.serviceClass = clazz;\n+    }\n+\n+    public Scope getScope() {\n+        return this.scope;\n+    }\n+\n+    public void setScope(Scope scope) {\n+        this.scope = scope;\n+    }", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMjUzMw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395432533", "bodyText": "Removed", "author": "booogu", "createdAt": "2020-03-20T04:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTUzMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395429531", "bodyText": "Should keep format unchanged as before, missing space character here.", "author": "ggndnn", "createdAt": "2020-03-20T03:55:43Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -34,8 +34,8 @@\n      */\n     @Test\n     public void testLoadByClassAndClassLoader() {\n-        Hello load = EnhancedServiceLoader.load(Hello.class, Hello.class.getClassLoader());\n-        Assertions.assertEquals(load.say(), \"Bonjour\");\n+        Hello load = EnhancedServiceLoader.load(Hello.class,Hello.class.getClassLoader());", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTc4NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395431785", "bodyText": "restored", "author": "booogu", "createdAt": "2020-03-20T04:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTU3NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395429574", "bodyText": "Should keep format unchanged as before, missing space character here.", "author": "ggndnn", "createdAt": "2020-03-20T03:55:53Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -54,15 +54,15 @@ public void testLoadException() {\n     @Test\n     public void testLoadByClass() {\n         Hello load = EnhancedServiceLoader.load(Hello.class);\n-        assertThat(load.say()).isEqualTo(\"Bonjour\");\n+        assertThat(load.say()).isEqualTo(\"Ol\u00e1.\");\n     }\n \n     /**\n      * Test load by class and activate name.\n      */\n     @Test\n     public void testLoadByClassAndActivateName() {\n-        Hello englishHello = EnhancedServiceLoader.load(Hello.class, \"EnglishHello\");\n+        Hello englishHello = EnhancedServiceLoader.load(Hello.class,\"EnglishHello\");", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMjM0NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395432345", "bodyText": "Restored the missing space character.", "author": "booogu", "createdAt": "2020-03-20T04:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMDI2Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395430266", "bodyText": "Format issue here.", "author": "ggndnn", "createdAt": "2020-03-20T04:00:14Z", "path": "core/src/main/java/io/seata/core/store/StoreMode.java", "diffHunk": "@@ -25,26 +25,35 @@\n     /**\n      * file store\n      */\n-    FILE,\n+    FILE(\"file\"),\n \n     /**\n      * database store\n      */\n-    DB;\n+    DB(\"db\");\n+\n+    private String name;\n+\n+    StoreMode(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n \n     /**\n-     * Valueof store mode.\n-     *\n-     * @param mode the mode\n-     * @return the store mode\n+     * get value of store mode\n+     * @param name the mode name\n+     *  @return the store mode", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTk4Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395431982", "bodyText": "Formated", "author": "booogu", "createdAt": "2020-03-20T04:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMDQ5Mw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395430493", "bodyText": "Should keep format unchanged as before, redundant tab character here.", "author": "ggndnn", "createdAt": "2020-03-20T04:01:24Z", "path": "server/src/main/java/io/seata/server/lock/db/DataBaseLocker.java", "diffHunk": "@@ -50,8 +51,8 @@ public DataBaseLocker() {\n      * @param logStoreDataSource the log store data source\n      */\n     public DataBaseLocker(DataSource logStoreDataSource) {\n-        lockStore = EnhancedServiceLoader.load(LockStore.class, StoreMode.DB.name(), new Class[] {DataSource.class},\n-            new Object[] {logStoreDataSource});\n+        lockStore = EnhancedServiceLoader.load(LockStore.class, StoreMode.DB.getName(), new Class[] {DataSource.class},\n+                new Object[] {logStoreDataSource});", "originalCommit": "6f4fcac48fb2abb83189e531a8aba6a46e392d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMjEyMg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395432122", "bodyText": "Ok,removed the redundant tab character.", "author": "booogu", "createdAt": "2020-03-20T04:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMDQ5Mw=="}], "type": "inlineReview"}, {"oid": "80151dc503eca9a69953df21af63650f9e569a28", "url": "https://github.com/seata/seata/commit/80151dc503eca9a69953df21af63650f9e569a28", "message": "format some code and make ExtensionDefinition final", "committedDate": "2020-03-20T05:29:43Z", "type": "commit"}, {"oid": "453c8c61e615ca1eb798c735123be10512ddacc9", "url": "https://github.com/seata/seata/commit/453c8c61e615ca1eb798c735123be10512ddacc9", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-20T06:15:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4MzAwMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395583001", "bodyText": "As said before, this statement should be if (defaultExtensionDefinition == null || priority > highestLoadPriority).", "author": "ggndnn", "createdAt": "2020-03-20T11:42:20Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,445 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+        private ExtensionDefinition defaultExtensionDefinition = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            result = definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+            return result;\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();\n+                    int o2 = definition2.getOrder();\n+                    return Integer.compare(o1, o2);\n+                });\n+            }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+            return extensionDefinitions;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, List<ExtensionDefinition> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionDefinition extensionDefinition = getExtensionDefinition(clazz);\n+                                    extensions.add(extensionDefinition);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionDefinition getExtensionDefinition(Class<?> clazz) {\n+            String serviceName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            ExtensionDefinition result = new ExtensionDefinition(serviceName, priority, scope, clazz);\n+            //do cache\n+            classToDefinitionMap.put(clazz, result);\n+            if (serviceName != null) {\n+                if (nameToDefinitionsMap.containsKey(serviceName)) {\n+                    List<ExtensionDefinition> definitions = nameToDefinitionsMap.get(serviceName);\n+                    definitions.add(result);\n+                } else {\n+                    List<ExtensionDefinition> definitions = new ArrayList<>();\n+                    definitions.add(result);\n+                    nameToDefinitionsMap.put(serviceName, definitions);\n+                }\n+            }\n+            if (defaultExtensionDefinition == null || priority >= highestLoadPriority) {", "originalCommit": "453c8c61e615ca1eb798c735123be10512ddacc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyODQxMw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396228413", "bodyText": "This part of code was removed cause that they wer unnecessary.", "author": "booogu", "createdAt": "2020-03-23T06:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4MzAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4NDMxOA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395584318", "bodyText": "Since extensionDefinitions were sorted, is the defaultExtensionDefinition calculating in getExtensionDefinition\nnecessary?", "author": "ggndnn", "createdAt": "2020-03-20T11:45:36Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,445 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+        private ExtensionDefinition defaultExtensionDefinition = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            result = definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+            return result;\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();", "originalCommit": "453c8c61e615ca1eb798c735123be10512ddacc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyODYzMA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396228630", "bodyText": "Yeah, it is true that the calculating in getExtensionDef is  unnecessary,I will remove them.", "author": "booogu", "createdAt": "2020-03-23T06:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4NDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4NTczNA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395585734", "bodyText": "Remove var result and return definitions.stream().map(ExtensionDefinition::getServiceClass).collect(Collectors.toList())?", "author": "ggndnn", "createdAt": "2020-03-20T11:48:54Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,445 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+        private ExtensionDefinition defaultExtensionDefinition = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            result = definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+            return result;", "originalCommit": "453c8c61e615ca1eb798c735123be10512ddacc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyODcxNg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396228716", "bodyText": "OK, done", "author": "booogu", "createdAt": "2020-03-23T06:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4NTczNA=="}], "type": "inlineReview"}, {"oid": "ba9b6b80ef810d324fe27fa708b2d79ea5fda712", "url": "https://github.com/seata/seata/commit/ba9b6b80ef810d324fe27fa708b2d79ea5fda712", "message": "resolve conflicts with dev", "committedDate": "2020-03-23T06:21:44Z", "type": "commit"}, {"oid": "10a56182bac3acac98dcfd31869359773f1adf18", "url": "https://github.com/seata/seata/commit/10a56182bac3acac98dcfd31869359773f1adf18", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-03-23T06:23:21Z", "type": "commit"}, {"oid": "8648cc77001be69904f0f81ddc44ef65018415de", "url": "https://github.com/seata/seata/commit/8648cc77001be69904f0f81ddc44ef65018415de", "message": "restore some code style", "committedDate": "2020-03-23T06:53:41Z", "type": "commit"}, {"oid": "42c63a2829bc5a51b5c4895dee3eff4144d215d6", "url": "https://github.com/seata/seata/commit/42c63a2829bc5a51b5c4895dee3eff4144d215d6", "message": "add newline in SQLOperateRecognizerHolderFactory", "committedDate": "2020-03-23T06:55:35Z", "type": "commit"}, {"oid": "7708d26153092c9212ec3823c6a1d74533760020", "url": "https://github.com/seata/seata/commit/7708d26153092c9212ec3823c6a1d74533760020", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-23T07:05:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1MDA0MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396250041", "bodyText": "It is recommended that findClassLoader() be placed in the EnhancedServiceLoader class, which is responsible for the parameter assembly.", "author": "slievrly", "createdAt": "2020-03-23T07:21:51Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -84,7 +77,8 @@\n      * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n      */\n     public static <S> S load(Class<S> service, String activateName) throws EnhancedServiceNotFoundException {\n-        return loadFile(service, activateName, findClassLoader());\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).load(activateName,", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2NjQzNg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396266436", "bodyText": "OK,now i place it in the EnhancedServiceLoader, and uniformly construct the parameters before calling the inner method.", "author": "booogu", "createdAt": "2020-03-23T08:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1MDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2MTI4Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396261287", "bodyText": "In the original logic, this could be empty.", "author": "slievrly", "createdAt": "2020-03-23T07:51:05Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,446 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition defaultExtensionDefinition = getDefaultExtensionDefinition();\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2ODc0Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396268747", "bodyText": "This method is used for scenarios where the user explicitly passes activateName, not the initial loaded scenario.", "author": "booogu", "createdAt": "2020-03-23T08:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2MTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI3MjcxNQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396272715", "bodyText": "When is this a collection instead of a single element?", "author": "slievrly", "createdAt": "2020-03-23T08:16:46Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,446 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI3NzQyNw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396277427", "bodyText": "I think we can allow an extension implementation to have the same name and interface name, so here a name may correspond to multiple implementations", "author": "booogu", "createdAt": "2020-03-23T08:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI3MjcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI4MzY1MA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396283650", "bodyText": "how about set\uff1f What happens if I write two identical records in the spi file?", "author": "slievrly", "createdAt": "2020-03-23T08:38:14Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,446 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition defaultExtensionDefinition = getDefaultExtensionDefinition();\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n+            }\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            return definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();\n+                    int o2 = definition2.getOrder();\n+                    return Integer.compare(o1, o2);\n+                });\n+            }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+            return extensionDefinitions;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, List<ExtensionDefinition> extensions)", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMTEyNA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396321124", "bodyText": "Without adjusting the data structure, now I will check whether the ExtensionDefinition has been loaded . If it is the same two-line configuration, I will print a warn log and skip the repeated loading", "author": "booogu", "createdAt": "2020-03-23T09:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI4MzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5MzE5OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396293198", "bodyText": "if necessary\uff1f", "author": "slievrly", "createdAt": "2020-03-23T08:54:58Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,446 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition defaultExtensionDefinition = getDefaultExtensionDefinition();\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n+            }\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDQ5NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396314495", "bodyText": "I checked all the call stacks of createNewExtension(), found that when createNew() is executed, all extension classes have been loaded, so it's unnecessary.I will remove it.", "author": "booogu", "createdAt": "2020-03-23T09:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5MzE5OA=="}], "type": "inlineReview"}, {"oid": "a1352e9930b47adbb04e7249d503f3d734e3f01c", "url": "https://github.com/seata/seata/commit/a1352e9930b47adbb04e7249d503f3d734e3f01c", "message": "Adjust the calling mode of EnhancedServiceLoader and InnerLoader", "committedDate": "2020-03-23T09:33:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTYyNA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395979624", "bodyText": "Can be changed to try-resource", "author": "ph3636", "createdAt": "2020-03-21T10:05:17Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,445 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+        private ExtensionDefinition defaultExtensionDefinition = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            result = definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+            return result;\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();\n+                    int o2 = definition2.getOrder();\n+                    return Integer.compare(o1, o2);\n+                });\n+            }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+            return extensionDefinitions;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, List<ExtensionDefinition> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionDefinition extensionDefinition = getExtensionDefinition(clazz);\n+                                    extensions.add(extensionDefinition);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);", "originalCommit": "453c8c61e615ca1eb798c735123be10512ddacc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1MDI2MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396350261", "bodyText": "Changed", "author": "booogu", "createdAt": "2020-03-23T10:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTY4NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r395979685", "bodyText": "Can be changed to\u3010nameToDefinitionsMap.computeIfAbsent(serviceName, e -> new ArrayList<>()).add(result);\u3011", "author": "ph3636", "createdAt": "2020-03-21T10:06:02Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +173,445 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+        private ExtensionDefinition defaultExtensionDefinition = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass() {\n+            return loadAllExtensionClass(findClassLoader());\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            loadAllExtensionClass(loader);\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            result = definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+            return result;\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();\n+                    int o2 = definition2.getOrder();\n+                    return Integer.compare(o1, o2);\n+                });\n+            }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+            return extensionDefinitions;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, List<ExtensionDefinition> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionDefinition extensionDefinition = getExtensionDefinition(clazz);\n+                                    extensions.add(extensionDefinition);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionDefinition getExtensionDefinition(Class<?> clazz) {\n+            String serviceName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            ExtensionDefinition result = new ExtensionDefinition(serviceName, priority, scope, clazz);\n+            //do cache\n+            classToDefinitionMap.put(clazz, result);\n+            if (serviceName != null) {\n+                if (nameToDefinitionsMap.containsKey(serviceName)) {\n+                    List<ExtensionDefinition> definitions = nameToDefinitionsMap.get(serviceName);\n+                    definitions.add(result);\n+                } else {\n+                    List<ExtensionDefinition> definitions = new ArrayList<>();\n+                    definitions.add(result);\n+                    nameToDefinitionsMap.put(serviceName, definitions);\n+                }", "originalCommit": "453c8c61e615ca1eb798c735123be10512ddacc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1MTE1Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396351156", "bodyText": "Nice simplification, done", "author": "booogu", "createdAt": "2020-03-23T10:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUwNjMzMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396506331", "bodyText": "I think the origin meaning was to change the code from line 513 - 517 to nameToDefinitionsMap.computeIfAbsent(serviceName, e -> new ArrayList<>()).add(result).", "author": "ggndnn", "createdAt": "2020-03-23T14:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MTM4Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396851386", "bodyText": "I think the origin meaning was to change the code from line 513 - 517 to nameToDefinitionsMap.computeIfAbsent(serviceName, e -> new ArrayList<>()).add(result).\n\nYeah\uff0cMy understanding is wrong, now changed", "author": "booogu", "createdAt": "2020-03-24T01:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3OTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2MzcxOQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396263719", "bodyText": "It should be singleton", "author": "ph3636", "createdAt": "2020-03-23T07:57:07Z", "path": "metrics/seata-metrics-exporter-prometheus/src/main/java/io/seata/metrics/exporter/prometheus/PrometheusExporter.java", "diffHunk": "@@ -37,7 +38,7 @@\n  *\n  * @author zhengyangyong\n  */\n-@LoadLevel(name = \"Prometheus\", order = 1)\n+@LoadLevel(name = \"prometheus\", order = 1, scope = Scope.PROTOTYPE)", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Mzg2NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396353864", "bodyText": "Changed.", "author": "booogu", "createdAt": "2020-03-23T10:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2MzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2Mzc4MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396263781", "bodyText": "It should be singleton", "author": "ph3636", "createdAt": "2020-03-23T07:57:14Z", "path": "metrics/seata-metrics-registry-compact/src/main/java/io/seata/metrics/registry/compact/CompactRegistry.java", "diffHunk": "@@ -37,7 +38,7 @@\n  *\n  * @author zhengyangyong\n  */\n-@LoadLevel(name = \"Compact\", order = 1)\n+@LoadLevel(name = \"compact\", order = 1, scope = Scope.PROTOTYPE)", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1NDk3NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396354975", "bodyText": "Changed", "author": "booogu", "createdAt": "2020-03-23T10:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2Mzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2Mzg2NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396263864", "bodyText": "It should be singleton", "author": "ph3636", "createdAt": "2020-03-23T07:57:25Z", "path": "serializer/seata-serializer-seata/src/main/java/io/seata/serializer/seata/SeataSerializer.java", "diffHunk": "@@ -28,7 +29,7 @@\n  *\n  * @author zhangsen\n  */\n-@LoadLevel(name = \"SEATA\")\n+@LoadLevel(name = \"SEATA\", scope = Scope.PROTOTYPE)", "originalCommit": "7708d26153092c9212ec3823c6a1d74533760020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1NTg4MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396355881", "bodyText": "Changed", "author": "booogu", "createdAt": "2020-03-23T10:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2Mzg2NA=="}], "type": "inlineReview"}, {"oid": "c034f8f74f6203dabcac2a5b7a13fcf71d0ebe63", "url": "https://github.com/seata/seata/commit/c034f8f74f6203dabcac2a5b7a13fcf71d0ebe63", "message": "adjust some scope value of @LoadLevel", "committedDate": "2020-03-23T11:05:37Z", "type": "commit"}, {"oid": "e86307894c585db431c769de1a0be66f5687f664", "url": "https://github.com/seata/seata/commit/e86307894c585db431c769de1a0be66f5687f664", "message": "remove unuse import", "committedDate": "2020-03-23T11:16:34Z", "type": "commit"}, {"oid": "67e06c31932e2c2a9e1dffeda1ba7f64c5078a93", "url": "https://github.com/seata/seata/commit/67e06c31932e2c2a9e1dffeda1ba7f64c5078a93", "message": "adjust import order in some class", "committedDate": "2020-03-23T12:07:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMjM0Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396412342", "bodyText": "Expression assertThat needs .isTrue().", "author": "ggndnn", "createdAt": "2020-03-23T12:25:42Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -98,4 +98,32 @@ public void getAllExtensionClass1() {\n         assertThat(allExtensionClass).isNotEmpty();\n     }\n \n+    @Test\n+    public void getSingletonExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        assertThat(hello1 == hello2);", "originalCommit": "67e06c31932e2c2a9e1dffeda1ba7f64c5078a93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0050e9834be8bc4b962f0c3e32ea48ccdadc0303", "url": "https://github.com/seata/seata/commit/0050e9834be8bc4b962f0c3e32ea48ccdadc0303", "message": "add isTrue after assert", "committedDate": "2020-03-23T12:39:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNjAyOQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396436029", "bodyText": "If service is SINGLETON and we call load twice with different args, what instance should return? So far we get the first created instance.", "author": "ggndnn", "createdAt": "2020-03-23T13:07:35Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -113,15 +106,8 @@\n      * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n      */\n     public static <S> S load(Class<S> service, String activateName, Object[] args)", "originalCommit": "0050e9834be8bc4b962f0c3e32ea48ccdadc0303", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MTUyOA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396851528", "bodyText": "We can mark as an issue and reslove it later.", "author": "booogu", "createdAt": "2020-03-24T01:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MTU1MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396861551", "bodyText": "fine.", "author": "ggndnn", "createdAt": "2020-03-24T01:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNjAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDExMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396454111", "bodyText": "Expression assertThat needs .isTrue().", "author": "ggndnn", "createdAt": "2020-03-23T13:35:25Z", "path": "common/src/test/java/io/seata/common/loader/EnhancedServiceLoaderTest.java", "diffHunk": "@@ -98,4 +98,32 @@ public void getAllExtensionClass1() {\n         assertThat(allExtensionClass).isNotEmpty();\n     }\n \n+    @Test\n+    public void getSingletonExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"ChineseHello\");\n+        assertThat(hello1 == hello2).isTrue();\n+    }\n+\n+    @Test\n+    public void getMultipleExtensionInstance(){\n+        Hello hello1 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        Hello hello2 = EnhancedServiceLoader.load(Hello.class, \"LatinHello\");\n+        assertThat(hello1 == hello2).isFalse();\n+    }\n+\n+    @Test\n+    public void getAllInstances(){\n+        List<Hello> hellows1 = EnhancedServiceLoader.loadAll(Hello.class);\n+        List<Hello> hellows2 = EnhancedServiceLoader.loadAll(Hello.class);\n+        for (Hello hello : hellows1){\n+            if(hello.say()!=\"Ol\u00e1.\"){\n+                assertThat(hellows2.contains(hello));", "originalCommit": "0050e9834be8bc4b962f0c3e32ea48ccdadc0303", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDM5NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396484394", "bodyText": "Added", "author": "booogu", "createdAt": "2020-03-23T14:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDExMQ=="}], "type": "inlineReview"}, {"oid": "c806d1ba7e1796c900393014a25153a6629e1986", "url": "https://github.com/seata/seata/commit/c806d1ba7e1796c900393014a25153a6629e1986", "message": "add isTrue after assert", "committedDate": "2020-03-23T14:24:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5NzE2NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396497165", "bodyText": "definitionsHolder.get() -> currentDefinitions", "author": "ggndnn", "createdAt": "2020-03-23T14:35:35Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +172,417 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n+    /**\n+     * Cannot use TCCL, in the pandora container will cause the class in the plugin not to be loaded\n+     *\n+     * @return\n+     */\n+    private static ClassLoader findClassLoader() {\n+        return EnhancedServiceLoader.class.getClassLoader();\n     }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+\n+    private static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(InnerEnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<List<ExtensionDefinition>> definitionsHolder = new Holder<>();\n+        private final ConcurrentMap<ExtensionDefinition, Holder<Object>> definitionToInstanceMap =\n+                new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionDefinition>> nameToDefinitionsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionDefinition> classToDefinitionMap = new ConcurrentHashMap<>();\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        private static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @param loader       the loader\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Object[] args, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, loader, argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @param loader  the class loader\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        private S load(String activateName, Class[] argsType, Object[] args, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         * @param loader  the class loader\n+         *\n+         * @return list list\n+         */\n+        private List<S> loadAll(ClassLoader loader) {\n+            return loadAll(null, null, loader);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        private List<S> loadAll(Class[] argsType, Object[] args, ClassLoader loader) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass(loader);\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionDefinition definition = classToDefinitionMap.get(clazz);\n+                    allInstances.add(getExtensionInstance(definition, loader, argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n \n-                extensions = activateExtensions;\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<Class> getAllExtensionClass(ClassLoader loader) {\n+            return loadAllExtensionClass(loader);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition defaultExtensionDefinition = getDefaultExtensionDefinition();\n+                return getExtensionInstance(defaultExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionDefinition cachedExtensionDefinition = getCachedExtensionDefinition(activateName);\n+                return getExtensionInstance(cachedExtensionDefinition, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n+            }\n+        }\n+\n+        private S getExtensionInstance(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes,\n+                                       Object[] args) {\n+            if (definition == null) {\n+                throw new EnhancedServiceNotFoundException(\"not found service provider for : \" + type.getName());\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(definition.getScope())) {\n+                Holder<Object> holder = definitionToInstanceMap.get(definition);\n+                if (holder == null) {\n+                    definitionToInstanceMap.putIfAbsent(definition, new Holder<>());\n+                    holder = definitionToInstanceMap.get(definition);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createNewExtension(definition, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(definition, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createNewExtension(ExtensionDefinition definition, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            Class<?> clazz = definition.getServiceClass();\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(definition: \" + definition + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private List<Class> loadAllExtensionClass(ClassLoader loader) {\n+            List<Class> result;\n+            List<ExtensionDefinition> definitions = definitionsHolder.get();\n+            if (definitions == null) {\n+                synchronized (definitionsHolder) {\n+                    definitions = definitionsHolder.get();\n+                    if (definitions == null) {\n+                        definitions = findAllExtensionDefinition(loader);\n+                        definitionsHolder.set(definitions);\n+                    }\n+                }\n             }\n+            return definitions.stream().map(def -> def.getServiceClass()).collect(Collectors.toList());\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        @SuppressWarnings(\"rawtypes\")\n+        private List<ExtensionDefinition> findAllExtensionDefinition(ClassLoader loader) {\n+            List<ExtensionDefinition> extensionDefinitions = new ArrayList<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensionDefinitions);\n+                loadFile(SEATA_DIRECTORY, loader, extensionDefinitions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n             }\n \n-            return Integer.compare(o1, o2);\n-\n-        });\n+            //After loaded all the extensions,sort the caches by order\n+            if (!nameToDefinitionsMap.isEmpty()) {\n+                for (List<ExtensionDefinition> definitions : nameToDefinitionsMap.values()) {\n+                    Collections.sort(definitions, (def1, def2) -> {\n+                        int o1 = def1.getOrder();\n+                        int o2 = def2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionDefinitions.isEmpty()) {\n+                Collections.sort(extensionDefinitions, (definition1, definition2) -> {\n+                    int o1 = definition1.getOrder();\n+                    int o2 = definition2.getOrder();\n+                    return Integer.compare(o1, o2);\n+                });\n+            }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+            return extensionDefinitions;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader loader, List<ExtensionDefinition> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (loader != null) {\n+                urls = loader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET))) {\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, loader);\n+                                    ExtensionDefinition extensionDefinition = getUnloadedExtensionDefinition(clazz);\n+                                    if (extensionDefinition == null) {\n+                                        LOGGER.warn(\"The same extension {} has already been loaded, skipped\", line);\n+                                        continue;\n+                                    }\n+                                    extensions.add(extensionDefinition);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"Load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionDefinition getUnloadedExtensionDefinition(Class<?> clazz) {\n+            String serviceName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            //Check whether the definition has been loaded\n+            if (!classToDefinitionMap.containsKey(clazz)) {\n+                ExtensionDefinition result = new ExtensionDefinition(serviceName, priority, scope, clazz);\n+                classToDefinitionMap.put(clazz, result);\n+                if (serviceName != null) {\n+                    if (nameToDefinitionsMap.containsKey(serviceName)) {\n+                        List<ExtensionDefinition> definitions = nameToDefinitionsMap.get(serviceName);\n+                        definitions.add(result);\n+                    } else {\n+                        nameToDefinitionsMap.computeIfAbsent(serviceName, e -> new ArrayList<>()).add(result);\n+                    }\n+                }\n+                return result;\n+            }\n+            return null;\n         }\n-        if (s instanceof Initialize) {\n-            ((Initialize)s).init();\n+\n+        private ExtensionDefinition getDefaultExtensionDefinition() {\n+            List<ExtensionDefinition> currentDefinitions = definitionsHolder.get();\n+            if (currentDefinitions != null && currentDefinitions.size() > 0) {\n+                return definitionsHolder.get().get(currentDefinitions.size() - 1);", "originalCommit": "c806d1ba7e1796c900393014a25153a6629e1986", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MTU5Mw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r396851593", "bodyText": "done", "author": "booogu", "createdAt": "2020-03-24T01:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5NzE2NQ=="}], "type": "inlineReview"}, {"oid": "03596f24e934dee6cf9c74dc611ff50eb302834f", "url": "https://github.com/seata/seata/commit/03596f24e934dee6cf9c74dc611ff50eb302834f", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-23T16:18:45Z", "type": "commit"}, {"oid": "112945ab822378e6c37b4d96fef3661f948e2cd3", "url": "https://github.com/seata/seata/commit/112945ab822378e6c37b4d96fef3661f948e2cd3", "message": "adjust the usage of computeIfAbsent", "committedDate": "2020-03-24T01:14:24Z", "type": "commit"}, {"oid": "15e979bb5061b68e7e2f7efa361cb2dc624e9b0b", "url": "https://github.com/seata/seata/commit/15e979bb5061b68e7e2f7efa361cb2dc624e9b0b", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-03-24T01:14:34Z", "type": "commit"}, {"oid": "8454613ba69e659ff745874ccec193d0a36b146e", "url": "https://github.com/seata/seata/commit/8454613ba69e659ff745874ccec193d0a36b146e", "message": "restructure", "committedDate": "2019-11-09T03:11:47Z", "type": "commit"}, {"oid": "387b7cbb08becf632ec62633c456e7c1fc77badc", "url": "https://github.com/seata/seata/commit/387b7cbb08becf632ec62633c456e7c1fc77badc", "message": "Restructure SQLRecognizer and UndoExecutor", "committedDate": "2019-11-09T06:38:09Z", "type": "commit"}, {"oid": "472cb658328284dedb9b66d3369419428ce2616d", "url": "https://github.com/seata/seata/commit/472cb658328284dedb9b66d3369419428ce2616d", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-11-11T06:35:24Z", "type": "commit"}, {"oid": "96de7fd8499b1a8344532465b92661485b59b2e1", "url": "https://github.com/seata/seata/commit/96de7fd8499b1a8344532465b92661485b59b2e1", "message": "optimize concurrency of UndoExecutorGruopFactory and SQLRecognizerGroupFactory", "committedDate": "2019-11-11T06:37:05Z", "type": "commit"}, {"oid": "d4f090ff64ca12f4d9a47a51d8d88f70cba90804", "url": "https://github.com/seata/seata/commit/d4f090ff64ca12f4d9a47a51d8d88f70cba90804", "message": "remove @version tags", "committedDate": "2019-11-11T07:14:20Z", "type": "commit"}, {"oid": "550f6e12e528e0b891f7fa5244cfd75ad40aa9dc", "url": "https://github.com/seata/seata/commit/550f6e12e528e0b891f7fa5244cfd75ad40aa9dc", "message": "add javaDoc;optimize UndoExecutorGroupFactory and SQLOperateRecognizerGroupFactory", "committedDate": "2019-11-11T08:13:55Z", "type": "commit"}, {"oid": "b0e250e7424b5c023e29c8cb302c90257fc6865f", "url": "https://github.com/seata/seata/commit/b0e250e7424b5c023e29c8cb302c90257fc6865f", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-11T09:17:47Z", "type": "commit"}, {"oid": "d06df2e0f95590f70c50cede0e91a0769b88047a", "url": "https://github.com/seata/seata/commit/d06df2e0f95590f70c50cede0e91a0769b88047a", "message": "rename **Group to **Holder", "committedDate": "2019-11-12T01:04:52Z", "type": "commit"}, {"oid": "3d46a4660cb487c73ddfc6da7bbab5122f7cda9f", "url": "https://github.com/seata/seata/commit/3d46a4660cb487c73ddfc6da7bbab5122f7cda9f", "message": "Merge branch 'develop' of https://github.com/CharmingRabbit/seata into develop", "committedDate": "2019-11-12T01:06:40Z", "type": "commit"}, {"oid": "28322ac0b56e79b26f156d9e927371ece2799c8b", "url": "https://github.com/seata/seata/commit/28322ac0b56e79b26f156d9e927371ece2799c8b", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-12T10:07:28Z", "type": "commit"}, {"oid": "57fb2d033e654890bc34adf3f5f2a3001c7600a7", "url": "https://github.com/seata/seata/commit/57fb2d033e654890bc34adf3f5f2a3001c7600a7", "message": "remove @data", "committedDate": "2019-11-12T11:08:51Z", "type": "commit"}, {"oid": "c3ae74a5359eec9b2d6fa7051cbe22f27ec79426", "url": "https://github.com/seata/seata/commit/c3ae74a5359eec9b2d6fa7051cbe22f27ec79426", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-11-12T11:10:06Z", "type": "commit"}, {"oid": "e9a163e1535ded6ad4d93884a7e4e6d38b938423", "url": "https://github.com/seata/seata/commit/e9a163e1535ded6ad4d93884a7e4e6d38b938423", "message": "Merge branch 'develop' of https://github.com/CharmingRabbit/seata into develop", "committedDate": "2019-11-12T11:10:36Z", "type": "commit"}, {"oid": "78f456fc5e4af3f86fc117f43d6f21acd16dac86", "url": "https://github.com/seata/seata/commit/78f456fc5e4af3f86fc117f43d6f21acd16dac86", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-13T04:52:40Z", "type": "commit"}, {"oid": "8c0f5d28d0fe236ef2cb783435b2df1e28d672e1", "url": "https://github.com/seata/seata/commit/8c0f5d28d0fe236ef2cb783435b2df1e28d672e1", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-13T09:24:52Z", "type": "commit"}, {"oid": "3e9a6bdbc44384652899470b6185958fc11a69b4", "url": "https://github.com/seata/seata/commit/3e9a6bdbc44384652899470b6185958fc11a69b4", "message": "fix NPE in UndoExecutorFactory", "committedDate": "2019-11-14T01:18:52Z", "type": "commit"}, {"oid": "19ef256b49f428f07e88a4600850cccc2d900e47", "url": "https://github.com/seata/seata/commit/19ef256b49f428f07e88a4600850cccc2d900e47", "message": "restructure", "committedDate": "2019-11-14T01:21:18Z", "type": "commit"}, {"oid": "43bc2c344dd8f44ad4f60dcadcbe54a6ba4ddbb1", "url": "https://github.com/seata/seata/commit/43bc2c344dd8f44ad4f60dcadcbe54a6ba4ddbb1", "message": "Restructure SQLRecognizer and UndoExecutor", "committedDate": "2019-11-14T01:21:19Z", "type": "commit"}, {"oid": "45a275caf806f3d9aae5edd7f27fcc27f5d1b9d8", "url": "https://github.com/seata/seata/commit/45a275caf806f3d9aae5edd7f27fcc27f5d1b9d8", "message": "optimize concurrency of UndoExecutorGruopFactory and SQLRecognizerGroupFactory", "committedDate": "2019-11-14T01:21:19Z", "type": "commit"}, {"oid": "a96fe5e8e36bbd242ad44d05c767c3263a2e75be", "url": "https://github.com/seata/seata/commit/a96fe5e8e36bbd242ad44d05c767c3263a2e75be", "message": "remove @version tags", "committedDate": "2019-11-14T01:21:20Z", "type": "commit"}, {"oid": "5febb227411c5594506c9c8eb1fabf7ad7e40a0a", "url": "https://github.com/seata/seata/commit/5febb227411c5594506c9c8eb1fabf7ad7e40a0a", "message": "add javaDoc;optimize UndoExecutorGroupFactory and SQLOperateRecognizerGroupFactory", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "b9a3696a94eecda0715732aff2eca04b0ec5bc8c", "url": "https://github.com/seata/seata/commit/b9a3696a94eecda0715732aff2eca04b0ec5bc8c", "message": "rename **Group to **Holder", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "ca8813429e12ef93c754c05efd3c496a9acab069", "url": "https://github.com/seata/seata/commit/ca8813429e12ef93c754c05efd3c496a9acab069", "message": "remove @data", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "05adb694c15ddff8379f3858afa8e821c44497f0", "url": "https://github.com/seata/seata/commit/05adb694c15ddff8379f3858afa8e821c44497f0", "message": "optimize: xid header lowercase (#1789)", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "b1b05a94656883c8ad4582dffa1581426715fce7", "url": "https://github.com/seata/seata/commit/b1b05a94656883c8ad4582dffa1581426715fce7", "message": "clean: reformat saga module (#1890)", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "2c5fe29ea4352dc7a01713e405ad228c4bdd52b5", "url": "https://github.com/seata/seata/commit/2c5fe29ea4352dc7a01713e405ad228c4bdd52b5", "message": "fix NPE in UndoExecutorFactory", "committedDate": "2019-11-14T01:21:21Z", "type": "commit"}, {"oid": "92bba972a2d761ca185dc256749b5194e199ffdc", "url": "https://github.com/seata/seata/commit/92bba972a2d761ca185dc256749b5194e199ffdc", "message": "Merge branch 'develop' of https://github.com/CharmingRabbit/seata into develop", "committedDate": "2019-11-14T02:54:43Z", "type": "commit"}, {"oid": "c116c9b0fb4b1e3e6cb6ff7c1ef77c2d453c8cd9", "url": "https://github.com/seata/seata/commit/c116c9b0fb4b1e3e6cb6ff7c1ef77c2d453c8cd9", "message": "merge latest code", "committedDate": "2019-11-14T12:02:14Z", "type": "commit"}, {"oid": "59fe1cf5118baed2467d3d9b5471fc9a415f96fa", "url": "https://github.com/seata/seata/commit/59fe1cf5118baed2467d3d9b5471fc9a415f96fa", "message": "bugfix:fix NPE in UndoExecutorFactory", "committedDate": "2019-11-14T12:04:39Z", "type": "commit"}, {"oid": "378e89c316845148800674914e9c740a03091178", "url": "https://github.com/seata/seata/commit/378e89c316845148800674914e9c740a03091178", "message": "local commit", "committedDate": "2019-11-21T07:16:01Z", "type": "commit"}, {"oid": "b8dcb893e02ee7d11f4692267c650a412aa4891e", "url": "https://github.com/seata/seata/commit/b8dcb893e02ee7d11f4692267c650a412aa4891e", "message": "merge remote", "committedDate": "2019-11-22T02:59:42Z", "type": "commit"}, {"oid": "9755622cb16b6014a7a8ed8a2ecb1c0e23551a65", "url": "https://github.com/seata/seata/commit/9755622cb16b6014a7a8ed8a2ecb1c0e23551a65", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-11-22T02:59:54Z", "type": "commit"}, {"oid": "ade3c8529a29485631b6f639d29fb255a52cb24a", "url": "https://github.com/seata/seata/commit/ade3c8529a29485631b6f639d29fb255a52cb24a", "message": "bugfix:A bug that will appear when the default constructor is declared private", "committedDate": "2019-11-22T03:03:21Z", "type": "commit"}, {"oid": "c0867c6aac833153e6eeddef3b3929a5fd3fc162", "url": "https://github.com/seata/seata/commit/c0867c6aac833153e6eeddef3b3929a5fd3fc162", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-11-22T08:51:55Z", "type": "commit"}, {"oid": "9fc4f5eacf38028b5bddbe726dfaff86159110f9", "url": "https://github.com/seata/seata/commit/9fc4f5eacf38028b5bddbe726dfaff86159110f9", "message": "code", "committedDate": "2019-11-22T08:53:44Z", "type": "commit"}, {"oid": "dbf102fa9528b7cc8e6b2b40182520f589392731", "url": "https://github.com/seata/seata/commit/dbf102fa9528b7cc8e6b2b40182520f589392731", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-23T09:00:46Z", "type": "commit"}, {"oid": "ea397a7bf89d48a98a29385e5a3836edad7bdf5f", "url": "https://github.com/seata/seata/commit/ea397a7bf89d48a98a29385e5a3836edad7bdf5f", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-24T07:24:40Z", "type": "commit"}, {"oid": "3f4dd2bed800b7291fb6bbe69b82fd86340a6a85", "url": "https://github.com/seata/seata/commit/3f4dd2bed800b7291fb6bbe69b82fd86340a6a85", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-29T03:44:56Z", "type": "commit"}, {"oid": "028a80d963f9393724256bd6bcb0b54429b94404", "url": "https://github.com/seata/seata/commit/028a80d963f9393724256bd6bcb0b54429b94404", "message": "Merge branch 'develop' into develop", "committedDate": "2019-11-29T13:10:28Z", "type": "commit"}, {"oid": "e1968bb425a2ce25123fff1de6165f596e876be8", "url": "https://github.com/seata/seata/commit/e1968bb425a2ce25123fff1de6165f596e876be8", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-12-02T07:34:12Z", "type": "commit"}, {"oid": "fd36c51a528ee06691ca976f0c44f0fa4b0f25b7", "url": "https://github.com/seata/seata/commit/fd36c51a528ee06691ca976f0c44f0fa4b0f25b7", "message": "Merge branch 'develop' of https://github.com/CharmingRabbit/seata into develop", "committedDate": "2019-12-02T07:34:45Z", "type": "commit"}, {"oid": "f01d15f86cb359c5fe59826b7572352548afd378", "url": "https://github.com/seata/seata/commit/f01d15f86cb359c5fe59826b7572352548afd378", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-12-05T11:26:23Z", "type": "commit"}, {"oid": "c9aa49b922a67e8257b420166e2a1da724cd3eb0", "url": "https://github.com/seata/seata/commit/c9aa49b922a67e8257b420166e2a1da724cd3eb0", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-12-17T07:57:43Z", "type": "commit"}, {"oid": "f195d869e57125771712dc79439fb61241bfd3b4", "url": "https://github.com/seata/seata/commit/f195d869e57125771712dc79439fb61241bfd3b4", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2019-12-30T00:55:57Z", "type": "commit"}, {"oid": "c3399fff0c4bfd65b79afae3c8a55a66560f7410", "url": "https://github.com/seata/seata/commit/c3399fff0c4bfd65b79afae3c8a55a66560f7410", "message": "Merge remote-tracking branch 'upstream/develop' into develop", "committedDate": "2020-01-04T06:59:02Z", "type": "commit"}, {"oid": "2def89c2359469ad3a66c122d4084cffa58bc745", "url": "https://github.com/seata/seata/commit/2def89c2359469ad3a66c122d4084cffa58bc745", "message": "optimize: optimize spi", "committedDate": "2020-01-04T10:18:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTUxNw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091517", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:57:26Z", "path": "server/src/main/java/io/seata/server/lock/db/DataBaseLocker.java", "diffHunk": "@@ -33,7 +34,7 @@\n  *\n  * @author zhangsen\n  */\n-@LoadLevel(name = \"db\")\n+@LoadLevel(name = \"db\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTUyNw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091527", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:57:37Z", "path": "server/src/main/java/io/seata/server/session/DefaultSessionManager.java", "diffHunk": "@@ -31,7 +32,7 @@\n  *\n  * @author sharajava\n  */\n-@LoadLevel(name = \"default\")\n+@LoadLevel(name = \"default\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1ODEwMA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363158100", "bodyText": "my mistake", "author": "zjinlei", "createdAt": "2020-01-06T04:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTUzMQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091531", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:57:44Z", "path": "server/src/main/java/io/seata/server/session/db/DataBaseSessionManager.java", "diffHunk": "@@ -46,7 +47,7 @@\n  *\n  * @author zhangsen\n  */\n-@LoadLevel(name = \"db\")\n+@LoadLevel(name = \"db\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTU0NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091544", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:57:53Z", "path": "server/src/main/java/io/seata/server/session/file/FileBasedSessionManager.java", "diffHunk": "@@ -45,7 +46,7 @@\n  *\n  * @author slievrly\n  */\n-@LoadLevel(name = \"file\")\n+@LoadLevel(name = \"file\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTU0OQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091549", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:57:58Z", "path": "server/src/main/java/io/seata/server/store/db/DatabaseTransactionStoreManager.java", "diffHunk": "@@ -54,7 +55,7 @@\n  *\n  * @author zhangsen\n  */\n-@LoadLevel(name = \"db\")\n+@LoadLevel(name = \"db\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5MTU1OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r363091558", "bodyText": "SINGLETON", "author": "zjinlei", "createdAt": "2020-01-05T12:58:06Z", "path": "server/src/main/java/io/seata/server/store/file/FileTransactionStoreManager.java", "diffHunk": "@@ -56,7 +57,7 @@\n  *\n  * @author slievrly\n  */\n-@LoadLevel(name = \"file\")\n+@LoadLevel(name = \"file\",scope = Scope.PROTOTYPE)", "originalCommit": "2def89c2359469ad3a66c122d4084cffa58bc745", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca3c46f56da3ff79aba406aa24737659829ec0e3", "url": "https://github.com/seata/seata/commit/ca3c46f56da3ff79aba406aa24737659829ec0e3", "message": "Adjust the case of name and scope in some @LoadLevel", "committedDate": "2020-01-06T06:06:47Z", "type": "commit"}, {"oid": "d635ca0b032c6a7f5e2dfa59e67acc9fc83d5f38", "url": "https://github.com/seata/seata/commit/d635ca0b032c6a7f5e2dfa59e67acc9fc83d5f38", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-01-06T07:00:38Z", "type": "commit"}, {"oid": "33c4e8f7571e2c9bb3316fb8af30e298b03d63f2", "url": "https://github.com/seata/seata/commit/33c4e8f7571e2c9bb3316fb8af30e298b03d63f2", "message": "resolve conflicts for spi refactor", "committedDate": "2020-02-05T08:21:00Z", "type": "commit"}, {"oid": "29cb3bcfca9f683e2fc4e6a5e2f4e9e07dea150f", "url": "https://github.com/seata/seata/commit/29cb3bcfca9f683e2fc4e6a5e2f4e9e07dea150f", "message": "adjust spi refactor", "committedDate": "2020-02-06T07:48:53Z", "type": "commit"}, {"oid": "74e8628a330a6f97049f3c561c7f24e89ba1c5d2", "url": "https://github.com/seata/seata/commit/74e8628a330a6f97049f3c561c7f24e89ba1c5d2", "message": "resolve conflict", "committedDate": "2020-02-06T09:24:50Z", "type": "commit"}, {"oid": "6a2b2af61c1d08b00b92019a227ddcf38c65be9a", "url": "https://github.com/seata/seata/commit/6a2b2af61c1d08b00b92019a227ddcf38c65be9a", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-02-07T03:53:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxMDU1OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r376310558", "bodyText": "different SPI loadLevel\u2018s name can be same.", "author": "slievrly", "createdAt": "2020-02-07T10:08:32Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -336,11 +422,51 @@ private static void loadFile(Class<?> service, String dir, ClassLoader classLoad\n         }\n     }\n \n+    private ExtensionURL getExtensionURL(Class<?> clazz) {\n+        String serviceName = null;\n+        String typeName = null;\n+        Integer priority = 0;\n+        Scope scope = Scope.SINGLETON;\n+        LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+        if (loadLevel == null) {\n+            typeName = clazz.getTypeName();\n+        } else {\n+            serviceName = loadLevel.name();\n+            priority = loadLevel.order();\n+            scope = loadLevel.scope();\n+        }\n+        ExtensionURL result = new ExtensionURL(serviceName, typeName, priority, scope);\n+        //do cache\n+        extensionClassUrlMap.put(clazz, result);\n+        if (loadLevel != null) {\n+            if (extensionNameUrlsMap.containsKey(serviceName)) {", "originalCommit": "6a2b2af61c1d08b00b92019a227ddcf38c65be9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxMzMyNQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r376313325", "bodyText": "remove", "author": "slievrly", "createdAt": "2020-02-07T10:14:33Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -336,11 +422,51 @@ private static void loadFile(Class<?> service, String dir, ClassLoader classLoad\n         }\n     }\n \n+    private ExtensionURL getExtensionURL(Class<?> clazz) {\n+        String serviceName = null;\n+        String typeName = null;\n+        Integer priority = 0;\n+        Scope scope = Scope.SINGLETON;\n+        LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+        if (loadLevel == null) {\n+            typeName = clazz.getTypeName();\n+        } else {\n+            serviceName = loadLevel.name();\n+            priority = loadLevel.order();\n+            scope = loadLevel.scope();\n+        }\n+        ExtensionURL result = new ExtensionURL(serviceName, typeName, priority, scope);\n+        //do cache\n+        extensionClassUrlMap.put(clazz, result);\n+        if (loadLevel != null) {\n+            if (extensionNameUrlsMap.containsKey(serviceName)) {\n+                List<ExtensionURL> urls = extensionNameUrlsMap.get(serviceName);\n+                urls.add(result);\n+            } else {\n+                List<ExtensionURL> urls = new ArrayList<>();\n+                urls.add(result);\n+                extensionNameUrlsMap.put(serviceName, urls);\n+            }\n+        }\n+        if (priority >= highestLoadPriority) {\n+            highestLoadPriority = priority;\n+            defaultExtensionURL = result;\n+            return defaultExtensionURL;", "originalCommit": "6a2b2af61c1d08b00b92019a227ddcf38c65be9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTg4OQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392541889", "bodyText": "The highest priority based on the order param in LoadLevel matches the current class's  defaultExtensionURL,we cached them together so that next time this extension is loaded,we can directly find the default extension by cache.", "author": "booogu", "createdAt": "2020-03-14T01:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxMzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMyMTg4MA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r376321880", "bodyText": "why not declare as TreeMap\uff1f", "author": "slievrly", "createdAt": "2020-02-07T10:33:21Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -179,133 +199,197 @@\n     /**\n      * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n      *\n-     * @param <S>     the type parameter\n-     * @param service the service\n      * @return all extension class\n      */\n     @SuppressWarnings(\"rawtypes\")\n-    public static <S> List<Class> getAllExtensionClass(Class<S> service) {\n-        return findAllExtensionClass(service, null, findClassLoader());\n+    public List<Class> getAllExtensionClass() {\n+        Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+        List<Class> result = new ArrayList<>(map.values());\n+        return result;\n     }\n \n     /**\n      * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n      *\n-     * @param <S>     the type parameter\n-     * @param service the service\n      * @param loader  the loader\n      * @return all extension class\n      */\n     @SuppressWarnings(\"rawtypes\")\n-    public static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+    public <S> List<Class> getAllExtensionClass(ClassLoader loader) {\n+        Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+        List<Class> result = new ArrayList<>(map.values());\n+        return result;\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n+    @SuppressWarnings(\"rawtypes\")\n+    private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                            Object[] args) {\n+        try {\n+            loadAllExtensionClass(loader);\n+            return getExtension(defaultExtensionURL, loader, argTypes, args);\n+        } catch (Throwable e) {\n+            if (e instanceof EnhancedServiceNotFoundException) {\n+                throw (EnhancedServiceNotFoundException)e;\n+            } else {\n+                throw new EnhancedServiceNotFoundException(\n+                        \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                .getFullStackTrace(e));\n+            }\n+        }\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n+    private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                            Object[] args) {\n+        if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+            throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+        }\n         try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n-                }\n+            loadAllExtensionClass(loader);\n+            ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+            return getExtension(cachedExtensionURL, loader, argTypes, args);\n+        } catch (Throwable e) {\n+            if (e instanceof EnhancedServiceNotFoundException) {\n+                throw (EnhancedServiceNotFoundException)e;\n+            } else {\n+                throw new EnhancedServiceNotFoundException(\n+                        \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                .getFullStackTrace(e));\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n+        }\n+    }\n \n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n+    private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                           Object[] args) {\n+        if (url == null) {\n+            throw new EnhancedServiceNotFoundException(\"service provider not found\");\n+        }\n+        if (Scope.SINGLETON.equals(url.getScope())) {\n+            Holder<Object> holder = extensionInstances.get(url);\n+            if (holder == null) {\n+                extensionInstances.putIfAbsent(url, new Holder<>());\n+                holder = extensionInstances.get(url);\n+            }\n+            Object instance = holder.get();\n+            if (instance == null) {\n+                synchronized (holder) {\n+                    instance = holder.get();\n+                    if (instance == null) {\n+                        instance = createExtension(url, loader, argTypes, args);\n+                        holder.set(instance);\n                     }\n                 }\n-\n-                extensions = activateExtensions;\n             }\n+            return (S)instance;\n+        } else {\n+            return createNewExtension(url, loader, argTypes, args);\n+        }\n+    }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n-            }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+    private S createExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                              Object[] args) {\n+        Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+        if (clazz == null) {\n+            throw new EnhancedServiceNotFoundException(\"Not Found\");\n+        }\n+        try {\n+            S instance = (S)EXTENSION_INSTANCES.get(clazz);\n+            if (instance == null) {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                EXTENSION_INSTANCES.putIfAbsent(clazz, newInstance);\n+                instance = newInstance;\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n-            } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+            return instance;\n+        } catch (Throwable t) {\n+            throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                    type + \")  could not be instantiated: \" + t.getMessage(), t);\n+        }\n+    }\n+\n+    private S createNewExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes, Object[] args) {\n+        Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+        if (clazz == null) {\n+            throw new EnhancedServiceNotFoundException(\"Not Found\");\n+        }\n+        try {\n+            S newInstance = initInstance(clazz, argTypes, args);\n+            return newInstance;\n+        } catch (Throwable t) {\n+            throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                    type + \")  could not be instantiated: \" + t.getMessage(), t);\n+        }\n+    }\n+\n+    private Map<ExtensionURL, Class<?>> loadAllExtensionClass(ClassLoader loader) {\n+        Map<ExtensionURL, Class<?>> classes = extensionClasses.get();\n+        if (classes == null) {\n+            synchronized (extensionClasses) {\n+                classes = extensionClasses.get();\n+                if (classes == null) {\n+                    classes = findAllExtensionClass(loader);\n+                    extensionClasses.set(classes);\n+                }\n             }\n         }\n+        return classes;\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n+    private Map<ExtensionURL, Class<?>> findAllExtensionClass(ClassLoader loader) {\n+        Map<ExtensionURL, Class<?>> extensions = new HashMap<>();", "originalCommit": "6a2b2af61c1d08b00b92019a227ddcf38c65be9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0ODUxOQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392548519", "bodyText": "Cause that treeMap uses comparable() to judge whether the extensionURLs are the same, but we need to judge by the hashCode() of extensionURLs, so here we can only declare as HashMap", "author": "booogu", "createdAt": "2020-03-14T02:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMyMTg4MA=="}], "type": "inlineReview"}, {"oid": "0aa6a585a2aebc154601ba969b083a23d3c777b7", "url": "https://github.com/seata/seata/commit/0aa6a585a2aebc154601ba969b083a23d3c777b7", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-02-08T02:21:20Z", "type": "commit"}, {"oid": "7eb4705e381b9b16d1caed543dffcf739a1240c8", "url": "https://github.com/seata/seata/commit/7eb4705e381b9b16d1caed543dffcf739a1240c8", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-02-11T01:33:59Z", "type": "commit"}, {"oid": "8a659dbf9263eedea843ec1c69ed0ba091274a45", "url": "https://github.com/seata/seata/commit/8a659dbf9263eedea843ec1c69ed0ba091274a45", "message": "resolve conflicts with 1.1.0", "committedDate": "2020-02-22T08:50:36Z", "type": "commit"}, {"oid": "5d7fe9f44b57b73c79c0078d932e5de34c986c8b", "url": "https://github.com/seata/seata/commit/5d7fe9f44b57b73c79c0078d932e5de34c986c8b", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-02-22T08:50:59Z", "type": "commit"}, {"oid": "3d1d576ae32c526b3fa60c9624399d6d74e77f58", "url": "https://github.com/seata/seata/commit/3d1d576ae32c526b3fa60c9624399d6d74e77f58", "message": "format code style", "committedDate": "2020-02-22T09:09:42Z", "type": "commit"}, {"oid": "478ecf5c0905eec739d043360ab6d218c5c339da", "url": "https://github.com/seata/seata/commit/478ecf5c0905eec739d043360ab6d218c5c339da", "message": "format code", "committedDate": "2020-02-22T10:27:52Z", "type": "commit"}, {"oid": "c232a8d4b019b115410aa65ee0a1bfec6a08f3eb", "url": "https://github.com/seata/seata/commit/c232a8d4b019b115410aa65ee0a1bfec6a08f3eb", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-02-26T07:06:49Z", "type": "commit"}, {"oid": "5483cb7e9af7aee23242f990111c8898c7d08933", "url": "https://github.com/seata/seata/commit/5483cb7e9af7aee23242f990111c8898c7d08933", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-02-27T12:50:06Z", "type": "commit"}, {"oid": "57033345699bacadc308f79ccf88c045c4f3813c", "url": "https://github.com/seata/seata/commit/57033345699bacadc308f79ccf88c045c4f3813c", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-02-28T07:25:07Z", "type": "commit"}, {"oid": "3bded951d05b4970e2efd3d5ce5e108953b425ba", "url": "https://github.com/seata/seata/commit/3bded951d05b4970e2efd3d5ce5e108953b425ba", "message": "merge", "committedDate": "2020-02-28T10:07:12Z", "type": "commit"}, {"oid": "e191ea99c3987ad06340e2b439c8b65be1bc9ee8", "url": "https://github.com/seata/seata/commit/e191ea99c3987ad06340e2b439c8b65be1bc9ee8", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-02-28T16:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5NDA5NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r385794095", "bodyText": "DataBaseSessionManager's taskName is different, so its Scope is PROTOTYPE.", "author": "zjinlei", "createdAt": "2020-02-28T16:29:45Z", "path": "server/src/main/java/io/seata/server/session/db/DataBaseSessionManager.java", "diffHunk": "@@ -79,7 +79,8 @@ public DataBaseSessionManager(String name) {\n ", "originalCommit": "e191ea99c3987ad06340e2b439c8b65be1bc9ee8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1dba73f01ff890166341f8501f6ea53c6c69023", "url": "https://github.com/seata/seata/commit/d1dba73f01ff890166341f8501f6ea53c6c69023", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-02-29T02:13:57Z", "type": "commit"}, {"oid": "4f895ee58fc7239113c35f14e2663d237631bcce", "url": "https://github.com/seata/seata/commit/4f895ee58fc7239113c35f14e2663d237631bcce", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-02-29T02:14:07Z", "type": "commit"}, {"oid": "cf8bbb61db84e6d8d25878f06ca2931bee438786", "url": "https://github.com/seata/seata/commit/cf8bbb61db84e6d8d25878f06ca2931bee438786", "message": "set dbSessionMgr scope prototype", "committedDate": "2020-02-29T02:15:49Z", "type": "commit"}, {"oid": "74a4f544a96ed15d9ba0385543c82f1ac2b679ca", "url": "https://github.com/seata/seata/commit/74a4f544a96ed15d9ba0385543c82f1ac2b679ca", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-02T08:40:35Z", "type": "commit"}, {"oid": "52e90dfb8cd019541639e4e45394fb950349b04e", "url": "https://github.com/seata/seata/commit/52e90dfb8cd019541639e4e45394fb950349b04e", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-02T13:12:47Z", "type": "commit"}, {"oid": "0ae21a8fd6bf8f4569ef88570842eb5c30de8321", "url": "https://github.com/seata/seata/commit/0ae21a8fd6bf8f4569ef88570842eb5c30de8321", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-03-02T13:13:02Z", "type": "commit"}, {"oid": "61283a88311e471aeee85c05edd15d304ea52390", "url": "https://github.com/seata/seata/commit/61283a88311e471aeee85c05edd15d304ea52390", "message": "restore spi load scope to prototype", "committedDate": "2020-03-04T01:51:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNzYyNg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r387607626", "bodyText": "Keep the EnhancedServiceLoader's api unchanged?", "author": "ggndnn", "createdAt": "2020-03-04T11:30:06Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -42,77 +45,100 @@\n  *\n  * @author slievrly\n  */\n-public class EnhancedServiceLoader {\n+public class EnhancedServiceLoader<S> {\n     private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n     private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n     private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n-    @SuppressWarnings(\"rawtypes\")\n-    private static Map<Class, List<Class>> providers = new ConcurrentHashMap<>();\n+\n+    private static final ConcurrentMap<Class<?>, EnhancedServiceLoader<?>> SERVICE_LOADERS =\n+            new ConcurrentHashMap<>();\n+    private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+    private final Class<S> type;\n+    private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+    private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+    private ExtensionURL defaultExtensionURL = null;\n+    private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+    private EnhancedServiceLoader(Class<S> type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * Get the ServiceLoader for the specified Class\n+     *\n+     * @param type the type of the extension point\n+     * @param <S> the type\n+     * @return the service loader\n+     */\n+    public static <S> EnhancedServiceLoader<S> getServiceLoader(Class<S> type) {", "originalCommit": "61283a88311e471aeee85c05edd15d304ea52390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU3MjE1NQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r391572155", "bodyText": "OK\uff0cI've restore the old api", "author": "booogu", "createdAt": "2020-03-12T11:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNzYyNg=="}], "type": "inlineReview"}, {"oid": "aad7732407d606b2de991dc77d6fd1d2c6fb6cc0", "url": "https://github.com/seata/seata/commit/aad7732407d606b2de991dc77d6fd1d2c6fb6cc0", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-05T01:09:28Z", "type": "commit"}, {"oid": "47d8481b9bb2fd4e4d1021c670b966fb8c5ee023", "url": "https://github.com/seata/seata/commit/47d8481b9bb2fd4e4d1021c670b966fb8c5ee023", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-06T12:58:15Z", "type": "commit"}, {"oid": "0c2e869a1c13b525913b9b636805ac4aeba174f0", "url": "https://github.com/seata/seata/commit/0c2e869a1c13b525913b9b636805ac4aeba174f0", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-09T01:55:29Z", "type": "commit"}, {"oid": "4a23f75500fa85db50640faf0b1014e9a5112c1b", "url": "https://github.com/seata/seata/commit/4a23f75500fa85db50640faf0b1014e9a5112c1b", "message": "Restore the old EnhancedServiceLoader API", "committedDate": "2020-03-09T11:50:47Z", "type": "commit"}, {"oid": "d9d4e5ef946938b9315c87bcf1e8646beedc3f8a", "url": "https://github.com/seata/seata/commit/d9d4e5ef946938b9315c87bcf1e8646beedc3f8a", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-12T10:36:30Z", "type": "commit"}, {"oid": "923d4f5d5ada702fdc988223df6cd07f35ca7a61", "url": "https://github.com/seata/seata/commit/923d4f5d5ada702fdc988223df6cd07f35ca7a61", "message": "adjust some load scope value", "committedDate": "2020-03-12T11:57:41Z", "type": "commit"}, {"oid": "cae683c162728069d277089de3709895f3a09745", "url": "https://github.com/seata/seata/commit/cae683c162728069d277089de3709895f3a09745", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-13T11:56:36Z", "type": "commit"}, {"oid": "01f97aa10848036afee2763dad1e4966e2d2ebf3", "url": "https://github.com/seata/seata/commit/01f97aa10848036afee2763dad1e4966e2d2ebf3", "message": "use treeMap instead of HashMap", "committedDate": "2020-03-14T01:03:28Z", "type": "commit"}, {"oid": "085cc366b81752e68628d19803874546226869cc", "url": "https://github.com/seata/seata/commit/085cc366b81752e68628d19803874546226869cc", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-14T01:03:50Z", "type": "commit"}, {"oid": "54f725ec1cd4de0a130e9cc5e56b9479e092c3f8", "url": "https://github.com/seata/seata/commit/54f725ec1cd4de0a130e9cc5e56b9479e092c3f8", "message": "Merge branch 'f_spi' of https://github.com/CharmingRabbit/seata into f_spi", "committedDate": "2020-03-14T01:04:42Z", "type": "commit"}, {"oid": "93a3e81dae81a2ff90035d183f0ce4afb4900036", "url": "https://github.com/seata/seata/commit/93a3e81dae81a2ff90035d183f0ce4afb4900036", "message": "format codeStyle", "committedDate": "2020-03-14T05:49:16Z", "type": "commit"}, {"oid": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "url": "https://github.com/seata/seata/commit/b2f3ed36f716d395e23818173d9e4aec4d9941ca", "message": "Merge branch 'develop' into f_spi", "committedDate": "2020-03-15T16:10:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0Mjg0Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392942846", "bodyText": "The class name is easy to misunderstand. What about ExtensionDefinition or ExtensionInfo? And access modifiers should be left default not public.", "author": "ggndnn", "createdAt": "2020-03-16T11:09:36Z", "path": "common/src/main/java/io/seata/common/loader/ExtensionURL.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.loader;\n+\n+import io.seata.common.util.StringUtils;\n+\n+/**\n+ * The type URL\n+ *\n+ * @author: haozhibei\n+ */\n+public class ExtensionURL {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk3OTU2Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392979566", "bodyText": "access left default done and how about ExtensionIdentifier?", "author": "booogu", "createdAt": "2020-03-16T12:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0Mjg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NTU0NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393095544", "bodyText": "I think this class is not used to distinguish extensions, but describes extensions, may be include more attributes in the future, so ExtensionIdentifier (extension ID) is not very suitable. In my opinion, definition is more suitable.", "author": "ggndnn", "createdAt": "2020-03-16T15:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0Mjg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQwOTUwNA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393409504", "bodyText": "Yeah,i agree with ExtensionDefinition", "author": "booogu", "createdAt": "2020-03-17T02:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0Mjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzUzMA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392943530", "bodyText": "Why not use createNewExtension here directly?", "author": "ggndnn", "createdAt": "2020-03-16T11:11:05Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);\n+                if (holder == null) {\n+                    extensionInstances.putIfAbsent(url, new Holder<>());\n+                    holder = extensionInstances.get(url);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createExtension(url, loader, argTypes, args);", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4NDg5MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393484891", "bodyText": "Our purpose is to distinguish whether the extension point is Singleton or multiple. When the LoadLevel's prototype was set to singleton, we return the same instance (using cache), while it was set to Prototype, we use CreateNewExtension() to create new instance", "author": "booogu", "createdAt": "2020-03-17T07:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4NjQwNg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393786406", "bodyText": "In the 415 row, use createNewExtension instead of createExtension.", "author": "ggndnn", "createdAt": "2020-03-17T15:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NDMwMg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392944302", "bodyText": "What's the benefit to use Holder here? Is Holder class necessary?", "author": "ggndnn", "createdAt": "2020-03-16T11:13:10Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4OTM2OA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393489368", "bodyText": "This part of the code which use Holder and Double-Checkd Locking refers to Dubbo SPI. I think it has two functions at present:\n1.When concurrent, ensure that an extensionDefinition use the same lock object\n2.Whether the value in the Holder is null can be used as the judgment condition of Double-Checked Locking\nWithout using Holder here,i think it is difficult to guarantee the above two points at the same time.", "author": "booogu", "createdAt": "2020-03-17T07:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NDMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NTM5Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392945396", "bodyText": "If ExtensionURL has the service-class as field, calling loadAllExtensionClass is not necessary.", "author": "ggndnn", "createdAt": "2020-03-16T11:16:27Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);\n+                if (holder == null) {\n+                    extensionInstances.putIfAbsent(url, new Holder<>());\n+                    holder = extensionInstances.get(url);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createExtension(url, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(url, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                                  Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S instance = (S)EXTENSION_INSTANCES.get(clazz);\n+                if (instance == null) {\n+                    S newInstance = initInstance(clazz, argTypes, args);\n+                    EXTENSION_INSTANCES.putIfAbsent(clazz, newInstance);\n+                    instance = newInstance;\n+                }\n+                return instance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private S createNewExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393493172", "bodyText": "Yeah,good idea,i add serviceClass field and change the data structure of  Map\uff08ExtensionDefinition_To_Class\uff09 to List", "author": "booogu", "createdAt": "2020-03-17T07:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NzkxMg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392947912", "bodyText": "@author: xxx -> @author xxx", "author": "ggndnn", "createdAt": "2020-03-16T11:23:22Z", "path": "common/src/main/java/io/seata/common/util/Holder.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.common.util;\n+\n+/**\n+ * Helper Class for hold a value.\n+ *\n+ * @author: haozhibei", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk1MDc4NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392950784", "bodyText": "The access modifiers here should be private.", "author": "ggndnn", "createdAt": "2020-03-16T11:29:04Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk1MTA5Nw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392951097", "bodyText": "The access modifiers here should be private.", "author": "ggndnn", "createdAt": "2020-03-16T11:29:42Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk1MTcwMw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r392951703", "bodyText": "The access modifiers here should be private.", "author": "ggndnn", "createdAt": "2020-03-16T11:30:51Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwMDE3MQ==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393000171", "bodyText": "changed", "author": "booogu", "createdAt": "2020-03-16T12:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk1MTcwMw=="}], "type": "inlineReview"}, {"oid": "7ab23a48250e2dc5ff330de2073edac014000f9f", "url": "https://github.com/seata/seata/commit/7ab23a48250e2dc5ff330de2073edac014000f9f", "message": "Merge remote-tracking branch 'upstream/develop' into f_spi", "committedDate": "2020-03-16T12:25:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNjM3Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393436372", "bodyText": "Since priority defaults to 0, is the statement better to be if (defaultExtensionURL == null || priority > highestLoadPriority)?", "author": "ggndnn", "createdAt": "2020-03-17T04:16:07Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);\n+                if (holder == null) {\n+                    extensionInstances.putIfAbsent(url, new Holder<>());\n+                    holder = extensionInstances.get(url);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createExtension(url, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(url, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                                  Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S instance = (S)EXTENSION_INSTANCES.get(clazz);\n+                if (instance == null) {\n+                    S newInstance = initInstance(clazz, argTypes, args);\n+                    EXTENSION_INSTANCES.putIfAbsent(clazz, newInstance);\n+                    instance = newInstance;\n+                }\n+                return instance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private S createNewExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n             }\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        private Map<ExtensionURL, Class<?>> loadAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> classes = extensionClasses.get();\n+            if (classes == null) {\n+                synchronized (extensionClasses) {\n+                    classes = extensionClasses.get();\n+                    if (classes == null) {\n+                        classes = findAllExtensionClass(loader);\n+                        extensionClasses.set(classes);\n+                    }\n+                }\n             }\n+            return classes;\n+        }\n \n-            return Integer.compare(o1, o2);\n+        @SuppressWarnings(\"rawtypes\")\n+        private Map<ExtensionURL, Class<?>> findAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> extensions = new HashMap<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensions);\n+                loadFile(SEATA_DIRECTORY, loader, extensions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n+            }\n \n-        });\n+            if (!extensions.isEmpty()) {\n+                extensions = sortAllExtensionClass(extensions);\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionNameUrlsMap.isEmpty()) {\n+                for (List<ExtensionURL> urlList : extensionNameUrlsMap.values()) {\n+                    Collections.sort(urlList, (url1, url2) -> {\n+                        int o1 = url1.getOrder();\n+                        int o2 = url2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n+            return extensions;\n+        }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+        private Map<ExtensionURL, Class<?>> sortAllExtensionClass(Map<ExtensionURL, Class<?>> extensions) {\n+            Set<ExtensionURL> entrySet = extensions.keySet();\n+            List<ExtensionURL> list = new ArrayList<>(entrySet);\n+            Collections.sort(list, (url1, url2) -> {\n+                int o1 = url1.getOrder();\n+                int o2 = url2.getOrder();\n+                return Integer.compare(o1, o2);\n+            });\n+            LinkedHashMap<ExtensionURL, Class<?>> linkedHashMap = new LinkedHashMap<ExtensionURL, Class<?>>();\n+            for (ExtensionURL url : list) {\n+                linkedHashMap.put(url, extensions.get(url));\n+            }\n+            return linkedHashMap;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, Map<ExtensionURL, Class<?>> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionURL extensionUrl = getExtensionURL(clazz);\n+                                    extensions.put(extensionUrl, clazz);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionURL getExtensionURL(Class<?> clazz) {\n+            String serviceName = null;\n+            String typeName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            typeName = clazz.getTypeName();\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            ExtensionURL result = new ExtensionURL(serviceName, typeName, priority, scope);\n+            //do cache\n+            extensionClassUrlMap.put(clazz, result);\n+            if (loadLevel != null) {\n+                if (extensionNameUrlsMap.containsKey(serviceName)) {\n+                    List<ExtensionURL> urls = extensionNameUrlsMap.get(serviceName);\n+                    urls.add(result);\n+                } else {\n+                    List<ExtensionURL> urls = new ArrayList<>();\n+                    urls.add(result);\n+                    extensionNameUrlsMap.put(serviceName, urls);\n+                }\n+            }\n+            if (priority >= highestLoadPriority) {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1NjM5Mg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393456392", "bodyText": "the highestLoadPriority is set to Integer.MIN_VALUE,so even if the default priority is 0, the old statement still works,but your statement will be easier to understand here.", "author": "booogu", "createdAt": "2020-03-17T05:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNjM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNjUwNw==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393436507", "bodyText": "The return statement can be removed.", "author": "ggndnn", "createdAt": "2020-03-17T04:16:40Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);\n+                if (holder == null) {\n+                    extensionInstances.putIfAbsent(url, new Holder<>());\n+                    holder = extensionInstances.get(url);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createExtension(url, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(url, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                                  Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S instance = (S)EXTENSION_INSTANCES.get(clazz);\n+                if (instance == null) {\n+                    S newInstance = initInstance(clazz, argTypes, args);\n+                    EXTENSION_INSTANCES.putIfAbsent(clazz, newInstance);\n+                    instance = newInstance;\n+                }\n+                return instance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private S createNewExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n             }\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        private Map<ExtensionURL, Class<?>> loadAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> classes = extensionClasses.get();\n+            if (classes == null) {\n+                synchronized (extensionClasses) {\n+                    classes = extensionClasses.get();\n+                    if (classes == null) {\n+                        classes = findAllExtensionClass(loader);\n+                        extensionClasses.set(classes);\n+                    }\n+                }\n             }\n+            return classes;\n+        }\n \n-            return Integer.compare(o1, o2);\n+        @SuppressWarnings(\"rawtypes\")\n+        private Map<ExtensionURL, Class<?>> findAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> extensions = new HashMap<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensions);\n+                loadFile(SEATA_DIRECTORY, loader, extensions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n+            }\n \n-        });\n+            if (!extensions.isEmpty()) {\n+                extensions = sortAllExtensionClass(extensions);\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionNameUrlsMap.isEmpty()) {\n+                for (List<ExtensionURL> urlList : extensionNameUrlsMap.values()) {\n+                    Collections.sort(urlList, (url1, url2) -> {\n+                        int o1 = url1.getOrder();\n+                        int o2 = url2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n+            return extensions;\n+        }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+        private Map<ExtensionURL, Class<?>> sortAllExtensionClass(Map<ExtensionURL, Class<?>> extensions) {\n+            Set<ExtensionURL> entrySet = extensions.keySet();\n+            List<ExtensionURL> list = new ArrayList<>(entrySet);\n+            Collections.sort(list, (url1, url2) -> {\n+                int o1 = url1.getOrder();\n+                int o2 = url2.getOrder();\n+                return Integer.compare(o1, o2);\n+            });\n+            LinkedHashMap<ExtensionURL, Class<?>> linkedHashMap = new LinkedHashMap<ExtensionURL, Class<?>>();\n+            for (ExtensionURL url : list) {\n+                linkedHashMap.put(url, extensions.get(url));\n+            }\n+            return linkedHashMap;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, Map<ExtensionURL, Class<?>> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionURL extensionUrl = getExtensionURL(clazz);\n+                                    extensions.put(extensionUrl, clazz);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionURL getExtensionURL(Class<?> clazz) {\n+            String serviceName = null;\n+            String typeName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            typeName = clazz.getTypeName();\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            ExtensionURL result = new ExtensionURL(serviceName, typeName, priority, scope);\n+            //do cache\n+            extensionClassUrlMap.put(clazz, result);\n+            if (loadLevel != null) {\n+                if (extensionNameUrlsMap.containsKey(serviceName)) {\n+                    List<ExtensionURL> urls = extensionNameUrlsMap.get(serviceName);\n+                    urls.add(result);\n+                } else {\n+                    List<ExtensionURL> urls = new ArrayList<>();\n+                    urls.add(result);\n+                    extensionNameUrlsMap.put(serviceName, urls);\n+                }\n+            }\n+            if (priority >= highestLoadPriority) {\n+                //the highest priority based on the order param in LoadLevel,matches the current class's\n+                //defaultExtensionURL,so cached them together\n+                highestLoadPriority = priority;\n+                defaultExtensionURL = result;\n+                return defaultExtensionURL;", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1Mjg5NA==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393452894", "bodyText": "removed", "author": "booogu", "createdAt": "2020-03-17T05:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNjUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNzEzMg==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393437132", "bodyText": "Should the if statement be if (serviceName != null), or other more suitable one?", "author": "ggndnn", "createdAt": "2020-03-17T04:19:48Z", "path": "common/src/main/java/io/seata/common/loader/EnhancedServiceLoader.java", "diffHunk": "@@ -198,181 +177,463 @@\n      */\n     @SuppressWarnings(\"rawtypes\")\n     static <S> List<Class> getAllExtensionClass(Class<S> service, ClassLoader loader) {\n-        return findAllExtensionClass(service, null, loader);\n+        return InnerEnhancedServiceLoader.getServiceLoader(service).getAllExtensionClass(loader);\n     }\n \n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader) {\n-        return loadFile(service, activateName, loader, null, null);\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> S loadFile(Class<S> service, String activateName, ClassLoader loader, Class[] argTypes,\n-                                  Object[] args) {\n-        try {\n-            boolean foundFromCache = true;\n-            List<Class> extensions = providers.get(service);\n-            if (extensions == null) {\n-                synchronized (service) {\n-                    extensions = providers.get(service);\n-                    if (extensions == null) {\n-                        extensions = findAllExtensionClass(service, activateName, loader);\n-                        foundFromCache = false;\n-                        providers.put(service, extensions);\n-                    }\n+    static class InnerEnhancedServiceLoader<S> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(EnhancedServiceLoader.class);\n+        private static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n+        private static final String SEATA_DIRECTORY = \"META-INF/seata/\";\n+\n+        private static final ConcurrentMap<Class<?>, InnerEnhancedServiceLoader<?>> SERVICE_LOADERS =\n+                new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();\n+\n+        private final Class<S> type;\n+        private final Holder<Map<ExtensionURL, Class<?>>> extensionClasses = new Holder<>();\n+        private final ConcurrentMap<ExtensionURL, Holder<Object>> extensionInstances = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<String, List<ExtensionURL>> extensionNameUrlsMap = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Class<?>, ExtensionURL> extensionClassUrlMap = new ConcurrentHashMap<>();\n+        private ExtensionURL defaultExtensionURL = null;\n+        private Integer highestLoadPriority = Integer.MIN_VALUE;\n+\n+        private InnerEnhancedServiceLoader(Class<S> type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Get the ServiceLoader for the specified Class\n+         *\n+         * @param type the type of the extension point\n+         * @param <S>  the type\n+         * @return the service loader\n+         */\n+        static <S> InnerEnhancedServiceLoader<S> getServiceLoader(Class<S> type) {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Enhanced Service type == null\");\n+            }\n+            InnerEnhancedServiceLoader<S> loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            if (loader == null) {\n+                SERVICE_LOADERS.putIfAbsent(type, new InnerEnhancedServiceLoader<S>(type));\n+                loader = (InnerEnhancedServiceLoader<S>)SERVICE_LOADERS.get(type);\n+            }\n+            return loader;\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param loader the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(ClassLoader loader) throws EnhancedServiceNotFoundException {\n+            return loadExtension(loader, null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load() throws EnhancedServiceNotFoundException {\n+            return loadExtension(findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * load service provider\n+         *\n+         * @param activateName the activate name\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName) throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), null, null);\n+        }\n+\n+        /**\n+         * Specify classLoader to load the service provider\n+         *\n+         * @param activateName the activate name\n+         * @param loader       the loader\n+         * @return s s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, ClassLoader loader)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, loader, null, null);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            Class[] argsType = null;\n+            if (args != null && args.length > 0) {\n+                argsType = new Class[args.length];\n+                for (int i = 0; i < args.length; i++) {\n+                    argsType[i] = args[i].getClass();\n                 }\n             }\n-            if (StringUtils.isNotEmpty(activateName)) {\n-                loadFile(service, SEATA_DIRECTORY + activateName.toLowerCase() + \"/\", loader, extensions);\n-\n-                List<Class> activateExtensions = new ArrayList<>();\n-                for (Class clz : extensions) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    LoadLevel activate = (LoadLevel) clz.getAnnotation(LoadLevel.class);\n-                    if (activate != null && activateName.equalsIgnoreCase(activate.name())) {\n-                        activateExtensions.add(clz);\n-                    }\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * Load s.\n+         *\n+         * @param activateName the activate name\n+         * @param argsType     the args type\n+         * @param args         the args\n+         * @return the s\n+         * @throws EnhancedServiceNotFoundException the enhanced service not found exception\n+         */\n+        public S load(String activateName, Class[] argsType, Object[] args)\n+                throws EnhancedServiceNotFoundException {\n+            return loadExtension(activateName, findClassLoader(), argsType, args);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @return list list\n+         */\n+        public List<S> loadAll() {\n+            return loadAll(null, null);\n+        }\n+\n+        /**\n+         * get all implements\n+         *\n+         * @param argsType the args type\n+         * @param args     the args\n+         * @return list list\n+         */\n+        public List<S> loadAll(Class[] argsType, Object[] args) {\n+            List<S> allInstances = new ArrayList<>();\n+            List<Class> allClazzs = getAllExtensionClass();\n+            if (CollectionUtils.isEmpty(allClazzs)) {\n+                return allInstances;\n+            }\n+            try {\n+                for (Class clazz : allClazzs) {\n+                    ExtensionURL url = extensionClassUrlMap.get(clazz);\n+                    allInstances.add(getExtension(url, findClassLoader(), argsType, args));\n                 }\n+            } catch (Throwable t) {\n+                throw new EnhancedServiceNotFoundException(t);\n+            }\n+            return allInstances;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass() {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(findClassLoader());\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n+\n+        /**\n+         * Get all the extension classes, follow {@linkplain LoadLevel} defined and sort order\n+         *\n+         * @param loader the loader\n+         * @return all extension class\n+         */\n+        @SuppressWarnings(\"rawtypes\")\n+        List<Class> getAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> map = loadAllExtensionClass(loader);\n+            List<Class> result = new ArrayList<>(map.values());\n+            return result;\n+        }\n \n-                extensions = activateExtensions;\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            try {\n+                loadAllExtensionClass(loader);\n+                return getExtension(defaultExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n+        }\n \n-            if (extensions.isEmpty()) {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \"[\" + activateName\n-                        + \"] and classloader : \" + ObjectUtils.toString(loader));\n+        @SuppressWarnings(\"rawtypes\")\n+        private S loadExtension(String activateName, ClassLoader loader, Class[] argTypes,\n+                                Object[] args) {\n+            if (io.seata.common.util.StringUtils.isEmpty(activateName)) {\n+                throw new IllegalArgumentException(\"the name of service provider for [\" + type.getName() + \"] name is null\");\n+            }\n+            try {\n+                loadAllExtensionClass(loader);\n+                ExtensionURL cachedExtensionURL = getCachedServiceURL(activateName);\n+                return getExtension(cachedExtensionURL, loader, argTypes, args);\n+            } catch (Throwable e) {\n+                if (e instanceof EnhancedServiceNotFoundException) {\n+                    throw (EnhancedServiceNotFoundException)e;\n+                } else {\n+                    throw new EnhancedServiceNotFoundException(\n+                            \"not found service provider for : \" + type.getName() + \" caused by \" + ExceptionUtils\n+                                    .getFullStackTrace(e));\n+                }\n             }\n-            Class<?> extension = extensions.get(extensions.size() - 1);\n-            S result = initInstance(service, extension, argTypes, args);\n-            if (!foundFromCache && LOGGER.isInfoEnabled()) {\n-                LOGGER.info(\"load \" + service.getSimpleName() + \"[\" + activateName + \"] extension by class[\" + extension\n-                    .getName() + \"]\");\n+        }\n+\n+        private S getExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                               Object[] args) {\n+            if (url == null) {\n+                throw new EnhancedServiceNotFoundException(\"service provider not found\");\n             }\n-            return result;\n-        } catch (Throwable e) {\n-            if (e instanceof EnhancedServiceNotFoundException) {\n-                throw (EnhancedServiceNotFoundException)e;\n+            if (Scope.SINGLETON.equals(url.getScope())) {\n+                Holder<Object> holder = extensionInstances.get(url);\n+                if (holder == null) {\n+                    extensionInstances.putIfAbsent(url, new Holder<>());\n+                    holder = extensionInstances.get(url);\n+                }\n+                Object instance = holder.get();\n+                if (instance == null) {\n+                    synchronized (holder) {\n+                        instance = holder.get();\n+                        if (instance == null) {\n+                            instance = createExtension(url, loader, argTypes, args);\n+                            holder.set(instance);\n+                        }\n+                    }\n+                }\n+                return (S)instance;\n             } else {\n-                throw new EnhancedServiceNotFoundException(\n-                    \"not found service provider for : \" + service.getName() + \" caused by \" + ExceptionUtils\n-                        .getFullStackTrace(e));\n+                return createNewExtension(url, loader, argTypes, args);\n             }\n         }\n-    }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static <S> List<Class> findAllExtensionClass(Class<S> service, String activateName, ClassLoader loader) {\n-        List<Class> extensions = new ArrayList<>();\n-        try {\n-            loadFile(service, SERVICES_DIRECTORY, loader, extensions);\n-            loadFile(service, SEATA_DIRECTORY, loader, extensions);\n-        } catch (IOException e) {\n-            throw new EnhancedServiceNotFoundException(e);\n+        private S createExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes,\n+                                  Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S instance = (S)EXTENSION_INSTANCES.get(clazz);\n+                if (instance == null) {\n+                    S newInstance = initInstance(clazz, argTypes, args);\n+                    EXTENSION_INSTANCES.putIfAbsent(clazz, newInstance);\n+                    instance = newInstance;\n+                }\n+                return instance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n+            }\n         }\n \n-        if (extensions.isEmpty()) {\n-            return extensions;\n-        }\n-        extensions.sort((c1, c2) -> {\n-            int o1 = 0;\n-            int o2 = 0;\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a1 = (LoadLevel) c1.getAnnotation(LoadLevel.class);\n-            @SuppressWarnings(\"unchecked\")\n-            LoadLevel a2 = (LoadLevel) c2.getAnnotation(LoadLevel.class);\n-\n-            if (a1 != null) {\n-                o1 = a1.order();\n+        private S createNewExtension(ExtensionURL url, ClassLoader loader, Class[] argTypes, Object[] args) {\n+            Class<?> clazz = loadAllExtensionClass(loader).get(url);\n+            if (clazz == null) {\n+                throw new EnhancedServiceNotFoundException(\"Not Found\");\n+            }\n+            try {\n+                S newInstance = initInstance(clazz, argTypes, args);\n+                return newInstance;\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(\"Extension instance(url: \" + url + \", class: \" +\n+                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n             }\n+        }\n \n-            if (a2 != null) {\n-                o2 = a2.order();\n+        private Map<ExtensionURL, Class<?>> loadAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> classes = extensionClasses.get();\n+            if (classes == null) {\n+                synchronized (extensionClasses) {\n+                    classes = extensionClasses.get();\n+                    if (classes == null) {\n+                        classes = findAllExtensionClass(loader);\n+                        extensionClasses.set(classes);\n+                    }\n+                }\n             }\n+            return classes;\n+        }\n \n-            return Integer.compare(o1, o2);\n+        @SuppressWarnings(\"rawtypes\")\n+        private Map<ExtensionURL, Class<?>> findAllExtensionClass(ClassLoader loader) {\n+            Map<ExtensionURL, Class<?>> extensions = new HashMap<>();\n+            try {\n+                loadFile(SERVICES_DIRECTORY, loader, extensions);\n+                loadFile(SEATA_DIRECTORY, loader, extensions);\n+            } catch (IOException e) {\n+                throw new EnhancedServiceNotFoundException(e);\n+            }\n \n-        });\n+            if (!extensions.isEmpty()) {\n+                extensions = sortAllExtensionClass(extensions);\n+            }\n \n-        return extensions;\n-    }\n+            if (!extensionNameUrlsMap.isEmpty()) {\n+                for (List<ExtensionURL> urlList : extensionNameUrlsMap.values()) {\n+                    Collections.sort(urlList, (url1, url2) -> {\n+                        int o1 = url1.getOrder();\n+                        int o2 = url2.getOrder();\n+                        return Integer.compare(o1, o2);\n+                    });\n+                }\n+            }\n+            return extensions;\n+        }\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static void loadFile(Class<?> service, String dir, ClassLoader classLoader, List<Class> extensions)\n-        throws IOException {\n-        String fileName = dir + service.getName();\n-        Enumeration<URL> urls;\n-        if (classLoader != null) {\n-            urls = classLoader.getResources(fileName);\n-        } else {\n-            urls = ClassLoader.getSystemResources(fileName);\n+        private Map<ExtensionURL, Class<?>> sortAllExtensionClass(Map<ExtensionURL, Class<?>> extensions) {\n+            Set<ExtensionURL> entrySet = extensions.keySet();\n+            List<ExtensionURL> list = new ArrayList<>(entrySet);\n+            Collections.sort(list, (url1, url2) -> {\n+                int o1 = url1.getOrder();\n+                int o2 = url2.getOrder();\n+                return Integer.compare(o1, o2);\n+            });\n+            LinkedHashMap<ExtensionURL, Class<?>> linkedHashMap = new LinkedHashMap<ExtensionURL, Class<?>>();\n+            for (ExtensionURL url : list) {\n+                linkedHashMap.put(url, extensions.get(url));\n+            }\n+            return linkedHashMap;\n         }\n \n-        if (urls != null) {\n-            while (urls.hasMoreElements()) {\n-                java.net.URL url = urls.nextElement();\n-                BufferedReader reader = null;\n-                try {\n-                    reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n-                    String line = null;\n-                    while ((line = reader.readLine()) != null) {\n-                        final int ci = line.indexOf('#');\n-                        if (ci >= 0) {\n-                            line = line.substring(0, ci);\n-                        }\n-                        line = line.trim();\n-                        if (line.length() > 0) {\n-                            try {\n-                                extensions.add(Class.forName(line, true, classLoader));\n-                            } catch (LinkageError | ClassNotFoundException e) {\n-                                LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+        @SuppressWarnings(\"rawtypes\")\n+        private void loadFile(String dir, ClassLoader classLoader, Map<ExtensionURL, Class<?>> extensions)\n+                throws IOException {\n+            String fileName = dir + type.getName();\n+            Enumeration<java.net.URL> urls;\n+            if (classLoader != null) {\n+                urls = classLoader.getResources(fileName);\n+            } else {\n+                urls = ClassLoader.getSystemResources(fileName);\n+            }\n+            if (urls != null) {\n+                while (urls.hasMoreElements()) {\n+                    java.net.URL url = urls.nextElement();\n+                    BufferedReader reader = null;\n+                    try {\n+                        reader = new BufferedReader(new InputStreamReader(url.openStream(), Constants.DEFAULT_CHARSET));\n+                        String line = null;\n+                        while ((line = reader.readLine()) != null) {\n+                            final int ci = line.indexOf('#');\n+                            if (ci >= 0) {\n+                                line = line.substring(0, ci);\n+                            }\n+                            line = line.trim();\n+                            if (line.length() > 0) {\n+                                try {\n+                                    Class<?> clazz = Class.forName(line, true, classLoader);\n+                                    ExtensionURL extensionUrl = getExtensionURL(clazz);\n+                                    extensions.put(extensionUrl, clazz);\n+                                } catch (LinkageError | ClassNotFoundException e) {\n+                                    LOGGER.warn(\"load [{}] class fail. {}\", line, e.getMessage());\n+                                }\n                             }\n                         }\n+                    } catch (Throwable e) {\n+                        LOGGER.warn(e.getMessage());\n+                    } finally {\n+                        IOUtil.close(reader);\n                     }\n-                } catch (Throwable e) {\n-                    LOGGER.warn(e.getMessage());\n-                } finally {\n-                    IOUtil.close(reader);\n                 }\n             }\n         }\n-    }\n \n-    /**\n-     * init instance\n-     *\n-     * @param <S>       the type parameter\n-     * @param service   the service\n-     * @param implClazz the impl clazz\n-     * @param argTypes  the arg types\n-     * @param args      the args\n-     * @return s s\n-     * @throws IllegalAccessException the illegal access exception\n-     * @throws InstantiationException the instantiation exception\n-     * @throws NoSuchMethodException the no such method exception\n-     * @throws InvocationTargetException the invocation target exception\n-     */\n-    protected static <S> S initInstance(Class<S> service, Class implClazz, Class[] argTypes, Object[] args)\n-        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n-        S s = null;\n-        if (argTypes != null && args != null) {\n-            // Constructor with arguments\n-            Constructor<S> constructor = implClazz.getDeclaredConstructor(argTypes);\n-            s = service.cast(constructor.newInstance(args));\n-        } else {\n-            // default Constructor\n-            s = service.cast(implClazz.newInstance());\n+        private ExtensionURL getExtensionURL(Class<?> clazz) {\n+            String serviceName = null;\n+            String typeName = null;\n+            Integer priority = 0;\n+            Scope scope = Scope.SINGLETON;\n+            LoadLevel loadLevel = clazz.getAnnotation(LoadLevel.class);\n+            typeName = clazz.getTypeName();\n+            if (loadLevel != null) {\n+                serviceName = loadLevel.name();\n+                priority = loadLevel.order();\n+                scope = loadLevel.scope();\n+            }\n+            ExtensionURL result = new ExtensionURL(serviceName, typeName, priority, scope);\n+            //do cache\n+            extensionClassUrlMap.put(clazz, result);\n+            if (loadLevel != null) {", "originalCommit": "b2f3ed36f716d395e23818173d9e4aec4d9941ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1Mzg1Ng==", "url": "https://github.com/seata/seata/pull/2135#discussion_r393453856", "bodyText": "Since if loadLevel is not null,the name will be required and not null,we can use either loadLevel or serviceName !=null here,to make it easier to understand, changed to (serviceName != null)", "author": "booogu", "createdAt": "2020-03-17T05:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzNzEzMg=="}], "type": "inlineReview"}]}