{"pr_number": 3374, "pr_title": "feature: add a Executor for INSERT ON DUPLICATE KEY UPDATE", "pr_createdAt": "2020-12-14T12:10:41Z", "pr_url": "https://github.com/seata/seata/pull/3374", "timeline": [{"oid": "88adb45a69016b169b6d23e9134dd9461736815b", "url": "https://github.com/seata/seata/commit/88adb45a69016b169b6d23e9134dd9461736815b", "message": "bugfix:INSERT ON DUPLICATE KEY UPDATE\u5f53update\u65f6\u4f1a\u629b\u5f02\u5e38\uff0c\u65b0\u52a0\u4e00\u4e2aExecutor", "committedDate": "2020-12-14T12:04:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r542356482", "bodyText": "ON DUPLICATE KEY UPDATE It should be set to a constant", "author": "a364176773", "createdAt": "2020-12-14T12:47:27Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "originalCommit": "88adb45a69016b169b6d23e9134dd9461736815b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NzE4Nw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r542357187", "bodyText": "JdbcConstants.MYSQL?", "author": "a364176773", "createdAt": "2020-12-14T12:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDE1NQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547240155", "bodyText": "\u53ef\u4ee5\u7684\uff0c\u8c22\u8c22", "author": "huan415", "createdAt": "2020-12-22T12:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNDU3Nw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547604577", "bodyText": "\u6539\u5b8c\u4e86\u5c31\u53ef\u4ee5\u81ea\u5df1\u70b9\u4e00\u4e0bResolve conversation\u3002", "author": "caohdgege", "createdAt": "2020-12-23T02:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r542376641", "bodyText": "\u600e\u4e48\u4fdd\u8bc1ON DUPLICATE KEY UPDATE\u6bcf\u4e2a\u5355\u8bcd\u4e4b\u95f4\u53ea\u6709\u4e00\u4e2a\u7a7a\u683c\uff1f\u901a\u8fc7druid\u751f\u6210\u7684\u8bed\u6cd5\u6811\u6765\u5224\u65ad\u4f1a\u4e0d\u4f1a\u597d\u4e00\u70b9\uff1f\u770b\u5230\u91cc\u9762\u662f\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u7684\u3002", "author": "caohdgege", "createdAt": "2020-12-14T13:19:38Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -85,9 +86,13 @@\n                 SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                 switch (sqlRecognizer.getSQLType()) {\n                     case INSERT:\n-                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n-                                new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n-                                new Object[]{statementProxy, statementCallback, sqlRecognizer});\n+                        if(sqlRecognizer.getOriginalSQL().toUpperCase().trim().contains(\"ON DUPLICATE KEY UPDATE\".trim()) && \"mysql\".equals(dbType)){", "originalCommit": "88adb45a69016b169b6d23e9134dd9461736815b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3NjQ0Ng==", "url": "https://github.com/seata/seata/pull/3374#discussion_r542976446", "bodyText": "+1", "author": "a364176773", "createdAt": "2020-12-15T01:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MzAxMA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547243010", "bodyText": "\u8fd9\u4e2a\u662f\u6211\u6b20\u8003\u8651\u4e86\u3002\u6ca1\u627e\u5230\u80fd\u5177\u4f53\u4e00\u70b9\u5417\uff1f\u662fMysqlInsertStatement\u91cc\u7684duplicateKeyUpdate\uff0c\u8fd9\u4e2a\u662f\u6709update\u7684\u5b57\u6bb5\uff0c\u60a8\u662f\u6307\u8fd9\u4e2a\u5417\uff1f", "author": "huan415", "createdAt": "2020-12-22T12:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2Mzg5Nw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547263897", "bodyText": "\u662f\u7684\uff0c\u5c31\u662f\u8fd9\u4e2a", "author": "caohdgege", "createdAt": "2020-12-22T12:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzU1MQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547337551", "bodyText": "\u5df2\u6539\u6b63\uff0c\u671b\u91c7\u7eb3", "author": "huan415", "createdAt": "2020-12-22T15:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY0MQ=="}], "type": "inlineReview"}, {"oid": "0dcb1f30c8156b2774ca27b5a4b2f1146e555836", "url": "https://github.com/seata/seata/commit/0dcb1f30c8156b2774ca27b5a4b2f1146e555836", "message": "bug:checkStyle", "committedDate": "2020-12-15T00:30:45Z", "type": "commit"}, {"oid": "7d2b96fcc204445759eae380d1dce1e3f28dd48f", "url": "https://github.com/seata/seata/commit/7d2b96fcc204445759eae380d1dce1e3f28dd48f", "message": "Not allow chinese character ! [RegexpSingleline]", "committedDate": "2020-12-18T14:59:25Z", "type": "commit"}, {"oid": "46d514af91e63542c6aabd205eeb3925e823ef61", "url": "https://github.com/seata/seata/commit/46d514af91e63542c6aabd205eeb3925e823ef61", "message": "'->' is not preceded with whitespace", "committedDate": "2020-12-18T15:13:24Z", "type": "commit"}, {"oid": "fd5b44328e16a23722c8f6230b1158402e87007c", "url": "https://github.com/seata/seata/commit/fd5b44328e16a23722c8f6230b1158402e87007c", "message": "'for' is not followed by whitespace", "committedDate": "2020-12-18T15:23:57Z", "type": "commit"}, {"oid": "f8deb06b6912e721f70ddc984dcc505490c31e60", "url": "https://github.com/seata/seata/commit/f8deb06b6912e721f70ddc984dcc505490c31e60", "message": "is not followed by whitespace", "committedDate": "2020-12-18T15:35:01Z", "type": "commit"}, {"oid": "6fe3166e197f7aadfab2cdb8d28d1643c599e5c1", "url": "https://github.com/seata/seata/commit/6fe3166e197f7aadfab2cdb8d28d1643c599e5c1", "message": "is not preceded with whitespace", "committedDate": "2020-12-18T15:43:34Z", "type": "commit"}, {"oid": "635ab95adf556dde6a4731d9fdea1896b31013e9", "url": "https://github.com/seata/seata/commit/635ab95adf556dde6a4731d9fdea1896b31013e9", "message": "is not preceded with whitespace. [WhitespaceAround]", "committedDate": "2020-12-18T15:49:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTg1MA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547271850", "bodyText": "\u8fd9\u4e2a\u62fc\u51fa\u6765\u7684\u662f\u4e0d\u662f\u4e0d\u7b26\u5408SQL\u8bed\u6cd5\u4e86\uff1f", "author": "caohdgege", "createdAt": "2020-12-22T13:16:16Z", "path": "sqlparser/seata-sqlparser-core/src/main/java/io/seata/sqlparser/SQLInsertRecognizer.java", "diffHunk": "@@ -45,4 +45,11 @@\n      * @return the insert rows\n      */\n     List<List<Object>> getInsertRows(Collection<Integer> primaryKeyIndex);\n+\n+    /**\n+     * Gets insert\n+     *\n+     * @return  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+     */\n+    List<String> getInsertParamsValue();", "originalCommit": "635ab95adf556dde6a4731d9fdea1896b31013e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1NjI1Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r548356252", "bodyText": "\u8fd9\u4e2a\u4e0d\u662fsql, \u4e3b\u8981\u4e0b\u60f3\u83b7\u53d6\u5360\u4f4d\u7b26\uff0c\u901a\u8fc7\u5360\u4f4d\u7b26\u6765\u83b7\u53d6\u5404\u4e2a\u5b57\u6bb5\u5bf9\u5e94\u7684\u503c\uff0c\u4e4b\u6240\u4ee5\u8003\u8651\u6709\u5360\u4f4d\u7b26\u6765\u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5\u503c\uff0c\u662f\u8003\u8651values\u6709\u53ef\u80fd\u662f\u5e38\u91cf\uff0c\u6bd4\u5982\u8bf4nows().   \u5982\u679c\u6709\u5e38\u91cf\u65f6,statementProxy.getParameters\u4e0erecognizer.getInsertColumns\u65e0\u6cd5\u4e00 \u4e00\u5bf9\u5e94", "author": "huan415", "createdAt": "2020-12-24T02:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547293745", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8df3\u8fc7\u4e86\u4e3b\u952e\uff1f\u4e3b\u952e\u4e5f\u5177\u6709\u552f\u4e00\u6027\uff0c\u4e5f\u5e94\u8be5\u89e6\u53d1\u8fd9\u4e2a\u624d\u5bf9\u5440\uff1f", "author": "caohdgege", "createdAt": "2020-12-22T14:01:08Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {", "originalCommit": "635ab95adf556dde6a4731d9fdea1896b31013e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1Njk1Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r548356952", "bodyText": "\u8fd9\u4e2a\u662f\u56e0\u4e3a\u524d\u7f6e\u955c\u50cf\u83b7\u53d6\u4e0d\u5230id\uff0c\u800c\u6211\u90a3\u65f6\u5019\u7684\u4e1a\u52a1\u573a\u666f\u5982\u679cid\u4e00\u6837\uff0c\u552f\u4e00\u7d22\u5f15\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u8fc7\u6ee4\u6389\u7684\u3002\u4ece\u7406\u8bba\u4e0a\u8bf4\u662f\u4e0d\u5e94\u8be5\u53bb\u6389\uff0c\u6211\u518d\u60f3\u60f3\u529e\u6cd5", "author": "huan415", "createdAt": "2020-12-24T02:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk2Nzc3NQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r548967775", "bodyText": "\u5df2\u6539\u6b63\uff0c\u5982\u679cinsert\u524d\u7f6e\u955c\u50cf\u6ca1\u6709id\uff0c\u5219\u4e0d\u5217\u5165\u67e5\u8be2\u6761\u4ef6", "author": "huan415", "createdAt": "2020-12-26T10:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Mzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTgyMQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r547295821", "bodyText": "\u8fd9\u91cc\u7528contains\u7684\u6027\u80fd\u662f\u4e0d\u662f\u4f1a\u5dee\u4e00\u70b9\uff1f\u5e76\u4e14contains\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u6709\u53ef\u80fd\u8bef\u5224\uff1f", "author": "caohdgege", "createdAt": "2020-12-22T14:05:14Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRows[0] = true;\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRows[0]) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        Map<String, List<Object>> pkValues = getPkValues();\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    protected TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    private String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        int insertNum = buildImageParamperters(recognizer, imageParamperterMap);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    v.getValues().forEach(m -> {\n+                        String columnName = m.getColumnName();\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(m.getColumnName()).get(finalI));\n+                    });\n+                    if (suffix.toString().contains(\"WHERE\")) {", "originalCommit": "635ab95adf556dde6a4731d9fdea1896b31013e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk2Nzk2OA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r548967968", "bodyText": "\u8fd9\u4e2asql\u662f\u6211\u4eec\u81ea\u5df1\u62fc\u63a5\u6765\u67e5\u8be2\u955c\u50cf\uff0c\u4e00\u822c\u4e0d\u4f1a\u6709\u8bef\u5224\u3002\n\u6539\u4e3a\u58f0\u660e\u4e86\u4e00\u4e2aflag\uff0c\u7b2c\u4e00\u6b21\u7684\u65f6\u5019\u62fc\u63a5where\uff0c\u4ee5\u540e\u62fc\u63a5\u7684\u662for", "author": "huan415", "createdAt": "2020-12-26T10:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTgyMQ=="}], "type": "inlineReview"}, {"oid": "4155abda8d203b151adfae0b84f75cb7e40f0671", "url": "https://github.com/seata/seata/commit/4155abda8d203b151adfae0b84f75cb7e40f0671", "message": "It should be set to a constant", "committedDate": "2020-12-22T15:10:36Z", "type": "commit"}, {"oid": "5c9f07493360d4f69236454a598881329c673158", "url": "https://github.com/seata/seata/commit/5c9f07493360d4f69236454a598881329c673158", "message": "bugfix:insertParams is characterstring constant", "committedDate": "2020-12-24T13:29:03Z", "type": "commit"}, {"oid": "6202dea6bc04415bf0a278ae19bfe873cb53ec79", "url": "https://github.com/seata/seata/commit/6202dea6bc04415bf0a278ae19bfe873cb53ec79", "message": "bugfix:insert params is characterstring constant", "committedDate": "2020-12-24T13:57:27Z", "type": "commit"}, {"oid": "0c89f8c8ee1148edbd28670def2e2fbd0ac8fbf8", "url": "https://github.com/seata/seata/commit/0c89f8c8ee1148edbd28670def2e2fbd0ac8fbf8", "message": "bugfix:when buildImage support index is PRIMARY", "committedDate": "2020-12-26T09:23:33Z", "type": "commit"}, {"oid": "ad5d24e646ba9255495632540a4c88a130dcaa1a", "url": "https://github.com/seata/seata/commit/ad5d24e646ba9255495632540a4c88a130dcaa1a", "message": "Merge pull request #1 from seata/develop\n\nmerge origin seata project", "committedDate": "2020-12-26T10:53:56Z", "type": "commit"}, {"oid": "d4db6da983e29960e8d8b6a3bce5b3bbad807eed", "url": "https://github.com/seata/seata/commit/d4db6da983e29960e8d8b6a3bce5b3bbad807eed", "message": "'>' is not followed by whitespace", "committedDate": "2020-12-26T11:14:45Z", "type": "commit"}, {"oid": "5323f259b7c4782f81f47657e1ccfcda2f751873", "url": "https://github.com/seata/seata/commit/5323f259b7c4782f81f47657e1ccfcda2f751873", "message": "')' is preceded with whitespace", "committedDate": "2020-12-26T11:25:43Z", "type": "commit"}, {"oid": "326a058fafc46d70462fd25dd10207ec511f1b80", "url": "https://github.com/seata/seata/commit/326a058fafc46d70462fd25dd10207ec511f1b80", "message": "'.*' form of import should be avoide", "committedDate": "2020-12-26T11:31:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549129843", "bodyText": "java\u5f00\u5934\u7684import\u8981\u8c03\u5230\u4e0a\u9762\u3002", "author": "caohdgege", "createdAt": "2020-12-27T16:03:58Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;", "originalCommit": "326a058fafc46d70462fd25dd10207ec511f1b80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NTA0Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549355042", "bodyText": "\u5df2\u6539\uff0c\u80fd\u8bf4\u4e00\u4e0b\u539f\u56e0\u5417", "author": "huan415", "createdAt": "2020-12-28T13:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NzMzOQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549357339", "bodyText": "\u89c4\u8303\u5427\u3002\u3002\u3002\u6211\u8fdb\u6765\u7684\u65f6\u5019\u5927\u4f6c\u4eec\u8ddf\u6211\u8bf4\u7684\u3002\u3002\u3002", "author": "caohdgege", "createdAt": "2020-12-28T13:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDAzOA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130038", "bodyText": "\u7528\u4ee5\u4e0b\u7684\u6ce8\u91ca\u65b9\u5f0f\n/**\n*\n*/", "author": "caohdgege", "createdAt": "2020-12-27T16:05:54Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not", "originalCommit": "326a058fafc46d70462fd25dd10207ec511f1b80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDE5Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130192", "bodyText": "\u8fd9\u4e2a\u65b9\u6cd5\u540d\u80fd\u4e0d\u80fd\u4f18\u5316\u4e00\u4e0b\uff1f", "author": "caohdgege", "createdAt": "2020-12-27T16:07:00Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {", "originalCommit": "326a058fafc46d70462fd25dd10207ec511f1b80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549130724", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u662f\u4e2a\u6570\u7ec4\u6765\u7684\uff1f", "author": "caohdgege", "createdAt": "2020-12-27T16:12:32Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    //is updated or not\n+    private boolean isUpdateFlag = false;\n+\n+    //before image sql and after image sql,condition is unique index\n+    private String selectSQL;\n+\n+    //the params of selectSQL, value is the unique index\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    //key is unique index name, value is unique index\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLog2(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLog2(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            Boolean[] isUpdateRows = {false};", "originalCommit": "326a058fafc46d70462fd25dd10207ec511f1b80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM1NjgyMA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549356820", "bodyText": "\u8fd9\u662f\u4e00\u4e2aflag, \u904d\u5386\u540e\u7f6e\u955c\u50cf\u91cc\u7684\u6bcf\u6761\u6570\u636e\uff0c\u5982\u679c\u8be5\u6761\u6570\u636e\u7684\u552f\u4e00\u7d22\u5f15\u5728\u524d\u7f6e\u955c\u50cf\u5df2\u7ecf\u5b58\u5728\uff0c\u5219\u6807\u8bb0\u6210true\u3002\u540e\u9762\u6839\u636e\u8fd9\u4e2a\u503c\u5224\u65ad\u662finsertUndolog\uff0c\u8fd8\u662fupdateUndolog\u3002\n\u6211\u5728\u5916\u9762\u58f0\u660eboolean\uff0csteam\u91cc\u9762\u4e0d\u80fd\u7528\uff0c\u6240\u4ee5\u7528\u6570\u7ec4\u3002\u5982\u679c\u7528\u6570\u7ec4\u4e0d\u597d\uff0c\u6211\u6539\u6210AtomicBoolean", "author": "huan415", "createdAt": "2020-12-28T13:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2MTEwNg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r549361106", "bodyText": "\u8fd9\u91cc\u7684\u8bdd\uff0c\u4f60\u5176\u5b9e\u5c31\u662f\u9700\u8981\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\uff0c\u7136\u540e\u8ba9\u4ed6\u53ef\u4ee5\u5728stream\u91cc\u9762\u4f7f\u7528\u5bf9\u5427\uff1f\u6709\u6ca1\u6709\u4e00\u4e9b\u66f4\u4f18\u96c5\u7684\u4f7f\u7528\u65b9\u5f0f\uff1f", "author": "caohdgege", "createdAt": "2020-12-28T14:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEzMDcyNA=="}], "type": "inlineReview"}, {"oid": "32b0318010e39dfbaba18b6379cf7be0214e3ada", "url": "https://github.com/seata/seata/commit/32b0318010e39dfbaba18b6379cf7be0214e3ada", "message": "formatcode pattern", "committedDate": "2020-12-28T13:38:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTYyNg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r553389626", "bodyText": "\u8fd9\u91cc\u76f4\u63a5\u7528afterImage\u5c31\u597d\u4e86\u5427", "author": "caohdgege", "createdAt": "2021-01-07T15:14:08Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;", "originalCommit": "32b0318010e39dfbaba18b6379cf7be0214e3ada", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUxNTA0MQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r554515041", "bodyText": "\u8fd9\u8fb9\u662f\u53ef\u4ee5\u76f4\u63a5\u8fd4\u56deafterImage", "author": "huan415", "createdAt": "2021-01-10T05:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzMDQ3Nw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r553330477", "bodyText": "\u4ec5\u7559@author\u5373\u53ef", "author": "a364176773", "createdAt": "2021-01-07T13:36:39Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @version: 1.00.00\n+ * @description:\n+ * @author: yangyicong\n+ * @date: 2020-11-26 09:06", "originalCommit": "32b0318010e39dfbaba18b6379cf7be0214e3ada", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8b4494ef2b8de8660e629aab88261df5a8d0603", "url": "https://github.com/seata/seata/commit/e8b4494ef2b8de8660e629aab88261df5a8d0603", "message": "add the test case of insertorUpdate", "committedDate": "2021-01-09T13:58:37Z", "type": "commit"}, {"oid": "45b69e4496adb1f93b3ad9301b9c934190c189c5", "url": "https://github.com/seata/seata/commit/45b69e4496adb1f93b3ad9301b9c934190c189c5", "message": "Optimize code", "committedDate": "2021-01-10T05:37:58Z", "type": "commit"}, {"oid": "3e5b6175b1f891d6253d4aa742687572d6d5442c", "url": "https://github.com/seata/seata/commit/3e5b6175b1f891d6253d4aa742687572d6d5442c", "message": "remmove redundant import", "committedDate": "2021-01-10T05:46:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDc1NTA5Mg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r560755092", "bodyText": "imageParamperterMap.computeIfAbsent(m,k->new ArrayList<>())", "author": "a364176773", "createdAt": "2021-01-20T08:17:16Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isEmpty(indexList)) {\n+                        indexList = new ArrayList<>();\n+                    }\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");\n+        StringBuilder suffix = new StringBuilder(\" FROM \").append(getFromTableInSQL());\n+        boolean[] isContainWhere = {false};\n+        for (int i = 0; i < insertNum; i++) {\n+            int finalI = i;\n+            List<Object> paramAppenderTempList = new ArrayList<>();\n+            tableMeta.getAllIndexes().forEach((k, v) -> {\n+                if (!v.isNonUnique()) {\n+                    List<String> uniqueList = new ArrayList<>();\n+                    for (ColumnMeta m : v.getValues()) {\n+                        String columnName = m.getColumnName();\n+                        if (imageParamperterMap.get(columnName) == null || imageParamperterMap.get(columnName).get(finalI) == null) {\n+                            continue;\n+                        }\n+                        uniqueList.add(columnName + \" = ? \");\n+                        paramAppenderTempList.add(imageParamperterMap.get(columnName).get(finalI));\n+                    }\n+                    if (isContainWhere[0]) {\n+                        suffix.append(\" OR (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                    } else {\n+                        suffix.append(\" WHERE (\").append(Joiner.on(\" and \").join(uniqueList)).append(\") \");\n+                        isContainWhere[0] = true;\n+                    }\n+                }\n+            });\n+            paramAppenderList.add(paramAppenderTempList);\n+        }\n+        suffix.append(\" FOR UPDATE\");\n+        StringJoiner selectSQLJoin = new StringJoiner(\", \", prefix.toString(), suffix.toString());\n+        return selectSQLJoin.toString();\n+    }\n+\n+    /**\n+     * build sql params\n+     * @param recognizer\n+     * @return\n+     */\n+    public Map<String, ArrayList<Object>> buildImageParamperters(SQLInsertRecognizer recognizer) {\n+        Map<String, ArrayList<Object>> imageParamperterMap = new HashMap<>();\n+        Map<Integer, ArrayList<Object>> parameters = ((PreparedStatementProxy) statementProxy).getParameters();\n+        //  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n+        List<String> insertParamsList = recognizer.getInsertParamsValue();\n+        List<String> insertColumns = recognizer.getInsertColumns();\n+        int paramsindex = 1;\n+        for (String insertParams : insertParamsList) {\n+            String[] insertParamsArray = insertParams.split(\",\");\n+            for (int i = 0; i < insertColumns.size(); i++) {\n+                String m = insertColumns.get(i);\n+                String params = insertParamsArray[i];\n+                ArrayList<Object> imageListTemp = imageParamperterMap.get(m);", "originalCommit": "3e5b6175b1f891d6253d4aa742687572d6d5442c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a3145349c98669a58f2513b61e58e9667c9f1e79", "url": "https://github.com/seata/seata/commit/a3145349c98669a58f2513b61e58e9667c9f1e79", "message": "optimize code", "committedDate": "2021-01-23T00:39:59Z", "type": "commit"}, {"oid": "0fb31f43da21f8bed23906748688bb7061a9b7ea", "url": "https://github.com/seata/seata/commit/0fb31f43da21f8bed23906748688bb7061a9b7ea", "message": "optimize code", "committedDate": "2021-01-23T00:48:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzODg2OA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r570938868", "bodyText": "else throw new NotSupportYetException ?", "author": "caohdgege", "createdAt": "2021-02-05T12:37:41Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }", "originalCommit": "0fb31f43da21f8bed23906748688bb7061a9b7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg4NzIwNw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r572887207", "bodyText": "\u5176\u4ed6\u7684dbType\uff0c\u6211\u662f\u60f3\u5148\u8ba9mysql\u8bd5\u8bd5\uff0c\u5982\u679c\u80fd\u88ab\u4f60\u4eec\u91c7\u7eb3\uff0c\u6211\u540e\u7eed\u4e5f\u60f3\u652f\u6301\u4e00\u4e0b\u5176\u4ed6\u7684", "author": "huan415", "createdAt": "2021-02-09T13:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzODg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzOTA1MA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r570939050", "bodyText": "\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u6ce8\u91ca\u6389\u7684\uff1f", "author": "caohdgege", "createdAt": "2021-02-05T12:38:03Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/ExecuteTemplate.java", "diffHunk": "@@ -98,6 +101,11 @@\n                     case SELECT_FOR_UPDATE:\n                         executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                         break;\n+                    case INSERT_ON_DUPLICATE_UPDATE:\n+                        if (JdbcConstants.MYSQL.equals(dbType)) {\n+                            executor = new MySQLInsertOrUpdateExecutor(statementProxy,statementCallback,sqlRecognizer);\n+                        }\n+                        //  break;", "originalCommit": "0fb31f43da21f8bed23906748688bb7061a9b7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg5MTIxMg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r572891212", "bodyText": "\u6ce8\u91ca\u6389\u7684\u539f\u56e0\u662f\uff1a\u5982\u679c\u4e00\u4e2a\u5f88\u6210\u719f\u7684\u9879\u76ee\u63a5\u5165seata\uff0c\u6709\u7528\u5230ON DUPLICATE KEY UPDATE\uff0c\u4f46\u662f\u4ed6\u4eec\u53c8\u4e0d\u77e5\u9053seata\u4e0d\u652f\u6301\u8fd9\u79cdsql.  \u6b64\u65f6\u5982\u679c\u6ca1\u6709\u6d4b\u8bd5\u5230\uff0c\u4e0a\u751f\u4ea7\u73af\u5883\u7684\u8bdd\u4f1a\u51fa\u95ee\u9898\u3002\u6240\u4ee5\u6211\u60f3\u6309\u6b63\u5e38\u7684sql\u6267\u884c\uff08\u6ca1\u6709\u5206\u5e03\u5f0f\u4e8b\u52a1\uff09\u3002\u6240\u4ee5\u6211\u628abreak\u6ce8\u91ca\u6389\uff0c\u4e0d\u5f71\u54cd\u4e1a\u52a1\uff0c\u53ea\u662f\u5206\u5e03\u5f0f\u4e8b\u52a1\u6ca1\u6709\u8d77\u4f5c\u7528", "author": "huan415", "createdAt": "2021-02-09T13:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDkzOTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0MzYxNw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r570943617", "bodyText": "\u8fd9\u91cc\u7684\u67e5\u8be2\u7684\u5b57\u6bb5\uff0c\u662f\u5426\u9700\u8981\u53d7onlyCareUpdateColumns\u8fd9\u4e2a\u53c2\u6570\u7684\u5f71\u54cd\uff1f", "author": "caohdgege", "createdAt": "2021-02-05T12:46:47Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);\n+                }\n+            });\n+        }\n+        List<Row> insertRows = new ArrayList<>();\n+        List<Row> updateRows = new ArrayList<>();\n+        List<Row> afterImageRows = afterImage.getRows();\n+        for (Row r : afterImageRows) {\n+            AtomicBoolean isUpdateRowsFlag = new AtomicBoolean(false);\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.get(k.toUpperCase());\n+                    if (CollectionUtils.isNotEmpty(indexList)) {\n+                        indexList.forEach(m -> {\n+                            if (m.equals(everyRowIndex.toString())) {\n+                                isUpdateRowsFlag.set(true);\n+                            }\n+                        });\n+                    }\n+                }\n+            });\n+            if (isUpdateRowsFlag.get()) {\n+                updateRows.add(r);\n+            } else {\n+                insertRows.add(r);\n+            }\n+        }\n+        if (CollectionUtils.isNotEmpty(updateRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(updateRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(SQLType.UPDATE, beforeImage, partAfterImage));\n+        }\n+        if (CollectionUtils.isNotEmpty(insertRows)) {\n+            TableRecords partAfterImage = new TableRecords(afterImage.getTableMeta());\n+            partAfterImage.setTableName(afterImage.getTableName());\n+            partAfterImage.setRows(insertRows);\n+            connectionProxy.appendUndoLog(buildUndoItem(TableRecords.empty(getTableMeta()), partAfterImage));\n+        }\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     * @param sqlType\n+     * @param beforeImage\n+     * @param afterImage\n+     * @return\n+     */\n+    protected SQLUndoLog buildUndoItem(SQLType sqlType, TableRecords beforeImage, TableRecords afterImage) {\n+        String tableName = sqlRecognizer.getTableName();\n+        SQLUndoLog sqlUndoLog = new SQLUndoLog();\n+        sqlUndoLog.setSqlType(sqlType);\n+        sqlUndoLog.setTableName(tableName);\n+        sqlUndoLog.setBeforeImage(beforeImage);\n+        sqlUndoLog.setAfterImage(afterImage);\n+        return sqlUndoLog;\n+    }\n+\n+\n+    @Override\n+    protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n+        if (isUpdateFlag) {\n+            return buildImage();\n+        } else {\n+            Map<String, List<Object>> pkValues = getPkValues();\n+            return afterImageInsert(pkValues);\n+        }\n+    }\n+\n+    private TableRecords afterImageInsert(Map<String, List<Object>> pkValues) throws SQLException {\n+        TableRecords afterImage = buildTableRecords(pkValues);\n+        if (afterImage == null) {\n+            throw new SQLException(\"Failed to build after-image for insert\");\n+        }\n+        return afterImage;\n+    }\n+\n+    @Override\n+    public TableRecords beforeImage() throws SQLException {\n+        return buildImage();\n+    }\n+\n+    /**\n+     * build before image and after image\n+     * @return\n+     * @throws SQLException\n+     */\n+    protected TableRecords buildImage() throws SQLException {\n+        TableMeta tmeta = getTableMeta();\n+        //after image sql the same of before image\n+        if (StringUtils.isBlank(selectSQL)) {\n+            paramAppenderList = new ArrayList<>();\n+            selectSQL = buildImageSQL(tmeta);\n+        }\n+        return buildTableRecords2(tmeta, selectSQL, paramAppenderList);\n+    }\n+\n+    /**\n+     *  build TableRecords\n+     * @param tableMeta\n+     * @param selectSQL\n+     * @param paramAppenderList\n+     * @return\n+     * @throws SQLException\n+     */\n+    public TableRecords buildTableRecords2(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n+        ResultSet rs = null;\n+        try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) {\n+            if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n+                for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n+                    List<Object> paramAppender = paramAppenderList.get(i);\n+                    for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n+                        ps.setObject(i * ds + j + 1, \"NULL\".equals(paramAppender.get(j).toString()) ? null : paramAppender.get(j));\n+                    }\n+                }\n+            }\n+            rs = ps.executeQuery();\n+            return TableRecords.buildRecords(tableMeta, rs);\n+        } finally {\n+            IOUtil.close(rs);\n+        }\n+    }\n+\n+    /**\n+     * build image sql\n+     * @param tableMeta\n+     * @return\n+     */\n+    public String buildImageSQL(TableMeta tableMeta) {\n+        if (CollectionUtils.isEmpty(paramAppenderList)) {\n+            paramAppenderList = new ArrayList<>();\n+        }\n+        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizer;\n+        int insertNum = recognizer.getInsertParamsValue().size();\n+        Map<String, ArrayList<Object>> imageParamperterMap =  buildImageParamperters(recognizer);\n+        StringBuilder prefix = new StringBuilder(\"SELECT * \");", "originalCommit": "0fb31f43da21f8bed23906748688bb7061a9b7ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjkxNTA4NA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r572915084", "bodyText": "\u597d\u50cf\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u662f\u524d\u7f6e\u955c\u50cf\u548c\u540e\u7f6e\u955c\u50cf\u5bf9\u6bd4\uff0c\u5f97\u51fa\u662finsert\u6216update\u3002\u505a\u524d\u7f6e\u955c\u50cf\u7684\u65f6\u5019\u8fd8\u4e0d\u77e5\u9053\u8fd9\u4e2a\u662finsert\u6216update, \u6240\u4ee5\u6240\u6709\u5b57\u6bb5\u90fd\u67e5\u4e86\u3002\u6709\u4ec0\u4e48\u6bd4\u8f83\u597d\u7684\u5efa\u8bae\uff1f", "author": "huan415", "createdAt": "2021-02-09T14:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0MzYxNw=="}], "type": "inlineReview"}, {"oid": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "url": "https://github.com/seata/seata/commit/cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "message": "throw new NotSupportYetException when oracle INSERT_ON_DUPLICATE_UPDATE", "committedDate": "2021-02-09T14:34:57Z", "type": "commit"}, {"oid": "71ecfa47f6116eb20b44e39b78bf42910c9654c7", "url": "https://github.com/seata/seata/commit/71ecfa47f6116eb20b44e39b78bf42910c9654c7", "message": "Specification code", "committedDate": "2021-02-09T15:47:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5NzQyOA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r572997428", "bodyText": "\u8fd9\u91cc\u62fc\u63a5\u5b57\u7b26\u4e32\u4f1a\u4e0d\u4f1a\u4e0d\u662f\u5f88\u597d\uff1f\u50cf\u90a3\u79cd(a,b)\u7684\u8054\u5408\u552f\u4e00\u7d22\u5f15\uff0ca=1,b=22 \u548c a=12,b=2\u7684\u8bdd\uff0c\u662f\u4e0d\u662f\u4f1a\u5bfc\u81f4\u8bef\u5224\uff1f", "author": "caohdgege", "createdAt": "2021-02-09T15:44:05Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());", "originalCommit": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ2MzM3Mw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r573463373", "bodyText": "\u8fd9\u4e2a\u4f1a\u8bef\u5224\uff0c\u6211\u52a0\u5206\u9694\u7b26\u628a", "author": "huan415", "createdAt": "2021-02-10T05:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5NzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5ODIyNA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r572998224", "bodyText": "\u8fd9\u4e00\u884c\u662f\u5426\u662f\u591a\u4f59\u7684\uff1f", "author": "caohdgege", "createdAt": "2021-02-09T15:45:02Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLInsertOrUpdateExecutor.class);\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n+        TableRecords afterImage = afterImage(beforeImage);\n+        prepareUndoLogAll(beforeImage, afterImage);\n+        return result;\n+    }\n+\n+    /**\n+     * prepare undo log.\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @throws SQLException the sql exception\n+     */\n+    protected void prepareUndoLogAll(TableRecords beforeImage, TableRecords afterImage) {\n+        if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n+            return;\n+        }\n+        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n+        TableRecords lockKeyRecords = afterImage;\n+        String lockKeys = buildLockKey(lockKeyRecords);\n+        connectionProxy.appendLockKey(lockKeys);\n+        buildUndoItemAll(connectionProxy,beforeImage, afterImage);\n+    }\n+\n+    /**\n+     * build a SQLUndoLog\n+     *\n+     * @param beforeImage the before image\n+     * @param afterImage  the after image\n+     * @return sql undo log\n+     */\n+    protected void buildUndoItemAll(ConnectionProxy connectionProxy, TableRecords beforeImage, TableRecords afterImage) {\n+        if (!isUpdateFlag) {\n+            SQLUndoLog sqlUndoLog = buildUndoItem(TableRecords.empty(getTableMeta()), afterImage);\n+            connectionProxy.appendUndoLog(sqlUndoLog);\n+            return;\n+        }\n+        List<Row> beforeImageRows = beforeImage.getRows();\n+        for (Row r : beforeImageRows) {\n+            getTableMeta().getAllIndexes().forEach((k, v) -> {\n+                if (!\"PRIMARY\".equals(k.toUpperCase()) && !v.isNonUnique()) {\n+                    StringBuilder everyRowIndex = new StringBuilder();\n+                    v.getValues().forEach(m -> {\n+                        for (Field f : r.getFields()) {\n+                            if (m.getColumnName().equals(f.getName())) {\n+                                everyRowIndex.append(f.getValue());\n+                            }\n+                        }\n+                    });\n+                    List<String> indexList = beforeUniqueIndexMap.computeIfAbsent(k.toUpperCase(),key -> new ArrayList<>());\n+                    indexList.add(everyRowIndex.toString());\n+                    beforeUniqueIndexMap.put(k.toUpperCase(), indexList);", "originalCommit": "cb3dc6a44f363f7cc7510b870e762d8cf80d20c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f503bbdcf402cc720ea484d36d01166d41fa9ce", "url": "https://github.com/seata/seata/commit/6f503bbdcf402cc720ea484d36d01166d41fa9ce", "message": "resove unique value is conflict", "committedDate": "2021-02-10T00:39:25Z", "type": "commit"}, {"oid": "b3f2852e1d7ded3edaa9bfda14af935ac8be0896", "url": "https://github.com/seata/seata/commit/b3f2852e1d7ded3edaa9bfda14af935ac8be0896", "message": "Merge pull request #2 from seata/develop\n\nmerge origin seata project", "committedDate": "2021-02-10T08:18:18Z", "type": "commit"}, {"oid": "f30c2a9d6940566e20765cadb6842fee173020df", "url": "https://github.com/seata/seata/commit/f30c2a9d6940566e20765cadb6842fee173020df", "message": "changes/1.5.0.md", "committedDate": "2021-02-10T09:19:36Z", "type": "commit"}, {"oid": "15f016a7424683edb3be869b18591b8fe179d919", "url": "https://github.com/seata/seata/commit/15f016a7424683edb3be869b18591b8fe179d919", "message": "Merge branch 'develop' into develop", "committedDate": "2021-02-18T08:17:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDAxMg==", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220012", "bodyText": "please remove :", "author": "xingfudeshi", "createdAt": "2021-02-18T08:28:37Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @author: yangyicong", "originalCommit": "15f016a7424683edb3be869b18591b8fe179d919", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDUxNw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220517", "bodyText": "please remove :", "author": "xingfudeshi", "createdAt": "2021-02-18T08:29:20Z", "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * @author: yangyicong", "originalCommit": "15f016a7424683edb3be869b18591b8fe179d919", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIyMDY0MA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r578220640", "bodyText": "Please do not use *.", "author": "xingfudeshi", "createdAt": "2021-02-18T08:29:32Z", "path": "rm-datasource/src/test/java/io/seata/rm/datasource/exec/MySQLInsertOrUpdateExecutorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec;\n+\n+import com.google.common.collect.Lists;\n+import io.seata.common.exception.ShouldNeverHappenException;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertExecutor;\n+import io.seata.rm.datasource.exec.mysql.MySQLInsertOrUpdateExecutor;\n+import io.seata.rm.datasource.sql.struct.*;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.struct.SqlDefaultExpr;\n+import io.seata.sqlparser.struct.SqlMethodExpr;\n+import io.seata.sqlparser.struct.SqlSequenceExpr;\n+import io.seata.sqlparser.util.JdbcConstants;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.*;", "originalCommit": "15f016a7424683edb3be869b18591b8fe179d919", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cfe2eec4357b7e4c9986c8f97e7d96d4e9fc5afb", "url": "https://github.com/seata/seata/commit/cfe2eec4357b7e4c9986c8f97e7d96d4e9fc5afb", "message": "remove unnecessary dependentment", "committedDate": "2021-02-19T04:08:46Z", "type": "commit"}, {"oid": "5967922f87c2f0f99cb0e35504c46f92d2c1e1f8", "url": "https://github.com/seata/seata/commit/5967922f87c2f0f99cb0e35504c46f92d2c1e1f8", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop", "committedDate": "2021-02-19T04:09:42Z", "type": "commit"}, {"oid": "a246d3f665f44da6f3776e44fad560b46ea20f34", "url": "https://github.com/seata/seata/commit/a246d3f665f44da6f3776e44fad560b46ea20f34", "message": "Merge branch 'develop' into develop", "committedDate": "2021-02-20T03:02:08Z", "type": "commit"}, {"oid": "57d93d4e74cf77c26f3ebfa82558326afa6e94c2", "url": "https://github.com/seata/seata/commit/57d93d4e74cf77c26f3ebfa82558326afa6e94c2", "message": "temp resove confit", "committedDate": "2021-02-20T13:59:04Z", "type": "commit"}, {"oid": "376f33b2738a1c73f94dd3080a355071af67c4e4", "url": "https://github.com/seata/seata/commit/376f33b2738a1c73f94dd3080a355071af67c4e4", "message": "changes/1.5.0.md", "committedDate": "2021-02-20T16:25:44Z", "type": "commit"}, {"oid": "7d5193287afbb5cb201f8edf574146afc16d8aa8", "url": "https://github.com/seata/seata/commit/7d5193287afbb5cb201f8edf574146afc16d8aa8", "message": "resove pk auto_increment", "committedDate": "2021-02-21T13:36:38Z", "type": "commit"}, {"oid": "1d914745ed18f83bf11ed9ec504a75eba4a0a524", "url": "https://github.com/seata/seata/commit/1d914745ed18f83bf11ed9ec504a75eba4a0a524", "message": "add blank space", "committedDate": "2021-02-21T14:08:20Z", "type": "commit"}, {"oid": "921d0c6509c8a4df2d122a0990416a04a514bc80", "url": "https://github.com/seata/seata/commit/921d0c6509c8a4df2d122a0990416a04a514bc80", "message": "add blank space", "committedDate": "2021-02-21T14:13:40Z", "type": "commit"}, {"oid": "a2d77f63f5fc2c21f4c4ab5ef54e7033300729da", "url": "https://github.com/seata/seata/commit/a2d77f63f5fc2c21f4c4ab5ef54e7033300729da", "message": "remove blank space", "committedDate": "2021-02-21T14:19:03Z", "type": "commit"}, {"oid": "0998d1d75e185bdd83e103c60b8e22cee49afb14", "url": "https://github.com/seata/seata/commit/0998d1d75e185bdd83e103c60b8e22cee49afb14", "message": "Merge branch 'develop' into develop", "committedDate": "2021-02-21T14:32:45Z", "type": "commit"}, {"oid": "2dfe24fed681e2879857b7a6d2c3be9109986e6b", "url": "https://github.com/seata/seata/commit/2dfe24fed681e2879857b7a6d2c3be9109986e6b", "message": "resove whitespace", "committedDate": "2021-02-21T14:40:03Z", "type": "commit"}, {"oid": "d290fbcc1f82bc596f6e1da546e8e5ea0c5ad3fa", "url": "https://github.com/seata/seata/commit/d290fbcc1f82bc596f6e1da546e8e5ea0c5ad3fa", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop", "committedDate": "2021-02-21T14:41:14Z", "type": "commit"}, {"oid": "8dc98136efbc29bcea43cebedf975f4c81ea7e87", "url": "https://github.com/seata/seata/commit/8dc98136efbc29bcea43cebedf975f4c81ea7e87", "message": "unique column value is null", "committedDate": "2021-02-22T12:20:23Z", "type": "commit"}, {"oid": "df056d1601a376cfbeef43d132e3ff919aad1075", "url": "https://github.com/seata/seata/commit/df056d1601a376cfbeef43d132e3ff919aad1075", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop", "committedDate": "2021-02-22T15:40:34Z", "type": "commit"}, {"oid": "6d021f554d388a6c7b822efc63f77bf0a7bd31b9", "url": "https://github.com/seata/seata/commit/6d021f554d388a6c7b822efc63f77bf0a7bd31b9", "message": "unique index column deafult", "committedDate": "2021-02-22T15:57:27Z", "type": "commit"}, {"oid": "29d45cc145efa288f86cac5da34f67651d4d817d", "url": "https://github.com/seata/seata/commit/29d45cc145efa288f86cac5da34f67651d4d817d", "message": "resove sqlType is INSERT_ON_DUPLICATE_UPDATE", "committedDate": "2021-02-23T05:05:03Z", "type": "commit"}, {"oid": "996e4fd4e29b509df989fe5abcdb7cf0221e99a4", "url": "https://github.com/seata/seata/commit/996e4fd4e29b509df989fe5abcdb7cf0221e99a4", "message": "Merge branch 'develop' into develop", "committedDate": "2021-02-23T05:10:29Z", "type": "commit"}, {"oid": "5f6b4031284719a505c483e8814138e0dd30394a", "url": "https://github.com/seata/seata/commit/5f6b4031284719a505c483e8814138e0dd30394a", "message": "resove unique cloumn have default", "committedDate": "2021-02-23T08:34:17Z", "type": "commit"}, {"oid": "2960c7a7e5ed3cbb519a1f8f9301293c79565ddd", "url": "https://github.com/seata/seata/commit/2960c7a7e5ed3cbb519a1f8f9301293c79565ddd", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop", "committedDate": "2021-02-23T08:35:11Z", "type": "commit"}, {"oid": "3c519f9bb80969e196d6b14befbe44762744ec89", "url": "https://github.com/seata/seata/commit/3c519f9bb80969e196d6b14befbe44762744ec89", "message": "resove unique column have default", "committedDate": "2021-02-23T08:52:45Z", "type": "commit"}, {"oid": "33e2d0efe32453eaf544e5bb31f38ceade8534f7", "url": "https://github.com/seata/seata/commit/33e2d0efe32453eaf544e5bb31f38ceade8534f7", "message": "resove unique column have default", "committedDate": "2021-02-23T09:13:19Z", "type": "commit"}, {"oid": "e32f78613ad614deb2e17e48c9f7aabc2fafb0e9", "url": "https://github.com/seata/seata/commit/e32f78613ad614deb2e17e48c9f7aabc2fafb0e9", "message": "resove update column is unique index", "committedDate": "2021-02-24T10:37:04Z", "type": "commit"}, {"oid": "51aa61dfd127dc1aed33c5aa6c014e3ac8df79ab", "url": "https://github.com/seata/seata/commit/51aa61dfd127dc1aed33c5aa6c014e3ac8df79ab", "message": "resove whitespace", "committedDate": "2021-02-24T10:48:48Z", "type": "commit"}, {"oid": "b470adaae1dbb382169736630f8e0ae642c03083", "url": "https://github.com/seata/seata/commit/b470adaae1dbb382169736630f8e0ae642c03083", "message": "remove Unused import", "committedDate": "2021-02-24T10:54:30Z", "type": "commit"}, {"oid": "34b399233b0fc80c8662dd8d35399efccb22fdcd", "url": "https://github.com/seata/seata/commit/34b399233b0fc80c8662dd8d35399efccb22fdcd", "message": "Merge branch 'develop' into develop", "committedDate": "2021-03-04T09:22:20Z", "type": "commit"}, {"oid": "528633754d60809dae30dcfd2b4866e30e6e6a92", "url": "https://github.com/seata/seata/commit/528633754d60809dae30dcfd2b4866e30e6e6a92", "message": "Merge pull request #3 from seata/develop\n\nmerge seata develop", "committedDate": "2021-03-14T10:43:56Z", "type": "commit"}, {"oid": "4c6b844b5413b3d003088bcfa98b603044f5d5ba", "url": "https://github.com/seata/seata/commit/4c6b844b5413b3d003088bcfa98b603044f5d5ba", "message": "resove test case", "committedDate": "2021-03-14T12:13:31Z", "type": "commit"}, {"oid": "ae35ac1fcd77fb2616d3a5e7c4533e2d0ebfb838", "url": "https://github.com/seata/seata/commit/ae35ac1fcd77fb2616d3a5e7c4533e2d0ebfb838", "message": "Merge branch 'develop' into develop", "committedDate": "2021-03-15T01:45:08Z", "type": "commit"}, {"oid": "5891b9adbd4dc25eecb5abc971620b3059eb164e", "url": "https://github.com/seata/seata/commit/5891b9adbd4dc25eecb5abc971620b3059eb164e", "message": "Merge branch 'develop' into develop", "committedDate": "2021-03-15T09:29:12Z", "type": "commit"}, {"oid": "5e88d857ab10108378cdfddfae72463423b24874", "url": "https://github.com/seata/seata/commit/5e88d857ab10108378cdfddfae72463423b24874", "message": "Merge branch 'develop' into develop", "committedDate": "2021-03-19T02:16:50Z", "type": "commit"}, {"oid": "541571559fdb233bdc322bb23af9818a4923512c", "url": "https://github.com/seata/seata/commit/541571559fdb233bdc322bb23af9818a4923512c", "message": "afterImage=beforeImageId+uniqueIndex", "committedDate": "2021-03-28T14:06:22Z", "type": "commit"}, {"oid": "bff2baffbb8b6f744c5cd130276344ba23565755", "url": "https://github.com/seata/seata/commit/bff2baffbb8b6f744c5cd130276344ba23565755", "message": "Merge branch 'develop' of https://github.com/huan415/seata into develop", "committedDate": "2021-03-28T14:15:32Z", "type": "commit"}, {"oid": "054846286321470256b6a8f7cc163295c157ccf4", "url": "https://github.com/seata/seata/commit/054846286321470256b6a8f7cc163295c157ccf4", "message": "Merge branch 'develop' into develop", "committedDate": "2021-03-29T04:24:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzUyMzI4NA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r607523284", "bodyText": "\u6709\u4e00\u4e9b\u5730\u65b9\u901a\u8fc7\u5224\u65ad sqlRecognizer.getSQLType() == SQLType.INSERT \u505a\u76f8\u5e94\u5904\u7406\uff0c\u8fd9\u6837\u7684\u5730\u65b9\u53ef\u80fd\u4e5f\u9700\u8981\u4e00\u8d77\u6539\u4e0b\uff0c\u6bd4\u5982\uff1aio.seata.rm.datasource.AbstractConnectionProxy#prepareStatement(java.lang.String)", "author": "ymwangzq", "createdAt": "2021-04-06T05:38:51Z", "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -61,7 +61,7 @@ public MySQLInsertRecognizer(String originalSQL, SQLStatement ast) {\n \n     @Override\n     public SQLType getSQLType() {\n-        return SQLType.INSERT;\n+        return isDuplicateKeyUpdate() ? SQLType.INSERT_ON_DUPLICATE_UPDATE : SQLType.INSERT;", "originalCommit": "054846286321470256b6a8f7cc163295c157ccf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTI1NzM2Nw==", "url": "https://github.com/seata/seata/pull/3374#discussion_r615257367", "bodyText": "\u5176\u4ed6\u7684\u5730\u65b9\u597d\u50cf\u4e0d\u9700\u8981\u52a0\u628a\u3002\u60a8\u4e3e\u4f8b\u7684\u8fd9\u4e2a\uff0c\u6211\u770b\u6ce8\u91ca\u662fsupport oracle 10.2+\uff0c\u4f46\u662foracle\u6ca1\u6709\u8fd9\u79cd\u8bed\u6cd5\u3002\u6240\u4ee5\u4e0d\u9700\u8981\u5427", "author": "huan415", "createdAt": "2021-04-17T13:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzUyMzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r608302709", "bodyText": "\u5982\u679cupdate \u64cd\u4f5c\u91cc\u6709\u4fee\u6539\u4e3b\u952e\uff0c\u53ef\u80fd\u8fd8\u9700\u8981\u62e6\u622a\u6389\u3002", "author": "ymwangzq", "createdAt": "2021-04-07T02:45:57Z", "path": "rm-datasource/src/main/java/io/seata/rm/datasource/exec/mysql/MySQLInsertOrUpdateExecutor.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ *  Copyright 1999-2019 Seata.io Group.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package io.seata.rm.datasource.exec.mysql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import com.google.common.base.Joiner;\n+import io.seata.common.exception.NotSupportYetException;\n+import io.seata.common.loader.LoadLevel;\n+import io.seata.common.loader.Scope;\n+import io.seata.common.util.CollectionUtils;\n+import io.seata.common.util.IOUtil;\n+import io.seata.common.util.StringUtils;\n+import io.seata.rm.datasource.ConnectionProxy;\n+import io.seata.rm.datasource.PreparedStatementProxy;\n+import io.seata.rm.datasource.StatementProxy;\n+import io.seata.rm.datasource.exec.StatementCallback;\n+import io.seata.rm.datasource.sql.struct.ColumnMeta;\n+import io.seata.rm.datasource.sql.struct.Field;\n+import io.seata.rm.datasource.sql.struct.Row;\n+import io.seata.rm.datasource.sql.struct.TableMeta;\n+import io.seata.rm.datasource.sql.struct.TableRecords;\n+import io.seata.rm.datasource.undo.SQLUndoLog;\n+import io.seata.sqlparser.SQLInsertRecognizer;\n+import io.seata.sqlparser.SQLRecognizer;\n+import io.seata.sqlparser.SQLType;\n+import io.seata.sqlparser.struct.Defaultable;\n+import io.seata.sqlparser.struct.Null;\n+import io.seata.sqlparser.util.JdbcConstants;\n+\n+/**\n+ * @author: yangyicong\n+ */\n+@LoadLevel(name = JdbcConstants.MYSQL, scope = Scope.PROTOTYPE)\n+public class MySQLInsertOrUpdateExecutor extends MySQLInsertExecutor implements Defaultable {\n+\n+\n+    private static final String COLUMN_SEPARATOR = \"|\";\n+\n+    /**\n+     * is updated or not\n+     */\n+    private boolean isUpdateFlag = false;\n+\n+    public String getSelectSQL() {\n+        return selectSQL;\n+    }\n+\n+    /**\n+     * before image sql and after image sql,condition is unique index\n+     */\n+    private String selectSQL;\n+\n+    public ArrayList<List<Object>> getParamAppenderList() {\n+        return paramAppenderList;\n+    }\n+\n+    /**\n+     * the params of selectSQL, value is the unique index\n+     */\n+    private ArrayList<List<Object>> paramAppenderList;\n+\n+    /**\n+     * key is unique index name, value is unique index\n+     */\n+    private Map<String, List<String>> beforeUniqueIndexMap = new HashMap<>();\n+\n+    public MySQLInsertOrUpdateExecutor(StatementProxy statementProxy, StatementCallback statementCallback, SQLRecognizer sqlRecognizer) {\n+        super(statementProxy, statementCallback, sqlRecognizer);\n+    }\n+\n+    /**\n+     * Execute auto commit false t.\n+     *\n+     * @param args the args\n+     * @return the t\n+     * @throws Exception the exception\n+     */\n+    @Override\n+    protected Object executeAutoCommitFalse(Object[] args) throws Exception {\n+        if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && getTableMeta().getPrimaryKeyOnlyName().size() > 1) {\n+            throw new NotSupportYetException(\"multi pk only support mysql!\");\n+        }\n+        TableRecords beforeImage = beforeImage();\n+        if (CollectionUtils.isNotEmpty(beforeImage.getRows())) {\n+            isUpdateFlag = true;\n+        } else {\n+            beforeImage = TableRecords.empty(getTableMeta());\n+        }\n+        Object result = statementCallback.execute(statementProxy.getTargetStatement(), args);", "originalCommit": "054846286321470256b6a8f7cc163295c157ccf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTI1NzQ3Ng==", "url": "https://github.com/seata/seata/pull/3374#discussion_r615257476", "bodyText": "\u62e6\u622a\u6389\uff1f\u4ec0\u4e48\u610f\u601d\uff0c\u6ca1\u660e\u767d", "author": "huan415", "createdAt": "2021-04-17T13:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMzMTYwOA==", "url": "https://github.com/seata/seata/pull/3374#discussion_r615331608", "bodyText": "\u53c2\u8003\u8fd9\u4e2a\u6539\u52a8\u4e4b\u524d\u7684\u7248\u672c https://github.com/seata/seata/pull/3287/files \uff08\u6539\u52a8\u4ee5\u540e\u903b\u8f91\u4e0d\u592a\u76f4\u89c2\uff09\n\u5728 UpdateExecutor \u91cc\u6784\u9020 beforeImage \u7684\u65f6\u5019\uff0c\u4f1a\u8c03\u7528 com.kuaishou.infra.seata.rm.datasource.exec.AbstractDMLBaseExecutor#assertContainsPKColumnName\n\u68c0\u67e5\u662f\u5426\u66f4\u65b0\u4e86\u4e3b\u952e\u3002\u5982\u679c\u4fee\u6539\u4e3b\u952e\u4f1a\u5bfc\u81f4beforeImage\u548cafterImage\u5bf9\u4e0d\u4e0a\uff0c\u65e0\u6cd5\u56de\u6eda.", "author": "ymwangzq", "createdAt": "2021-04-18T02:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzU0Mjk3Ng==", "url": "https://github.com/seata/seata/pull/3374#discussion_r617542976", "bodyText": "insert into  on duplicate key update.  \u4e3b\u952e\u4e0d\u4e00\u6837\u5c31\u662finsert\u4e86\uff0c\u9664\u975e\u7528\u552f\u4e00\u952e\u6765\u66f4\u65b0\u4e3b\u952e\uff08on duplicate key update.\u540e\u9762\u66f4\u65b0\u4e3b\u952e\uff09\uff0c\u611f\u89c9\u8fd9\u79cd\u5199\u6cd5\u5f88\u5947\u8469\uff0c\u4f46\u662f\u6700\u597d\u4e5f\u652f\u6301\u4e00\u4e0b\u3002\u6240\u4ee5UpdateExecutor\u662f\u5224\u65adbeforeImage\u548cafterImage\u5927\u5c0f\u4e0d\u4e00\u6837\uff0c\u5c31\u8ba4\u4e3a\u662f\u66f4\u65b0\u4e86\u4e3b\u952e\u76f4\u63a5\u629b\u5f02\u5e38\uff1f  \u6240\u4ee5\u8fd9\u5982\u679c\u662fupdate\u7684\u60c5\u51b5\u4e0b\uff0c\u4e5f\u5224\u65adafterImage\u548cafterImage\u4e0d\u4e00\u6837\u5c31\u629b\u5f02\u5e38\u4e0d\u652f\u6301\uff1f", "author": "huan415", "createdAt": "2021-04-21T13:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODMwMjcwOQ=="}], "type": "inlineReview"}, {"oid": "7b4408cc05364f9164f24378905ffb5c25768d92", "url": "https://github.com/seata/seata/commit/7b4408cc05364f9164f24378905ffb5c25768d92", "message": "Merge branch 'develop' into develop", "committedDate": "2021-04-16T09:13:06Z", "type": "commit"}, {"oid": "918c5372a7b0b5b76fb4ac3cb6d3aa3a64af83fd", "url": "https://github.com/seata/seata/commit/918c5372a7b0b5b76fb4ac3cb6d3aa3a64af83fd", "message": "fix bug when update primaryKey", "committedDate": "2021-04-21T14:27:50Z", "type": "commit"}, {"oid": "a1af8dbc9a7bd706b91594728a7dc782faf8f7d3", "url": "https://github.com/seata/seata/commit/a1af8dbc9a7bd706b91594728a7dc782faf8f7d3", "message": "Merge branch 'develop' into develop", "committedDate": "2021-04-22T01:49:52Z", "type": "commit"}, {"oid": "fdaf16bb979de4877c8b1ca8dd5ce58009682751", "url": "https://github.com/seata/seata/commit/fdaf16bb979de4877c8b1ca8dd5ce58009682751", "message": "import class", "committedDate": "2021-04-22T02:45:25Z", "type": "commit"}, {"oid": "fe2281517e305e7a20b33e83c778fa9dcf91e055", "url": "https://github.com/seata/seata/commit/fe2281517e305e7a20b33e83c778fa9dcf91e055", "message": "fix bug of update pk", "committedDate": "2021-04-24T05:42:28Z", "type": "commit"}, {"oid": "54875f40855ab62eb58ff07e9dfd74094920480f", "url": "https://github.com/seata/seata/commit/54875f40855ab62eb58ff07e9dfd74094920480f", "message": "Merge branch 'develop' into develop", "committedDate": "2021-04-27T05:18:19Z", "type": "commit"}, {"oid": "b9e0a55a0a4feac0f256c11fe828381508f3f10f", "url": "https://github.com/seata/seata/commit/b9e0a55a0a4feac0f256c11fe828381508f3f10f", "message": "Merge branch 'develop' into develop", "committedDate": "2021-05-02T14:44:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDg5NTExNQ==", "url": "https://github.com/seata/seata/pull/3374#discussion_r624895115", "bodyText": "\u4e0d\u5141\u8bb8import *", "author": "a364176773", "createdAt": "2021-05-03T06:21:55Z", "path": "sqlparser/seata-sqlparser-druid/src/main/java/io/seata/sqlparser/druid/mysql/MySQLInsertRecognizer.java", "diffHunk": "@@ -17,11 +17,7 @@\n \n import com.alibaba.druid.sql.ast.SQLExpr;\n import com.alibaba.druid.sql.ast.SQLStatement;\n-import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLNullExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;\n-import com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr;\n+import com.alibaba.druid.sql.ast.expr.*;", "originalCommit": "b9e0a55a0a4feac0f256c11fe828381508f3f10f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "090c84cc1352ae80a303f4b06aba92610fb70969", "url": "https://github.com/seata/seata/commit/090c84cc1352ae80a303f4b06aba92610fb70969", "message": "resove proplem of ci", "committedDate": "2021-05-03T08:00:57Z", "type": "commit"}, {"oid": "442b7959f324c808f3b0a04dae67f78bf078168e", "url": "https://github.com/seata/seata/commit/442b7959f324c808f3b0a04dae67f78bf078168e", "message": "Merge branch 'develop' into develop", "committedDate": "2021-05-03T12:11:37Z", "type": "commit"}]}