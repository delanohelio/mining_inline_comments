{"pr_number": 9259, "pr_title": "[androiddebugbridge] initial contribution", "pr_createdAt": "2020-12-06T16:17:37Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9259", "timeline": [{"oid": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "url": "https://github.com/openhab/openhab-addons/commit/a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "message": "initial contribution\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-06T15:56:13Z", "type": "commit"}, {"oid": "a0b12d2b8096e71f24c281493069fe7b201c9848", "url": "https://github.com/openhab/openhab-addons/commit/a0b12d2b8096e71f24c281493069fe7b201c9848", "message": "fix start package on devices without keys\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-13T00:17:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MjU3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541982578", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # AndroidDebugBridge Binding\n          \n          \n            \n            # Android Debug Bridge Binding", "author": "fwolter", "createdAt": "2020-12-13T18:54:11Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Mjc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541982765", "bodyText": "You need to escape the lower than and greater than signs.\nIf you put each sentence in a separate line, reading the diffs would be easier.", "author": "fwolter", "createdAt": "2020-12-13T18:54:57Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MjkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541982925", "bodyText": "Isn't this sentence redundant?", "author": "fwolter", "createdAt": "2020-12-13T18:56:04Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.\n+\n+## Supported Things\n+\n+As I said this binding allow to connect openHAB with android devices on the current network.", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MzEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541983122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | discoveryIpRangeMin | int | Used to limit the numbers of ips checked while discovering |\n          \n          \n            \n            | discoveryIpRangeMin | int | Used to limit the number of IPs checked while discovering |", "author": "fwolter", "createdAt": "2020-12-13T18:57:11Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.\n+\n+## Supported Things\n+\n+As I said this binding allow to connect openHAB with android devices on the current network.\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the numbers of ips checked while discovering |", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MzI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541983240", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | ThinTypeID   | description                  |\n          \n          \n            \n            | ThingTypeID   | description                  |", "author": "fwolter", "createdAt": "2020-12-13T18:57:36Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.\n+\n+## Supported Things\n+\n+As I said this binding allow to connect openHAB with android devices on the current network.\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the numbers of ips checked while discovering |\n+| discoveryIpRangeMax | int | Used to limit the numbers of ips checked while discovering |\n+\n+## Thing Configuration\n+\n+| ThinTypeID   | description                  |", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MzMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541983332", "bodyText": "It's unusal to append a unit suffix to the configuration parameters.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | refreshTimeSec | int | Seconds between device status refreshes (default: 30) |\n          \n          \n            \n            | refreshTime | int | Seconds between device status refreshes (default: 30) |", "author": "fwolter", "createdAt": "2020-12-13T18:58:20Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.\n+\n+## Supported Things\n+\n+As I said this binding allow to connect openHAB with android devices on the current network.\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the numbers of ips checked while discovering |\n+| discoveryIpRangeMax | int | Used to limit the numbers of ips checked while discovering |\n+\n+## Thing Configuration\n+\n+| ThinTypeID   | description                  |\n+|----------|------------------------------|\n+| android | Android device |\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| ip | String | Device ip address |\n+| port | int | Device port listening to adb connections |\n+| refreshTimeSec | int | Seconds between device status refreshes (default: 30) |", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MzQyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541983428", "bodyText": "Does the user know what exactly to send here?", "author": "fwolter", "createdAt": "2020-12-13T18:58:59Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,63 @@\n+# AndroidDebugBridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on <device name>\" or something like that.\n+\n+## Supported Things\n+\n+As I said this binding allow to connect openHAB with android devices on the current network.\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the numbers of ips checked while discovering |\n+| discoveryIpRangeMax | int | Used to limit the numbers of ips checked while discovering |\n+\n+## Thing Configuration\n+\n+| ThinTypeID   | description                  |\n+|----------|------------------------------|\n+| android | Android device |\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| ip | String | Device ip address |\n+| port | int | Device port listening to adb connections |\n+| refreshTimeSec | int | Seconds between device status refreshes (default: 30) |\n+\n+## Channels\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| key-event  | String | Send key event to android device |", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ4MTE2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542481166", "bodyText": "I forgot to add the possible values. These are defined on the thing description but I will add them also here. Thanks.", "author": "GiviMAD", "createdAt": "2020-12-14T15:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4MzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Mzk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541983983", "bodyText": "Can you ask the developer to make it available on a repository openHAB supports?", "author": "fwolter", "createdAt": "2020-12-13T19:02:02Z", "path": "bundles/org.openhab.binding.androiddebugbridge/pom.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.androiddebugbridge</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: AndroidDebugBridge Binding</name>\n+\n+  <repositories>\n+    <repository>\n+      <id>jitpack.io</id>\n+      <url>https://jitpack.io</url>\n+    </repository>\n+  </repositories>", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUzNDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542534566", "bodyText": "I find out that there is a fork of the project more maintained and available on maven. I will move to that one.", "author": "GiviMAD", "createdAt": "2020-12-14T16:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Mzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NDE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541984155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<feature name=\"openhab-binding-androiddebugbridge\" description=\"AndroidDebugBridge Binding\" version=\"${project.version}\">\n          \n          \n            \n            \t<feature name=\"openhab-binding-androiddebugbridge\" description=\"Android Debug Bridge Binding\" version=\"${project.version}\">", "author": "fwolter", "createdAt": "2020-12-13T19:02:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+\tCopyright (c) 2010-2020 Contributors to the openHAB project\n+\n+\tSee the NOTICE file(s) distributed with this work for additional\n+\tinformation.\n+\n+\tThis program and the accompanying materials are made available under the\n+\tterms of the Eclipse Public License 2.0 which is available at\n+\thttp://www.eclipse.org/legal/epl-2.0\n+\n+\tSPDX-License-Identifier: EPL-2.0\n+\n+-->\n+<features name=\"org.openhab.binding.androiddebugbridge-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-androiddebugbridge\" description=\"AndroidDebugBridge Binding\" version=\"${project.version}\">", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NDM5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541984392", "bodyText": "Is this field package-private by intention by not specifying private or public?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                static AdbCrypto adbCrypto;\n          \n          \n            \n                static @Nullable AdbCrypto ADB_CRYPTO;", "author": "fwolter", "createdAt": "2020-12-13T19:04:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985546", "bodyText": "You could create these files in OH's userdata directory. There are constants available to get the path.", "author": "fwolter", "createdAt": "2020-12-13T19:11:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985640", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:11:43Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985849", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:12:42Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985975", "bodyText": "AndroidDebugBridgeDeviceException is never thrown.", "author": "fwolter", "createdAt": "2020-12-13T19:13:35Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n          \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", stream, \"--get\", \"|\",", "author": "fwolter", "createdAt": "2020-12-13T19:15:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMTMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542501329", "bodyText": "Seems like I can't apply this change. runAdbShell expect this \"String... args\".", "author": "GiviMAD", "createdAt": "2020-12-14T16:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxMDc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542510797", "bodyText": "You're right, that won't work.", "author": "fwolter", "createdAt": "2020-12-14T16:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986383", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:15:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987175", "bodyText": "If you don't need to distinguish between the exception types, you could use the same type with a different message.", "author": "fwolter", "createdAt": "2020-12-13T19:20:09Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987476", "bodyText": "Please use Thing.PROPERTY_* where applicable.", "author": "fwolter", "createdAt": "2020-12-13T19:21:49Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());\n          \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());", "author": "fwolter", "createdAt": "2020-12-13T19:22:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(PARAMETER_SERIAL)\n+                .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987981", "bodyText": "How long can this take at maximum? dispose() is supposed to return fast.", "author": "fwolter", "createdAt": "2020-12-13T19:24:50Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxMjc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542712750", "bodyText": "I made some test and it takes less than 5 ms always.", "author": "GiviMAD", "createdAt": "2020-12-14T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200600", "bodyText": "What if there is a network problem? Would disconnect still execute quickly?", "author": "cpmeister", "createdAt": "2021-01-20T18:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMxMTYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561311639", "bodyText": "I've never face that problem when I was testing the device disconnection and reconnection. Also I have reviewed the implementation and I don't see any reason why its execution could be blocked by a network problem.", "author": "GiviMAD", "createdAt": "2021-01-20T21:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988173", "bodyText": "Unchecked exceptions are handled by the framework. So, this could be removed.", "author": "fwolter", "createdAt": "2020-12-13T19:26:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);\n+                }\n+                try {\n+                    adbConnection.connect();\n+                } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                        | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException e) {\n+                    logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                    return;\n+                }\n+                if (adbConnection.isConnected()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    refreshStatus();\n+                }\n+            }\n+        } catch (Exception e) {\n+            // retry on unexpected errors", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988324", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "author": "fwolter", "createdAt": "2020-12-13T19:27:03Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    @Nullable\n+    private AndroidDebugBridgeDiscoveryService discoveryService;\n+    @Nullable\n+    private ServiceRegistration<?> discoveryServiceRegistration;\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        if (THING_TYPE_ANDROID_DEVICE.equals(thingTypeUID)) {\n+            return new AndroidDebugBridgeHandler(thing, new AndroidDebugBridgeDevice());\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void registerDiscoveryService(AndroidDebugBridgeBindingConfiguration config) {\n+        AndroidDebugBridgeDiscoveryService androidADBDiscoveryService = discoveryService;\n+        if (androidADBDiscoveryService != null) {\n+            androidADBDiscoveryService.updateConfig(config);\n+        } else {\n+            androidADBDiscoveryService = new AndroidDebugBridgeDiscoveryService();\n+            androidADBDiscoveryService.updateConfig(config);\n+            discoveryService = androidADBDiscoveryService;\n+            discoveryServiceRegistration = bundleContext.registerService(DiscoveryService.class.getName(),\n+                    androidADBDiscoveryService, null);\n+        }\n+    }\n+\n+    private void unregisterDiscoveryService() {\n+        var adbDiscoveryServiceRegistration = discoveryServiceRegistration;\n+        if (adbDiscoveryServiceRegistration != null) {\n+            adbDiscoveryServiceRegistration.unregister();\n+            discoveryServiceRegistration = null;\n+        }\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+        modified(config);\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY5NzAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542697016", "bodyText": "I was reviewing the documentation in the pr and seems like I need to create a bridge, right now I'm just passing the binding configurations to the discovery.\nIs there any other way to access to the binding configuration from the discovery service?\nOr should I create a bridge just to configure the service discovery?\nMaybe I'm missing something.\nThanks in advance.", "author": "GiviMAD", "createdAt": "2020-12-14T19:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543441409", "bodyText": "If your discovery implements ThingHandlerService you need to implement the interface method setThingHandler(ThingHandler handler). Then, you can retrieve the bridge's config from the handler: handler.getThing().getConfiguration()", "author": "fwolter", "createdAt": "2020-12-15T15:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3Mzc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543473751", "bodyText": "It doesn't seem to fit my case because I don't have any bridge implemented on the binding. I configure the discovery through the binding configuration.", "author": "GiviMAD", "createdAt": "2020-12-15T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxMTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543511346", "bodyText": "Now I get it. The binding configuration is stored as properties in the AndroidDebugBridgeHandlerFactory service. I never done this, but if you're keen, you could retrieve the config by injecting ConfigurationAdmin in the discovery class:\n    @Reference\n    void setConfigurationAdmin(ConfigurationAdmin admin) {\n        this.admin = admin;\n    }\n \n    public void ranking() throws IOException {\n        Configuration configOnline =\n            this.admin.getConfiguration(\n                \"org.fipro.ds.data.online.OnlineDataService\",\n                null);\n        Dictionary<String, Object> propsOnline = null;\n        if (configOnline != null\n                && configOnline.getProperties() != null) {\n            propsOnline = configOnline.getProperties();\n        }\n\nThe string argument to admin.getConfiguration() must be the PID of your factory: \"binding.androiddebugbridge\"\nThen, you should be able to obtain a config parameter by calling for example propsOnline.get(\"discoveryPort\"). I'm curious if this works.\nEDIT: I got the code frome here http://blog.vogella.com/2016/09/26/configuring-osgi-declarative-services/", "author": "fwolter", "createdAt": "2020-12-15T16:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODQ4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988482", "bodyText": "The author tag is deprecated and should therefore be removed. See openhab/openhab-core#1844.", "author": "fwolter", "createdAt": "2020-12-13T19:27:42Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"androiddebugbridge\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>AndroidDebugBridge Binding</name>\n+\t<description>This is the binding for connect to Android devices using the Android Debug Bridge protocol.</description>\n+\t<author>Miguel \u00c1lvarez</author>", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<name>AndroidDebugBridge Binding</name>\n          \n          \n            \n            \t<name>Android Debug Bridge Binding</name>", "author": "fwolter", "createdAt": "2020-12-13T19:27:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"androiddebugbridge\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>AndroidDebugBridge Binding</name>", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988566", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"discoveryReachableMs\" type=\"integer\" required=\"true\">\n          \n          \n            \n            \t\t<parameter name=\"discoveryReachableMs\" type=\"integer\" required=\"true\" unit=\"ms\">", "author": "fwolter", "createdAt": "2020-12-13T19:28:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"androiddebugbridge\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>AndroidDebugBridge Binding</name>\n+\t<description>This is the binding for connect to Android devices using the Android Debug Bridge protocol.</description>\n+\t<author>Miguel \u00c1lvarez</author>\n+\n+\t<config-description>\n+\t\t<parameter name=\"discoveryPort\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Discovery Port</label>\n+\t\t\t<description>Port used on discovery to connect to the device through adb.</description>\n+\t\t\t<default>5555</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"discoveryReachableMs\" type=\"integer\" required=\"true\">", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988602", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with up to 25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<label>Discovery Reachable ms</label>\n          \n          \n            \n            \t\t\t<label>Discovery Reachable</label>", "author": "fwolter", "createdAt": "2020-12-13T19:28:30Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"androiddebugbridge\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>AndroidDebugBridge Binding</name>\n+\t<description>This is the binding for connect to Android devices using the Android Debug Bridge protocol.</description>\n+\t<author>Miguel \u00c1lvarez</author>\n+\n+\t<config-description>\n+\t\t<parameter name=\"discoveryPort\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Discovery Port</label>\n+\t\t\t<description>Port used on discovery to connect to the device through adb.</description>\n+\t\t\t<default>5555</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"discoveryReachableMs\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Discovery Reachable ms</label>", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988779", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refreshTimeSec\" type=\"integer\" min=\"10\" max=\"120\" required=\"true\">\n          \n          \n            \n            \t\t\t<parameter name=\"refreshTimeSec\" type=\"integer\" min=\"10\" max=\"120\" unit=\"s\" required=\"true\">", "author": "fwolter", "createdAt": "2020-12-13T19:29:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,375 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"androiddebugbridge\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"android\">\n+\t\t<label>Android Device Thing</label>\n+\t\t<description>Android Device Thing for Android Debug Bridge Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"key-event\" typeId=\"key-event-channel\"/>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\"/>\n+\t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>\n+\t\t\t<channel id=\"media-control\" typeId=\"media-control-channel\"/>\n+\t\t\t<channel id=\"start-package\" typeId=\"start-package-channel\"/>\n+\t\t\t<channel id=\"stop-package\" typeId=\"stop-package-channel\"/>\n+\t\t\t<channel id=\"current-package\" typeId=\"current-package-channel\"/>\n+\t\t</channels>\n+\t\t<representation-property>serial</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ip\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>Device ip address.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>ADB Port</label>\n+\t\t\t\t<description>Device port listening to adb connections.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTimeSec\" type=\"integer\" min=\"10\" max=\"120\" required=\"true\">", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4OTczMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541989733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Refresh device {} status\", config.ip);\n          \n          \n            \n                        logger.debug(\"Refresh device {} status\", currentConfig.ip);", "author": "fwolter", "createdAt": "2020-12-13T19:35:01Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "034b86b1e5da198b5c627fd0ddc774820ee675db", "url": "https://github.com/openhab/openhab-addons/commit/034b86b1e5da198b5c627fd0ddc774820ee675db", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T18:00:20Z", "type": "commit"}, {"oid": "4d5a456df2ef9cb0f643af9703311e218ce97bc4", "url": "https://github.com/openhab/openhab-addons/commit/4d5a456df2ef9cb0f643af9703311e218ce97bc4", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T19:42:50Z", "type": "commit"}, {"oid": "bc7f05e731424a489b28055c07a99da45736ed60", "url": "https://github.com/openhab/openhab-addons/commit/bc7f05e731424a489b28055c07a99da45736ed60", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-15T22:41:42Z", "type": "commit"}, {"oid": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "url": "https://github.com/openhab/openhab-addons/commit/50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "message": "fix adb keys path\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T01:23:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2OTc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544469793", "bodyText": "Great to see this works!\nYou could inject this via the constructor to get rid of the Nullable annotation.", "author": "fwolter", "createdAt": "2020-12-16T17:06:13Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MDQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544470494", "bodyText": "Can you make \"binding.androiddebugbridge\" a constant?", "author": "fwolter", "createdAt": "2020-12-16T17:07:08Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }\n+\n+    private @Nullable Dictionary<String, Object> getConfig() {\n+        var currentAdmin = admin;\n+        if (currentAdmin == null) {\n+            logger.warn(\"Configuration admin not ready\");\n+            return null;\n+        }\n+        try {\n+            Configuration configOnline = currentAdmin.getConfiguration(\"binding.androiddebugbridge\", null);", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544472236", "bodyText": "I think you could use the constant here, too.", "author": "fwolter", "createdAt": "2020-12-16T17:09:37Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3NDU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544474586", "bodyText": "This renders all into one long line in my markdown viewer. Maybe it's better to put these in a list below the table?", "author": "fwolter", "createdAt": "2020-12-16T17:12:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,62 @@\n+# Android Debug Bridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. \n+The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. \n+If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on \\<device name\\>\" or something like that.\n+\n+## Supported Things\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the number of IPs checked while discovering |\n+| discoveryIpRangeMax | int | Used to limit the number of IPs checked while discovering |\n+\n+## Thing Configuration\n+\n+| ThingTypeID   | description                  |\n+|----------|------------------------------|\n+| android | Android device |\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| ip | String | Device ip address |\n+| port | int | Device port listening to adb connections |\n+| refreshTime | int | Seconds between device status refreshes (default: 30) |\n+\n+## Channels\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| key-event  | String | Send key event to android device. Possible values: KEYCODE_0,KEYCODE_1,KEYCODE_11,KEYCODE_12,KEYCODE_2,KEYCODE_3,KEYCODE_3D_MODE,KEYCODE_4,KEYCODE_5,KEYCODE_6,KEYCODE_7,KEYCODE_8,KEYCODE_9,KEYCODE_A,KEYCODE_ALL_APPS,KEYCODE_ALT_LEFT,KEYCODE_ALT_RIGHT,KEYCODE_APOSTROPHE,KEYCODE_APP_SWITCH,KEYCODE_ASSIST,KEYCODE_AT,KEYCODE_AVR_INPUT,KEYCODE_AVR_POWER,KEYCODE_B,KEYCODE_BACK,KEYCODE_BACKSLASH,KEYCODE_BOOKMARK,KEYCODE_BREAK,KEYCODE_BRIGHTNESS_DOWN,KEYCODE_BRIGHTNESS_UP,KEYCODE_BUTTON_1,KEYCODE_BUTTON_10,KEYCODE_BUTTON_11,KEYCODE_BUTTON_12,KEYCODE_BUTTON_13,KEYCODE_BUTTON_14,KEYCODE_BUTTON_15,KEYCODE_BUTTON_16,KEYCODE_BUTTON_2,KEYCODE_BUTTON_3,KEYCODE_BUTTON_4,KEYCODE_BUTTON_5,KEYCODE_BUTTON_6,KEYCODE_BUTTON_7,KEYCODE_BUTTON_8,KEYCODE_BUTTON_9,KEYCODE_BUTTON_A,KEYCODE_BUTTON_B,KEYCODE_BUTTON_C,KEYCODE_BUTTON_L1,KEYCODE_BUTTON_L2,KEYCODE_BUTTON_MODE,KEYCODE_BUTTON_R1,KEYCODE_BUTTON_R2,KEYCODE_BUTTON_SELECT,KEYCODE_BUTTON_START,KEYCODE_BUTTON_THUMBL,KEYCODE_BUTTON_THUMBR,KEYCODE_BUTTON_X,KEYCODE_BUTTON_Y,KEYCODE_BUTTON_Z,KEYCODE_C,KEYCODE_CALCULATOR,KEYCODE_CALENDAR,KEYCODE_CALL,KEYCODE_CAMERA,KEYCODE_CAPS_LOCK,KEYCODE_CAPTIONS,KEYCODE_CHANNEL_DOWN,KEYCODE_CHANNEL_UP,KEYCODE_CLEAR,KEYCODE_COMMA,KEYCODE_CONTACTS,KEYCODE_COPY,KEYCODE_CTRL_LEFT,KEYCODE_CTRL_RIGHT,KEYCODE_CUT,KEYCODE_D,KEYCODE_DEL,KEYCODE_DPAD_CENTER,KEYCODE_DPAD_DOWN,KEYCODE_DPAD_DOWN_LEFT,KEYCODE_DPAD_DOWN_RIGHT,KEYCODE_DPAD_LEFT,KEYCODE_DPAD_RIGHT,KEYCODE_DPAD_UP,KEYCODE_DPAD_UP_LEFT,KEYCODE_DPAD_UP_RIGHT,KEYCODE_DVR,KEYCODE_E,KEYCODE_EISU,KEYCODE_ENDCALL,KEYCODE_ENTER,KEYCODE_ENVELOPE,KEYCODE_EQUALS,KEYCODE_ESCAPE,KEYCODE_EXPLORER,KEYCODE_F,KEYCODE_F1,KEYCODE_F10,KEYCODE_F11,KEYCODE_F12,KEYCODE_F2,KEYCODE_F3,KEYCODE_F4,KEYCODE_F5,KEYCODE_F6,KEYCODE_F7,KEYCODE_F8,KEYCODE_F9,KEYCODE_FOCUS,KEYCODE_FORWARD,KEYCODE_FORWARD_DEL,KEYCODE_FUNCTION,KEYCODE_G,KEYCODE_GRAVE,KEYCODE_GUIDE,KEYCODE_H,KEYCODE_HEADSETHOOK,KEYCODE_HELP,KEYCODE_HENKAN,KEYCODE_HOME,KEYCODE_I,KEYCODE_INFO,KEYCODE_INSERT,KEYCODE_J,KEYCODE_K,KEYCODE_KANA,KEYCODE_KATAKANA_HIRAGANA,KEYCODE_L,KEYCODE_LANGUAGE_SWITCH,KEYCODE_LAST_CHANNEL,KEYCODE_LEFT_BRACKET,KEYCODE_M,KEYCODE_MANNER_MODE,KEYCODE_MEDIA_AUDIO_TRACK,KEYCODE_MEDIA_CLOSE,KEYCODE_MEDIA_EJECT,KEYCODE_MEDIA_FAST_FORWARD,KEYCODE_MEDIA_NEXT,KEYCODE_MEDIA_PAUSE,KEYCODE_MEDIA_PLAY,KEYCODE_MEDIA_PLAY_PAUSE,KEYCODE_MEDIA_PREVIOUS,KEYCODE_MEDIA_RECORD,KEYCODE_MEDIA_REWIND,KEYCODE_MEDIA_SKIP_BACKWARD,KEYCODE_MEDIA_SKIP_FORWARD,KEYCODE_MEDIA_STEP_BACKWARD,KEYCODE_MEDIA_STEP_FORWARD,KEYCODE_MEDIA_STOP,KEYCODE_MEDIA_TOP_MENU,KEYCODE_MENU,KEYCODE_META_LEFT,KEYCODE_META_RIGHT,KEYCODE_MINUS,KEYCODE_MOVE_END,KEYCODE_MOVE_HOME,KEYCODE_MUHENKAN,KEYCODE_MUSIC,KEYCODE_MUTE,KEYCODE_N,KEYCODE_NAVIGATE_IN,KEYCODE_NAVIGATE_NEXT,KEYCODE_NAVIGATE_OUT,KEYCODE_NAVIGATE_PREVIOUS,KEYCODE_NOTIFICATION,KEYCODE_NUM,KEYCODE_NUMPAD_0,KEYCODE_NUMPAD_1,KEYCODE_NUMPAD_2,KEYCODE_NUMPAD_3,KEYCODE_NUMPAD_4,KEYCODE_NUMPAD_5,KEYCODE_NUMPAD_6,KEYCODE_NUMPAD_7,KEYCODE_NUMPAD_8,KEYCODE_NUMPAD_9,KEYCODE_NUMPAD_ADD,KEYCODE_NUMPAD_COMMA,KEYCODE_NUMPAD_DIVIDE,KEYCODE_NUMPAD_DOT,KEYCODE_NUMPAD_ENTER,KEYCODE_NUMPAD_EQUALS,KEYCODE_NUMPAD_LEFT_PAREN,KEYCODE_NUMPAD_MULTIPLY,KEYCODE_NUMPAD_RIGHT_PAREN,KEYCODE_NUMPAD_SUBTRACT,KEYCODE_NUM_LOCK,KEYCODE_O,KEYCODE_P,KEYCODE_PAGE_DOWN,KEYCODE_PAGE_UP,KEYCODE_PAIRING,KEYCODE_PASTE,KEYCODE_PERIOD,KEYCODE_PICTSYMBOLS,KEYCODE_PLUS,KEYCODE_POUND,KEYCODE_POWER,KEYCODE_PROFILE_SWITCH,KEYCODE_PROG_BLUE,KEYCODE_PROG_GREEN,KEYCODE_PROG_RED,KEYCODE_PROG_YELLOW,KEYCODE_Q,KEYCODE_R,KEYCODE_REFRESH,KEYCODE_RIGHT_BRACKET,KEYCODE_RO,KEYCODE_S,KEYCODE_SCROLL_LOCK,KEYCODE_SEARCH,KEYCODE_SEMICOLON,KEYCODE_SETTINGS,KEYCODE_SHIFT_LEFT,KEYCODE_SHIFT_RIGHT,KEYCODE_SLASH,KEYCODE_SLEEP,KEYCODE_SOFT_LEFT,KEYCODE_SOFT_RIGHT,KEYCODE_SOFT_SLEEP,KEYCODE_SPACE,KEYCODE_STAR,KEYCODE_STB_INPUT,KEYCODE_STB_POWER,KEYCODE_STEM_1,KEYCODE_STEM_2,KEYCODE_STEM_3,KEYCODE_STEM_PRIMARY,KEYCODE_SWITCH_CHARSET,KEYCODE_SYM,KEYCODE_SYSRQ,KEYCODE_SYSTEM_NAVIGATION_DOWN,KEYCODE_SYSTEM_NAVIGATION_LEFT,KEYCODE_SYSTEM_NAVIGATION_RIGHT,KEYCODE_SYSTEM_NAVIGATION_UP,KEYCODE_T,KEYCODE_TAB,KEYCODE_THUMBS_DOWN,KEYCODE_THUMBS_UP,KEYCODE_TV,KEYCODE_TV_ANTENNA_CABLE,KEYCODE_TV_AUDIO_DESCRIPTION,KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN,KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP,KEYCODE_TV_CONTENTS_MENU,KEYCODE_TV_DATA_SERVICE,KEYCODE_TV_INPUT,KEYCODE_TV_INPUT_COMPONENT_1,KEYCODE_TV_INPUT_COMPONENT_2,KEYCODE_TV_INPUT_COMPOSITE_1,KEYCODE_TV_INPUT_COMPOSITE_2,KEYCODE_TV_INPUT_HDMI_1,KEYCODE_TV_INPUT_HDMI_2,KEYCODE_TV_INPUT_HDMI_3,KEYCODE_TV_INPUT_HDMI_4,KEYCODE_TV_INPUT_VGA_1,KEYCODE_TV_MEDIA_CONTEXT_MENU,KEYCODE_TV_NETWORK,KEYCODE_TV_NUMBER_ENTRY,KEYCODE_TV_POWER,KEYCODE_TV_RADIO_SERVICE,KEYCODE_TV_SATELLITE,KEYCODE_TV_SATELLITE_BS,KEYCODE_TV_SATELLITE_CS,KEYCODE_TV_SATELLITE_SERVICE,KEYCODE_TV_TELETEXT,KEYCODE_TV_TERRESTRIAL_ANALOG,KEYCODE_TV_TERRESTRIAL_DIGITAL,KEYCODE_TV_TIMER_PROGRAMMING,KEYCODE_TV_ZOOM_MODE,KEYCODE_U,KEYCODE_UNKNOWN,KEYCODE_V,KEYCODE_VOICE_ASSIST,KEYCODE_VOLUME_DOWN,KEYCODE_VOLUME_MUTE,KEYCODE_VOLUME_UP,KEYCODE_W,KEYCODE_WAKEUP,KEYCODE_WINDOW,KEYCODE_X,KEYCODE_Y,KEYCODE_YEN,KEYCODE_Z,KEYCODE_ZENKAKU_HANKAKU,KEYCODE_ZOOM_IN,KEYCODE_ZOOM_OUT  |", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "commit"}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548345185", "bodyText": "In order for the dependency to be embedded into the binding jar you need to mark it with the compile scope.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  <version>1.2</version>\n          \n          \n            \n                </dependency>\n          \n          \n            \n                  <version>1.2</version>\n          \n          \n            \n                  <scope>compile</scope>\n          \n          \n            \n                </dependency>", "author": "cpmeister", "createdAt": "2020-12-24T01:44:58Z", "path": "bundles/org.openhab.binding.androiddebugbridge/pom.xml", "diffHunk": "@@ -0,0 +1,25 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.androiddebugbridge</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: Android Debug Bridge Binding</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.tananaev</groupId>\n+      <artifactId>adblib</artifactId>\n+      <version>1.2</version>\n+    </dependency>", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548345711", "bodyText": "Please add the licenses of your dependencies to this file.", "author": "cpmeister", "createdAt": "2020-12-24T01:47:08Z", "path": "bundles/org.openhab.binding.androiddebugbridge/NOTICE", "diffHunk": "@@ -0,0 +1,13 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab-addons", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548345794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private Socket socket;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private AdbConnection connection;\n          \n          \n            \n                private @Nullable Socket socket;\n          \n          \n            \n                private @Nullable AdbConnection connection;", "author": "cpmeister", "createdAt": "2020-12-24T01:47:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346264", "bodyText": "Please do not perform sleep operations in the startScan method. Those are called from a UI thread and as such you should make sure that startScan returns quickly.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:04Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346384", "bodyText": "super.dispose() should be called last.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:52Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346725", "bodyText": "InterruptExceptions should cause an immediate return from the current method. You should not perform additional operations once an interrupt has been received since you would be delaying openhab from shutting down.", "author": "cpmeister", "createdAt": "2020-12-24T01:52:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_CONTROL_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh play status: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh current package: {}\", e.getMessage());\n+        }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346848", "bodyText": "Should such errors also cause the thing status to go offline?", "author": "cpmeister", "createdAt": "2020-12-24T01:53:10Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc2ODc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548768758", "bodyText": "It will allow to detect that the device is offline sooner, so yes I'll change it", "author": "GiviMAD", "createdAt": "2020-12-25T00:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzNDE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551834158", "bodyText": "For my Fire TV Stick this warning is logged all the time. I think we should reduce logging level here. Otherwise it will be very annoying. Or I have to reduce logging to ERROR for this binding in my logging config.", "author": "cweitkamp", "createdAt": "2021-01-05T10:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NzI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347277", "bodyText": "Please don't use var for primitives, it just leads to possible confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            var retries = 0;\n          \n          \n            \n                                            int retries = 0;", "author": "cpmeister", "createdAt": "2020-12-24T01:55:16Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347747", "bodyText": "Since these exceptions are used outside of this class, please move these exceptions to their own files.", "author": "cpmeister", "createdAt": "2020-12-24T01:57:06Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+        connection = adbConnection;\n+        socket = sock;\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        synchronized (adb) {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        }\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));\n+    }\n+\n+    private static AdbCrypto loadKeyPair(String pubKeyFile, String privKeyFile)\n+            throws NoSuchAlgorithmException, IOException, InvalidKeySpecException {\n+        File pub = new File(pubKeyFile);\n+        File priv = new File(privKeyFile);\n+        AdbCrypto c = null;\n+        // load key pair\n+        if (pub.exists() && priv.exists()) {\n+            try {\n+                c = AdbCrypto.loadAdbKeyPair(getBase64Impl(), priv, pub);\n+            } catch (IOException ignored) {\n+                // Keys don't exits\n+            }\n+        }\n+        if (c == null) {\n+            // generate key pair\n+            c = AdbCrypto.generateAdbKeyPair(getBase64Impl());\n+            c.saveAdbKeyPair(priv, pub);\n+        }\n+        return c;\n+    }\n+\n+    public void disconnect() {\n+        var adb = connection;\n+        var sock = socket;\n+        if (adb != null) {\n+            try {\n+                adb.close();\n+            } catch (IOException ignored) {\n+            }\n+            connection = null;\n+        }\n+        if (sock != null) {\n+            try {\n+                sock.close();\n+            } catch (IOException ignored) {\n+            }\n+            socket = null;\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceException extends Exception {\n+        public AndroidDebugBridgeDeviceException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceReadException extends Exception {\n+        public AndroidDebugBridgeDeviceReadException(String message) {\n+            super(message);\n+        }\n+    }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347874", "bodyText": "Please use brackets for every if statement.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!discoveryRunning)\n          \n          \n            \n                                    break;\n          \n          \n            \n                                if (!discoveryRunning) {\n          \n          \n            \n                                    break;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2020-12-24T01:57:55Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72083e308970c6f374ee9c086b2444f8305536d7", "url": "https://github.com/openhab/openhab-addons/commit/72083e308970c6f374ee9c086b2444f8305536d7", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-25T00:32:16Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "forcePushed"}, {"oid": "bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "url": "https://github.com/openhab/openhab-addons/commit/bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "message": "Merge branch 'main' of https://github.com/openhab/openhab-addons into androiddebugbridge", "committedDate": "2021-01-04T10:34:16Z", "type": "commit"}, {"oid": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "url": "https://github.com/openhab/openhab-addons/commit/8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "message": "update copyright message and version number\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-04T10:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537695710", "bodyText": "Can we set the reason why the thing is offline? And I think we should do this only if the connect() fails e.g. in the catch block below.", "author": "cweitkamp", "createdAt": "2020-12-07T17:36:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5ODAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537698037", "bodyText": "Do not do this. The OHC framweork takes care of it.", "author": "cweitkamp", "createdAt": "2020-12-07T17:39:59Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704403", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:48:56Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704522", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:49:05Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537706468", "bodyText": "You can add the default port here. Maybe even set a min and max value.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"port\" type=\"integer\" required=\"true\">\n          \n          \n            \n            \t\t\t\t<label>ADB Port</label>\n          \n          \n            \n            \t\t\t\t<description>Device port listening to adb connections.</description>\n          \n          \n            \n            \t\t\t</parameter>\n          \n          \n            \n            \t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n          \n          \n            \n            \t\t\t\t<label>Port</label>\n          \n          \n            \n            \t\t\t\t<description>Device port listening to adb connections.</description>\n          \n          \n            \n            \t\t\t\t<default>5555</default>\n          \n          \n            \n            \t\t\t</parameter>", "author": "cweitkamp", "createdAt": "2020-12-07T17:51:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,375 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"androiddebugbridge\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"android\">\n+\t\t<label>Android Device Thing</label>\n+\t\t<description>Android Device Thing for Android Debug Bridge Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"key-event\" typeId=\"key-event-channel\"/>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\"/>\n+\t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>\n+\t\t\t<channel id=\"media-control\" typeId=\"media-control-channel\"/>\n+\t\t\t<channel id=\"start-package\" typeId=\"start-package-channel\"/>\n+\t\t\t<channel id=\"stop-package\" typeId=\"stop-package-channel\"/>\n+\t\t\t<channel id=\"current-package\" typeId=\"current-package-channel\"/>\n+\t\t</channels>\n+\t\t<representation-property>serial</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ip\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>Device ip address.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>ADB Port</label>\n+\t\t\t\t<description>Device port listening to adb connections.</description>\n+\t\t\t</parameter>", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxMzI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551813287", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n          \n          \n            \n            This binding was tested on the Fire TV Stick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you tested it with other android versions to reflect the compatibility of the binding.", "author": "cweitkamp", "createdAt": "2021-01-05T09:29:19Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,354 @@\n+# Android Debug Bridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. \n+The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. \n+If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on \\<device name\\>\" or something like that.\n+\n+## Supported Things\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. ", "originalCommit": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgxNDAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551814022", "bodyText": "Maybe add a hint about the default port for adb here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | port | int | Device port listening to adb connections |\n          \n          \n            \n            | port | int | Device port listening to adb connections (default: 5555) |", "author": "cweitkamp", "createdAt": "2021-01-05T09:30:35Z", "path": "bundles/org.openhab.binding.androiddebugbridge/README.md", "diffHunk": "@@ -0,0 +1,354 @@\n+# Android Debug Bridge Binding\n+\n+This binding allows to connect to android devices through the adb protocol. \n+The device needs to have **usb debugging enabled** and **allow debugging over tcp**, some devices allow to enable this in the device options but others need a previous connection through adb or even be rooted. \n+If you are not familiar with adb I suggest you to search \"How to enable adb over wifi on \\<device name\\>\" or something like that.\n+\n+## Supported Things\n+\n+This binding was tested on the FireStick (android version 7.1.2, volume control not working) and Nexus5x (android version 8.1.0, everything works nice), please update this document if you test with other android versions to reflect the compatibility of the biding. \n+\n+## Discovery\n+\n+As I can not find a way to identify android devices in the network the discovery will try to connect through adb to all the reachable ip in the defined range, you could customize the discovery process through the binding options. **Your device will prop a message requesting you to authorize the connection, you should check the option \"Always allow connections from this device\" (or something similar) and accept**.\n+\n+## Binding Configuration\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| discoveryPort | int | Port used on discovery to connect to the device through adb |\n+| discoveryReachableMs | int | Milliseconds to wait while discovering to determine if the ip is reachable |\n+| discoveryIpRangeMin | int | Used to limit the number of IPs checked while discovering |\n+| discoveryIpRangeMax | int | Used to limit the number of IPs checked while discovering |\n+\n+## Thing Configuration\n+\n+| ThingTypeID   | description                  |\n+|----------|------------------------------|\n+| android | Android device |\n+\n+| Config   |  Type  | description                  |\n+|----------|----------|------------------------------|\n+| ip | String | Device ip address |\n+| port | int | Device port listening to adb connections |", "originalCommit": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551830720", "bodyText": "I personally would check on \"media_sesssion\" first before \"audio\". At least for Android TV or Fire TV. Wdyt?\nIn general I am not very happy with the isPlaying() detection. E.g. My Fire TV Stick is playing all the time, event when I am on the home screen. Maybe we can add a configuration parameter to exclude specific, user-defined packages (e.g. \"com.amazon.tv.launcher\") for.\nIIRC I somewhere read about kind of \"state_detection_rules\" for Android TV:\nstate_detection_rules = {\n    'com.amazon.tv.launcher': ['idle'],\n    'com.netflix.ninja': ['media_session_state'],\n    'com.ellation.vrv': ['audio_state'],\n    'com.hulu.plus': [{'playing': {'wake_lock_size': 4}}, {'paused': {'wake_lock_size': 2}}],\n    'com.plexapp.android': [{'paused': {'media_session_state': 3,'wake_lock_size': 1}}, {'playing': {'media_session_state\u02d3': 3}}, 'idle']\n}\n\nVALID_STATES = ('idle', 'off', 'playing', 'paused', 'standby')", "author": "cweitkamp", "createdAt": "2021-01-05T10:01:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");", "originalCommit": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzkyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r552883924", "bodyText": "I wasn't taking in account the current app for the playing check, now it should work better.\nAlso I ended up implementing different ways of detect the player state, I have added the documentation. It's something similar to the solution implemented by HA. Basically you can configure a different detection mode by package name.", "author": "GiviMAD", "createdAt": "2021-01-06T18:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554426991", "bodyText": "Did you test them? What is your personal feeling?", "author": "cweitkamp", "createdAt": "2021-01-09T13:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}], "type": "inlineReview"}, {"oid": "df6d0c31577b6dab608946b51b061370b9e00731", "url": "https://github.com/openhab/openhab-addons/commit/df6d0c31577b6dab608946b51b061370b9e00731", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:05:18Z", "type": "forcePushed"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "commit"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "forcePushed"}, {"oid": "785e2da4b4858005d59048334aeb38ea00624be2", "url": "https://github.com/openhab/openhab-addons/commit/785e2da4b4858005d59048334aeb38ea00624be2", "message": "fix device reconnection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-09T17:50:06Z", "type": "commit"}, {"oid": "c6776489b88dfb2b3d441bf122e77366efcc2ad7", "url": "https://github.com/openhab/openhab-addons/commit/c6776489b88dfb2b3d441bf122e77366efcc2ad7", "message": "fix dispose errors\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T00:52:22Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1ODE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554458154", "bodyText": "We should prefer system default channel types instead of defining popular, reusable types on our own.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>\n          \n          \n            \n            \t\t\t<channel id=\"media-volume\" typeId=\"system.volume\"/>", "author": "cweitkamp", "createdAt": "2021-01-09T18:36:12Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,403 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"androiddebugbridge\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"android\">\n+\t\t<label>Android Device Thing</label>\n+\t\t<description>Android Device Thing for Android Debug Bridge Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"key-event\" typeId=\"key-event-channel\"/>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\"/>\n+\t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>", "originalCommit": "785e2da4b4858005d59048334aeb38ea00624be2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1ODI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554458277", "bodyText": "Same here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<channel id=\"media-control\" typeId=\"media-control-channel\"/>\n          \n          \n            \n            \t\t\t<channel id=\"media-control\" typeId=\"system.media-control\"/>", "author": "cweitkamp", "createdAt": "2021-01-09T18:37:08Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,403 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"androiddebugbridge\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"android\">\n+\t\t<label>Android Device Thing</label>\n+\t\t<description>Android Device Thing for Android Debug Bridge Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"key-event\" typeId=\"key-event-channel\"/>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\"/>\n+\t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>\n+\t\t\t<channel id=\"media-control\" typeId=\"media-control-channel\"/>", "originalCommit": "785e2da4b4858005d59048334aeb38ea00624be2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1ODYxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554458618", "bodyText": "This channel does not really make sense to me. I guess I understand it's purpose but isn't a simple \"stop\" (Switch) channel easier to understand? It can pick the current package name and stop it.", "author": "cweitkamp", "createdAt": "2021-01-09T18:41:03Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,403 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"androiddebugbridge\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"android\">\n+\t\t<label>Android Device Thing</label>\n+\t\t<description>Android Device Thing for Android Debug Bridge Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"key-event\" typeId=\"key-event-channel\"/>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\"/>\n+\t\t\t<channel id=\"media-volume\" typeId=\"media-volume-channel\"/>\n+\t\t\t<channel id=\"media-control\" typeId=\"media-control-channel\"/>\n+\t\t\t<channel id=\"start-package\" typeId=\"start-package-channel\"/>\n+\t\t\t<channel id=\"stop-package\" typeId=\"stop-package-channel\"/>", "originalCommit": "785e2da4b4858005d59048334aeb38ea00624be2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIwOTU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r559209541", "bodyText": "That channel allows to close an application by package name either if it is running in the background or not, I would like to keep it like this. I'm using it in a rule right now to close the previous application when I send a new one, there I can add extra logic to avoid close the launcher or certain applications.\nI will add another channel stop-current-package that works as you mention because you are right it could be more useful and simple in many situations.", "author": "GiviMAD", "createdAt": "2021-01-17T17:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1ODYxOA=="}], "type": "inlineReview"}, {"oid": "38017de65a87a9a8f582af1ce951add2acc4e111", "url": "https://github.com/openhab/openhab-addons/commit/38017de65a87a9a8f582af1ce951add2acc4e111", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-18T23:28:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA4MTY0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r560081646", "bodyText": "You can use a switch-statement instead of the if-else combination.\nswitch(channelId) {\n    case STOP_CURRENT_PACKAGE_CHANNEL:\n        ...\n        break;\n...\n}", "author": "cweitkamp", "createdAt": "2021-01-19T10:43:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -110,6 +110,10 @@ private void handleCommandInternal(ChannelUID channelUID, Command command)\n                     new StringType(command.toFullString()));\n         } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n             adbConnection.stopPackage(command.toFullString());\n+        } else if (STOP_CURRENT_PACKAGE_CHANNEL.equals(channelId)) {", "originalCommit": "38017de65a87a9a8f582af1ce951add2acc4e111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "770e2c4871110b709efd035278fd0922095179cc", "url": "https://github.com/openhab/openhab-addons/commit/770e2c4871110b709efd035278fd0922095179cc", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T13:49:10Z", "type": "commit"}, {"oid": "9674b9ab2953cb250954a6102baf08763faa6b3f", "url": "https://github.com/openhab/openhab-addons/commit/9674b9ab2953cb250954a6102baf08763faa6b3f", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T14:02:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4NzIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561187219", "bodyText": "You should specify the Charset you are using here.", "author": "cpmeister", "createdAt": "2021-01-20T18:35:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        });\n+        this.commandFuture = commandFuture;\n+        return commandFuture.get(timeoutSec, TimeUnit.SECONDS);\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4ODYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561188605", "bodyText": "The use of var here makes it hard to understand what the type at a glance.", "author": "cpmeister", "createdAt": "2021-01-20T18:37:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4OTExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561189111", "bodyText": "All if statements should have brackets.", "author": "cpmeister", "createdAt": "2021-01-20T18:38:34Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5MzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561193929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!(inetAddress instanceof Inet4Address))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (!(inetAddress instanceof Inet4Address) || inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP)) {\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2021-01-20T18:46:07Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561195669", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean discoveryRunning = false;\n          \n          \n            \n                private ConfigurationAdmin admin;\n          \n          \n            \n                private final ConfigurationAdmin admin;\n          \n          \n            \n                private boolean discoveryRunning = false;", "author": "cpmeister", "createdAt": "2021-01-20T18:48:54Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NzQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561197402", "bodyText": "Since you are trying against all the network interfaces, it is expected for most of them to fail. So I think logging warning here would unnecessarily fill the logs.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n          \n          \n            \n                                        logger.debug(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "author": "cpmeister", "createdAt": "2021-01-20T18:51:39Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (int i = configuration.discoveryIpRangeMin; i <= configuration.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n+                            break;\n+                        }\n+                        ipParts[3] = Integer.toString(i);\n+                        String currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(configuration.discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                int retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, configuration.discoveryPort);\n+                                    } catch (AndroidDebugBridgeDeviceReadException | TimeoutException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDeviceException | AndroidDebugBridgeDeviceReadException\n+                                | TimeoutException | ExecutionException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5OTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561199839", "bodyText": "You should check the cause of the ExecutionException since if it was caused by a cancellation then that would mean that the handler is getting shut down, thus you shouldn't be changing statuses or disconnecting the connection since the dispose would already be handling that.", "author": "cpmeister", "createdAt": "2021-01-20T18:55:36Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200982", "bodyText": "You should include the exception message in the log.", "author": "cpmeister", "createdAt": "2021-01-20T18:57:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"{} - read error: {}\", currentConfig.ip, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.warn(\"{} - timeout error\", currentConfig.ip);\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (!isLinked(channelUID)){\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case KEY_EVENT_CHANNEL:\n+                adbConnection.sendKeyEvent(command.toFullString());\n+                break;\n+            case TEXT_CHANNEL:\n+                adbConnection.sendText(command.toFullString());\n+                break;\n+            case MEDIA_VOLUME_CHANNEL:\n+                handleMediaVolume(channelUID, command);\n+                break;\n+            case MEDIA_CONTROL_CHANNEL:\n+                handleMediaControlCommand(channelUID, command);\n+                break;\n+            case START_PACKAGE_CHANNEL:\n+                adbConnection.startPackage(command.toFullString());\n+                updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                        new StringType(command.toFullString()));\n+                break;\n+            case STOP_PACKAGE_CHANNEL:\n+                adbConnection.stopPackage(command.toFullString());\n+                break;\n+            case STOP_CURRENT_PACKAGE_CHANNEL:\n+                if (OnOffType.from(command.toFullString()).equals(OnOffType.OFF)) {\n+                    adbConnection.stopPackage(adbConnection.getCurrentPackage());\n+                }\n+                break;\n+            case CURRENT_PACKAGE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    var packageName = adbConnection.getCurrentPackage();\n+                    updateState(channelUID, new StringType(packageName));\n+                }\n+                break;\n+            case WAKE_LOCK_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    int lock = adbConnection.getPowerWakeLock();\n+                    updateState(channelUID, new DecimalType(lock));\n+                }\n+                break;\n+            case SCREEN_STATE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    boolean screenState = adbConnection.isScreenOn();\n+                    updateState(channelUID, OnOffType.from(screenState));\n+                }\n+                break;\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceReadException, AndroidDebugBridgeDeviceException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            var volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0){\n+                return; // We can not transform percentage\n+            }\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            boolean playing;\n+            String currentPackage = adbConnection.getCurrentPackage();\n+            var currentPackageConfig = packageConfigs != null ? Arrays.stream(packageConfigs)\n+                    .filter(pc -> pc.name.equals(currentPackage)).findFirst().orElse(null) : null;\n+            if (currentPackageConfig != null) {\n+                logger.debug(\"media stream config found for {}, mode: {}\", currentPackage, currentPackageConfig.mode);\n+                switch (currentPackageConfig.mode) {\n+                    case \"idle\":\n+                        playing = false;\n+                        break;\n+                    case \"wake_lock\":\n+                        int wakeLockState = adbConnection.getPowerWakeLock();\n+                        playing = currentPackageConfig.wakeLockPlayStates.contains(wakeLockState);\n+                        break;\n+                    case \"media_state\":\n+                        playing = adbConnection.isPlayingMedia(currentPackage);\n+                        break;\n+                    case \"audio\":\n+                        playing = adbConnection.isPlayingAudio();\n+                        break;\n+                    default:\n+                        logger.warn(\"media state config: package {} unsupported mode\", currentPackage);\n+                        playing = false;\n+                }\n+            } else {\n+                logger.debug(\"media stream config not found for {}\", currentPackage);\n+                playing = adbConnection.isPlayingMedia(currentPackage);\n+            }\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        var mediaStateJSONConfig = currentConfig.mediaStateJSONConfig;\n+        if (mediaStateJSONConfig != null && !mediaStateJSONConfig.isEmpty()) {\n+            loadMediaStateConfig(mediaStateJSONConfig);\n+        }\n+        adbConnection.configure(currentConfig.ip, currentConfig.port, currentConfig.timeout);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    private void loadMediaStateConfig(String mediaStateJSONConfig) {\n+        try {\n+            this.packageConfigs = gson.fromJson(mediaStateJSONConfig,\n+                    AndroidDebugBridgeMediaStatePackageConfig[].class);\n+        } catch (JsonSyntaxException e) {\n+            logger.warn(\"unable to parse media state config\");", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMTcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561201720", "bodyText": "You can avoid making your configuration nullable by setting it to the default config initially.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable AndroidDebugBridgeConfiguration config;\n          \n          \n            \n                private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();", "author": "cpmeister", "createdAt": "2021-01-20T18:58:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwNDQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561204475", "bodyText": "Instead of defining this here, define it in the AndroidDebugBridgeHandler as a static final constant.", "author": "cpmeister", "createdAt": "2021-01-20T19:03:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = BINDING_CONFIGURATION_PID, service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    Gson gson = new Gson();", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "url": "https://github.com/openhab/openhab-addons/commit/d89cd4b00101df472b19eaaee4614ceb60ba5750", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-20T21:11:31Z", "type": "commit"}]}