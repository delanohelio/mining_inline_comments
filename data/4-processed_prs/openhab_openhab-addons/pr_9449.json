{"pr_number": 9449, "pr_title": "[resol] Add Resol Controller Binding - Initial Contribution", "pr_createdAt": "2020-12-21T00:00:58Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9449", "timeline": [{"oid": "14e88d0c0fd543e7e7ad445c921d3499201e1be8", "url": "https://github.com/openhab/openhab-addons/commit/14e88d0c0fd543e7e7ad445c921d3499201e1be8", "message": "swap to OH3, improve docs and some minor fixes\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-12-21T00:09:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTI1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551015250", "bodyText": "This can be removed, then.", "author": "fwolter", "createdAt": "2021-01-03T14:47:28Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551015441", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-01-03T14:49:20Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551015485", "bodyText": "or?", "author": "fwolter", "createdAt": "2021-01-03T14:49:49Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+\n+## Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen after autodiscovery or ", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwNDI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551504255", "bodyText": "good question :-) I have no clue how we should check it. Should we log the names in trace mode? - currently in trace the localized names - which are used as channel labels are printed. Maybe it would be better to change it output the channel name? Or should we just assume that any user is capable of looking the channels up in the web UI? - even those who still configure using text files?\nI am tending to change the sentence to\nThe channels supported for your device can be seen in the UI after data is received from the physical device.", "author": "ramack", "createdAt": "2021-01-04T18:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUzNDY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551534640", "bodyText": "I think logging in trace is ok for users who doesn't use an UI.", "author": "fwolter", "createdAt": "2021-01-04T19:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551015729", "bodyText": "Channel names should start with lower case.", "author": "fwolter", "createdAt": "2021-01-03T14:52:41Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+\n+## Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen after autodiscovery or \n+\n+| channel                       | type                     | description                                        |\n+|-------------------------------|--------------------------|----------------------------------------------------|\n+| Pump_speed_relay_x            | Number:Dimensionless     | Percentage of the output state of relay 'x'        |", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwNTE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551505145", "bodyText": "ok. I use the name as defined by Resol and output by the vbus-java library and replace spaces and some other characters which are not allowed as channel names. Should I make them all lower case or just the first char?", "author": "ramack", "createdAt": "2021-01-04T18:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUzNTI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551535297", "bodyText": "If you use underscores to separate the words, all letters should be lower case.", "author": "fwolter", "createdAt": "2021-01-04T19:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MzI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551583279", "bodyText": "the underscores are replacements of spaces from the name in the library. But you're fully right it doesn't look good and I will just make all channel names lower case.", "author": "ramack", "createdAt": "2021-01-04T21:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNjAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551016022", "bodyText": "Did you consider implementing this as state options? https://www.openhab.org/docs/developer/bindings/thing-xml.html#state-description Then, only one Channel is necessary.", "author": "fwolter", "createdAt": "2021-01-03T14:55:18Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+\n+## Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen after autodiscovery or \n+\n+| channel                       | type                     | description                                        |\n+|-------------------------------|--------------------------|----------------------------------------------------|\n+| Pump_speed_relay_x            | Number:Dimensionless     | Percentage of the output state of relay 'x'        |\n+| Temperature_sensor_x          | Number:Temperature       | Temperature sensor 'x' of the controller           |\n+| Temperature_Module_y_Sensor_x | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |\n+| Pressure_sensor_x             | Number:Pressure          | Pressure sensor 'x'                                |\n+| Humidity_sensor_x             | Number:Dimensionless     | Humidity sensor 'x'                                |\n+| Irradiation_sensor_x          | Number:Intensity         | Sunlight intensity sensor                          |\n+| Output_M                      | Number:Dimensionless     | PWM/0-10V level value of the output 'M'            |\n+| System_date                   | DateTime                 | Date and time of the controller clock              |\n+| Error_mask                    | Number                   | Bitmask for the different errors                   |\n+| Error_Sensor_line_broken-str  | String                   | Sensor line broken status (details for Error_mask) |\n+| Flow_rate_sensor_x            | Number:VolumetricFlowRate| of sensor 'x'                                      |\n+| Flow_set_temperature          | Number:Temperature       | Heating circuit set temperature                    |\n+| Operating_state               | Number                   | Heating circuit operationg state                   |\n+| Operating_state-str           | String                   | Heating circuit operationg state, as text          |", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTA2MTgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551061837", "bodyText": "No I didn't. I searched for such a concept (looking for enum) but didn't find the state options. - This seems to do the trick, while it's not obvious how localization should be handled. - The string channel comes with the localized text (in en, de, anf fr) already from the library. - And it could be quite some effort to change but probably worth the effort. I'll investigate - sadly tomorrow I'll be back in work :-)", "author": "ramack", "createdAt": "2021-01-03T22:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNjAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNjM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551016391", "bodyText": "Then, the correct unit is chosen automatically based on the system settings.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Number:Temperature SolarTemperature \"Solar Collector Temperature [%.1f \u00b0C]\" <temperature> { channel=\"resol:device:VBUS:DeltaSol_MX-Controller:Temperature_sensor_1\" }\n          \n          \n            \n            Number:Temperature SolarTemperature \"Solar Collector Temperature [%.1f %unit%]\" <temperature> { channel=\"resol:device:VBUS:DeltaSol_MX-Controller:Temperature_sensor_1\" }", "author": "fwolter", "createdAt": "2021-01-03T14:58:08Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+\n+## Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen after autodiscovery or \n+\n+| channel                       | type                     | description                                        |\n+|-------------------------------|--------------------------|----------------------------------------------------|\n+| Pump_speed_relay_x            | Number:Dimensionless     | Percentage of the output state of relay 'x'        |\n+| Temperature_sensor_x          | Number:Temperature       | Temperature sensor 'x' of the controller           |\n+| Temperature_Module_y_Sensor_x | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |\n+| Pressure_sensor_x             | Number:Pressure          | Pressure sensor 'x'                                |\n+| Humidity_sensor_x             | Number:Dimensionless     | Humidity sensor 'x'                                |\n+| Irradiation_sensor_x          | Number:Intensity         | Sunlight intensity sensor                          |\n+| Output_M                      | Number:Dimensionless     | PWM/0-10V level value of the output 'M'            |\n+| System_date                   | DateTime                 | Date and time of the controller clock              |\n+| Error_mask                    | Number                   | Bitmask for the different errors                   |\n+| Error_Sensor_line_broken-str  | String                   | Sensor line broken status (details for Error_mask) |\n+| Flow_rate_sensor_x            | Number:VolumetricFlowRate| of sensor 'x'                                      |\n+| Flow_set_temperature          | Number:Temperature       | Heating circuit set temperature                    |\n+| Operating_state               | Number                   | Heating circuit operationg state                   |\n+| Operating_state-str           | String                   | Heating circuit operationg state, as text          |\n+| Heat_quantity                 | Number:Energy            | Total heat quantity (of a HQM)                     |\n+| Heat_quantity_today           | Number:Energy            | Todays heat quantity (of a HQM)                    |\n+| Heat_quantity_week            | Number:Energy            | This weeks heat quantity (of a HQM)                |\n+| Heat_quantity_month           | Number:Energy            | This months heat quantity (of a HQM)               |\n+| Volume_in_total               | Number:Volume            | Total volume (of a HQM)                            |\n+| Volume_today                  | Number:Volume            | Todays volume (of a HQM)                           |\n+| Volume_week                   | Number:Volume            | This weeks volume (of a HQM)                       |\n+| Volume_month                  | Number:Volume            | This months volume (of a HQM)                      |\n+| Power                         | Number:Power             | Current power (of a HQM)                           |\n+\n+\n+Channels are dynamically created dependent on the devices connected to the VBus.\n+So far only reading is supported.\n+The classical channels are for temperature sensors and the like, but also relay outputs with the output level (0-100%) are visible as numerical values with the corresponding unit.\n+Some data points have an enumeration type and are available in two versions, a numerical and a textual channel.\n+Examples are Error mask, which is a number for the complete mask and each bit is available as single string channel, or the operation state of a heating circuit.\n+In those cases the numerical version is hidden and have to be view explicitly if needed, while the string representation has an \"-str\" suffix in the name.\n+\n+String values are localized as far as possible, but only French, German and English are supported by the underlaying library which is based on the vbus-specification file from Resol.\n+\n+## Full Example\n+\n+For a DeltaSol MX system controller with on extension module EM you can use this example:\n+\n+resol.things\n+\n+```\n+Bridge resol:vbuslan:VBUS \"VBUSLAN\" [ ipAddress=\"192.168.0.2\", password=\"vbus\", port=7053] {\n+      Thing device DeltaSol_MX-Controller \"DeltaSol MX [Controller]\" []\n+      Thing device DeltaSol_MX-Heating_circuit-1 \"DeltaSol MX [Heating Circuit]\" []\n+      Thing device DeltaSol_MX-HQM-1 \"DeltaSol MX [WMZ 1] Solar\" []\n+      Thing device DeltaSol_MX-Modules \"DeltaSol MX [Modules]\" []\n+}\n+```\n+\n+resol.items\n+```\n+/*************************************************/\n+/* Solar system                                  */\n+/*************************************************/\n+Number:Temperature SolarTemperature \"Solar Collector Temperature [%.1f \u00b0C]\" <temperature> { channel=\"resol:device:VBUS:DeltaSol_MX-Controller:Temperature_sensor_1\" }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNzk5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551017992", "bodyText": "To make the binding compile, you need to rebase your branch and set the version to the current snapshot: 3.1.0-SNAPSHOT.\nHere are the commands for rebasing your branch:\nIf not already done, add the upstream openHAB addon repo as a remote to your local repo and fetch it:\ngit remote add upstream https://github.com/openhab/openhab-addons.git\ngit fetch upstream\n\nThen, you can rebase your PR's branch onto main:\ngit rebase upstream/main\n\nFinally force-push the rebased branch to this PR's branch:\ngit push origin [your branch name of this PR] --force-with-lease", "author": "fwolter", "createdAt": "2021-01-03T15:13:09Z", "path": "bundles/org.openhab.binding.resol/pom.xml", "diffHunk": "@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxODUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551018503", "bodyText": "Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> pollingJob;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> pollingJob;", "author": "fwolter", "createdAt": "2021-01-03T15:17:22Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxOTM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551019344", "bodyText": "Syntactical sugar. Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> availableDevices = new HashSet<String>();\n          \n          \n            \n                private Set<String> availableDevices = new HashSet<>();", "author": "fwolter", "createdAt": "2021-01-03T15:25:26Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020391", "bodyText": "Please put all fields to the top of the class.", "author": "fwolter", "createdAt": "2021-01-03T15:34:44Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020544", "bodyText": "You could make this a method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Runnable pollingRunnable = new Runnable() {\n          \n          \n            \n                    @Override\n          \n          \n            \n                    public void run() {\n          \n          \n            \n            private void pollingRunnable() {", "author": "fwolter", "createdAt": "2021-01-03T15:35:55Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDYzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020630", "bodyText": "Are you logging the stack trace by intention?", "author": "fwolter", "createdAt": "2021-01-03T15:36:30Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU0MDMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551540328", "bodyText": "no, not really. e.getMessage() should be sufficient.", "author": "ramack", "createdAt": "2021-01-04T20:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDc3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020775", "bodyText": "The context of this message might not be clear if there are intermittent log messages from other loggers in the log. If the unconnectedReason is logged via updateStatus(), this message could be removed at all.", "author": "fwolter", "createdAt": "2021-01-03T15:37:54Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021012", "bodyText": "This could be removed, according to the principle if there's no error message the operation suceeded.", "author": "fwolter", "createdAt": "2021-01-03T15:39:43Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021172", "bodyText": "Is there a reason why you don't add the listener immediately after the connection is established? For what are you waiting here?", "author": "fwolter", "createdAt": "2021-01-03T15:41:34Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551551391", "bodyText": "you are right. I guess this was left over from an early phase where the listener did not correctly update the connected status. Will remove it.", "author": "ramack", "createdAt": "2021-01-04T20:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTUzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021537", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2021-01-03T15:44:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021882", "bodyText": "scheduler tasks should not use sleep, because the threadpool is shared among all bindings and that could potentially exhaust the pool, affecting other bindings. You could schedule another task with a delay of 3sec.", "author": "fwolter", "createdAt": "2021-01-03T15:47:23Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjEyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022127", "bodyText": "If you apply above change.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n          \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2021-01-03T15:49:44Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022229", "bodyText": "You could move this into a separate class, as this class is already quite long.", "author": "fwolter", "createdAt": "2021-01-03T15:50:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                for (int x : emThingHandlerMap.keySet()) {\n+                    ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                    if (emu != null) {\n+                        emu.stop();\n+                    }\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551561326", "bodyText": "This will get quite a big refactoring. Do you think it is worth it?", "author": "ramack", "createdAt": "2021-01-04T20:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551575814", "bodyText": "It's only three clicks in Eclipse. It was only a suggestion. I won't insist on changing it.", "author": "fwolter", "createdAt": "2021-01-04T21:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551582516", "bodyText": "I tried that, but it failed. And the inner class accesses quite some outer class fields - maybe that is also not the nicest design but I would not want to change that without a strong need \ud83d\ude00", "author": "ramack", "createdAt": "2021-01-04T21:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022558", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-01-03T15:53:56Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                for (int x : emThingHandlerMap.keySet()) {\n+                    ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                    if (emu != null) {\n+                        emu.stop();\n+                    }\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    isConnected = ConnectionState.CONNECTED.equals(connState);\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());\n+\n+                    if (isConnected) {\n+                        unconnectedReason = \"\";\n+                    } else {\n+                        unconnectedReason = \"TCP connection failed: \" + connState.toString();\n+                    }\n+                }\n+                updateStatus();\n+            }\n+        }\n+\n+        @Override\n+        public void packetReceived(@Nullable Connection connection, @Nullable Packet packet) {\n+            if (connection == null || packet == null) {\n+                return;\n+            }\n+            String thingType = spec.getSourceDeviceSpec(packet).getName(); // use En here\n+\n+            thingType = thingType.replace(\" [\", \"-\");\n+            thingType = thingType.replace(\"]\", \"\");\n+            thingType = thingType.replace(\" #\", \"-\");\n+            thingType = thingType.replace(\" \", \"_\");\n+            thingType = thingType.replace(\"/\", \"_\");\n+            thingType = thingType.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            /*\n+             * It would be nice for the combination of MX and EM devices to filter only those with a peerAddress of\n+             * 0x10, because the MX redelivers the data from the EM to the DFA.\n+             * But the MX is the exception in this case and many other controllers do not redeliver data, so we keep it.\n+             */\n+            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",\n+                    spec.getSourceDeviceSpec(packet).getName(lang),\n+                    Integer.toHexString(spec.getSourceDeviceSpec(packet).getSelfAddress()),\n+                    Integer.toHexString(spec.getSourceDeviceSpec(packet).getPeerAddress()), thingType);\n+\n+            if (emThingHandlerMap.containsKey(spec.getSourceDeviceSpec(packet).getPeerAddress())) {\n+                ResolEmuEMThingHandler emThingHandler = emThingHandlerMap\n+                        .get(spec.getSourceDeviceSpec(packet).getPeerAddress());\n+                if (emThingHandler != null) {\n+                    emThingHandler.handle(packet);\n+                }\n+            } else {\n+                // a generic packet was received, so let's handle it here\n+                if (!availableDevices.contains(thingType)) {\n+                    // register the seen device\n+                    createThing(ResolBindingConstants.THING_ID_DEVICE, thingType,\n+                            spec.getSourceDeviceSpec(packet).getName(lang));\n+                    availableDevices.add(thingType);\n+                }\n+\n+                PacketFieldValue[] pfvs = spec.getPacketFieldValuesForHeaders(new Packet[] { packet });\n+                for (PacketFieldValue pfv : pfvs) {\n+                    logger.trace(\"Id: {}, Name: {}, Raw: {}, Text: {}\", pfv.getPacketFieldId(), pfv.getName(lang),\n+                            pfv.getRawValueDouble(), pfv.formatTextValue(null, Locale.getDefault()));\n+                    ResolThingHandler thingHandler = thingHandlerMap.get(thingType);\n+                    if (thingHandler != null) {\n+                        String channelId = pfv.getName(); // use English here\n+                        channelId = channelId.replace(\" [\", \"-\");\n+                        channelId = channelId.replace(\"]\", \"\");\n+                        channelId = channelId.replace(\"(\", \"-\");\n+                        channelId = channelId.replace(\")\", \"\");\n+                        channelId = channelId.replace(\" #\", \"-\");\n+                        channelId = channelId.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+                        ChannelTypeUID channelTypeUID;\n+\n+                        if (pfv.getPacketFieldSpec().getUnit().getUnitId() >= 0) {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                                    pfv.getPacketFieldSpec().getUnit().getUnitCodeText());\n+                        } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.Number) {\n+                            if (pfv.getEnumVariant() != null) {\n+                                // Do not auto-link the numeric value, if there is an enum for it\n+                                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"NoneHidden\");\n+                            } else {\n+                                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+                            }\n+\n+                        } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.DateTime) {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"DateTime\");\n+                        } else {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+                        }\n+\n+                        String acceptedItemType = \"String\";\n+\n+                        Thing thing = thingHandler.getThing();\n+                        switch (pfv.getPacketFieldSpec().getType()) {\n+                            case DateTime:\n+                                acceptedItemType = \"DateTime\";\n+                                break;\n+                            case WeekTime:\n+                            case Number:\n+                                acceptedItemType = ResolChannelTypeProvider\n+                                        .itemTypeForUnit(pfv.getPacketFieldSpec().getUnit());\n+                                break;\n+                            case Time:\n+                            default:\n+                                acceptedItemType = \"String\";\n+                                break;\n+                        }\n+                        Channel a = thing.getChannel(channelId);\n+\n+                        if (a == null && pfv.getRawValueDouble() != null) {\n+                            ThingBuilder thingBuilder = thingHandler.editThing();\n+\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            Channel channel = ChannelBuilder.create(channelUID, acceptedItemType)\n+                                    .withType(channelTypeUID).withLabel(pfv.getName(lang)).build();\n+\n+                            thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+\n+                            thingHandler.updateThing(thingBuilder.build());\n+                        }\n+\n+                        switch (pfv.getPacketFieldSpec().getType()) {\n+                            case Number:\n+                                Double dd = pfv.getRawValueDouble();\n+                                if (dd != null) {\n+                                    if (isSpecialValue(dd)) {\n+                                        /* some error occurred in the measurement - ignore the value */\n+                                    } else {\n+                                        thingHandler.setChannelValue(channelId, dd.doubleValue());\n+                                    }\n+                                } else {\n+                                    /*\n+                                     * field not available in this packet, e. g. old firmware version\n+                                     * not (yet) transmitting it\n+                                     */\n+                                }\n+                                break;\n+                            case DateTime:\n+                                thingHandler.setChannelValue(channelId, pfv.getRawValueDate());\n+                                break;\n+                            case WeekTime:\n+                            case Time:\n+                            default:\n+                                thingHandler.setChannelValue(channelId,\n+                                        pfv.formatTextValue(pfv.getPacketFieldSpec().getUnit(), locale));\n+                        }\n+\n+                        if (pfv.getEnumVariant() != null) {\n+                            // if we have an enum, we additionally add that as channel\n+                            String enumChannelId = channelId + \"-str\";\n+                            if (thing.getChannel(enumChannelId) == null) {\n+                                ChannelTypeUID enumChannelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                                        \"None\");\n+                                ThingBuilder thingBuilder = thingHandler.editThing();\n+\n+                                ChannelUID enumChannelUID = new ChannelUID(thing.getUID(), enumChannelId);\n+                                Channel channel = ChannelBuilder.create(enumChannelUID, \"String\")\n+                                        .withType(enumChannelTypeUID).withLabel(pfv.getName(lang)).build();\n+\n+                                thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+\n+                                thingHandler.updateThing(thingBuilder.build());\n+                            }\n+\n+                            thingHandler.setChannelValue(enumChannelId, pfv.getEnumVariant().getText(lang));\n+                        }\n+                    } else {\n+                        logger.info(\"ThingHandler for {} not registered.\", thingType);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022686", "bodyText": "See above. Method.", "author": "fwolter", "createdAt": "2021-01-03T15:55:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends BaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay\";\n+    public static final String CHANNEL_TEMP = \"temperature\";\n+    public static final String CHANNEL_RESIST = \"resitor\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+\n+    private int deviceId = 1;\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    @Nullable\n+    private EmDeviceEmulator device;\n+\n+    // Background Runables\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    Pattern relayPattern = Pattern.compile(\"Pump speed relay (\\\\d*).1\");\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    private Runnable updateRunnable = new Runnable() {\n+\n+        private long lastTime = System.currentTimeMillis();\n+\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022808", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2021-01-03T15:56:04Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends BaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay\";\n+    public static final String CHANNEL_TEMP = \"temperature\";\n+    public static final String CHANNEL_RESIST = \"resitor\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+\n+    private int deviceId = 1;\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    @Nullable\n+    private EmDeviceEmulator device;\n+\n+    // Background Runables\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    Pattern relayPattern = Pattern.compile(\"Pump speed relay (\\\\d*).1\");\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    private Runnable updateRunnable = new Runnable() {\n+\n+        private long lastTime = System.currentTimeMillis();\n+\n+        @Override\n+        public void run() {\n+            EmDeviceEmulator d = device;\n+            if (d != null) {\n+                long now = System.currentTimeMillis();\n+                int diff = (int) (now - lastTime);\n+                lastTime = now;\n+\n+                d.update(diff);\n+            }\n+        }\n+    };\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    private void unregisterResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.unregisterThingListener(this);\n+        } else {\n+            logger.debug(\"Can't unregister {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2Mjg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551562897", "bodyText": "OMG - what did I do here? For sure this shall vanish.", "author": "ramack", "createdAt": "2021-01-04T20:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwODgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551608818", "bodyText": "ah, now as I removed it the compiler reminds me why it is there... actually it changes the access from protected to public to allow the call from ResolBridgeHandler.registerResolThingListener()", "author": "ramack", "createdAt": "2021-01-04T22:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023125", "bodyText": "What's the purpose of these?", "author": "fwolter", "createdAt": "2021-01-03T15:58:42Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    public ResolThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public ThingBuilder editThing() {\n+        return super.editThing();\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }\n+\n+    @Override\n+    public void updateThing(Thing thing) {\n+        super.updateThing(thing);\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwOTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551609069", "bodyText": "same here to extend the access", "author": "ramack", "createdAt": "2021-01-04T22:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023309", "bodyText": "You could make this a field to save resources.", "author": "fwolter", "createdAt": "2021-01-03T15:59:33Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    public ResolThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public ThingBuilder editThing() {\n+        return super.editThing();\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }\n+\n+    @Override\n+    public void updateThing(Thing thing) {\n+        super.updateThing(thing);\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    private void unregisterResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.unregisterThingListener(this);\n+        } else {\n+            logger.debug(\"Can't unregister {} at bridge bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            SimpleDateFormat s = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023353", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n          \n          \n            \n                        Stream.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM);", "author": "fwolter", "createdAt": "2021-01-03T16:00:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolBindingConstants.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ResolBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBindingConstants {\n+\n+    private static final String BRIDGE_VBUSLAN = \"vbuslan\";\n+\n+    public static final String BINDING_ID = \"resol\";\n+\n+    // List of all ChannelTypeUIDs is empty, as we got totally rid of static channel types.\n+    // ChannelTypeUIDs are constructed from the BINDING_ID and the UnitCodeTextIndex from the VSF\n+\n+    // List of all Thing Type\n+    public static final String THING_ID_DEVICE = \"device\";\n+    public static final String THING_ID_EMU_EM = \"emulatedEM\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_UID_BRIDGE = new ThingTypeUID(BINDING_ID, BRIDGE_VBUSLAN);\n+\n+    public static final ThingTypeUID THING_TYPE_UID_DEVICE = new ThingTypeUID(BINDING_ID, THING_ID_DEVICE);\n+\n+    public static final ThingTypeUID THING_TYPE_UID_EMU_EM = new ThingTypeUID(BINDING_ID, THING_ID_EMU_EM);\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n+            Stream.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM).collect(Collectors.toSet()));", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023413", "bodyText": "You could inject it into the constructor of this class to get rid of the Nullable annotation.", "author": "fwolter", "createdAt": "2021-01-03T16:00:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.Hashtable;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolHandlerFactory.class);\n+\n+    private @Nullable LocaleProvider localeProvider;\n+\n+    @Reference\n+    protected void setLocaleProvider(final LocaleProvider localeProvider) {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023535", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2021-01-03T16:02:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDiscoveryService.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDiscoveryService} class handles the discovery of things.\n+ * with broadcasting and put it to inbox, if found.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDiscoveryService.class);\n+\n+    private ResolBridgeHandler resolBridgeHandler;\n+\n+    public ResolDiscoveryService(ResolBridgeHandler resolBridgeHandler) throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS, 10, false);\n+        this.resolBridgeHandler = resolBridgeHandler;\n+    }\n+\n+    private void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withProperties(properties).withLabel(name).build();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxNzc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554617784", "bodyText": "For the thing \"device\" it there is only one of each type on each VBUS and therefore with the bridge unique. Can you please check whether I understood it right, now to do it then?", "author": "ramack", "createdAt": "2021-01-10T20:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc4MzExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r556783112", "bodyText": "You've done it right!", "author": "fwolter", "createdAt": "2021-01-13T19:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023609", "bodyText": "See above. Method.", "author": "fwolter", "createdAt": "2021-01-03T16:03:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"Start discovery of Resol VBus-LAN Adapter\");\n+        scheduler.execute(searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    private Runnable searchRunnable = new Runnable() {\n+\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023730", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2021-01-03T16:04:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"Start discovery of Resol VBus-LAN Adapter\");\n+        scheduler.execute(searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    private Runnable searchRunnable = new Runnable() {\n+\n+        @Override\n+        public void run() {\n+            logger.trace(\"Start adapter discovery...\");\n+\n+            try {\n+                InetAddress broadcastAddress = InetAddress\n+                        .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+                TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500,\n+                        false);\n+\n+                HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+                for (TcpDataSource ds : dataSources) {\n+                    InetAddress address = ds.getAddress();\n+                    String addressId = address.getHostAddress();\n+                    TcpDataSource dsWithInfo;\n+                    try {\n+                        dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                        logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                                dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                        currentDataSourceById.put(addressId, dsWithInfo);\n+                        addAdapter(addressId, dsWithInfo);\n+                        // here we can add the detection of Multi-Channel interfaces like DL3\n+                    } catch (IOException ex) {\n+                        /* address is no valid adapter */\n+                    }\n+\n+                }\n+            } catch (UnknownHostException e) {\n+                logger.debug(\"Could not resolve IPv4 broadcast address\");\n+            }\n+        }\n+    };\n+\n+    private void addAdapter(String remoteIP, TcpDataSource dsWithInfo) {\n+        String adapterSerial = dsWithInfo.getSerial();\n+        Map<String, Object> properties = new HashMap<>(3);\n+        properties.put(\"ipAddress\", remoteIP);\n+        properties.put(\"port\", dsWithInfo.getLivePort());\n+        properties.put(\"adapterSerial\", adapterSerial);\n+\n+        ThingUID uid = new ThingUID(ResolBindingConstants.THING_TYPE_UID_BRIDGE, adapterSerial);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(dsWithInfo.getName()).build());", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxNzgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554617801", "bodyText": "The bridge is uniquely identified by the adapterSerial, which is read on discovery, but not required in file based configuration.\nIf I add a bridge manually in the configuration files the very same one is still autodetected, as long as I don't give the optional parameter adapterSerial. - Wouldn't it be better in this case to use the IP address as representation property?", "author": "ramack", "createdAt": "2021-01-10T20:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc4NDQwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r556784405", "bodyText": "Not sure. I would go for the IP address.", "author": "fwolter", "createdAt": "2021-01-13T19:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE5NjYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r559196604", "bodyText": "I though I read that it should be a not-changing property and the IP would even not be recommended. But 1. I don't find that statement anymore, 2 the scenario that a bridge is using DHCP and getting a changed IP is quite unlikely.", "author": "ramack", "createdAt": "2021-01-17T15:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzkzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023930", "bodyText": "The author tag is deprecated and should therefore be removed. See openhab/openhab-core#1844.", "author": "fwolter", "createdAt": "2021-01-03T16:05:49Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"resol\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Resol Binding</name>\n+\t<description>This is the binding for Resol solar and system controllers (including branded versions).</description>\n+\t<author>Raphael Mack</author>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023953", "bodyText": "Can this file be removed?", "author": "fwolter", "createdAt": "2021-01-03T16:06:01Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/i18n/resol_xx_XX.properties", "diffHunk": "@@ -0,0 +1,17 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNjgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551606805", "bodyText": "I was planning to do the translation into German at least and the file is a form of a reminder. But obviously it did not work well...", "author": "ramack", "createdAt": "2021-01-04T22:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024017", "bodyText": "This context is not valid for the port.", "author": "fwolter", "createdAt": "2021-01-03T16:06:27Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter\n+\t\t</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN adapter.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<context>network-address</context>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNjA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551606069", "bodyText": "is there a better one or can I simply remove the context tag completely?", "author": "ramack", "createdAt": "2021-01-04T22:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMzk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r552923986", "bodyText": "Unfortunately there's no context for ports. So, you can remove it.", "author": "fwolter", "createdAt": "2021-01-06T19:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024142", "bodyText": "Words in labels should be capitalized (except prepositions and so on). See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "author": "fwolter", "createdAt": "2021-01-03T16:07:21Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter\n+\t\t</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN adapter.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>VBus-LAN adapter live data port</label>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>AdapterSerial</label>\n          \n          \n            \n            \t\t\t\t<label>Adapter Serial Number</label>", "author": "fwolter", "createdAt": "2021-01-03T16:07:37Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter\n+\t\t</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN adapter.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>VBus-LAN adapter live data port</label>\n+\t\t\t\t<description>Port for live data on the LAN gateway</description>\n+\t\t\t\t<default>7053</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"adapterSerial\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>AdapterSerial</label>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<description>Refreshtime in seconds for discovering devices, not relevant for data updates.</description>\n          \n          \n            \n            \t\t\t\t<description>Refresh time in seconds for discovering devices, not relevant for data updates.</description>", "author": "fwolter", "createdAt": "2021-01-03T16:07:56Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter\n+\t\t</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN adapter.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>VBus-LAN adapter live data port</label>\n+\t\t\t\t<description>Port for live data on the LAN gateway</description>\n+\t\t\t\t<default>7053</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"adapterSerial\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>AdapterSerial</label>\n+\t\t\t\t<description>The serial number of the adapter (informative).</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>The password for the VBusLAN connection.</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" min=\"5\" max=\"600\" unit=\"s\">\n+\t\t\t\t<context>refresh</context>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Refreshtime in seconds for discovering devices, not relevant for data updates.</description>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024336", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <description>Virtual relay output, will be set by the controller and can be used to communicate data from the resol controller to Openhab.</description>\n          \n          \n            \n                    <description>Virtual relay output, will be set by the controller and can be used to communicate data from the resol controller to openHAB.</description>", "author": "fwolter", "createdAt": "2021-01-03T16:09:07Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated Extension Module (EM) Device</label>\n+\t\t<description>Emulation of an EM device which can be connected through the VBUS to resol controllers which support the EM devices.</description>\n+\t    <channels>\n+            <channel id=\"relay1\" typeId=\"relay\"/>\n+            <channel id=\"relay2\" typeId=\"relay\"/>\n+            <channel id=\"relay3\" typeId=\"relay\"/>\n+            <channel id=\"relay4\" typeId=\"relay\"/>\n+            <channel id=\"relay5\" typeId=\"relay\"/>\n+            \n+            <channel id=\"temperature1\" typeId=\"temperature\"/>\n+            <channel id=\"temperature2\" typeId=\"temperature\"/>\n+            <channel id=\"temperature3\" typeId=\"temperature\"/>\n+            <channel id=\"temperature4\" typeId=\"temperature\"/>\n+            <channel id=\"temperature5\" typeId=\"temperature\"/>\n+            <channel id=\"temperature6\" typeId=\"temperature\"/>\n+\n+            <channel id=\"resistor1\" typeId=\"resistance\"/>\n+            <channel id=\"resistor2\" typeId=\"resistance\"/>\n+            <channel id=\"resistor3\" typeId=\"resistance\"/>\n+            <channel id=\"resistor4\" typeId=\"resistance\"/>\n+            <channel id=\"resistor5\" typeId=\"resistance\"/>\n+            <channel id=\"resistor6\" typeId=\"resistance\"/>\n+        </channels>\n+        \n+        <config-description>\n+            <parameter name=\"deviceId\" type=\"integer\" required=\"true\" min=\"1\" max=\"15\">\n+                <label>Module ID to be emulated</label>\n+                <description>The (sub-)address of the emulated EM device, usable range depends on the used controller.</description>\n+            </parameter>\n+        </config-description>\n+        \n+\t</thing-type>\n+\n+\t<channel-type id=\"None\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Any</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"NoneHidden\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Any</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+    <channel-type id=\"relay\" advanced=\"false\">\n+        <item-type>Number:Dimensionless</item-type>\n+        <label>Relay State</label>\n+        <description>Virtual relay output, will be set by the controller and can be used to communicate data from the resol controller to Openhab.</description>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024455", "bodyText": "What do you mean by emulated?", "author": "fwolter", "createdAt": "2021-01-03T16:10:16Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTA2MjI3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551062272", "bodyText": "Normally an \"EM\" is a physical device which extends the solar controller by some sensor and relay channels and it is connected to the VBUS. This thing type allow openHAB to act as such a slave device on the VBUS and transmit sensor inputs and read relay output states to and from the solar controller. If a physical EM device is attached openHAB can only read the relay output and the sensor inputs measured by it but not transmit temperature values which will be handled by the solar controller.", "author": "ramack", "createdAt": "2021-01-03T22:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwNzg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551507858", "bodyText": "normally an EM device is a physical unit which extends the solar controller by 6 more sensor inputs and 5 relay outputs. If those are transmitting data on the VBUS they are discovered and openHAB is able to read the sensor inputs and relay output states.\nThe target of emulating an EM is to make openHAB a slave on the VBUS to be able to actively write sensor data which will then be used as \"module sensors\" in the solar controller, and the solar controller does not know that those values are injected by openHAB but will \"see\" them as another EM.", "author": "ramack", "createdAt": "2021-01-04T19:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551024494", "bodyText": "Can you remove the new lines?", "author": "fwolter", "createdAt": "2021-01-03T16:10:46Z", "path": "bundles/pom.xml", "diffHunk": "@@ -5,547 +5,1074 @@\n   <modelVersion>4.0.0</modelVersion>\n \n   <parent>\n+", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2ODc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570568785", "bodyText": "The empty lines are still present.", "author": "fwolter", "createdAt": "2021-02-04T21:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4OTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551489158", "bodyText": "The feature.xml doesn't need a license header. You could remove it.", "author": "fwolter", "createdAt": "2021-01-04T18:27:55Z", "path": "bundles/org.openhab.binding.resol/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+\tCopyright (c) 2010-2020 Contributors to the openHAB project\n+\n+\tSee the NOTICE file(s) distributed with this work for additional\n+\tinformation.\n+\n+\tThis program and the accompanying materials are made available under the\n+\tterms of the Eclipse Public License 2.0 which is available at\n+\thttp://www.eclipse.org/legal/epl-2.0\n+\n+\tSPDX-License-Identifier: EPL-2.0\n+\n+-->", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4OTM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551489393", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "author": "fwolter", "createdAt": "2021-01-04T18:28:21Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated Extension Module (EM) Device</label>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4OTQ5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551489499", "bodyText": "Words in labels should be capitalized (except prepositions and so on). See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "author": "fwolter", "createdAt": "2021-01-04T18:28:39Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated Extension Module (EM) Device</label>\n+\t\t<description>Emulation of an EM device which can be connected through the VBUS to resol controllers which support the EM devices.</description>\n+\t    <channels>\n+            <channel id=\"relay1\" typeId=\"relay\"/>\n+            <channel id=\"relay2\" typeId=\"relay\"/>\n+            <channel id=\"relay3\" typeId=\"relay\"/>\n+            <channel id=\"relay4\" typeId=\"relay\"/>\n+            <channel id=\"relay5\" typeId=\"relay\"/>\n+            \n+            <channel id=\"temperature1\" typeId=\"temperature\"/>\n+            <channel id=\"temperature2\" typeId=\"temperature\"/>\n+            <channel id=\"temperature3\" typeId=\"temperature\"/>\n+            <channel id=\"temperature4\" typeId=\"temperature\"/>\n+            <channel id=\"temperature5\" typeId=\"temperature\"/>\n+            <channel id=\"temperature6\" typeId=\"temperature\"/>\n+\n+            <channel id=\"resistor1\" typeId=\"resistance\"/>\n+            <channel id=\"resistor2\" typeId=\"resistance\"/>\n+            <channel id=\"resistor3\" typeId=\"resistance\"/>\n+            <channel id=\"resistor4\" typeId=\"resistance\"/>\n+            <channel id=\"resistor5\" typeId=\"resistance\"/>\n+            <channel id=\"resistor6\" typeId=\"resistance\"/>\n+        </channels>\n+        \n+        <config-description>\n+            <parameter name=\"deviceId\" type=\"integer\" required=\"true\" min=\"1\" max=\"15\">\n+                <label>Module ID to be emulated</label>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ5MDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551490013", "bodyText": "%d would result in conversion errors/warnings. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <state pattern=\"%d %unit%\" readOnly=\"true\"/>\n          \n          \n            \n                    <state pattern=\"%.1f %unit%\" readOnly=\"true\"/>", "author": "fwolter", "createdAt": "2021-01-04T18:29:40Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated Extension Module (EM) Device</label>\n+\t\t<description>Emulation of an EM device which can be connected through the VBUS to resol controllers which support the EM devices.</description>\n+\t    <channels>\n+            <channel id=\"relay1\" typeId=\"relay\"/>\n+            <channel id=\"relay2\" typeId=\"relay\"/>\n+            <channel id=\"relay3\" typeId=\"relay\"/>\n+            <channel id=\"relay4\" typeId=\"relay\"/>\n+            <channel id=\"relay5\" typeId=\"relay\"/>\n+            \n+            <channel id=\"temperature1\" typeId=\"temperature\"/>\n+            <channel id=\"temperature2\" typeId=\"temperature\"/>\n+            <channel id=\"temperature3\" typeId=\"temperature\"/>\n+            <channel id=\"temperature4\" typeId=\"temperature\"/>\n+            <channel id=\"temperature5\" typeId=\"temperature\"/>\n+            <channel id=\"temperature6\" typeId=\"temperature\"/>\n+\n+            <channel id=\"resistor1\" typeId=\"resistance\"/>\n+            <channel id=\"resistor2\" typeId=\"resistance\"/>\n+            <channel id=\"resistor3\" typeId=\"resistance\"/>\n+            <channel id=\"resistor4\" typeId=\"resistance\"/>\n+            <channel id=\"resistor5\" typeId=\"resistance\"/>\n+            <channel id=\"resistor6\" typeId=\"resistance\"/>\n+        </channels>\n+        \n+        <config-description>\n+            <parameter name=\"deviceId\" type=\"integer\" required=\"true\" min=\"1\" max=\"15\">\n+                <label>Module ID to be emulated</label>\n+                <description>The (sub-)address of the emulated EM device, usable range depends on the used controller.</description>\n+            </parameter>\n+        </config-description>\n+        \n+\t</thing-type>\n+\n+\t<channel-type id=\"None\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Any</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"NoneHidden\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Any</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+    <channel-type id=\"relay\" advanced=\"false\">\n+        <item-type>Number:Dimensionless</item-type>\n+        <label>Relay State</label>\n+        <description>Virtual relay output, will be set by the controller and can be used to communicate data from the resol controller to Openhab.</description>\n+        <category>Switch</category>\n+        <state pattern=\"%d %%\" readOnly=\"true\"/>\n+    </channel-type>\n+\n+    <channel-type id=\"temperature\" advanced=\"false\">\n+        <item-type>Number:Temperature</item-type>\n+        <label>Temperature</label>\n+        <description>Virtual temperature sensor, will be read by the controller and can be used to communicate data from Openhab to the resol controller.</description>\n+        <category>Temperature</category>\n+        <state pattern=\"%d %unit%\" readOnly=\"true\"/>", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r550306227", "bodyText": "This part can be omitted. We only but the above statement in the NOTICE file.", "author": "Hilbrand", "createdAt": "2020-12-30T19:39:49Z", "path": "bundles/org.openhab.binding.resol/NOTICE", "diffHunk": "@@ -0,0 +1,33 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab-addons\n+\n+== Third-party Content\n+\n+resol-vbus-java\n+* License: MIT License\n+* Project: https://github.com/danielwippermann/resol-vbus-java\n+* Source:  https://github.com/danielwippermann/resol-vbus-java\n+\n+== Third-party license(s)\n+\n+=== MIT License resol-vbus-java\n+Copyright (C) 2008-2016, RESOL - Elektronische Regelungen GmbH.\n+\n+Copyright (C) 2016-2018, Daniel Wippermann.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r550306546", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Flow_rate_sensor_x            | Number:VolumetricFlowRate| of sensor 'x'                                      |\n          \n          \n            \n            | Flow_rate_sensor_x            | Number:Volumetric        | FlowRate of sensor 'x'                              |", "author": "Hilbrand", "createdAt": "2020-12-30T19:41:08Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,196 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+VBusLAN-Bridge, DataLogger DL2 and DL3 as a live data interface between LAN and Resol VBus.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+\n+On top of the bridge devices, which enables access to the VBUS many, if not all, Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers. This includes\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+## Binding Configuration\n+\n+The Resol binding doesn't need any form of configuration in files.\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+\n+## Thing Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least INFO level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+\n+## Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen after autodiscovery or \n+\n+| channel                       | type                     | description                                        |\n+|-------------------------------|--------------------------|----------------------------------------------------|\n+| Pump_speed_relay_x            | Number:Dimensionless     | Percentage of the output state of relay 'x'        |\n+| Temperature_sensor_x          | Number:Temperature       | Temperature sensor 'x' of the controller           |\n+| Temperature_Module_y_Sensor_x | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |\n+| Pressure_sensor_x             | Number:Pressure          | Pressure sensor 'x'                                |\n+| Humidity_sensor_x             | Number:Dimensionless     | Humidity sensor 'x'                                |\n+| Irradiation_sensor_x          | Number:Intensity         | Sunlight intensity sensor                          |\n+| Output_M                      | Number:Dimensionless     | PWM/0-10V level value of the output 'M'            |\n+| System_date                   | DateTime                 | Date and time of the controller clock              |\n+| Error_mask                    | Number                   | Bitmask for the different errors                   |\n+| Error_Sensor_line_broken-str  | String                   | Sensor line broken status (details for Error_mask) |\n+| Flow_rate_sensor_x            | Number:VolumetricFlowRate| of sensor 'x'                                      |", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2OTUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551569523", "bodyText": "But if I check here: https://next.openhab.org/docs/concepts/units-of-measurement.html\nthe type is given as VolumetricFlowRate - ok, I could still add \"Flow rate \" to the description, but the unit should stay, shouldn't it?", "author": "ramack", "createdAt": "2021-01-04T21:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxMjkwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554612905", "bodyText": "@Hilbrand I don't catch the point here. Can you explain why Number:VolumetricFlowRate is not correct?", "author": "ramack", "createdAt": "2021-01-10T19:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYyNTU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554625598", "bodyText": "Yes you are right. I misread the description. Maybe indeed a good idea to add it.", "author": "Hilbrand", "createdAt": "2021-01-10T21:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDg4NTE3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r550885177", "bodyText": "Something went wrong here, can you revert these additional lines.", "author": "Hilbrand", "createdAt": "2021-01-02T14:08:22Z", "path": "bundles/pom.xml", "diffHunk": "@@ -5,547 +5,1074 @@\n   <modelVersion>4.0.0</modelVersion>\n \n   <parent>\n+", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551553664", "bodyText": "You probably should not keep a map of things. The bridge already tracks this itself via children. So you're re-implementing part of what is already available, making this code more complex than needed. See if you can change the code to make use of this functionality.", "author": "Hilbrand", "createdAt": "2021-01-04T20:34:31Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxODk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554618975", "bodyText": "I feel stupid or blind right now \ud83d\ude00, can you please point me to it?", "author": "ramack", "createdAt": "2021-01-10T20:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYyNjc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554626788", "bodyText": "You can get it via getThing().getThings() see for example \n  \n    \n      openhab-addons/bundles/org.openhab.binding.spotify/src/main/java/org/openhab/binding/spotify/internal/handler/SpotifyBridgeHandler.java\n    \n    \n         Line 427\n      in\n      b6eea71\n    \n    \n    \n    \n\n        \n          \n           getThing().getThings().stream() //", "author": "Hilbrand", "createdAt": "2021-01-10T21:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1NjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551556682", "bodyText": "This is not allowed. This service should be in control of when scanning is done. What you can do is instead of in activate  register to the bridge here and in stopScan unregister. Or keep a list of unknown things in the bridge and let discovery get (and clear) the list when discovery is started here.", "author": "Hilbrand", "createdAt": "2021-01-04T20:40:46Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDiscoveryService.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDiscoveryService} class handles the discovery of things.\n+ * with broadcasting and put it to inbox, if found.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDiscoveryService.class);\n+\n+    private ResolBridgeHandler resolBridgeHandler;\n+\n+    public ResolDiscoveryService(ResolBridgeHandler resolBridgeHandler) throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS, 10, false);\n+        this.resolBridgeHandler = resolBridgeHandler;\n+    }\n+\n+    private void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withProperties(properties).withLabel(name).build();\n+            logger.trace(\"call register: {} label: {}\", discoveryResult.getBindingId(), discoveryResult.getLabel());\n+            thingDiscovered(discoveryResult);\n+        } else {\n+            logger.debug(\"Discovered Thing is unsupported: type '{}'\", type);\n+        }\n+    }\n+\n+    public void addResolThing(String thingType, String thingID, String name) {\n+\n+        addThing(resolBridgeHandler.getThing().getUID(), thingType, thingID, name);\n+    }\n+\n+    public void activate() {\n+        resolBridgeHandler.registerDiscoveryService(this);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        resolBridgeHandler.unregisterDiscoveryService();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // Scan will be done by bridge", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1Nzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551557777", "bodyText": "Can you implement registering the discovery bound to a bridge as a ThingHandlerService. See this preliminary documentation on how to do that: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "author": "Hilbrand", "createdAt": "2021-01-04T20:43:18Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.Hashtable;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolHandlerFactory.class);\n+\n+    private @Nullable LocaleProvider localeProvider;\n+\n+    @Reference\n+    protected void setLocaleProvider(final LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    protected void unsetLocaleProvider(final LocaleProvider localeProvider) {\n+        this.localeProvider = null;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_DEVICE)) {\n+            return new ResolThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_EMU_EM)) {\n+            return new ResolEmuEMThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_BRIDGE)) {\n+            ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n+            registerThingDiscovery(handler);\n+            return handler;\n+        }\n+\n+        return null;\n+    }\n+\n+    private synchronized void registerThingDiscovery(ResolBridgeHandler bridgeHandler) {\n+        ResolDiscoveryService discoveryService = new ResolDiscoveryService(bridgeHandler);\n+        logger.trace(\"Try to register VBUS Discovery service on BundleID: {} Service: {}\",\n+                bundleContext.getBundle().getBundleId(), DiscoveryService.class.getName());\n+\n+        Hashtable<@Nullable String, String> prop = new Hashtable<@Nullable String, String>();\n+\n+        bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, prop);\n+        discoveryService.activate();\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUwMDkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r560500921", "bodyText": "ok, I tried that, can you please check it? What I recognized, was that bridge defined in a thing file was still detected (even though I changed the representationproperty to the ipAddress) but when I added the discovered one it magically disappeared... So maybe I didn't do it right fully.", "author": "ramack", "createdAt": "2021-01-19T21:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1Nzc3Nw=="}], "type": "inlineReview"}, {"oid": "9cdc0854dfcca08120b7529c147190822d8dffe2", "url": "https://github.com/openhab/openhab-addons/commit/9cdc0854dfcca08120b7529c147190822d8dffe2", "message": "add representation-property\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-01-10T20:40:19Z", "type": "forcePushed"}, {"oid": "e6d17062d2261669c552226c5ec427956764f8c6", "url": "https://github.com/openhab/openhab-addons/commit/e6d17062d2261669c552226c5ec427956764f8c6", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-01-30T22:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0OTA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570549091", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ###Emulated Extension Module EM\n          \n          \n            \n            ### Emulated Extension Module EM", "author": "fwolter", "createdAt": "2021-02-04T21:17:24Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0OTY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570549659", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For the connection from the Resol binding the bridge requires the configuration of\n          \n          \n            \n            For the connection from the Resol binding the bridge requires the configuration of the following parameters:", "author": "fwolter", "createdAt": "2021-02-04T21:18:23Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM\n+\n+Some controllers like the Deltasol MX can be connected to an extension module, which can be emulated by the thing type *emulatedEM*.\n+The emulated EM is a virtual device, visible on the VBUS to a Resol controller and provides an interface between openHAB and the controller.\n+Relay channels are outputs from the controller point of view and therefore read-only in OH.\n+The sensor channels as inputs for the solar or system controller and intended to be written by OH.\n+\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0OTk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570549982", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | property             | type    | Required | description                                                |\n          \n          \n            \n            | parameter             | type    | Required | description                                                |", "author": "fwolter", "createdAt": "2021-02-04T21:18:58Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM\n+\n+Some controllers like the Deltasol MX can be connected to an extension module, which can be emulated by the thing type *emulatedEM*.\n+The emulated EM is a virtual device, visible on the VBUS to a Resol controller and provides an interface between openHAB and the controller.\n+Relay channels are outputs from the controller point of view and therefore read-only in OH.\n+The sensor channels as inputs for the solar or system controller and intended to be written by OH.\n+\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MDUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570550511", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *emulatedEM* devices cannot be auto-discovered and require beside the bridge the following configuration:\n          \n          \n            \n            *emulatedEM* devices cannot be auto-discovered and require beside the bridge the following configuration:", "author": "fwolter", "createdAt": "2021-02-04T21:20:02Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM\n+\n+Some controllers like the Deltasol MX can be connected to an extension module, which can be emulated by the thing type *emulatedEM*.\n+The emulated EM is a virtual device, visible on the VBUS to a Resol controller and provides an interface between openHAB and the controller.\n+Relay channels are outputs from the controller point of view and therefore read-only in OH.\n+The sensor channels as inputs for the solar or system controller and intended to be written by OH.\n+\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+## Device Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least DEBUG level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+## Emulated EM Configuration\n+\n+*emulatedEM* devices cannot be auto-discovered and require beside the bridge the following configuration:", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTIzMjg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571232878", "bodyText": "What is different here? I am too blind to see the change from \"and\" to \"and\" \ud83d\ude22", "author": "ramack", "createdAt": "2021-02-05T20:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MDUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQwMjAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571402008", "bodyText": "It's the new line after the colon. There should be an empty line before tables, head lines and so on.", "author": "fwolter", "createdAt": "2021-02-06T10:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MDUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU4OTMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571589301", "bodyText": "ah yes, clear. I was focused on the red indicated and in the diff such that I didn't recognize the newline, sorry.", "author": "ramack", "createdAt": "2021-02-07T09:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MDUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MTE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570551143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | temperature_Module_y_Sensor_x     | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |\n          \n          \n            \n            | temperature_module_y_Sensor_x     | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |", "author": "fwolter", "createdAt": "2021-02-04T21:21:09Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM\n+\n+Some controllers like the Deltasol MX can be connected to an extension module, which can be emulated by the thing type *emulatedEM*.\n+The emulated EM is a virtual device, visible on the VBUS to a Resol controller and provides an interface between openHAB and the controller.\n+Relay channels are outputs from the controller point of view and therefore read-only in OH.\n+The sensor channels as inputs for the solar or system controller and intended to be written by OH.\n+\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+## Device Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least DEBUG level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+## Emulated EM Configuration\n+\n+*emulatedEM* devices cannot be auto-discovered and require beside the bridge the following configuration:\n+| property  | type | Required | description                                                |\n+|-----------|------|----------|-----------------------------------------------------------------------------------------------------------------|\n+| moduleID  | int  | yes      | The module ID on the VBUS in range 0-15, but further restrictions might apply depending on the resol controller. |\n+\n+\n+## Device Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen in the UI or in the logs if DEBUG logging is enabled for this binding after data is received from the physical device.\n+\n+| channel                           | type                     | description                                        |\n+|-----------------------------------|--------------------------|----------------------------------------------------|\n+| pump_speed_relay_x                | Number:Dimensionless     | Percentage of the output state of relay 'x'        |\n+| temperature_sensor_x              | Number:Temperature       | Temperature sensor 'x' of the controller           |\n+| temperature_Module_y_Sensor_x     | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1MTQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570551470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | error_sensor_line_broken          | Number                   | Sensor line broken status (details for Error_mask) |\n          \n          \n            \n            | error_sensor_line_short-circuited | Number                   | Sensor short circuit status (details for Error_mask) |\n          \n          \n            \n            | error_sensor_line_broken          | Number                   | Sensor line broken status (details for error_mask) |\n          \n          \n            \n            | error_sensor_line_short-circuited | Number                   | Sensor short circuit status (details for error_mask) |", "author": "fwolter", "createdAt": "2021-02-04T21:21:44Z", "path": "bundles/org.openhab.binding.resol/README.md", "diffHunk": "@@ -0,0 +1,250 @@\n+# Resol Binding\n+\n+Resol Binding connects to Solar and System Controllers of RESOL - Elektronische Regelungen GmbH, also including branded versions from Viessmann, SOLEX, COSMO, SOLTEX, DeDietrich and many more.\n+\n+![Resol](doc/RESOL_Logo_de.png)\n+\n+This binding is based on and includes the [Resol-VBUS-Java library](https://github.com/danielwippermann/resol-vbus-java), developed by Daniel Wippermann.\n+\n+\n+## Supported Things\n+\n+### Bridge\n+\n+For the connection of the VBUS devices a network interface is required.\n+Supported interfaces are VBUS-LAN, KM1, KM2, DataLogger DL2 and DL3 as live data interface between openHAB and the Resol VBUS via network.\n+On the DL3 currently there is only the first VBUS channel supported and the sensors directly connected to the DL3 are not accessible via this binding.\n+Currently only network based bridges are supported and if a USB-VBUS interface shall be used a serial-network proxy has to be used.\n+In the binding might support USB-type bridges in future.\n+\n+### Device\n+\n+On top of the bridge things, which enable access to the VBUS, many - if not all - Resol Controllers and Modules like WMZ heat meters, HKM Heating circuit extensions etc. are supported including branded versions from different suppliers as thing type *device*.\n+The supported devices include\n+\n+ * Solar controller DeltaSol\u00ae A/AX/AX HE\n+ * Solar controller DeltaSol\u00ae AL E HE\n+ * Solar controller DeltaSol\u00ae CS (Plus)\n+ * Solar controller DeltaSol\u00ae B\n+ * Solar controller DeltaSol\u00ae BS series\n+ * Solar controller DeltaSol\u00ae SLL\n+ * Solar controller DeltaSol\u00ae SL\n+ * Solar controller DeltaSol\u00ae BX series\n+ * System controller DeltaSol\u00ae SLT\n+ * System controller DeltaSol\u00ae MX\n+ * System controller DeltaSol\u00ae E\n+ * DeltaSol Fresh\u00ae\n+ * DeltaSol\u00ae Pool\n+ * DeltaSol\u00ae Minipool\n+ * DeltaSol\u00ae ES\n+ * Frista\n+ * DeltaTherm\u00ae HC\n+ * DeltaTherm\u00ae FK\n+ * Deltatherm\u00ae HT\n+ * DeltaTherm\u00ae DH\n+ * Sonnenkraft SKSC3\n+ * Sonnenkraft STRG BX PLUS\n+ * Sonnenkraft SKSC3+\n+ * Sonnenkraft SKSC3HE\n+ * Sonnenkraft SKSR 1/2/3\n+ * Vitosolic 200\n+ * COSMO Multi\n+ * Drainback DeDietrich\n+ * Diemasol C\n+\n+A more complete list can be found in the doc of the [resol-vbus-java library](http://danielwippermann.github.io/resol-vbus/vbus-packets.html).\n+\n+###Emulated Extension Module EM\n+\n+Some controllers like the Deltasol MX can be connected to an extension module, which can be emulated by the thing type *emulatedEM*.\n+The emulated EM is a virtual device, visible on the VBUS to a Resol controller and provides an interface between openHAB and the controller.\n+Relay channels are outputs from the controller point of view and therefore read-only in OH.\n+The sensor channels as inputs for the solar or system controller and intended to be written by OH.\n+\n+\n+## Discovery\n+\n+Discovery is tested for VBus-LAN adapters DL2, DL3 and KM2 devices, it should also work for other devices providing a live data port.\n+After a bridge is detected in the local network the password needs to be given and the things on the VBUS will popup in the inbox.\n+\n+\n+## Bridge Configuration\n+\n+The bridge is the device connecting the Resol VBUS to the network, usually a VBus-LAN adapter or integrated in some of the solar controllers like DL3.\n+For the connection from the Resol binding the bridge requires the configuration of\n+\n+| property             | type    | Required | description                                                |\n+|----------------------|---------|----------|------------------------------------------------------------|\n+| ipAddress            | String  | yes      | IP address or hostname of the VBUS adapter                 |\n+| password             | String  | yes      | Password, defaults to 'vbus' for factory setting devices   |\n+| port                 | Number  | no       | Port for the TCP connection, defaults to 7053              |\n+| adapterSerial        | String  | no       | Serialnumber of the device (informative only)              |\n+\n+## Device Configuration\n+\n+Depending on the solar/heating controller you have attached to your VBUS there will be a \"controller\" and several other things like heat quantity meters, heating circuit controls, etc.\n+These do not require any configuration parameters and will pop up in your inbox after the bridge has received data from them.\n+The name of the devices is usually the Resol name with spaced replaced by _ and a \"-Controller\" suffix like \"DeltaSol_MX-Controller\".\n+For configuration in files you can enable the logging with at least DEBUG level for the resol binding and search the logs for \"ThingHandler for (.*) not registered.\" to identify the names of the things you can add for your VBUS devices.\n+\n+## Emulated EM Configuration\n+\n+*emulatedEM* devices cannot be auto-discovered and require beside the bridge the following configuration:\n+| property  | type | Required | description                                                |\n+|-----------|------|----------|-----------------------------------------------------------------------------------------------------------------|\n+| moduleID  | int  | yes      | The module ID on the VBUS in range 0-15, but further restrictions might apply depending on the resol controller. |\n+\n+\n+## Device Channels\n+\n+The channels of a thing are determined automatically based on the received VBUS data and are highly dependent on the used device.\n+Here is a list of the channels of a DeltaSol MX with a heat quantity meter (HQM) and an extension module EM.\n+The channels supported for your device can be seen in the UI or in the logs if DEBUG logging is enabled for this binding after data is received from the physical device.\n+\n+| channel                           | type                     | description                                        |\n+|-----------------------------------|--------------------------|----------------------------------------------------|\n+| pump_speed_relay_x                | Number:Dimensionless     | Percentage of the output state of relay 'x'        |\n+| temperature_sensor_x              | Number:Temperature       | Temperature sensor 'x' of the controller           |\n+| temperature_Module_y_Sensor_x     | Number:Temperature       | Temperature sensor 'x' of the extension module 'y' |\n+| pressure_sensor_x                 | Number:Pressure          | Pressure sensor 'x'                                |\n+| humidity_sensor_x                 | Number:Dimensionless     | Humidity sensor 'x'                                |\n+| irradiation_sensor_x              | Number:Intensity         | Sunlight intensity sensor                          |\n+| output_m                          | Number:Dimensionless     | PWM/0-10V level value of the output 'm'            |\n+| system_date                       | DateTime                 | Date and time of the controller clock              |\n+| error_mask                        | Number                   | Bitmask for the different errors                   |\n+| error_sensor_line_broken          | Number                   | Sensor line broken status (details for Error_mask) |\n+| error_sensor_line_short-circuited | Number                   | Sensor short circuit status (details for Error_mask) |", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NDA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570554092", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-04T21:26:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    public void registerDiscoveryService(ResolDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(ResolDeviceDiscoveryService.class);\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+            }\n+        }\n+    }\n+\n+    private void pollingRunnable() {\n+        if (!isConnected) {\n+            synchronized (ResolBridgeHandler.this) {\n+                Connection connection = tcpConnection;\n+                /* first cleanup in case there is an old but failed TCP connection around */\n+                try {\n+                    if (connection != null) {\n+                        connection.disconnect();\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).stop();\n+                            }\n+                        });\n+\n+                        connection = null;\n+                        tcpConnection = null;\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"TCP disconnect failed: {}\", e.getMessage());\n+                }\n+                TcpDataSource source = null;\n+                /* now try to establish a new TCP connection */\n+                try {\n+                    source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                    if (source != null) {\n+                        source.setLivePassword(password);\n+                    }\n+                } catch (IOException e) {\n+                    isConnected = false;\n+                    unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                }\n+                if (source != null) {\n+                    try {\n+                        logger.debug(\"Opening a new connection to {} {} @{}\", source.getProduct(),\n+                                source.getDeviceName(), source.getAddress());\n+                        connection = source.connectLive(0, 0x0020);\n+                        tcpConnection = connection;\n+                    } catch (Exception e) {\n+                        // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                        // generic type\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+\n+                    if (connection != null) {\n+                        // Add a listener to the Connection to monitor state changes and\n+                        // read incoming frames\n+                        connection.addListener(new ResolConnectorAdapter());\n+                    }\n+                }\n+                // Establish the connection\n+                if (connection != null) {\n+                    try {\n+                        connection.connect();\n+                        final Connection c = connection;\n+                        // now set the connection the thing handlers for the emulated EMs\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).useConnection(c);\n+                            }\n+                        });\n+                    } catch (IOException e) {\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        isConnected = false;\n+                    }\n+                } else {\n+                    isConnected = false;\n+                }\n+                if (!isConnected) {\n+                    logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                } else {\n+                    unconnectedReason = \"\";\n+                }\n+                updateStatus();\n+            }\n+        }\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                getThing().getThings().stream().forEach(thing -> {\n+                    ThingHandler th = thing.getHandler();\n+                    if (th instanceof ResolEmuEMThingHandler) {\n+                        ((ResolEmuEMThingHandler) th).stop();\n+                    }\n+                });\n+\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    Locale getLocale() {\n+        return locale;\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    if (ConnectionState.CONNECTED.equals(connState)) {\n+                        isConnected = true;\n+                    } else if (ConnectionState.DISCONNECTED.equals(connState)\n+                            || ConnectionState.INTERRUPTED.equals(connState)) {\n+                        isConnected = false;\n+                    }\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1Njc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570556796", "bodyText": "You could enclose this with an if, that the data is not calculated when running in normal logging mode.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",\n          \n          \n            \n                        if (logger.isTraceEnabled()) {\n          \n          \n            \n                            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",", "author": "fwolter", "createdAt": "2021-02-04T21:30:51Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    public void registerDiscoveryService(ResolDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(ResolDeviceDiscoveryService.class);\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+            }\n+        }\n+    }\n+\n+    private void pollingRunnable() {\n+        if (!isConnected) {\n+            synchronized (ResolBridgeHandler.this) {\n+                Connection connection = tcpConnection;\n+                /* first cleanup in case there is an old but failed TCP connection around */\n+                try {\n+                    if (connection != null) {\n+                        connection.disconnect();\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).stop();\n+                            }\n+                        });\n+\n+                        connection = null;\n+                        tcpConnection = null;\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"TCP disconnect failed: {}\", e.getMessage());\n+                }\n+                TcpDataSource source = null;\n+                /* now try to establish a new TCP connection */\n+                try {\n+                    source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                    if (source != null) {\n+                        source.setLivePassword(password);\n+                    }\n+                } catch (IOException e) {\n+                    isConnected = false;\n+                    unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                }\n+                if (source != null) {\n+                    try {\n+                        logger.debug(\"Opening a new connection to {} {} @{}\", source.getProduct(),\n+                                source.getDeviceName(), source.getAddress());\n+                        connection = source.connectLive(0, 0x0020);\n+                        tcpConnection = connection;\n+                    } catch (Exception e) {\n+                        // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                        // generic type\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+\n+                    if (connection != null) {\n+                        // Add a listener to the Connection to monitor state changes and\n+                        // read incoming frames\n+                        connection.addListener(new ResolConnectorAdapter());\n+                    }\n+                }\n+                // Establish the connection\n+                if (connection != null) {\n+                    try {\n+                        connection.connect();\n+                        final Connection c = connection;\n+                        // now set the connection the thing handlers for the emulated EMs\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).useConnection(c);\n+                            }\n+                        });\n+                    } catch (IOException e) {\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        isConnected = false;\n+                    }\n+                } else {\n+                    isConnected = false;\n+                }\n+                if (!isConnected) {\n+                    logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                } else {\n+                    unconnectedReason = \"\";\n+                }\n+                updateStatus();\n+            }\n+        }\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                getThing().getThings().stream().forEach(thing -> {\n+                    ThingHandler th = thing.getHandler();\n+                    if (th instanceof ResolEmuEMThingHandler) {\n+                        ((ResolEmuEMThingHandler) th).stop();\n+                    }\n+                });\n+\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    Locale getLocale() {\n+        return locale;\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    if (ConnectionState.CONNECTED.equals(connState)) {\n+                        isConnected = true;\n+                    } else if (ConnectionState.DISCONNECTED.equals(connState)\n+                            || ConnectionState.INTERRUPTED.equals(connState)) {\n+                        isConnected = false;\n+                    }\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());\n+\n+                    if (isConnected) {\n+                        unconnectedReason = \"\";\n+                    } else {\n+                        unconnectedReason = \"TCP connection failed: \" + connState.toString();\n+                    }\n+                }\n+                updateStatus();\n+            }\n+        }\n+\n+        @Override\n+        public void packetReceived(@Nullable Connection connection, @Nullable Packet packet) {\n+            if (connection == null || packet == null) {\n+                return;\n+            }\n+            boolean packetHandled = false;\n+            String thingType = spec.getSourceDeviceSpec(packet).getName(); // use En here\n+\n+            thingType = thingType.replace(\" [\", \"-\");\n+            thingType = thingType.replace(\"]\", \"\");\n+            thingType = thingType.replace(\" #\", \"-\");\n+            thingType = thingType.replace(\" \", \"_\");\n+            thingType = thingType.replace(\"/\", \"_\");\n+            thingType = thingType.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            /*\n+             * It would be nice for the combination of MX and EM devices to filter only those with a peerAddress of\n+             * 0x10, because the MX redelivers the data from the EM to the DFA.\n+             * But the MX is the exception in this case and many other controllers do not redeliver data, so we keep it.\n+             */\n+            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NzU4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570557587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> updateJob;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> updateJob;", "author": "fwolter", "createdAt": "2021-02-04T21:32:19Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1OTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570559573", "bodyText": "This will convert to the current quantity's unit. E.g. if the user uses Fahrenheit, it will convert to the Fahrenheit value. You can use command.toUnit() to convert it to the expected value.", "author": "fwolter", "createdAt": "2021-02-04T21:35:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = ((QuantityType<?>) command).floatValue();", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570561314", "bodyText": "Can you set the status detail message, that the user gets a clue what is wrong?", "author": "fwolter", "createdAt": "2021-02-04T21:39:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = ((QuantityType<?>) command).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;\n+        }\n+\n+        if (update) {\n+            EmDeviceEmulator dev = device;\n+            if (dev != null) {\n+                if (chID.startsWith(CHANNEL_TEMP)) {\n+                    dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                    if (intValue == 0) {\n+                        /* switch is open => 1 megaohm */\n+                        dev.setResistorValueByNr(channel, 1000000000);\n+                        updateState(channelUID, OnOffType.OFF);\n+                    } else {\n+                        /* switch is closed */\n+                        dev.setResistorValueByNr(channel, 0);\n+                        updateState(channelUID, OnOffType.ON);\n+                    }\n+                } else if (chID.startsWith(CHANNEL_RESIST)) {\n+                    dev.setResistorValueByNr(channel, (int) (value * 1000.0));\n+                    updateState(channelUID, new QuantityType<>(intValue, Units.OHM));\n+                } else if (chID.startsWith(CHANNEL_TEMP_ADJUST)) {\n+                    basValues[channel - 1].temperatureOffset = value;\n+                    updateBas(channel);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_MODE)) {\n+                    basValues[channel - 1].mode = intValue;\n+                    updateBas(channel);\n+                    updateState(channelUID, new DecimalType(intValue));\n+                } else {\n+                    /* set resistor value for Open Connection, 1 megaohm */\n+                    dev.setResistorValueByNr(channel, 1000000000);\n+                    updateState(channelUID, new QuantityType<>(1000000, Units.OHM));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateBas(int channel) {\n+        int resistor = 0; /* in milliohm */\n+        int delta = (int) ((basValues[channel - 1].temperatureOffset * 210.0f / 15.0f) * 1000.0f);\n+        switch (basValues[channel - 1].mode) {\n+            case 4: /* Automatic range 76 - 496 ohm */\n+                resistor = 286 * 1000 + delta;\n+                break;\n+            case 0: /* OFF range 1840 - 2260 ohm */\n+                resistor = 2050 * 1000 + delta;\n+                break;\n+            case 2: /* Night range 660 - 1080 ohm */\n+                resistor = 870 * 1000 + delta;\n+                break;\n+            case 3: /* Party is automatic mode with +15K */\n+                resistor = 286 * 1000 + 210 * 1000;\n+                break;\n+            case 1: /* Summer range 1240 - 1660 ohm */\n+                resistor = 1450 * 1000 + delta;\n+                break;\n+            default:\n+                /* signal a shortcut as error */\n+                resistor = 0;\n+                break;\n+        }\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.setResistorValueByNr(channel, resistor);\n+        }\n+    }\n+\n+    @Override\n+    public void propertyChange(@Nullable PropertyChangeEvent evt) {\n+        if (evt != null) {\n+            String s = evt.getPropertyName();\n+            if (s.startsWith(\"relay\") && s.endsWith(\"Value\")) {\n+                int v = (Integer) evt.getNewValue();\n+                int i = Integer.parseInt(s.substring(5, 6));\n+                setRelayChannelValue(i, v);\n+            } else if (s.contentEquals(\"connectionState\")) {\n+                ConnectionState ste = (ConnectionState) evt.getNewValue();\n+                if (ste.equals(ConnectionState.CONNECTED)) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570561706", "bodyText": "Can this be a constant?", "author": "fwolter", "createdAt": "2021-02-04T21:39:48Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private SimpleDateFormat dateFormat = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTI0NjU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571246599", "bodyText": "Do you mean to make it final?", "author": "ramack", "createdAt": "2021-02-05T20:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQwMjQ1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571402451", "bodyText": "Yes, and make it static. SimpleDateFormat is also not thread-safe. You need to synchronize access if it can be accessed by multiple threads concurrently.", "author": "fwolter", "createdAt": "2021-02-06T10:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU4NzU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571587546", "bodyText": "ok. I don't see any reason here to have multithreaded calls here, so I'd not add synchronized.", "author": "ramack", "createdAt": "2021-02-07T09:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MzA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570563070", "bodyText": "Can the comment be removed?", "author": "fwolter", "createdAt": "2021-02-04T21:42:23Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private SimpleDateFormat dateFormat = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolBridgeHandler bridgeHandler = getBridgeHandler();\n+        this.bridgeHandler = bridgeHandler;\n+        if (bridgeHandler != null) {\n+            updateStatus(bridgeHandler.getStatus());\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    public void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, long value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"Number\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value);\n+        } else {\n+            this.updateState(channelId, new StringType(Long.toString(value)));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new DateTimeType(dateFormat.format(value)));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, double value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+            return;\n+        }\n+\n+        String itmType = channel.getAcceptedItemType();\n+        if (itmType != null && itmType.startsWith(\"Number\")) {\n+            this.updateState(channelId, new DecimalType(value));\n+        } else {\n+            logger.warn(\"ItemType '{}' for channel '{}' not matching parameter type double\",\n+                    channel.getAcceptedItemType(), channelId);\n+        }\n+    }\n+\n+    @Override\n+    public void packetReceived(Specification spec, Language lang, Packet packet) {\n+        PacketFieldValue[] pfvs = spec.getPacketFieldValuesForHeaders(new Packet[] { packet });\n+        for (PacketFieldValue pfv : pfvs) {\n+            logger.trace(\"Id: {}, Name: {}, Raw: {}, Text: {}\", pfv.getPacketFieldId(), pfv.getName(lang),\n+                    pfv.getRawValueDouble(), pfv.formatTextValue(null, Locale.getDefault()));\n+\n+            String channelId = pfv.getName(); // use English name as channel\n+            channelId = channelId.replace(\" [\", \"-\");\n+            channelId = channelId.replace(\"]\", \"\");\n+            channelId = channelId.replace(\"(\", \"-\");\n+            channelId = channelId.replace(\")\", \"\");\n+            channelId = channelId.replace(\" #\", \"-\");\n+            channelId = channelId.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            channelId = channelId.toLowerCase(Locale.ENGLISH);\n+\n+            ChannelTypeUID channelTypeUID;\n+\n+            if (pfv.getPacketFieldSpec().getUnit().getUnitId() >= 0) {\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                        pfv.getPacketFieldSpec().getUnit().getUnitCodeText());\n+            } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.DateTime) {\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"DateTime\");\n+            } else {\n+                /* used for enums and the numeric types without unit */\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+            }\n+\n+            String acceptedItemType;\n+\n+            Thing thing = getThing();\n+            switch (pfv.getPacketFieldSpec().getType()) {\n+                case DateTime:\n+                    acceptedItemType = \"DateTime\";\n+                    break;\n+                case WeekTime:\n+                case Number:\n+                    acceptedItemType = ResolChannelTypeProvider.itemTypeForUnit(pfv.getPacketFieldSpec().getUnit());\n+                    break;\n+                case Time:\n+                default:\n+                    acceptedItemType = \"String\";\n+                    break;\n+            }\n+            Channel a = thing.getChannel(channelId);\n+\n+            if (a == null) {\n+                /* channel doesn't exit, let's create it */\n+                ThingBuilder thingBuilder = editThing();\n+                ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+\n+                if (pfv.getEnumVariant() != null) {\n+                    /* create a state option channel */\n+                    List<StateOption> options = new ArrayList<>();\n+                    PacketFieldSpec ff = pfv.getPacketFieldSpec();\n+                    Enum e = ff.getEnum();\n+                    for (long l : e.getValues()) {\n+                        EnumVariant v = e.getEnumVariantForValue(l);\n+                        options.add(new StateOption(Long.toString(l), v.getText(lang)));\n+                    }\n+\n+                    stateDescriptionProvider.setStateOptions(channelUID, options);\n+\n+                    Channel channel = ChannelBuilder.create(channelUID, \"Number\").withType(channelTypeUID)\n+                            .withLabel(pfv.getName(lang)).build();\n+\n+                    thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+                    updateThing(thingBuilder.build());\n+                } else if (pfv.getRawValueDouble() != null) {\n+                    /* a number channel */\n+                    Channel channel = ChannelBuilder.create(channelUID, acceptedItemType).withType(channelTypeUID)\n+                            .withLabel(pfv.getName(lang)).build();\n+\n+                    thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+                    updateThing(thingBuilder.build());\n+                }\n+                logger.debug(\"Creating channel: {}\", channelUID);\n+            }\n+\n+            if (pfv.getEnumVariant() != null) {\n+                /* update the enum / State channel */\n+                setChannelValue(channelId, pfv.getRawValueLong()); // pfv.getEnumVariant().getText(lang));", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTI0NzgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571247827", "bodyText": "it can not only, it shall be removed \ud83d\ude00", "author": "ramack", "createdAt": "2021-02-05T21:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NDA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570564084", "bodyText": "Fields should be placed at the top of the class.", "author": "fwolter", "createdAt": "2021-02-04T21:44:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    public ResolDeviceDiscoveryService() throws IllegalArgumentException {\n+        super(Set.of(ResolBindingConstants.THING_TYPE_UID_DEVICE), 15, false);\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDeviceDiscoveryService.class);\n+\n+    private @Nullable ResolBridgeHandler resolBridgeHandler;", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NDgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570564814", "bodyText": "This should be cancelled if stopScan() is invoked.", "author": "fwolter", "createdAt": "2021-02-04T21:45:30Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(this::searchRunnable);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570565391", "bodyText": "Better make ipAddress a constant.", "author": "fwolter", "createdAt": "2021-02-04T21:46:26Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+            for (TcpDataSource ds : dataSources) {\n+                InetAddress address = ds.getAddress();\n+                String addressId = address.getHostAddress();\n+                TcpDataSource dsWithInfo;\n+                try {\n+                    dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                    logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                            dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                    currentDataSourceById.put(addressId, dsWithInfo);\n+                    addAdapter(addressId, dsWithInfo);\n+                    // here we can add the detection of Multi-Channel interfaces like DL3\n+                } catch (IOException ex) {\n+                    /* address is no valid adapter */\n+                }\n+\n+            }\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Could not resolve IPv4 broadcast address\");\n+        }\n+    }\n+\n+    private void addAdapter(String remoteIP, TcpDataSource dsWithInfo) {\n+        String adapterSerial = dsWithInfo.getSerial();\n+        Map<String, Object> properties = new HashMap<>(3);\n+        properties.put(\"ipAddress\", remoteIP);\n+        properties.put(\"port\", dsWithInfo.getLivePort());\n+        properties.put(\"adapterSerial\", adapterSerial);\n+\n+        ThingUID uid = new ThingUID(ResolBindingConstants.THING_TYPE_UID_BRIDGE, adapterSerial);\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"ipAddress\")", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570565502", "bodyText": "Better make type a constant.", "author": "fwolter", "createdAt": "2021-02-04T21:46:38Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    public ResolDeviceDiscoveryService() throws IllegalArgumentException {\n+        super(Set.of(ResolBindingConstants.THING_TYPE_UID_DEVICE), 15, false);\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDeviceDiscoveryService.class);\n+\n+    private @Nullable ResolBridgeHandler resolBridgeHandler;\n+\n+    public void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withRepresentationProperty(\"type\").withProperties(properties).withLabel(name).build();", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570566236", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.resol.description = Verbinded Solar- und Systemregler des Herstellers Resol und vielen die f\u00fcr andere Marken von Resol produziert werden.\n          \n          \n            \n            binding.resol.description = Verbindet Solar- und Systemregler des Herstellers Resol und weitere, die f\u00fcr andere Marken von Resol produziert werden.", "author": "fwolter", "createdAt": "2021-02-04T21:47:53Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/i18n/resol_de.properties", "diffHunk": "@@ -0,0 +1,45 @@\n+# binding\n+binding.resol.name = Resol Binding\n+binding.resol.description = Verbinded Solar- und Systemregler des Herstellers Resol und vielen die f\u00fcr andere Marken von Resol produziert werden.", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NzA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570567068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.config.resol.vbuslan.refreshInterval.label = Aktualisierungsinterval\n          \n          \n            \n            thing-type.config.resol.vbuslan.refreshInterval.label = Aktualisierungsintervall", "author": "fwolter", "createdAt": "2021-02-04T21:49:21Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/i18n/resol_de.properties", "diffHunk": "@@ -0,0 +1,45 @@\n+# binding\n+binding.resol.name = Resol Binding\n+binding.resol.description = Verbinded Solar- und Systemregler des Herstellers Resol und vielen die f\u00fcr andere Marken von Resol produziert werden.\n+\n+# thing types\n+thing-type.resol.device.label = Resol Ger\u00e4t\n+thing-type.resol.device.description = Solar- oder Systemregler oder ein anderes Ger\u00e4t welches mit dem Resol VBus verbunden ist.\n+thing-type.resol.emulatedEM.label = Emuliertes EM Modul\n+thing-type.resol.emulatedEM.description = Emulation eines Erweiterungs-Modules (EM) welches \u00fcber den VBus an daf\u00fcr ausgelegten Resol Reglern angebunden wird. Es ersetzt ein physikalisch vorhandenes EM durch openHAB.\n+thing-type.resol.vbuslan.label = VBusLAN Adapter\n+thing-type.resol.vbuslan.description = Diese bridge verwendet ein Ger\u00e4t mit TCP/IP live port als Schnittstelle zum Resol VBus. Dies kann als eigenst\u00e4ndiger VBus-LAN Adapter aber auch ein andere Ger\u00e4t mit integriertem VBus live port wie einem KM2, DL2/3 oder sonstiges sein.\n+.\n+# thing type config description\n+# thing-type.config.resol.device does not have configuration parameters\n+thing-type.config.resol.emulatedEM.deviceId.label = Modul ID\n+thing-type.config.resol.emulatedEM.deviceId.description = Subaddress des emulierten EM Moduls. Der verwendbare Bereich h\u00e4ngt vom verwendeten Regler ab.\n+thing-type.config.resol.vbuslan.ipAddress.label = IP-Adresse\n+thing-type.config.resol.vbuslan.ipAddress.description = IP-Adresse der VBus-LAN Schnittstelle.\n+thing-type.config.resol.vbuslan.port.label = Live Data Port\n+thing-type.config.resol.vbuslan.port.description = TCP-Port der Live-Data-Schnittstelle des VBus Gateways.\n+thing-type.config.resol.vbuslan.adapterSerial.label = Adapter Seriennummer\n+thing-type.config.resol.vbuslan.adapterSerial.description = Seriennummer des VBus-LAN-Schnittstellenger\u00e4tes (nur zur Information).\n+thing-type.config.resol.vbuslan.password.label = Passwort\n+thing-type.config.resol.vbuslan.password.description = Passwort f\u00fcr die VBus-LAN Schnittstelle.\n+thing-type.config.resol.vbuslan.refreshInterval.label = Aktualisierungsinterval", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NzE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570567144", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.config.resol.vbuslan.refreshInterval.description = Zeitinterval in Sekunden um die Verbindung zur VBus-LAN-Schnittstelle zu pr\u00fcfen. Die Aktualisierung der Daten geschieht unabh\u00e4ngig hiervon sobald sie auf dem VBus empfangen werden.\n          \n          \n            \n            thing-type.config.resol.vbuslan.refreshInterval.description = Zeitintervall in Sekunden um die Verbindung zur VBus-LAN-Schnittstelle zu pr\u00fcfen. Die Aktualisierung der Daten geschieht unabh\u00e4ngig hiervon sobald sie auf dem VBus empfangen werden.", "author": "fwolter", "createdAt": "2021-02-04T21:49:30Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/i18n/resol_de.properties", "diffHunk": "@@ -0,0 +1,45 @@\n+# binding\n+binding.resol.name = Resol Binding\n+binding.resol.description = Verbinded Solar- und Systemregler des Herstellers Resol und vielen die f\u00fcr andere Marken von Resol produziert werden.\n+\n+# thing types\n+thing-type.resol.device.label = Resol Ger\u00e4t\n+thing-type.resol.device.description = Solar- oder Systemregler oder ein anderes Ger\u00e4t welches mit dem Resol VBus verbunden ist.\n+thing-type.resol.emulatedEM.label = Emuliertes EM Modul\n+thing-type.resol.emulatedEM.description = Emulation eines Erweiterungs-Modules (EM) welches \u00fcber den VBus an daf\u00fcr ausgelegten Resol Reglern angebunden wird. Es ersetzt ein physikalisch vorhandenes EM durch openHAB.\n+thing-type.resol.vbuslan.label = VBusLAN Adapter\n+thing-type.resol.vbuslan.description = Diese bridge verwendet ein Ger\u00e4t mit TCP/IP live port als Schnittstelle zum Resol VBus. Dies kann als eigenst\u00e4ndiger VBus-LAN Adapter aber auch ein andere Ger\u00e4t mit integriertem VBus live port wie einem KM2, DL2/3 oder sonstiges sein.\n+.\n+# thing type config description\n+# thing-type.config.resol.device does not have configuration parameters\n+thing-type.config.resol.emulatedEM.deviceId.label = Modul ID\n+thing-type.config.resol.emulatedEM.deviceId.description = Subaddress des emulierten EM Moduls. Der verwendbare Bereich h\u00e4ngt vom verwendeten Regler ab.\n+thing-type.config.resol.vbuslan.ipAddress.label = IP-Adresse\n+thing-type.config.resol.vbuslan.ipAddress.description = IP-Adresse der VBus-LAN Schnittstelle.\n+thing-type.config.resol.vbuslan.port.label = Live Data Port\n+thing-type.config.resol.vbuslan.port.description = TCP-Port der Live-Data-Schnittstelle des VBus Gateways.\n+thing-type.config.resol.vbuslan.adapterSerial.label = Adapter Seriennummer\n+thing-type.config.resol.vbuslan.adapterSerial.description = Seriennummer des VBus-LAN-Schnittstellenger\u00e4tes (nur zur Information).\n+thing-type.config.resol.vbuslan.password.label = Passwort\n+thing-type.config.resol.vbuslan.password.description = Passwort f\u00fcr die VBus-LAN Schnittstelle.\n+thing-type.config.resol.vbuslan.refreshInterval.label = Aktualisierungsinterval\n+thing-type.config.resol.vbuslan.refreshInterval.description = Zeitinterval in Sekunden um die Verbindung zur VBus-LAN-Schnittstelle zu pr\u00fcfen. Die Aktualisierung der Daten geschieht unabh\u00e4ngig hiervon sobald sie auf dem VBus empfangen werden.", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2Nzg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570567867", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\topenHAB independent from this setting as soon as the are received on the VBus.</description>\n          \n          \n            \n            \t\t\t\t\topenHAB independently from this setting as soon as they are received on the VBus.</description>", "author": "fwolter", "createdAt": "2021-02-04T21:50:50Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN Adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter which can be any device with a TCP/IP live port, either\n+\t\t\tthe standalone device VBus-LAN Adapter, KM2, DL2/3 or similar.\n+\t\t</description>\n+\t\t<representation-property>ipAddress</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN gateway.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<label>Live Data Port</label>\n+\t\t\t\t<description>Port for live data on the VBUS-LAN gateway.</description>\n+\t\t\t\t<default>7053</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"adapterSerial\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Adapter Serial Number</label>\n+\t\t\t\t<description>The serial number of the adapter (informative).</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>The password for the VBusLAN connection.</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" min=\"5\" max=\"1800\" unit=\"s\">\n+\t\t\t\t<context>refresh</context>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Refresh time in seconds to check the connection to the VBus gateway. Data updates are propagated to\n+\t\t\t\t\topenHAB independent from this setting as soon as the are received on the VBus.</description>", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da565c563c24e29007c9ee5877916fd49b175527", "url": "https://github.com/openhab/openhab-addons/commit/da565c563c24e29007c9ee5877916fd49b175527", "message": "Update bundles/org.openhab.binding.resol/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T20:22:10Z", "type": "forcePushed"}, {"oid": "906f0f7d00b63050bbc9e0d650314b6d97663e7d", "url": "https://github.com/openhab/openhab-addons/commit/906f0f7d00b63050bbc9e0d650314b6d97663e7d", "message": "swap to OH3, improve docs and some minor fixes\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "0b7efbf4ae71312d78fd51669be4101e57469362", "url": "https://github.com/openhab/openhab-addons/commit/0b7efbf4ae71312d78fd51669be4101e57469362", "message": "fix typos\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "2a174df64c2675f03f93371faacd66766d9807e8", "url": "https://github.com/openhab/openhab-addons/commit/2a174df64c2675f03f93371faacd66766d9807e8", "message": "first version with EM emulation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "dca50edf01387832f89d06563e6568d4ec405426", "url": "https://github.com/openhab/openhab-addons/commit/dca50edf01387832f89d06563e6568d4ec405426", "message": "bump version and remove useless logging\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "be63c2cef2e7475a7dfe8b44a394cf78ff708360", "url": "https://github.com/openhab/openhab-addons/commit/be63c2cef2e7475a7dfe8b44a394cf78ff708360", "message": "improve logging, threadsafety and detection of special values\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "d9a5ed6e7db3bc16214c7b9070f268a0fb8a53fa", "url": "https://github.com/openhab/openhab-addons/commit/d9a5ed6e7db3bc16214c7b9070f268a0fb8a53fa", "message": "bump version, remove resource file which is included in the mvn dependency, rework from reviews and finalize Emulated EM with BAD support\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "a36cb66970e8a319616b8c47dcaf127008982ab4", "url": "https://github.com/openhab/openhab-addons/commit/a36cb66970e8a319616b8c47dcaf127008982ab4", "message": "fix style errors\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "f3b363a0308a44d7a9ea3f901be6189cd1d89bab", "url": "https://github.com/openhab/openhab-addons/commit/f3b363a0308a44d7a9ea3f901be6189cd1d89bab", "message": "use state options for enum values\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "19af86c98af764575a97029b12f28f8858915428", "url": "https://github.com/openhab/openhab-addons/commit/19af86c98af764575a97029b12f28f8858915428", "message": "inject LocaleProvider in constructor\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "8f893f0531f743f9c60d349f0c7abb06488fb1eb", "url": "https://github.com/openhab/openhab-addons/commit/8f893f0531f743f9c60d349f0c7abb06488fb1eb", "message": "add representation-property\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "e8e78bf0086e1bc83d4e48d719fe6d3140579090", "url": "https://github.com/openhab/openhab-addons/commit/e8e78bf0086e1bc83d4e48d719fe6d3140579090", "message": "update documentation and German translation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "5f64874d3ab01aa6fcdca8f3e15f61423e4793bc", "url": "https://github.com/openhab/openhab-addons/commit/5f64874d3ab01aa6fcdca8f3e15f61423e4793bc", "message": "make the BAS mode a state with options\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "3849287e24bdd8f213016c76949106f7c1219624", "url": "https://github.com/openhab/openhab-addons/commit/3849287e24bdd8f213016c76949106f7c1219624", "message": "implement the thing discovery as ThingHandlerService\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "ae9d68ef3b3ec5ccb7bbfd1abbecd79095591304", "url": "https://github.com/openhab/openhab-addons/commit/ae9d68ef3b3ec5ccb7bbfd1abbecd79095591304", "message": "bump version\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "a385bdeeb783c74b19686713ea03c2989d60dacd", "url": "https://github.com/openhab/openhab-addons/commit/a385bdeeb783c74b19686713ea03c2989d60dacd", "message": "refactor and improve the design by moving the work into ThingHandlers and more rewort from the review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "a790f286f7e6b035476db5c7cd3121b215ec1922", "url": "https://github.com/openhab/openhab-addons/commit/a790f286f7e6b035476db5c7cd3121b215ec1922", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "0085f144bf750058e42b9d11c5a5ea85cba4fa67", "url": "https://github.com/openhab/openhab-addons/commit/0085f144bf750058e42b9d11c5a5ea85cba4fa67", "message": "fix typo in translation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "68a09453342ead392f7ae47b75d2bf67fe3ee2ad", "url": "https://github.com/openhab/openhab-addons/commit/68a09453342ead392f7ae47b75d2bf67fe3ee2ad", "message": "add missing translation for state options\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "89d890c443d40862480fb4866e94a0a64c2eb9f9", "url": "https://github.com/openhab/openhab-addons/commit/89d890c443d40862480fb4866e94a0a64c2eb9f9", "message": "fix channel names in README\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "7895616c8c977c4652120a3979d89d082c498f12", "url": "https://github.com/openhab/openhab-addons/commit/7895616c8c977c4652120a3979d89d082c498f12", "message": "Update bundles/org.openhab.binding.resol/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "57f1835919feef6549c5774231d35fccaff5fe1d", "url": "https://github.com/openhab/openhab-addons/commit/57f1835919feef6549c5774231d35fccaff5fe1d", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "57f1835919feef6549c5774231d35fccaff5fe1d", "url": "https://github.com/openhab/openhab-addons/commit/57f1835919feef6549c5774231d35fccaff5fe1d", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "forcePushed"}, {"oid": "102ef689eadbcf16adae4029cda440bd43bdf18f", "url": "https://github.com/openhab/openhab-addons/commit/102ef689eadbcf16adae4029cda440bd43bdf18f", "message": "further rework and reduce visibilibty of some methods\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T09:38:55Z", "type": "commit"}, {"oid": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "url": "https://github.com/openhab/openhab-addons/commit/e3977c70f3b4268e9494d9989cf1167c9de57cf9", "message": "fix typo\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T16:23:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571645609", "bodyText": "What is the meaning of the value of 888.8\u00b0C? You could log a warning if the unit cannot be converted. This occurs if the user sent an invalid command.", "author": "fwolter", "createdAt": "2021-02-07T16:51:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NzI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571647258", "bodyText": "888.8 is used in the VBUS in case of not available values - e. g. if the sensor wire would be broken. So in my eyes it fits quite well to the illegal input case here.", "author": "ramack", "createdAt": "2021-02-07T17:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY1MTIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571651213", "bodyText": "Me as a user would be happy about a hint what went wrong. I leave it up to you how to handle that case.", "author": "fwolter", "createdAt": "2021-02-07T17:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571645734", "bodyText": "As it is a constant now, the name should be all upper case.", "author": "fwolter", "createdAt": "2021-02-07T16:53:15Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NjIwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571646206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.resol.description = Verbindet Solar- und Systemregler des Herstellers Resol und weiteren, die f\u00fcr andere Marken von Resol produziert werden.\n          \n          \n            \n            binding.resol.description = Verbindet Solar- und Systemregler des Herstellers Resol und weitere, die f\u00fcr andere Marken von Resol produziert werden.", "author": "fwolter", "createdAt": "2021-02-07T16:57:04Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/i18n/resol_de.properties", "diffHunk": "@@ -0,0 +1,45 @@\n+# binding\n+binding.resol.name = Resol Binding\n+binding.resol.description = Verbindet Solar- und Systemregler des Herstellers Resol und weiteren, die f\u00fcr andere Marken von Resol produziert werden.", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NjM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571646362", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\topenHAB independently from this setting as soon as the are received on the VBus.</description>\n          \n          \n            \n            \t\t\t\t\topenHAB independently from this setting as soon as they are received on the VBus.</description>", "author": "fwolter", "createdAt": "2021-02-07T16:58:04Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN Adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter which can be any device with a TCP/IP live port, either\n+\t\t\tthe standalone device VBus-LAN Adapter, KM2, DL2/3 or similar.\n+\t\t</description>\n+\t\t<representation-property>ipAddress</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN gateway.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<label>Live Data Port</label>\n+\t\t\t\t<description>Port for live data on the VBUS-LAN gateway.</description>\n+\t\t\t\t<default>7053</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"adapterSerial\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Adapter Serial Number</label>\n+\t\t\t\t<description>The serial number of the adapter (informative).</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>The password for the VBusLAN connection.</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" min=\"5\" max=\"1800\" unit=\"s\">\n+\t\t\t\t<context>refresh</context>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Refresh time in seconds to check the connection to the VBus gateway. Data updates are propagated to\n+\t\t\t\t\topenHAB independently from this setting as soon as the are received on the VBus.</description>", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "52b1d0663a6639a30907fd78636fe850b62644d9", "url": "https://github.com/openhab/openhab-addons/commit/52b1d0663a6639a30907fd78636fe850b62644d9", "message": "rework from review: fix typos, make constant upper case\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T17:10:54Z", "type": "commit"}, {"oid": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "url": "https://github.com/openhab/openhab-addons/commit/188f95e41f90cc591e83636f52cbed2f1d2173e3", "message": "rework checkstyle warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T19:14:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577342235", "bodyText": "This should be part of static initialization.", "author": "cpmeister", "createdAt": "2021-02-17T05:50:00Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\n+            DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        synchronized (DATE_FORMAT) {\n+            DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        }", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM1NjkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577356911", "bodyText": "makes sense, yes. But do I need to keep the synchronized block in the static initializer? Without having that deep experience in Java I would expect, that the static init is ensured to be executed completely before any other thread accesses methods of objects of this class. - Is that true, or should I keep the synchronized even there?", "author": "ramack", "createdAt": "2021-02-17T06:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4ODYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584188611", "bodyText": "@cpmeister any more comment on this one? Keep the synchronized in the static initialization or is it not needed there?", "author": "ramack", "createdAt": "2021-02-27T20:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585210318", "bodyText": "The synchronized isn't needed here but synchronizing access to the SimpleDateFormat sets a good precedent since few realize that it isn't thread-safe in general. Keep or remove it I'm fine either way.", "author": "cpmeister", "createdAt": "2021-03-02T02:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577344232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n          \n          \n            \n                        Map<String, TcpDataSource> currentDataSourceById = new HashMap<>();", "author": "cpmeister", "createdAt": "2021-02-17T05:55:50Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        discoveryRunning = false;\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NDQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577344412", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean discoveryRunning = false;\n          \n          \n            \n                private volatile boolean discoveryRunning = false;", "author": "cpmeister", "createdAt": "2021-02-17T05:56:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private boolean discoveryRunning = false;", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NTQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577345495", "bodyText": "There are only 5 relays?", "author": "cpmeister", "createdAt": "2021-02-17T05:59:11Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated EM Device</label>\n+\t\t<description>Emulation of an Extension Module (EM) device which can be connected through the VBUS to Resol controllers\n+\t\t\twhich support the EM devices. Replaces a physically available EM by openHAB.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"relay_1\" typeId=\"relay\"/>\n+\t\t\t<channel id=\"relay_2\" typeId=\"relay\"/>\n+\t\t\t<channel id=\"relay_3\" typeId=\"relay\"/>\n+\t\t\t<channel id=\"relay_4\" typeId=\"relay\"/>\n+\t\t\t<channel id=\"relay_5\" typeId=\"relay\"/>", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM1NzY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577357668", "bodyText": "yes per EM there are 6 sensors inputs and 5 relays on EM devices.", "author": "ramack", "createdAt": "2021-02-17T06:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577346220", "bodyText": "The @Component annotation isn't compatible with ThingHandlerService atm.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class)\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {", "author": "cpmeister", "createdAt": "2021-02-17T06:01:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM3NDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577374437", "bodyText": "The code looks pretty good to be honest. Only a few changes I'd suggest.\n\nThanks, that is due to the valuable review comments from @fwolter and @Hilbrand!", "author": "ramack", "createdAt": "2021-02-17T07:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577346561", "bodyText": "Is there a reason this needs to be package private?", "author": "cpmeister", "createdAt": "2021-02-17T06:02:25Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM2OTk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577369978", "bodyText": "no, and we even can get rid of this completely.", "author": "ramack", "createdAt": "2021-02-17T07:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjU2MQ=="}], "type": "inlineReview"}, {"oid": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "url": "https://github.com/openhab/openhab-addons/commit/7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-17T07:06:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzMjEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r561332104", "bodyText": "context refresh doesn't exist. Please remove. See https://www.openhab.org/docs/developer/bindings/config-xml.html#xml-structure-for-configuration-descriptions", "author": "Hilbrand", "createdAt": "2021-01-20T21:54:14Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,40 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<bridge-type id=\"vbuslan\">\n+\t\t<label>Bridge VBusLAN Adapter</label>\n+\t\t<description>This bridge represents the Resol VBus-LAN adapter which can be any device with a TCP/IP live port, either the standalone device VBus-LAN Adapter, KM2, DL2/3 or similar.\n+\t\t</description>\n+        <representation-property>ipAddress</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>The IP address of the of the VBus-LAN gateway.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\" min=\"1024\" max=\"65535\">\n+\t\t\t\t<label>Live Data Port</label>\n+\t\t\t\t<description>Port for live data on the VBUS-LAN gateway.</description>\n+\t\t\t\t<default>7053</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"adapterSerial\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Adapter Serial Number</label>\n+\t\t\t\t<description>The serial number of the adapter (informative).</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>The password for the VBusLAN connection.</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" min=\"5\" max=\"1800\" unit=\"s\">\n+\t\t\t\t<context>refresh</context>", "originalCommit": "f80f22f6b929c6afd58a23ae05f281597142fb17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577914900", "bodyText": "Why update the channels here? at this point it gets a command because the value of the channel changed. So this update changes the value to the value the channel already contains? So it seems redundant to do this.", "author": "Hilbrand", "createdAt": "2021-02-17T20:17:12Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;\n+        }\n+\n+        if (update) {\n+            EmDeviceEmulator dev = device;\n+            if (dev != null) {\n+                if (chID.startsWith(CHANNEL_TEMP)) {\n+                    dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                    if (intValue == 0) {\n+                        /* switch is open => 1 megaohm */\n+                        dev.setResistorValueByNr(channel, 1000000000);\n+                        updateState(channelUID, OnOffType.OFF);", "originalCommit": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkyNzQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577927463", "bodyText": "I added these updates, because otherwise the MainUI did not correctly update the view (of the widget I tried with). Maybe I just did something wrong as I am not yet used to MainUI or whatever. Let me know if I should remove it.", "author": "ramack", "createdAt": "2021-02-17T20:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4ODkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584188910", "bodyText": "@Hilbrand any remark on that? - I have added the update here to have the MainUI showing the update. Should I remove it?", "author": "ramack", "createdAt": "2021-02-27T20:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNjgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577916817", "bodyText": "These fields can be final", "author": "Hilbrand", "createdAt": "2021-02-17T20:20:14Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private LocaleProvider localeProvider;", "originalCommit": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxOTE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577919157", "bodyText": "You can give the enumerated channels a label so they are better recognizable in the ui:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<channel id=\"relay_1\" typeId=\"relay\"/>\n          \n          \n            \n            \t\t\t<channel id=\"relay_1\" typeId=\"relay\">\n          \n          \n            \n            \t\t\t    <label>Relay 1</label>\n          \n          \n            \n            \t\t\t</channel>", "author": "Hilbrand", "createdAt": "2021-02-17T20:24:24Z", "path": "bundles/org.openhab.binding.resol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"resol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Resol Device</label>\n+\t\t<description>Solar or system controller (or any other real device on the VBus) from Resol.</description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"emulatedEM\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"vbuslan\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Emulated EM Device</label>\n+\t\t<description>Emulation of an Extension Module (EM) device which can be connected through the VBUS to Resol controllers\n+\t\t\twhich support the EM devices. Replaces a physically available EM by openHAB.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"relay_1\" typeId=\"relay\"/>", "originalCommit": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkzMDU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577930545", "bodyText": "ok, should in this case the Label in the channel-type be removed?", "author": "ramack", "createdAt": "2021-02-17T20:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxOTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4OTA3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584189073", "bodyText": "I have added the individual labels, but should the label in the channel-type stay as it is never used now?", "author": "ramack", "createdAt": "2021-02-27T20:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxOTE1Nw=="}], "type": "inlineReview"}, {"oid": "10373f36be67c9514348b055fc7b91ff4a314eb1", "url": "https://github.com/openhab/openhab-addons/commit/10373f36be67c9514348b055fc7b91ff4a314eb1", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-17T21:48:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583073133", "bodyText": "Since the locale can be changed during runtime, it would be better to retrieve locale information from the provider on demand instead of trying to cache it in fields.", "author": "cpmeister", "createdAt": "2021-02-25T18:37:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIxODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583218545", "bodyText": "Is it worth to increase the depth of the call tree for each received packet for checking the locale only for this rather seldom use case? As a user, I personally would favor runtime performance over this. Or is there at least a callback that I can register to get notified on the locale update?", "author": "ramack", "createdAt": "2021-02-25T21:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MDgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583970818", "bodyText": "The performance impact would be negligible and would allow the user to change the locale in openhab without having to restart your binding.\nThat said I don't know what the performance impact of calling SpecificationFile.getLanguageForLocale would be. So it might be worth caching the return value from that method and only changing it when the returned locale from the provider changes.", "author": "cpmeister", "createdAt": "2021-02-26T22:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4NzYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584187628", "bodyText": "SpecificationFile.getLanguageForLocale looks also quite fast, so I changed to read the locale dynamically.", "author": "ramack", "createdAt": "2021-02-27T20:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583080218", "bodyText": "I second @fwolter's recommendation to cancel the async task with an interrupt when stopScan is called. Setting discoveryRunning = false is not sufficient.", "author": "cpmeister", "createdAt": "2021-02-25T18:47:08Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private volatile boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwNjcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583206713", "bodyText": "Can you point me to an example? Since I was requested to use directly the execute() with the method as parameter I don't have any object anymore that could be canceled...", "author": "ramack", "createdAt": "2021-02-25T21:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MTExMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583971113", "bodyText": "If you use submit instead then it would return a Future which you could store to a field and then cancel that future as part of stopScan.", "author": "cpmeister", "createdAt": "2021-02-26T23:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583081394", "bodyText": "You should make sure to exit early if you catch an InterruptedIOException.", "author": "cpmeister", "createdAt": "2021-02-25T18:48:54Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private volatile boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        discoveryRunning = false;\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            Map<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+            for (TcpDataSource ds : dataSources) {\n+                if (!discoveryRunning) {\n+                    break;\n+                }\n+                InetAddress address = ds.getAddress();\n+                String addressId = address.getHostAddress();\n+                TcpDataSource dsWithInfo;\n+                try {\n+                    dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                    logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                            dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                    currentDataSourceById.put(addressId, dsWithInfo);\n+                    addAdapter(addressId, dsWithInfo);\n+                    // here we can add the detection of Multi-Channel interfaces like DL3\n+                } catch (IOException ex) {\n+                    /* address is no valid adapter */\n+                }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwNzc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583207781", "bodyText": "you mean by adding a break statement?", "author": "ramack", "createdAt": "2021-02-25T21:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIyMzYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583223616", "bodyText": "and why should we even? If for one of the TcpDataSource's that we get from the discovery in the library one is faulty, why should we not try the next one?", "author": "ramack", "createdAt": "2021-02-25T21:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MzQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583973421", "bodyText": "I meant that you should add an extra catch statement for InterruptedIOException which is a type of IOException which is thrown when the thread doing IO is interrupted. The reason for requiring this is to make sure that the thread actually exits as fast as possible when an interrupt occurs. When a thread receives and interrupts it should be assumed that the system is trying to shutdown and typically complete shutdown can't occur until all of the non-daemon threads have stopped running. Since the running thread might be non-daemon it prevent the system from shutting down as long as it is running.", "author": "cpmeister", "createdAt": "2021-02-26T23:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4OTQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584189472", "bodyText": "ok, this way I think I got it! Thanks for the explanation.", "author": "ramack", "createdAt": "2021-02-27T20:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583082005", "bodyText": "Instead of using an update flag, why not just exit early here?", "author": "cpmeister", "createdAt": "2021-02-25T18:49:47Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwOTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583209669", "bodyText": "By a return you mean? Is that really better or purely a matter of taste?", "author": "ramack", "createdAt": "2021-02-25T21:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk2ODc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583968773", "bodyText": "Well by returning early you don't need to use an update variable. I'd say that less variables would make the code more maintainable.", "author": "cpmeister", "createdAt": "2021-02-26T22:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583082684", "bodyText": "updateJob should be canceled here as well.", "author": "cpmeister", "createdAt": "2021-02-25T18:50:47Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwOTgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583209834", "bodyText": "how do I do that?", "author": "ramack", "createdAt": "2021-02-25T21:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk2ODM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583968353", "bodyText": "You already do the canceling as part of ResolEmuEMThingHandler.stop() so you either need to call that method or make a common method that does the canceling logic and call that instead.", "author": "cpmeister", "createdAt": "2021-02-26T22:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4NDI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583084264", "bodyText": "If this updated anywhere then you should make this final.", "author": "cpmeister", "createdAt": "2021-02-25T18:53:06Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4ODkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583088918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private class BasSetting {\n          \n          \n            \n                private static class BasSetting {", "author": "cpmeister", "createdAt": "2021-02-25T18:59:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583090070", "bodyText": "Can you also handle refresh commands?", "author": "cpmeister", "createdAt": "2021-02-25T19:01:53Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIyMDA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583220062", "bodyText": "I don't think so, as there is no polling mechanism on the VBUS, we have to wait until the packets are transmitted the next time.", "author": "ramack", "createdAt": "2021-02-25T21:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583090982", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n          \n          \n            \n                        return handler;\n          \n          \n            \n                        return new ResolBridgeHandler((Bridge) thing, localeProvider);", "author": "cpmeister", "createdAt": "2021-02-25T19:03:28Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final LocaleProvider localeProvider;\n+\n+    private final ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    @Activate\n+    public ResolHandlerFactory(final @Reference ResolStateDescriptionOptionProvider stateDescriptionProvider,\n+            final @Reference LocaleProvider localeProvider) {\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_DEVICE)) {\n+            return new ResolThingHandler(thing, stateDescriptionProvider);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_EMU_EM)) {\n+            return new ResolEmuEMThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_BRIDGE)) {\n+            ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n+            return handler;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20dad9db5b5f7d0c6b61eca50d9d24b5a0757155", "url": "https://github.com/openhab/openhab-addons/commit/20dad9db5b5f7d0c6b61eca50d9d24b5a0757155", "message": "further rework\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-25T21:41:09Z", "type": "commit"}, {"oid": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "url": "https://github.com/openhab/openhab-addons/commit/811349f225a2305270ff073d2ed4f25faf3d7fa1", "message": "further rework\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-27T21:14:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMTYxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585211612", "bodyText": "You should make sure that the quantity channels are using QuantityType instead of DecimalType.", "author": "cpmeister", "createdAt": "2021-03-02T02:59:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\n+            DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    static {\n+        synchronized (DATE_FORMAT) {\n+            DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        }\n+    }\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolBridgeHandler bridgeHandler = getBridgeHandler();\n+        if (bridgeHandler != null) {\n+            updateStatus(bridgeHandler.getStatus());\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    protected void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, long value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"Number\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value);\n+        } else {\n+            this.updateState(channelId, new StringType(Long.toString(value)));\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            synchronized (DATE_FORMAT) {\n+                this.updateState(channelId, new DateTimeType(DATE_FORMAT.format(value)));\n+            }\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, double value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+            return;\n+        }\n+\n+        String itmType = channel.getAcceptedItemType();\n+        if (itmType != null && itmType.startsWith(\"Number\")) {\n+            this.updateState(channelId, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMjMzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585212335", "bodyText": "You should be using QuantityType here.", "author": "cpmeister", "createdAt": "2021-03-02T03:01:16Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private static class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        ScheduledFuture<?> job = updateJob;\n+        if (job != null) {\n+            job.cancel(true);\n+        }\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+        } else {\n+            /* nothing to do */\n+            return;\n+        }\n+\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            if (chID.startsWith(CHANNEL_TEMP)) {\n+                dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                updateState(channelUID, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMjc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585212742", "bodyText": "and here", "author": "cpmeister", "createdAt": "2021-03-02T03:02:31Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private static class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        ScheduledFuture<?> job = updateJob;\n+        if (job != null) {\n+            job.cancel(true);\n+        }\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+        } else {\n+            /* nothing to do */\n+            return;\n+        }\n+\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            if (chID.startsWith(CHANNEL_TEMP)) {\n+                dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                updateState(channelUID, new DecimalType(value));\n+            } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                if (intValue == 0) {\n+                    /* switch is open => 1 megaohm */\n+                    dev.setResistorValueByNr(channel, 1000000000);\n+                    updateState(channelUID, OnOffType.OFF);\n+                } else {\n+                    /* switch is closed */\n+                    dev.setResistorValueByNr(channel, 0);\n+                    updateState(channelUID, OnOffType.ON);\n+                }\n+            } else if (chID.startsWith(CHANNEL_RESIST)) {\n+                dev.setResistorValueByNr(channel, (int) (value * 1000.0));\n+                updateState(channelUID, new QuantityType<>(intValue, Units.OHM));\n+            } else if (chID.startsWith(CHANNEL_TEMP_ADJUST)) {\n+                basValues[channel - 1].temperatureOffset = value;\n+                updateBas(channel);\n+                updateState(channelUID, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1afec52f316203b281ecf811c622c12646fd729a", "url": "https://github.com/openhab/openhab-addons/commit/1afec52f316203b281ecf811c622c12646fd729a", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:20:55Z", "type": "forcePushed"}, {"oid": "bcfff1edd846e8ac5b4be48d276da663ed2ae821", "url": "https://github.com/openhab/openhab-addons/commit/bcfff1edd846e8ac5b4be48d276da663ed2ae821", "message": "use UoM\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:25:59Z", "type": "commit"}, {"oid": "bcfff1edd846e8ac5b4be48d276da663ed2ae821", "url": "https://github.com/openhab/openhab-addons/commit/bcfff1edd846e8ac5b4be48d276da663ed2ae821", "message": "use UoM\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:25:59Z", "type": "forcePushed"}]}