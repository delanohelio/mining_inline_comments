{"pr_number": 8669, "pr_title": "[WLed]  Initial contribution - Binding for LED strings with a large range of built in FX.", "pr_createdAt": "2020-10-05T10:19:05Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8669", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4Njk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504086990", "bodyText": "As this is not binding related, you could instead add a link to https://www.openhab.org/docs/administration/logging.html#defining-what-to-log", "author": "fwolter", "createdAt": "2020-10-13T16:21:43Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5NzA0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506797048", "bodyText": "DONE: Removed the entire section.", "author": "Skinah", "createdAt": "2020-10-17T05:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4Njk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4ODE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504088155", "bodyText": "Can you mention the time unit?", "author": "fwolter", "createdAt": "2020-10-13T16:22:50Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |\n+| `pollTime`| How often you want the states of the LED fetched in case you make changes with a non openHAB app, web browser, or the light is auto changing FX or presets. |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5NzQxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506797411", "bodyText": "DONE.", "author": "Skinah", "createdAt": "2020-10-17T05:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4ODE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4OTYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504089613", "bodyText": "Can you add a required/optional and a default value column?", "author": "fwolter", "createdAt": "2020-10-13T16:24:17Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5ODY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506798651", "bodyText": "Done", "author": "Skinah", "createdAt": "2020-10-17T05:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4OTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MjE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504092173", "bodyText": "Are these read-only Channels? In which case do they differ from one WLED to another?", "author": "fwolter", "createdAt": "2020-10-13T16:27:14Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |\n+| `pollTime`| How often you want the states of the LED fetched in case you make changes with a non openHAB app, web browser, or the light is auto changing FX or presets. |\n+| `saturationThreshold` | Allows you to use a colorpicker control linked to the `masterControls` channel to trigger only using the pure white LEDs when your using RGBW strings instead of creating fake white light from the RGB channels. Try setting the value to 12 or for RGB strings, leave this on 0. |\n+\n+## Channels\n+\n+| Channel | Type | Description |\n+|-|-|-|\n+| `masterControls` | Color | Gives you control over the WLED like it is any normal light. Tag this control for Alexa or Google/Nest to change the lights instantly to any colour, brightness or on/off state that you ask for regardless of what mode the light is in. |\n+| `primaryColor` | Color | The primary colour used in FX. |\n+| `primaryWhite` | Dimmer | The amount of white light used in the primary colour if you have RGBW LEDs. |\n+| `secondaryColor` | Color | The secondary colour used in FX. |\n+| `secondaryWhite` | Dimmer | The amount of white light used in the secondary colour if you have RGBW LEDs. |\n+| `palettes` | String | A list of colour palettes you can select from that are used in the FX. |\n+| `fx` | String |  A list of Effects you can select from. |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgwMDIzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506800230", "bodyText": "No they are not read only as I use them from SELECTION drop down lists on my sitemap. They can display the current STATE and they can also send COMMAND to change the light. They can be different if the light has different firmware loaded, usually every firmware adds more FX and this binding will scrape and auto match the firmware's list.", "author": "Skinah", "createdAt": "2020-10-17T05:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MjMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504092337", "bodyText": "Same question as above.", "author": "fwolter", "createdAt": "2020-10-13T16:27:30Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |\n+| `pollTime`| How often you want the states of the LED fetched in case you make changes with a non openHAB app, web browser, or the light is auto changing FX or presets. |\n+| `saturationThreshold` | Allows you to use a colorpicker control linked to the `masterControls` channel to trigger only using the pure white LEDs when your using RGBW strings instead of creating fake white light from the RGB channels. Try setting the value to 12 or for RGB strings, leave this on 0. |\n+\n+## Channels\n+\n+| Channel | Type | Description |\n+|-|-|-|\n+| `masterControls` | Color | Gives you control over the WLED like it is any normal light. Tag this control for Alexa or Google/Nest to change the lights instantly to any colour, brightness or on/off state that you ask for regardless of what mode the light is in. |\n+| `primaryColor` | Color | The primary colour used in FX. |\n+| `primaryWhite` | Dimmer | The amount of white light used in the primary colour if you have RGBW LEDs. |\n+| `secondaryColor` | Color | The secondary colour used in FX. |\n+| `secondaryWhite` | Dimmer | The amount of white light used in the secondary colour if you have RGBW LEDs. |\n+| `palettes` | String | A list of colour palettes you can select from that are used in the FX. |\n+| `fx` | String |  A list of Effects you can select from. |\n+| `speed` | Dimmer | Changes the speed of the loaded effect. |\n+| `intensity` | Dimmer | Changes the intensity of the loaded effect. |\n+| `presets` | String |  A list of presets that you can select from.  |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgwMTUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506801501", "bodyText": "No they are not read only, they display the STATE and also send COMMANDS.", "author": "Skinah", "createdAt": "2020-10-17T05:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MjMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504093313", "bodyText": "These sound more like QuantityType:Time rather than a Dimmer?", "author": "fwolter", "createdAt": "2020-10-13T16:28:56Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |\n+| `pollTime`| How often you want the states of the LED fetched in case you make changes with a non openHAB app, web browser, or the light is auto changing FX or presets. |\n+| `saturationThreshold` | Allows you to use a colorpicker control linked to the `masterControls` channel to trigger only using the pure white LEDs when your using RGBW strings instead of creating fake white light from the RGB channels. Try setting the value to 12 or for RGB strings, leave this on 0. |\n+\n+## Channels\n+\n+| Channel | Type | Description |\n+|-|-|-|\n+| `masterControls` | Color | Gives you control over the WLED like it is any normal light. Tag this control for Alexa or Google/Nest to change the lights instantly to any colour, brightness or on/off state that you ask for regardless of what mode the light is in. |\n+| `primaryColor` | Color | The primary colour used in FX. |\n+| `primaryWhite` | Dimmer | The amount of white light used in the primary colour if you have RGBW LEDs. |\n+| `secondaryColor` | Color | The secondary colour used in FX. |\n+| `secondaryWhite` | Dimmer | The amount of white light used in the secondary colour if you have RGBW LEDs. |\n+| `palettes` | String | A list of colour palettes you can select from that are used in the FX. |\n+| `fx` | String |  A list of Effects you can select from. |\n+| `speed` | Dimmer | Changes the speed of the loaded effect. |\n+| `intensity` | Dimmer | Changes the intensity of the loaded effect. |\n+| `presets` | String |  A list of presets that you can select from.  |\n+| `presetCycle` | Switch | Turns ON/OFF the automatic changing from one preset to the next. |\n+| `presetDuration` | Dimmer | How long it will display a preset for, before it begins to change from one preset to the next with `presetCycle` turned ON. |\n+| `transformTime` | Dimmer | How long it takes to transform/morph from one look to the next. |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgwNDgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506804834", "bodyText": "Yes they are in seconds (1.5 seconds is valid so not INT based) and the API is 1 way so it only accepts a COMMAND. Is there a good example binding I can peak at for this?", "author": "Skinah", "createdAt": "2020-10-17T05:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507191727", "bodyText": "Sure, org.openhab.binding.modbus.helioseasycontrols uses Number:Time.", "author": "fwolter", "createdAt": "2020-10-18T17:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NDU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r510084571", "bodyText": "DONE, but not sure how you specify the unit the time is in? It works the way I have updated it to and I discovered a very annoying thing about this project. They use milliseconds for the HTTP api and Deci seconds for JSON commands and then use seconds for their UI, grrr lack of consistency.", "author": "Skinah", "createdAt": "2020-10-22T11:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMjEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511022130", "bodyText": "If you send a command via rules, you would send a QuantityType in which you specify the unit.", "author": "fwolter", "createdAt": "2020-10-23T17:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzOTk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511339980", "bodyText": "Thanks, I worked it out\npattern=\"%.1f Second\"\nDoing that solved some errors in the logs when I used the %unit% that other bindings were using in the thing-types.xml", "author": "Skinah", "createdAt": "2020-10-24T08:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511363283", "bodyText": "Actually the symbol is \"s\". See https://www.openhab.org/docs/concepts/units-of-measurement.html#list-of-units\nDoes \"s\" work for you, too?", "author": "fwolter", "createdAt": "2020-10-24T09:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUzODIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511538222", "bodyText": "Thank you for helping with this, I misunderstood this and after a lot and via trial and error, I hope I have it right this time around. It works if '60 s' and '1 min' is sent via a command.", "author": "Skinah", "createdAt": "2020-10-25T02:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504093616", "bodyText": "Does a WLED user know what that mean or how it work?", "author": "fwolter", "createdAt": "2020-10-13T16:29:21Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |\n+| `pollTime`| How often you want the states of the LED fetched in case you make changes with a non openHAB app, web browser, or the light is auto changing FX or presets. |\n+| `saturationThreshold` | Allows you to use a colorpicker control linked to the `masterControls` channel to trigger only using the pure white LEDs when your using RGBW strings instead of creating fake white light from the RGB channels. Try setting the value to 12 or for RGB strings, leave this on 0. |\n+\n+## Channels\n+\n+| Channel | Type | Description |\n+|-|-|-|\n+| `masterControls` | Color | Gives you control over the WLED like it is any normal light. Tag this control for Alexa or Google/Nest to change the lights instantly to any colour, brightness or on/off state that you ask for regardless of what mode the light is in. |\n+| `primaryColor` | Color | The primary colour used in FX. |\n+| `primaryWhite` | Dimmer | The amount of white light used in the primary colour if you have RGBW LEDs. |\n+| `secondaryColor` | Color | The secondary colour used in FX. |\n+| `secondaryWhite` | Dimmer | The amount of white light used in the secondary colour if you have RGBW LEDs. |\n+| `palettes` | String | A list of colour palettes you can select from that are used in the FX. |\n+| `fx` | String |  A list of Effects you can select from. |\n+| `speed` | Dimmer | Changes the speed of the loaded effect. |\n+| `intensity` | Dimmer | Changes the intensity of the loaded effect. |\n+| `presets` | String |  A list of presets that you can select from.  |\n+| `presetCycle` | Switch | Turns ON/OFF the automatic changing from one preset to the next. |\n+| `presetDuration` | Dimmer | How long it will display a preset for, before it begins to change from one preset to the next with `presetCycle` turned ON. |\n+| `transformTime` | Dimmer | How long it takes to transform/morph from one look to the next. |\n+| `sleep` | Switch | Turns on the sleep timer. |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgwNTQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506805457", "bodyText": "Yes. It is a full on project with loads of settings which makes it popular and youtube is full of videos showing the setup and use. The thread on the forum has not turned up any questions on how to use which is good as I really dont want to teach people to use their opensource lights.", "author": "Skinah", "createdAt": "2020-10-17T05:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507191971", "bodyText": "Actually I meant only the sleep Channel, as the description seems a bit non-self explaining.", "author": "fwolter", "createdAt": "2020-10-18T17:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NzMwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r510087308", "bodyText": "Done: Added more info on the sleep timer but it can be setup to do many things. Sleep timer or a night light mode and anywhere in between.", "author": "Skinah", "createdAt": "2020-10-22T11:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5MzYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NDU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504094560", "bodyText": "Can the port be changed by the user and can https be used? If not, you could simply make this an IP address.", "author": "fwolter", "createdAt": "2020-10-13T16:30:47Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding\n+\n+This openHAB binding allows you to auto discover and use LED strings based on the WLED project:\n+<https://github.com/Aircoookie/WLED>\n+\n+## Fault Finding\n+\n+To watch what the binding does you can enter this in to the openHAB console, `log:set TRACE org.openhab.binding.wled` which will allow you to test the same commands in a web browser to determine if it is a bug in the binding, or in the firmware for WLED.\n+Firmware 0.10.2 is working very well with this binding after extensive testing, so if an issue is found please report what firmware version you are using.\n+\n+## Supported Things\n+\n+| Thing Type ID | Description |\n+|-|-|\n+| `wled` | Use this for RGB and RGBW strings. |\n+\n+## Discovery\n+\n+The auto discovery will work with this binding if your network supports mDNS.\n+If it fails to find your WLED, you can manually add a `wled` thing by using the UI or textual methods.\n+The full example section below gives everything needed to quickly setup using textual config.\n+\n+## Thing Configuration\n+\n+| Parameter | Description |\n+|-|-|\n+| `address`| The full URL to your WLED device. Example is `http://192.168.0.2:80` |", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMxMDU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505310571", "bodyText": "This project keeps adding a huge number of features, a kitchen sink is probably planned. Https has been mentioned as possible and planned in ESP32, so whilst it appears to not have the support yet, it is safer to assume at some point it will get added.\n\nmDNS reports the URL that is in the example so no need to change it from what the auto discovery gives.\nI use hostnames as much as possible instead of IP address'\nI have already made the binding accept a plain IP Address should a user enter one in. Both formats work.\n\nI will remove the tag that you suggested in another comment.", "author": "Skinah", "createdAt": "2020-10-15T08:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NDU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNjgzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505716835", "bodyText": "It's a shame that you can't use the UI validation, then. But I don't have a better solution.", "author": "fwolter", "createdAt": "2020-10-15T17:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504095336", "bodyText": "Can you document the ThingActions?", "author": "fwolter", "createdAt": "2020-10-13T16:32:02Z", "path": "bundles/org.openhab.binding.wled/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+# WLED Binding", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgxNDk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506814968", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-17T05:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NTMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NjcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504096720", "bodyText": "Action labes shall be lower case, that you can use them in a sentence. See #8732 (comment)", "author": "fwolter", "createdAt": "2020-10-13T16:34:09Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedActions} is responsible for Actions.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@ThingActionsScope(name = \"wled\")\n+@NonNullByDefault\n+public class WLedActions implements ThingActions {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private @Nullable WLedHandler handler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        this.handler = (WLedHandler) handler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"Save Preset\", description = \"Save a WLED state to a preset location\")", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgxNTIzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506815230", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-17T05:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NjcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5OTEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504099102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n          \n          \n            \n            @Component(service = MDNSDiscoveryParticipant.class)", "author": "fwolter", "createdAt": "2020-10-13T16:36:53Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5OTY4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504099685", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2020-10-13T16:37:28Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String name = service.getName().toLowerCase();\n+        if (!name.equals(\"wled\")) {\n+            return null;\n+        }\n+        String address[] = service.getURLs();\n+        if ((address == null) || address.length < 1) {\n+            logger.debug(\"WLED discovered with empty IP address-{}\", service);\n+            return null;\n+        }\n+        logger.info(\"WLED discovered at {}\", address[0]);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwMTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504101485", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2020-10-13T16:39:06Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, immediate = true)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String name = service.getName().toLowerCase();\n+        if (!name.equals(\"wled\")) {\n+            return null;\n+        }\n+        String address[] = service.getURLs();\n+        if ((address == null) || address.length < 1) {\n+            logger.debug(\"WLED discovered with empty IP address-{}\", service);\n+            return null;\n+        }\n+        logger.info(\"WLED discovered at {}\", address[0]);\n+        ThingTypeUID thingtypeuid = new ThingTypeUID(\"wled\", \"wled\");\n+        ThingUID thingUID = new ThingUID(thingtypeuid,\n+                address[0].substring(7, address[0].length() - 3).replace(\".\", \"-\"));\n+        return DiscoveryResultBuilder.create(thingUID).withProperty(CONFIG_ADDRESS, address[0])\n+                .withLabel(\"WLED @\" + address[0]).build();", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAwMjU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507002570", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-18T01:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwMTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504104761", "bodyText": "Are you sure 3 sec. is sufficient? Many bindings use 10 sec. as timeout.", "author": "fwolter", "createdAt": "2020-10-13T16:42:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMxODQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505318420", "bodyText": "I am happy to use either 10 or 3. I just like 3 seconds as it is more than enough for a device on a local network and you have a faster response to the device going OFFLINE if the power switch is turned off. Otherwise it could be 20 seconds after you turn the light off at the wall that openHAB knows it is offline due to the default 10 second poll and then another 10 for the timeout. If it was talking to remote servers on the web, then I would want 10 seconds.", "author": "Skinah", "createdAt": "2020-10-15T08:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNzQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505717491", "bodyText": "I'm fine with 3 sec. Your arguments are valid.", "author": "fwolter", "createdAt": "2020-10-15T17:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNzkzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504107938", "bodyText": "The interrupted flags gets reset when an interrupted exception is cought. You need to set the flag again by Thread.currentThread().interrupt();, or don't catch the exception here.", "author": "fwolter", "createdAt": "2020-10-13T16:46:26Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4ODA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507088077", "bodyText": "DONE: I added Thread.currentThread().interrupt(); as it feels wrong to throw and not catch.", "author": "Skinah", "createdAt": "2020-10-18T10:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEwNzkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504112017", "bodyText": "If you need to implement a parser like this again, you could take a deeper look into regular expressions. That would make such code much simpler.", "author": "fwolter", "createdAt": "2020-10-13T16:53:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNzk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r505407979", "bodyText": "Thanks for the suggestion it is apricated. Will look into that when I get a spare half hour.", "author": "Skinah", "createdAt": "2020-10-15T09:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMjg1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504112855", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n          \n          \n            \n                    for (String value : getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {", "author": "fwolter", "createdAt": "2020-10-13T16:54:25Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMzM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504113391", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        fxOptions.add(new StateOption(\"\" + counter++, value));\n          \n          \n            \n                        fxOptions.add(new StateOption(Integer.toString(counter++), value));", "author": "fwolter", "createdAt": "2020-10-13T16:55:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504116101", "bodyText": "What's the purpose of the binary AND mask?", "author": "fwolter", "createdAt": "2020-10-13T16:59:36Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzNDA4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507134081", "bodyText": "REMOVED and used your suggestion.", "author": "Skinah", "createdAt": "2020-10-18T12:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNzE5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504117197", "bodyText": "When building strings in loops, StringBuilder should be used. In this case, you could replace the block by something like this return String.format(\"h%06X\", hsb.getRGB());.", "author": "fwolter", "createdAt": "2020-10-13T17:01:24Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzMzY4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507133685", "bodyText": "Added your suggestion and it works, thanks much nicer.", "author": "Skinah", "createdAt": "2020-10-18T12:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504118551", "bodyText": "See above. Logging to info. And below.", "author": "fwolter", "createdAt": "2020-10-13T17:03:46Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgxOTIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506819232", "bodyText": "DONE: removed them all.", "author": "Skinah", "createdAt": "2020-10-17T06:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExOTQ2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504119464", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bigTemp = new BigDecimal(0);\n          \n          \n            \n                                bigTemp = BigDecimal.ZERO;", "author": "fwolter", "createdAt": "2020-10-13T17:05:17Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMDUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504120521", "bodyText": "The ThingHandler provides an ExecutorService you can use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pollingFuture = threadPool.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);\n          \n          \n            \n                    pollingFuture = scheduler.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2020-10-13T17:07:14Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(1);\n+    private BigDecimal masterBrightness = new BigDecimal(0);\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = new BigDecimal(0);\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = new BigDecimal(0);\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request = httpClient.newRequest(config.address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.debug(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : (getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            fxOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        String hex = Integer.toHexString(hsb.getRGB() & 0xffffff);\n+        while (hex.length() < 6) {\n+            hex = \"0\" + hex;\n+        }\n+        return \"h\" + hex;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=2000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=2000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=2000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=2000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=2000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    logger.info(\"OnOffType commands should use masterControls channel\");\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    logger.info(\"IncreaseDecrease commands should use masterControls channel\");\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }\n+                sendGetRequest(\"/win&SX=\" + bigTemp);\n+                break;\n+            case CHANNEL_INTENSITY:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }\n+                sendGetRequest(\"/win&IX=\" + bigTemp);\n+                break;\n+            case CHANNEL_SLEEP:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&ND\");\n+                } else {\n+                    sendGetRequest(\"/win&NL=0\");\n+                }\n+                break;\n+            case CHANNEL_PRESETS:\n+                sendGetRequest(\"/win&PL=\" + command);\n+                break;\n+            case CHANNEL_PRESET_DURATION:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(600)).add(new BigDecimal(500));\n+                }\n+                sendGetRequest(\"/win&PT=\" + bigTemp);\n+                break;\n+            case CHANNEL_TRANS_TIME:\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = new BigDecimal(0);\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(600)).add(new BigDecimal(500));\n+                }\n+                sendGetRequest(\"/win&TT=\" + bigTemp);\n+                break;\n+            case CHANNEL_PRESET_CYCLE:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&CY=1\");\n+                } else {\n+                    sendGetRequest(\"/win&CY=0\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void savePreset(int presetIndex) {\n+        if (presetIndex > 16) {\n+            logger.warn(\"Presets above 16 do not exist, and the action sent {}\", presetIndex);\n+            return;\n+        }\n+        sendGetRequest(\"/win&PS=\" + presetIndex);\n+    }\n+\n+    private void pollLED() {\n+        sendGetRequest(\"/win\");\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WLedConfiguration.class);\n+        if (!config.address.contains(\"://\")) {\n+            logger.debug(\"Address was not entered in correct format, it may be the raw IP so adding http:// to start\");\n+            config.address = \"http://\" + config.address;\n+        }\n+        pollingFuture = threadPool.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504121612", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<feature name=\"openhab-binding-wled\" description=\"WLed Binding\" version=\"${project.version}\">\n          \n          \n            \n            \t<feature name=\"openhab-binding-wled\" description=\"WLED Binding\" version=\"${project.version}\">", "author": "fwolter", "createdAt": "2020-10-13T17:08:59Z", "path": "bundles/org.openhab.binding.wled/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.wled-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${project.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-wled\" description=\"WLed Binding\" version=\"${project.version}\">", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMjI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504122257", "bodyText": "network-address should only allow IP addresses.", "author": "fwolter", "createdAt": "2020-10-13T17:10:08Z", "path": "bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,162 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wled\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"wled\">\n+\t\t<label>WLED String</label>\n+\t\t<description>A WLED string of LEDs</description>\n+\t\t<category>ColorLight</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"masterControls\" typeId=\"masterControls\"/>\n+\t\t\t<channel id=\"primaryColor\" typeId=\"primaryColor\"/>\n+\t\t\t<channel id=\"primaryWhite\" typeId=\"primaryWhite\"/>\n+\t\t\t<channel id=\"secondaryColor\" typeId=\"secondaryColor\"/>\n+\t\t\t<channel id=\"secondaryWhite\" typeId=\"secondaryWhite\"/>\n+\t\t\t<channel id=\"presets\" typeId=\"presets\"/>\n+\t\t\t<channel id=\"presetDuration\" typeId=\"presetDuration\"/>\n+\t\t\t<channel id=\"transformTime\" typeId=\"transformTime\"/>\n+\t\t\t<channel id=\"presetCycle\" typeId=\"presetCycle\"/>\n+\t\t\t<channel id=\"palettes\" typeId=\"palettes\"/>\n+\t\t\t<channel id=\"fx\" typeId=\"fx\"/>\n+\t\t\t<channel id=\"speed\" typeId=\"speed\"/>\n+\t\t\t<channel id=\"intensity\" typeId=\"intensity\"/>\n+\t\t\t<channel id=\"sleep\" typeId=\"sleep\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgwNjU3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r506806575", "bodyText": "DONE: removed as discussed above.", "author": "Skinah", "createdAt": "2020-10-17T05:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMjc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r504122752", "bodyText": "The max paramter is optional.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollTime\" type=\"integer\" required=\"true\" min=\"1\" max=\"9999999\" unit=\"s\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollTime\" type=\"integer\" required=\"true\" min=\"1\" unit=\"s\">", "author": "fwolter", "createdAt": "2020-10-13T17:10:57Z", "path": "bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,162 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wled\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"wled\">\n+\t\t<label>WLED String</label>\n+\t\t<description>A WLED string of LEDs</description>\n+\t\t<category>ColorLight</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"masterControls\" typeId=\"masterControls\"/>\n+\t\t\t<channel id=\"primaryColor\" typeId=\"primaryColor\"/>\n+\t\t\t<channel id=\"primaryWhite\" typeId=\"primaryWhite\"/>\n+\t\t\t<channel id=\"secondaryColor\" typeId=\"secondaryColor\"/>\n+\t\t\t<channel id=\"secondaryWhite\" typeId=\"secondaryWhite\"/>\n+\t\t\t<channel id=\"presets\" typeId=\"presets\"/>\n+\t\t\t<channel id=\"presetDuration\" typeId=\"presetDuration\"/>\n+\t\t\t<channel id=\"transformTime\" typeId=\"transformTime\"/>\n+\t\t\t<channel id=\"presetCycle\" typeId=\"presetCycle\"/>\n+\t\t\t<channel id=\"palettes\" typeId=\"palettes\"/>\n+\t\t\t<channel id=\"fx\" typeId=\"fx\"/>\n+\t\t\t<channel id=\"speed\" typeId=\"speed\"/>\n+\t\t\t<channel id=\"intensity\" typeId=\"intensity\"/>\n+\t\t\t<channel id=\"sleep\" typeId=\"sleep\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Use this format http://192.168.1.2:80</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollTime\" type=\"integer\" required=\"true\" min=\"1\" max=\"9999999\" unit=\"s\">", "originalCommit": "94078d9eb689907e9424ea30887624d8650c7768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0MzQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r512543490", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @ActionInput(name = \"presetNumber\", label = \"Save State to Preset Slot\", description = \"Enter the number for the preset slot you wish to use\") int presetNumber) {\n          \n          \n            \n                        @ActionInput(name = \"presetNumber\", label = \"Preset Slot\", description = \"Number for the preset slot you wish to use\") int presetNumber) {", "author": "fwolter", "createdAt": "2020-10-27T09:42:10Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedActions} is responsible for Actions.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@ThingActionsScope(name = \"wled\")\n+@NonNullByDefault\n+public class WLedActions implements ThingActions {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private @Nullable WLedHandler handler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        this.handler = (WLedHandler) handler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"save state to preset\", description = \"Save a WLED state to a preset slot\")\n+    public void savePreset(\n+            @ActionInput(name = \"presetNumber\", label = \"Save State to Preset Slot\", description = \"Enter the number for the preset slot you wish to use\") int presetNumber) {", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0OTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r512549752", "bodyText": "The user can specify any time unit he wants.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>Time in seconds for how long to show each preset for before moving to the next</description>\n          \n          \n            \n            \t\t<description>Time for how long to show each preset for before moving to the next</description>", "author": "fwolter", "createdAt": "2020-10-27T09:51:41Z", "path": "bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,169 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wled\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"wled\">\n+\t\t<label>WLED String</label>\n+\t\t<description>A WLED string of LEDs</description>\n+\t\t<category>ColorLight</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"masterControls\" typeId=\"masterControls\"/>\n+\t\t\t<channel id=\"primaryColor\" typeId=\"primaryColor\"/>\n+\t\t\t<channel id=\"primaryWhite\" typeId=\"primaryWhite\"/>\n+\t\t\t<channel id=\"secondaryColor\" typeId=\"secondaryColor\"/>\n+\t\t\t<channel id=\"secondaryWhite\" typeId=\"secondaryWhite\"/>\n+\t\t\t<channel id=\"presets\" typeId=\"presets\"/>\n+\t\t\t<channel id=\"presetDuration\" typeId=\"presetDuration\"/>\n+\t\t\t<channel id=\"transformTime\" typeId=\"transformTime\"/>\n+\t\t\t<channel id=\"presetCycle\" typeId=\"presetCycle\"/>\n+\t\t\t<channel id=\"palettes\" typeId=\"palettes\"/>\n+\t\t\t<channel id=\"fx\" typeId=\"fx\"/>\n+\t\t\t<channel id=\"speed\" typeId=\"speed\"/>\n+\t\t\t<channel id=\"intensity\" typeId=\"intensity\"/>\n+\t\t\t<channel id=\"sleep\" typeId=\"sleep\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Use this format http://192.168.1.2:80</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollTime\" type=\"integer\" required=\"true\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Poll States</label>\n+\t\t\t\t<description>Time in seconds of how often to fetch the state of the LEDs.</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"segmentIndex\" type=\"integer\" required=\"true\" min=\"0\">\n+\t\t\t\t<label>Segment Index</label>\n+\t\t\t\t<description>Leave this as 0 if you are not using segments, otherwise set this to the segment index number that you\n+\t\t\t\t\twish to control.</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"saturationThreshold\" type=\"integer\" required=\"true\" min=\"0\" max=\"99\">\n+\t\t\t\t<label>Saturation Threshold</label>\n+\t\t\t\t<description>This feature allows you to specify a number that if the saturation drops below, will trigger white.\n+\t\t\t\t</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"masterControls\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Master Controls</label>\n+\t\t<description>Allows you to exit FX mode and use the LEDS like a normal light</description>\n+\t\t<category>ColorLight</category>\n+\t\t<tags>\n+\t\t\t<tag>Lighting</tag>\n+\t\t</tags>\n+\t</channel-type>\n+\n+\t<channel-type id=\"primaryColor\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Primary Color</label>\n+\t\t<description>Allows you to change the primary color used in FX</description>\n+\t\t<category>ColorLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"primaryWhite\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Primary White</label>\n+\t\t<description>Changes the brightness of the primary white LED</description>\n+\t\t<category>DimmableLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"secondaryColor\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Secondary Color</label>\n+\t\t<description>Allows you to change the secondary color used in FX</description>\n+\t\t<category>ColorLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"secondaryWhite\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Secondary White</label>\n+\t\t<description>Changes the brightness of the white LED</description>\n+\t\t<category>DimmableLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"palettes\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Palettes</label>\n+\t\t<description>Change the colours used by the FX</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fx\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Effect</label>\n+\t\t<description>Use the built in FX</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"presets\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Presets</label>\n+\t\t<description>Auto rotate or change to a saved preset</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"1\">Preset 1</option>\n+\t\t\t\t<option value=\"2\">Preset 2</option>\n+\t\t\t\t<option value=\"3\">Preset 3</option>\n+\t\t\t\t<option value=\"4\">Preset 4</option>\n+\t\t\t\t<option value=\"5\">Preset 5</option>\n+\t\t\t\t<option value=\"6\">Preset 6</option>\n+\t\t\t\t<option value=\"7\">Preset 7</option>\n+\t\t\t\t<option value=\"8\">Preset 8</option>\n+\t\t\t\t<option value=\"9\">Preset 9</option>\n+\t\t\t\t<option value=\"10\">Preset 10</option>\n+\t\t\t\t<option value=\"11\">Preset 11</option>\n+\t\t\t\t<option value=\"12\">Preset 12</option>\n+\t\t\t\t<option value=\"13\">Preset 13</option>\n+\t\t\t\t<option value=\"14\">Preset 14</option>\n+\t\t\t\t<option value=\"15\">Preset 15</option>\n+\t\t\t\t<option value=\"16\">Preset 16</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"presetDuration\" advanced=\"true\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Preset Duration</label>\n+\t\t<description>Time in seconds for how long to show each preset for before moving to the next</description>", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyMDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r507020013", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n          \n          \n            \n                        Arrays.asList(THING_TYPE_WLED));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_WLED);", "author": "cpmeister", "createdAt": "2020-10-18T05:39:09Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedBindingConstants.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link WLedBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedBindingConstants {\n+\n+    public static final String BINDING_ID = \"wled\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_WLED = new ThingTypeUID(BINDING_ID, \"wled\");\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_WLED));", "originalCommit": "9822855aaeed4801b4dfda92fff4c3d29d1a236e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU0OTIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511549239", "bodyText": "You should log these", "author": "cpmeister", "createdAt": "2020-10-25T05:21:31Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedDiscoveryService} Discovers and adds any Wled devices found.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class)\n+public class WLedDiscoveryService implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(WLedDiscoveryService.class);\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public WLedDiscoveryService(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    private String sendGetRequest(String address, String url) {\n+        Request request = httpClient.newRequest(address + url);\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                return contentResponse.getContentAsString();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        } catch (TimeoutException | ExecutionException e) {\n+        }", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0Mzg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514943869", "bodyText": "DONE: I made it only a debug level since this is only during a discovery and not normal use that it would occur.", "author": "Skinah", "createdAt": "2020-10-30T08:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU0OTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU0OTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r511549310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>Changes the brightness of the white LED</description>\n          \n          \n            \n            \t\t<description>Changes the brightness of the secondary white LED</description>", "author": "cpmeister", "createdAt": "2020-10-25T05:22:53Z", "path": "bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,169 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wled\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"wled\">\n+\t\t<label>WLED String</label>\n+\t\t<description>A WLED string of LEDs</description>\n+\t\t<category>ColorLight</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"masterControls\" typeId=\"masterControls\"/>\n+\t\t\t<channel id=\"primaryColor\" typeId=\"primaryColor\"/>\n+\t\t\t<channel id=\"primaryWhite\" typeId=\"primaryWhite\"/>\n+\t\t\t<channel id=\"secondaryColor\" typeId=\"secondaryColor\"/>\n+\t\t\t<channel id=\"secondaryWhite\" typeId=\"secondaryWhite\"/>\n+\t\t\t<channel id=\"presets\" typeId=\"presets\"/>\n+\t\t\t<channel id=\"presetDuration\" typeId=\"presetDuration\"/>\n+\t\t\t<channel id=\"transformTime\" typeId=\"transformTime\"/>\n+\t\t\t<channel id=\"presetCycle\" typeId=\"presetCycle\"/>\n+\t\t\t<channel id=\"palettes\" typeId=\"palettes\"/>\n+\t\t\t<channel id=\"fx\" typeId=\"fx\"/>\n+\t\t\t<channel id=\"speed\" typeId=\"speed\"/>\n+\t\t\t<channel id=\"intensity\" typeId=\"intensity\"/>\n+\t\t\t<channel id=\"sleep\" typeId=\"sleep\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Use this format http://192.168.1.2:80</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollTime\" type=\"integer\" required=\"true\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Poll States</label>\n+\t\t\t\t<description>Time in seconds of how often to fetch the state of the LEDs.</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"segmentIndex\" type=\"integer\" required=\"true\" min=\"0\">\n+\t\t\t\t<label>Segment Index</label>\n+\t\t\t\t<description>Leave this as 0 if you are not using segments, otherwise set this to the segment index number that you\n+\t\t\t\t\twish to control.</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"saturationThreshold\" type=\"integer\" required=\"true\" min=\"0\" max=\"99\">\n+\t\t\t\t<label>Saturation Threshold</label>\n+\t\t\t\t<description>This feature allows you to specify a number that if the saturation drops below, will trigger white.\n+\t\t\t\t</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"masterControls\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Master Controls</label>\n+\t\t<description>Allows you to exit FX mode and use the LEDS like a normal light</description>\n+\t\t<category>ColorLight</category>\n+\t\t<tags>\n+\t\t\t<tag>Lighting</tag>\n+\t\t</tags>\n+\t</channel-type>\n+\n+\t<channel-type id=\"primaryColor\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Primary Color</label>\n+\t\t<description>Allows you to change the primary color used in FX</description>\n+\t\t<category>ColorLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"primaryWhite\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Primary White</label>\n+\t\t<description>Changes the brightness of the primary white LED</description>\n+\t\t<category>DimmableLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"secondaryColor\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Secondary Color</label>\n+\t\t<description>Allows you to change the secondary color used in FX</description>\n+\t\t<category>ColorLight</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"secondaryWhite\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Secondary White</label>\n+\t\t<description>Changes the brightness of the white LED</description>", "originalCommit": "d1bae43971cdc9518c6f1e73b7494cf54b1aa88d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513703179", "bodyText": "Should probably make new BigDecimal(2.55) a constant since you use it in quite a few places.", "author": "cpmeister", "createdAt": "2020-10-28T19:22:56Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMDQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514110455", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-10-29T09:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNDk4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513704988", "bodyText": "Why are you creating a new HSBType when you can cast the command?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                primaryColor = new HSBType(command.toString());\n          \n          \n            \n                                primaryColor = (HSBType) command;", "author": "cpmeister", "createdAt": "2020-10-28T19:26:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNTg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513705896", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-28T19:27:34Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5MjYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514192638", "bodyText": "FIXED", "author": "Skinah", "createdAt": "2020-10-29T11:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNjI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513706240", "bodyText": "not implemented?", "author": "cpmeister", "createdAt": "2020-10-28T19:28:15Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NDg5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514944892", "bodyText": "Correct, it is implemented on the MASTER controls just not on the colour selections for the FX use. I removed this code to make it shorter.", "author": "Skinah", "createdAt": "2020-10-30T08:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwNjI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMDk2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513710964", "bodyText": "What you are doing here is kinda inefficient with all of the new object creation going on.\nIf you take advantage of the built-in type conversion functions in State you can make this much more concise.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            BigDecimal bigTemp = new BigDecimal(command.toString());\n          \n          \n            \n                            if (OnOffType.OFF.equals(command)) {\n          \n          \n            \n                                bigTemp = BigDecimal.ZERO;\n          \n          \n            \n                            } else if (OnOffType.ON.equals(command)) {\n          \n          \n            \n                                bigTemp = new BigDecimal(255);\n          \n          \n            \n                            } else {\n          \n          \n            \n                                bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n          \n          \n            \n                            }\n          \n          \n            \n                            BigDecimal bigTemp = ((State)command).as(PercentType.class).multiply(BIG_DECIMAL_2_55));\n          \n      \n    \n    \n  \n\nThe same change would apply for the CHANNEL_INTENSITY case as well.", "author": "cpmeister", "createdAt": "2020-10-28T19:37:01Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                BigDecimal bigTemp = new BigDecimal(command.toString());\n+                if (OnOffType.OFF.equals(command)) {\n+                    bigTemp = BigDecimal.ZERO;\n+                } else if (OnOffType.ON.equals(command)) {\n+                    bigTemp = new BigDecimal(255);\n+                } else {\n+                    bigTemp = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                }", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNDc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513714777", "bodyText": "String parsing is an expensive operation, please avoid where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n          \n          \n            \n                                        + primaryColor.getSaturation().toString() + \",command\");\n          \n          \n            \n                                primaryColor = new HSBType(primaryColor.getHue(), primaryColor.getSaturation(),  ((State)command).as(PercentType.class));", "author": "cpmeister", "createdAt": "2020-10-28T19:44:00Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513715040", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                secondaryColor = new HSBType(command.toString());\n          \n          \n            \n                                secondaryColor = (HSBType) command;", "author": "cpmeister", "createdAt": "2020-10-28T19:44:25Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r513715185", "bodyText": "same here.", "author": "cpmeister", "createdAt": "2020-10-28T19:44:42Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness.divide(new BigDecimal(2.55), RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(new BigDecimal(2.55),\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + new BigDecimal(command.toString()).multiply(new BigDecimal(2.55)));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    masterBrightness = new BigDecimal((((HSBType) command).getBrightness()).toString())\n+                            .multiply(new BigDecimal(2.55));\n+                    primaryColor = new HSBType(command.toString());\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\n+                                \"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\" + masterBrightness);\n+                    }\n+                } else {// should only be PercentType left\n+                    masterBrightness = new BigDecimal(command.toString()).multiply(new BigDecimal(2.55));\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    primaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    primaryColor = new HSBType(primaryColor.getHue().toString() + \",\"\n+                            + primaryColor.getSaturation().toString() + \",command\");\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof OnOffType) {\n+                    return;\n+                } else if (command instanceof HSBType) {\n+                    secondaryColor = new HSBType(command.toString());\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    return;\n+                } else {// Percentype\n+                    secondaryColor = new HSBType(secondaryColor.getHue().toString() + \",\"\n+                            + secondaryColor.getSaturation().toString() + \",command\");", "originalCommit": "8e90dd0555c2cb5a38d611b89f7f4eaed5d45214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0NzAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r514147015", "bodyText": "FIXED", "author": "Skinah", "createdAt": "2020-10-29T10:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNTE4NQ=="}], "type": "inlineReview"}, {"oid": "d3f8aa82864778c13dda3e6419ea77eb4904db80", "url": "https://github.com/openhab/openhab-addons/commit/d3f8aa82864778c13dda3e6419ea77eb4904db80", "message": "V3\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:32Z", "type": "commit"}, {"oid": "66fa166c8edc090fa302e76d41c3887101ce7ed5", "url": "https://github.com/openhab/openhab-addons/commit/66fa166c8edc090fa302e76d41c3887101ce7ed5", "message": "formatting.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:35Z", "type": "commit"}, {"oid": "9a536cd20b19574e73ad8f1349fa179a8851c4f5", "url": "https://github.com/openhab/openhab-addons/commit/9a536cd20b19574e73ad8f1349fa179a8851c4f5", "message": "V3 binding\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "a9db5de295c9bbf9c96961b48661403ca19e13e4", "url": "https://github.com/openhab/openhab-addons/commit/a9db5de295c9bbf9c96961b48661403ca19e13e4", "message": "POM fixed\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ae8d5d1ef8f4bd63ffe507069de69c702e1dd27c", "url": "https://github.com/openhab/openhab-addons/commit/ae8d5d1ef8f4bd63ffe507069de69c702e1dd27c", "message": "Add comments.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "792205fa1c258c6dd5e63556415644d1d2a66664", "url": "https://github.com/openhab/openhab-addons/commit/792205fa1c258c6dd5e63556415644d1d2a66664", "message": "add to CODEOWNERS\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "d3342614158940c717ef493be203d6c2c1512a97", "url": "https://github.com/openhab/openhab-addons/commit/d3342614158940c717ef493be203d6c2c1512a97", "message": "Comments\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "e3dfba2f94d34cff7d593e63275c99891e068baa", "url": "https://github.com/openhab/openhab-addons/commit/e3dfba2f94d34cff7d593e63275c99891e068baa", "message": "Spotless and POM fixed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "9588cad82ef69c4afdd8539d29d81aa08e34e279", "url": "https://github.com/openhab/openhab-addons/commit/9588cad82ef69c4afdd8539d29d81aa08e34e279", "message": "Update examples to be compatible with 'Create equipment from thing' in\nV3.x\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "878f185b867825a910bc8c5d6f3f20eb82e5061d", "url": "https://github.com/openhab/openhab-addons/commit/878f185b867825a910bc8c5d6f3f20eb82e5061d", "message": "Change thing type category\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "464e95179848d0656dd1ab552808ea2d046866f9", "url": "https://github.com/openhab/openhab-addons/commit/464e95179848d0656dd1ab552808ea2d046866f9", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "31146450a0db01aa652ab9eeedfb62b349529022", "url": "https://github.com/openhab/openhab-addons/commit/31146450a0db01aa652ab9eeedfb62b349529022", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ce88330c4390c9012267748b9a77e03fc75378c9", "url": "https://github.com/openhab/openhab-addons/commit/ce88330c4390c9012267748b9a77e03fc75378c9", "message": "Update bundles/org.openhab.binding.wled/src/main/feature/feature.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "a40b4ad91db4cb6edcc87601332d8517cb05736c", "url": "https://github.com/openhab/openhab-addons/commit/a40b4ad91db4cb6edcc87601332d8517cb05736c", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "613005121a9187ca0436f764537075221f596620", "url": "https://github.com/openhab/openhab-addons/commit/613005121a9187ca0436f764537075221f596620", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedDiscoveryService.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "23f7e6b105c1d4d54d136d2f0e7640ede84e2800", "url": "https://github.com/openhab/openhab-addons/commit/23f7e6b105c1d4d54d136d2f0e7640ede84e2800", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "55904473a5dffb3901ffbab96c31104814077025", "url": "https://github.com/openhab/openhab-addons/commit/55904473a5dffb3901ffbab96c31104814077025", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "333b1505417a327954874dd78d4c26008507c779", "url": "https://github.com/openhab/openhab-addons/commit/333b1505417a327954874dd78d4c26008507c779", "message": "remove unneeded threadpool.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "ab70200d92bff684b479e5f26adc177fa40ebf36", "url": "https://github.com/openhab/openhab-addons/commit/ab70200d92bff684b479e5f26adc177fa40ebf36", "message": "Use BigDecimal.ZERO\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "b5182e4839fa76ec7bc199b7caf9fdf3c5ccc4f8", "url": "https://github.com/openhab/openhab-addons/commit/b5182e4839fa76ec7bc199b7caf9fdf3c5ccc4f8", "message": "Readme cleanup\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "55e3d80f7ef45489e27e3150a6f04c3d71246adf", "url": "https://github.com/openhab/openhab-addons/commit/55e3d80f7ef45489e27e3150a6f04c3d71246adf", "message": "Rule actions made lower case and readme info added.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "bad563dadadca2474644aafefcd03ca5344e13e0", "url": "https://github.com/openhab/openhab-addons/commit/bad563dadadca2474644aafefcd03ca5344e13e0", "message": "removed logging.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "b8de0ab1d2d6ba3ce06910438d7190bfc4d0f402", "url": "https://github.com/openhab/openhab-addons/commit/b8de0ab1d2d6ba3ce06910438d7190bfc4d0f402", "message": "no more logging to info.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "d2f0e77bbcd733558750d0fdd2ef70c7719173ae", "url": "https://github.com/openhab/openhab-addons/commit/d2f0e77bbcd733558750d0fdd2ef70c7719173ae", "message": "withRepresentationProperty added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:36Z", "type": "commit"}, {"oid": "912b01c213a401c257fca62117fd6067ac29bea3", "url": "https://github.com/openhab/openhab-addons/commit/912b01c213a401c257fca62117fd6067ac29bea3", "message": "simplify code\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "c1541a278d651ddb653f175022dd3a71b9500347", "url": "https://github.com/openhab/openhab-addons/commit/c1541a278d651ddb653f175022dd3a71b9500347", "message": "Change to using Number:Time\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a979cd87927d48a3c558e80575a95daa25fcd052", "url": "https://github.com/openhab/openhab-addons/commit/a979cd87927d48a3c558e80575a95daa25fcd052", "message": "Segment feature added.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "8f5d0fdf56ae0abfa791e5fbe9cefc3c796b3b70", "url": "https://github.com/openhab/openhab-addons/commit/8f5d0fdf56ae0abfa791e5fbe9cefc3c796b3b70", "message": "Change Number:Time to use pattern=\"%.1f Second\"\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "c243f95da9b891639ffd3f1765277fc4ef581308", "url": "https://github.com/openhab/openhab-addons/commit/c243f95da9b891639ffd3f1765277fc4ef581308", "message": "UOM fixes.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "03762ec96809fe2c716d6dbb5ded99957ac6eb2c", "url": "https://github.com/openhab/openhab-addons/commit/03762ec96809fe2c716d6dbb5ded99957ac6eb2c", "message": "readme sitemap updated.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "9aa4c8cc2920f83eb65f38d9653c4894b2296f26", "url": "https://github.com/openhab/openhab-addons/commit/9aa4c8cc2920f83eb65f38d9653c4894b2296f26", "message": "Allow segment commands to be bypassed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "1bb86969742ad2e6e924c20622d2b14d5d33e6bb", "url": "https://github.com/openhab/openhab-addons/commit/1bb86969742ad2e6e924c20622d2b14d5d33e6bb", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "e2869a5db689ffec7fef08f0dcc255dfa2828d95", "url": "https://github.com/openhab/openhab-addons/commit/e2869a5db689ffec7fef08f0dcc255dfa2828d95", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedActions.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "d9be35a4ef720c085f0a84814d5a248a03797178", "url": "https://github.com/openhab/openhab-addons/commit/d9be35a4ef720c085f0a84814d5a248a03797178", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedBindingConstants.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a1b02b49ec9fc2e8f45703fc45ee1e6b4211e749", "url": "https://github.com/openhab/openhab-addons/commit/a1b02b49ec9fc2e8f45703fc45ee1e6b4211e749", "message": "Update bundles/org.openhab.binding.wled/src/main/resources/OH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "981e33f743f72d9c6fdf8aaed49295ccd0441d35", "url": "https://github.com/openhab/openhab-addons/commit/981e33f743f72d9c6fdf8aaed49295ccd0441d35", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\ncommand.toString()\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "e4c673a1d8bc1c2e3a8877ce1f00bc3d9a215143", "url": "https://github.com/openhab/openhab-addons/commit/e4c673a1d8bc1c2e3a8877ce1f00bc3d9a215143", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "a4e5a55ef6bacd6e51fd3de20937aba5eb3a95b2", "url": "https://github.com/openhab/openhab-addons/commit/a4e5a55ef6bacd6e51fd3de20937aba5eb3a95b2", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "80881a5c26a5a8785cda41a6ce2a1172f4cca725", "url": "https://github.com/openhab/openhab-addons/commit/80881a5c26a5a8785cda41a6ce2a1172f4cca725", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "bd11f2d950937b965cc57528eb663eea4178cb1b", "url": "https://github.com/openhab/openhab-addons/commit/bd11f2d950937b965cc57528eb663eea4178cb1b", "message": "Use casting instead of parsing strings.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T07:25:37Z", "type": "commit"}, {"oid": "be4fe1964f1333cb68f7bc7a291bc668e641dc26", "url": "https://github.com/openhab/openhab-addons/commit/be4fe1964f1333cb68f7bc7a291bc668e641dc26", "message": "Add debug logging for discovery timeouts.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T08:40:50Z", "type": "commit"}, {"oid": "eb1f704a5af775c62541ac020024e244052833a6", "url": "https://github.com/openhab/openhab-addons/commit/eb1f704a5af775c62541ac020024e244052833a6", "message": "fix build error\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-30T11:12:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        palleteOptions.add(new StateOption(\"\" + counter++, value));\n          \n          \n            \n                        palleteOptions.add(new StateOption(Integer.toString(counter++), value));", "author": "cpmeister", "createdAt": "2020-10-31T04:02:34Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(\"\" + counter++, value));", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452367", "bodyText": "At the very least you should log the payload that failed to parse. That way a user would have a better idea of what went wrong.", "author": "cpmeister", "createdAt": "2020-10-31T04:04:36Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields.\");", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2MDE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515560144", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-11-01T01:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452390", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-31T04:04:44Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final BigDecimal BIG_DECIMAL_2_55 = new BigDecimal(2.55);\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields.\");", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2MDE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515560155", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-11-01T01:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1MjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1Mjc5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515452798", "bodyText": "I don't see you using this dependency in your pom file. Is it needed?", "author": "cpmeister", "createdAt": "2020-10-31T04:10:39Z", "path": "bundles/org.openhab.binding.wled/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.wled-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${project.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-wled\" description=\"WLED Binding\" version=\"${project.version}\">\n+\t\t<feature>openhab-runtime-base</feature>\n+\t\t<bundle dependency=\"true\">mvn:org.eclipse.paho/org.eclipse.paho.client.mqttv3/1.2.2</bundle>", "originalCommit": "eb1f704a5af775c62541ac020024e244052833a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MzM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515553390", "bodyText": "REMOVED: It used to be used, but not anymore.", "author": "Skinah", "createdAt": "2020-10-31T23:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1Mjc5OA=="}], "type": "inlineReview"}, {"oid": "6b657c7538912f19f2ce8d2d64dd5729b86d884e", "url": "https://github.com/openhab/openhab-addons/commit/6b657c7538912f19f2ce8d2d64dd5729b86d884e", "message": "Remove Paho from feature.xml\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-10-31T23:51:41Z", "type": "commit"}, {"oid": "c56f0190ddec080cbc17eb70e74b6425f8db87f7", "url": "https://github.com/openhab/openhab-addons/commit/c56f0190ddec080cbc17eb70e74b6425f8db87f7", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-10-31T23:56:39Z", "type": "commit"}, {"oid": "66977e0c887c6f8ec799155c096cdf10b246e231", "url": "https://github.com/openhab/openhab-addons/commit/66977e0c887c6f8ec799155c096cdf10b246e231", "message": "Sync send and receive added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-01T00:58:52Z", "type": "commit"}, {"oid": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "url": "https://github.com/openhab/openhab-addons/commit/dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "message": "Fix discovery bug.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-01T03:34:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515584897", "bodyText": "I can't really tell if this method is used anywhere, if it is then you should make the return type List instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static LinkedList<String> listOfResults(String message, String element, String end) {\n          \n          \n            \n                    LinkedList<String> results = new LinkedList<String>();\n          \n          \n            \n                static List<String> listOfResults(String message, String element, String end) {\n          \n          \n            \n                    List<String> results = new LinkedList<>();", "author": "cpmeister", "createdAt": "2020-11-01T07:03:18Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.LinkedList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link WLedHelper} Provides helper classes that are used from multiple classes in the binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedHelper {\n+\n+    /**\n+     * @return A string that starts after finding the element and terminates when it finds the first occurrence of the\n+     *         end string after the element.\n+     */\n+    static String getValue(String message, String element, String end) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex != -1) // -1 means \"not found\"\n+        {\n+            int endIndex = message.indexOf(end, startIndex + element.length());\n+            if (endIndex != -1) {\n+                return message.substring(startIndex + element.length(), endIndex);\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    static LinkedList<String> listOfResults(String message, String element, String end) {\n+        LinkedList<String> results = new LinkedList<String>();", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515585187", "bodyText": "If temp is empty wouldn't this loop forever?", "author": "cpmeister", "createdAt": "2020-11-01T07:06:33Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import java.util.LinkedList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link WLedHelper} Provides helper classes that are used from multiple classes in the binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WLedHelper {\n+\n+    /**\n+     * @return A string that starts after finding the element and terminates when it finds the first occurrence of the\n+     *         end string after the element.\n+     */\n+    static String getValue(String message, String element, String end) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex != -1) // -1 means \"not found\"\n+        {\n+            int endIndex = message.indexOf(end, startIndex + element.length());\n+            if (endIndex != -1) {\n+                return message.substring(startIndex + element.length(), endIndex);\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    static LinkedList<String> listOfResults(String message, String element, String end) {\n+        LinkedList<String> results = new LinkedList<String>();\n+        String temp = \"\";\n+        for (int startLookingFromIndex = 0; startLookingFromIndex != -1;) {\n+            startLookingFromIndex = message.indexOf(element, startLookingFromIndex);\n+            if (startLookingFromIndex >= 0) {\n+                temp = getValue(message.substring(startLookingFromIndex), element, end);\n+                if (!temp.isEmpty()) {\n+                    results.add(temp);\n+                    ++startLookingFromIndex;\n+                }\n+            }\n+        }", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwMjI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515702279", "bodyText": "FIXED: thanks for finding this.", "author": "Skinah", "createdAt": "2020-11-02T01:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515585351", "bodyText": "The config field shouldn't be initialized in the constructor. This should be done in initialize() instead. But it looks like you are already doing that so just remove it here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config = getConfigAs(WLedConfiguration.class);", "author": "cpmeister", "createdAt": "2020-11-01T07:08:53Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config;\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        config = getConfigAs(WLedConfiguration.class);", "originalCommit": "dcb23e7575c1f6f4375e2bb47038cc934c768e6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY5ODc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515698764", "bodyText": "If I do that then I get \"The @nonnull field config may not have been initialized\", error by the compiler. If I make the config nullable then I have to check every time I use it, if it is null. So I went with this approach by doing it twice. How should it be handled then?", "author": "Skinah", "createdAt": "2020-11-02T01:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0NDc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r515744785", "bodyText": "The general pattern in other bindings is to initially set the config to a default instance. So in this case just define your config field as:\nprivate WLedConfiguration config = new WLedConfiguration();", "author": "cpmeister", "createdAt": "2020-11-02T05:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516444185", "bodyText": "FIXED: Thank you, its so obvious now you pointed it out.", "author": "Skinah", "createdAt": "2020-11-03T06:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM1MQ=="}], "type": "inlineReview"}, {"oid": "870821ce0c67e93edb505da1485ec242e3b4e907", "url": "https://github.com/openhab/openhab-addons/commit/870821ce0c67e93edb505da1485ec242e3b4e907", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHelper.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-11-02T01:05:36Z", "type": "commit"}, {"oid": "2af2b72772aca04f3e13e4e49be27cf6f5a0b547", "url": "https://github.com/openhab/openhab-addons/commit/2af2b72772aca04f3e13e4e49be27cf6f5a0b547", "message": "Prevent endless loop.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-02T01:23:58Z", "type": "commit"}, {"oid": "351c1fd2776e528deff0b18b62f0630026daa384", "url": "https://github.com/openhab/openhab-addons/commit/351c1fd2776e528deff0b18b62f0630026daa384", "message": "Stop double init of config.\n\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-03T06:06:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516471540", "bodyText": "Please address the null build warnings. If there are any others please address them by using a local variable like so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingFuture != null) {\n          \n          \n            \n                        pollingFuture.cancel(true);\n          \n          \n            \n                    }\n          \n          \n            \n                    Future<?> future = pollingFuture;\n          \n          \n            \n                    if (future != null) {\n          \n          \n            \n                        future.cancel(true);\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-11-03T07:44:04Z", "path": "bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wled.internal;\n+\n+import static org.openhab.binding.wled.internal.WLedBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WLedHandler} is responsible for handling commands and states, which are\n+ * sent to one of the channels or http replies back.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class WLedHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final HttpClient httpClient;\n+    private final WledDynamicStateDescriptionProvider stateDescriptionProvider;\n+    private @Nullable ScheduledFuture<?> pollingFuture = null;\n+    private BigDecimal masterBrightness255 = BigDecimal.ZERO;\n+    private HSBType primaryColor = new HSBType();\n+    private BigDecimal primaryWhite = BigDecimal.ZERO;\n+    private HSBType secondaryColor = new HSBType();\n+    private BigDecimal secondaryWhite = BigDecimal.ZERO;\n+    private boolean hasWhite = false;\n+    private WLedConfiguration config = new WLedConfiguration();\n+\n+    public WLedHandler(Thing thing, HttpClient httpClient,\n+            WledDynamicStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    private void sendGetRequest(String url) {\n+        Request request;\n+        if (url.contains(\"json\") || config.segmentIndex == -1) {\n+            request = httpClient.newRequest(config.address + url);\n+        } else {\n+            request = httpClient.newRequest(config.address + url + \"&SM=\" + config.segmentIndex);\n+        }\n+        request.timeout(3, TimeUnit.SECONDS);\n+        request.method(HttpMethod.GET);\n+        request.header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n+        logger.trace(\"Sending WLED GET:{}\", url);\n+        String errorReason = \"\";\n+        try {\n+            ContentResponse contentResponse = request.send();\n+            if (contentResponse.getStatus() == 200) {\n+                processState(contentResponse.getContentAsString());\n+                return;\n+            } else {\n+                errorReason = String.format(\"WLED request failed with %d: %s\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorReason = \"TimeoutException: WLED was not reachable on your network\";\n+        } catch (ExecutionException e) {\n+            errorReason = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            errorReason = String.format(\"InterruptedException: %s\", e.getMessage());\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorReason);\n+    }\n+\n+    private HSBType parseToHSBType(String message, String element) {\n+        int startIndex = message.indexOf(element);\n+        if (startIndex == -1) {\n+            return new HSBType();\n+        }\n+        int endIndex = message.indexOf(\"<\", startIndex + element.length());\n+        int r = 0, g = 0, b = 0;\n+        try {\n+            r = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for second element\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            g = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+            // look for third element called <cl>\n+            startIndex = message.indexOf(element, endIndex);\n+            if (startIndex == -1) {\n+                return new HSBType();\n+            }\n+            endIndex = message.indexOf(\"<\", startIndex + element.length());\n+            b = Integer.parseInt(message.substring(startIndex + element.length(), endIndex));\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED color fields:{}\", e.getMessage());\n+        }\n+        return HSBType.fromRGB(r, g, b);\n+    }\n+\n+    private void parseColours(String message) {\n+        primaryColor = parseToHSBType(message, \"<cl>\");\n+        updateState(CHANNEL_PRIMARY_COLOR, primaryColor);\n+        secondaryColor = parseToHSBType(message, \"<cs>\");\n+        updateState(CHANNEL_SECONDARY_COLOR, secondaryColor);\n+        try {\n+            primaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<wv>\", \"<\"));\n+            if (primaryWhite.intValue() > -1) {\n+                hasWhite = true;\n+                updateState(CHANNEL_PRIMARY_WHITE,\n+                        new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+                secondaryWhite = new BigDecimal(WLedHelper.getValue(message, \"<ws>\", \"<\"));\n+                updateState(CHANNEL_SECONDARY_WHITE,\n+                        new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"NumberFormatException when parsing the WLED colour and white fields:{}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     *\n+     * This function should prevent the need to keep updating the binding as more FX and Palettes are added to the\n+     * firmware.\n+     */\n+    private void scrapeChannelOptions(String message) {\n+        List<StateOption> fxOptions = new ArrayList<>();\n+        List<StateOption> palleteOptions = new ArrayList<>();\n+        int counter = 0;\n+        for (String value : WLedHelper.getValue(message, \"\\\"effects\\\":[\", \"]\").replace(\"\\\"\", \"\").split(\",\")) {\n+            fxOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_FX), fxOptions);\n+        counter = 0;\n+        for (String value : (WLedHelper.getValue(message, \"\\\"palettes\\\":[\", \"]\").replace(\"\\\"\", \"\")).split(\",\")) {\n+            palleteOptions.add(new StateOption(Integer.toString(counter++), value));\n+        }\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_PALETTES), palleteOptions);\n+    }\n+\n+    private void processState(String message) {\n+        logger.trace(\"WLED states are:{}\", message);\n+        if (thing.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            sendGetRequest(\"/json\"); // fetch FX and Pallete names\n+        }\n+        if (message.contains(\"\\\"effects\\\":[\")) {// JSON API reply\n+            scrapeChannelOptions(message);\n+            return;\n+        }\n+        if (message.contains(\"<ac>0</ac>\")) {\n+            updateState(CHANNEL_MASTER_CONTROLS, OnOffType.OFF);\n+        } else {\n+            masterBrightness255 = new BigDecimal(WLedHelper.getValue(message, \"<ac>\", \"<\"));\n+            updateState(CHANNEL_MASTER_CONTROLS,\n+                    new PercentType(masterBrightness255.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP)));\n+        }\n+        if (message.contains(\"<ix>0</ix>\")) {\n+            updateState(CHANNEL_INTENSITY, OnOffType.OFF);\n+        } else {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<ix>\", \"<\")).divide(BIG_DECIMAL_2_55,\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_INTENSITY, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<cy>1</cy>\")) {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_PRESET_CYCLE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nl>1</nl>\")) {\n+            updateState(CHANNEL_SLEEP, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SLEEP, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<ns>1</ns>\")) {\n+            updateState(CHANNEL_SYNC_SEND, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SYNC_SEND, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<nr>1</nr>\")) {\n+            updateState(CHANNEL_SYNC_RECEIVE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_SYNC_RECEIVE, OnOffType.OFF);\n+        }\n+        if (message.contains(\"<fx>\")) {\n+            updateState(CHANNEL_FX, new StringType(WLedHelper.getValue(message, \"<fx>\", \"<\")));\n+        }\n+        if (message.contains(\"<sx>\")) {\n+            BigDecimal bigTemp = new BigDecimal(WLedHelper.getValue(message, \"<sx>\", \"<\")).divide(BIG_DECIMAL_2_55,\n+                    RoundingMode.HALF_UP);\n+            updateState(CHANNEL_SPEED, new PercentType(bigTemp));\n+        }\n+        if (message.contains(\"<fp>\")) {\n+            updateState(CHANNEL_PALETTES, new StringType(WLedHelper.getValue(message, \"<fp>\", \"<\")));\n+        }\n+        parseColours(message);\n+    }\n+\n+    private void sendWhite() {\n+        if (hasWhite) {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFF000000\" + \"&A=\" + masterBrightness255);\n+        } else {\n+            sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=hFFFFFF\" + \"&A=\" + masterBrightness255);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param hsb\n+     * @return WLED needs the letter h followed by 2 digit HEX code for RRGGBB\n+     */\n+    private String createColorHex(HSBType hsb) {\n+        return String.format(\"h%06X\", hsb.getRGB());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        BigDecimal bigTemp;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MASTER_CONTROLS:\n+                    sendGetRequest(\"/win\");\n+            }\n+            return;// no need to check for refresh below\n+        }\n+        logger.debug(\"command {} sent to {}\", command, channelUID.getId());\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SYNC_SEND:\n+                if (OnOffType.OFF.equals(command)) {\n+                    sendGetRequest(\"/win&NS=0\");\n+                } else {\n+                    sendGetRequest(\"/win&NS=1\");\n+                }\n+                break;\n+            case CHANNEL_SYNC_RECEIVE:\n+                if (OnOffType.OFF.equals(command)) {\n+                    sendGetRequest(\"/win&NR=0\");\n+                } else {\n+                    sendGetRequest(\"/win&NR=1\");\n+                }\n+                break;\n+            case CHANNEL_PRIMARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W=\" + ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55));\n+                }\n+                break;\n+            case CHANNEL_SECONDARY_WHITE:\n+                if (command instanceof PercentType) {\n+                    sendGetRequest(\"/win&W2=\" + ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55));\n+                }\n+                break;\n+            case CHANNEL_MASTER_CONTROLS:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.OFF.equals(command)) {\n+                        sendGetRequest(\"/win&TT=250&T=0\");\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&T=1\");\n+                    }\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                        if (masterBrightness255.intValue() < 240) {\n+                            sendGetRequest(\"/win&TT=1000&A=~15\"); // 255 divided by 15 = 17 different levels\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=255\");\n+                        }\n+                    } else {\n+                        if (masterBrightness255.intValue() > 15) {\n+                            sendGetRequest(\"/win&TT=1000&A=~-15\");\n+                        } else {\n+                            sendGetRequest(\"/win&TT=1000&A=0\");\n+                        }\n+                    }\n+                } else if (command instanceof HSBType) {\n+                    if ((((HSBType) command).getBrightness()) == PercentType.ZERO) {\n+                        sendGetRequest(\"/win&TT=500&T=0\");\n+                    }\n+                    primaryColor = (HSBType) command;\n+                    masterBrightness255 = primaryColor.getBrightness().toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                    if (primaryColor.getSaturation().intValue() < config.saturationThreshold) {\n+                        sendWhite();\n+                    } else if (primaryColor.getSaturation().intValue() == 32 && primaryColor.getHue().intValue() == 36\n+                            && hasWhite) {\n+                        // Google sends this when it wants white\n+                        sendWhite();\n+                    } else {\n+                        sendGetRequest(\"/win&TT=1000&FX=0&CY=0&CL=\" + createColorHex(primaryColor) + \"&A=\"\n+                                + masterBrightness255);\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    masterBrightness255 = ((PercentType) command).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                    sendGetRequest(\"/win&TT=1000&A=\" + masterBrightness255);\n+                }\n+                return;\n+            case CHANNEL_PRIMARY_COLOR:\n+                if (command instanceof HSBType) {\n+                    primaryColor = (HSBType) command;\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                } else if (command instanceof PercentType) {\n+                    primaryColor = new HSBType(primaryColor.getHue(), primaryColor.getSaturation(),\n+                            ((PercentType) command));\n+                    sendGetRequest(\"/win&CL=\" + createColorHex(primaryColor));\n+                }\n+                return;\n+            case CHANNEL_SECONDARY_COLOR:\n+                if (command instanceof HSBType) {\n+                    secondaryColor = (HSBType) command;\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                } else if (command instanceof PercentType) {\n+                    secondaryColor = new HSBType(secondaryColor.getHue(), secondaryColor.getSaturation(),\n+                            ((PercentType) command));\n+                    sendGetRequest(\"/win&C2=\" + createColorHex(secondaryColor));\n+                }\n+                return;\n+            case CHANNEL_PALETTES:\n+                sendGetRequest(\"/win&FP=\" + command);\n+                break;\n+            case CHANNEL_FX:\n+                sendGetRequest(\"/win&FX=\" + command);\n+                break;\n+            case CHANNEL_SPEED:\n+                bigTemp = ((State) command).as(PercentType.class).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                sendGetRequest(\"/win&SX=\" + bigTemp);\n+                break;\n+            case CHANNEL_INTENSITY:\n+                bigTemp = ((State) command).as(PercentType.class).toBigDecimal().multiply(BIG_DECIMAL_2_55);\n+                sendGetRequest(\"/win&IX=\" + bigTemp);\n+                break;\n+            case CHANNEL_SLEEP:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&NL=1\");\n+                } else {\n+                    sendGetRequest(\"/win&NL=0\");\n+                }\n+                break;\n+            case CHANNEL_PRESETS:\n+                sendGetRequest(\"/win&PL=\" + command);\n+                break;\n+            case CHANNEL_PRESET_DURATION:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> seconds = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+                    if (seconds != null) {\n+                        bigTemp = new BigDecimal(seconds.intValue()).multiply(new BigDecimal(1000));\n+                        sendGetRequest(\"/win&PT=\" + bigTemp.intValue());\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TRANS_TIME:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> seconds = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+                    if (seconds != null) {\n+                        bigTemp = new BigDecimal(seconds.intValue()).multiply(new BigDecimal(1000));\n+                        sendGetRequest(\"/win&TT=\" + bigTemp.intValue());\n+                    }\n+                }\n+                break;\n+            case CHANNEL_PRESET_CYCLE:\n+                if (OnOffType.ON.equals(command)) {\n+                    sendGetRequest(\"/win&CY=1\");\n+                } else {\n+                    sendGetRequest(\"/win&CY=0\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void savePreset(int presetIndex) {\n+        if (presetIndex > 16) {\n+            logger.warn(\"Presets above 16 do not exist, and the action sent {}\", presetIndex);\n+            return;\n+        }\n+        sendGetRequest(\"/win&PS=\" + presetIndex);\n+    }\n+\n+    private void pollLED() {\n+        sendGetRequest(\"/win\");\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WLedConfiguration.class);\n+        if (!config.address.contains(\"://\")) {\n+            logger.debug(\"Address was not entered in correct format, it may be the raw IP so adding http:// to start\");\n+            config.address = \"http://\" + config.address;\n+        }\n+        pollingFuture = scheduler.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingFuture != null) {\n+            pollingFuture.cancel(true);\n+        }", "originalCommit": "351c1fd2776e528deff0b18b62f0630026daa384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU0NTgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8669#discussion_r516545803", "bodyText": "Thank you for showing how it is meant to be handled, all warnings of that type are gone.", "author": "Skinah", "createdAt": "2020-11-03T09:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTU0MA=="}], "type": "inlineReview"}, {"oid": "f3fe2cd6d0a1b4e19adf78cf4fa5bb2ef0af3a78", "url": "https://github.com/openhab/openhab-addons/commit/f3fe2cd6d0a1b4e19adf78cf4fa5bb2ef0af3a78", "message": "Update bundles/org.openhab.binding.wled/src/main/java/org/openhab/binding/wled/internal/WLedHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Connor Petty <mistercpp2000@gmail.com>", "committedDate": "2020-11-03T09:44:07Z", "type": "commit"}, {"oid": "b1e5e3cc4ce636ec2396cbc2819c7641597347c4", "url": "https://github.com/openhab/openhab-addons/commit/b1e5e3cc4ce636ec2396cbc2819c7641597347c4", "message": "Fix null compiler warnings.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-11-03T09:53:20Z", "type": "commit"}]}