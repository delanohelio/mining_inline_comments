{"pr_number": 8791, "pr_title": "[remoteopenhab] Remote openHAB binding - initial contribution", "pr_createdAt": "2020-10-18T14:37:42Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8791", "timeline": [{"oid": "023b3589c4f2f270c9a07e5f0771115b70942832", "url": "https://github.com/openhab/openhab-addons/commit/023b3589c4f2f270c9a07e5f0771115b70942832", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-18T15:52:08Z", "type": "forcePushed"}, {"oid": "e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "url": "https://github.com/openhab/openhab-addons/commit/e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-18T16:36:44Z", "type": "forcePushed"}, {"oid": "332da34cd131b5797a00aa8b48d8fd5110013422", "url": "https://github.com/openhab/openhab-addons/commit/332da34cd131b5797a00aa8b48d8fd5110013422", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T22:51:30Z", "type": "forcePushed"}, {"oid": "5e078b7c3c989058f6c29adce34e9ea5886df99b", "url": "https://github.com/openhab/openhab-addons/commit/5e078b7c3c989058f6c29adce34e9ea5886df99b", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T23:11:18Z", "type": "forcePushed"}, {"oid": "335f18e30dddff63ee31f101dd58b9cda870055a", "url": "https://github.com/openhab/openhab-addons/commit/335f18e30dddff63ee31f101dd58b9cda870055a", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-19T23:45:49Z", "type": "forcePushed"}, {"oid": "a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "url": "https://github.com/openhab/openhab-addons/commit/a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T12:34:43Z", "type": "forcePushed"}, {"oid": "d752da047f972112f9a3ac01e557acc150b205c8", "url": "https://github.com/openhab/openhab-addons/commit/d752da047f972112f9a3ac01e557acc150b205c8", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T12:46:46Z", "type": "forcePushed"}, {"oid": "35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "url": "https://github.com/openhab/openhab-addons/commit/35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-20T18:32:21Z", "type": "forcePushed"}, {"oid": "a95bdbfa2b6335e53d419720ad294a8c38078acc", "url": "https://github.com/openhab/openhab-addons/commit/a95bdbfa2b6335e53d419720ad294a8c38078acc", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-21T21:14:45Z", "type": "forcePushed"}, {"oid": "978d18e87a8056157d3ab3963b676727b1c8a744", "url": "https://github.com/openhab/openhab-addons/commit/978d18e87a8056157d3ab3963b676727b1c8a744", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-21T22:47:55Z", "type": "forcePushed"}, {"oid": "d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "url": "https://github.com/openhab/openhab-addons/commit/d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-22T11:27:34Z", "type": "forcePushed"}, {"oid": "b623bd4cc53f5fe6b10ef91ce0be832b67748003", "url": "https://github.com/openhab/openhab-addons/commit/b623bd4cc53f5fe6b10ef91ce0be832b67748003", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-22T18:27:58Z", "type": "forcePushed"}, {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-23T20:12:45Z", "type": "commit"}, {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-23T20:12:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296767", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    createChannels(items, false);\n          \n          \n            \n                    createChannels(List.of(item), false);", "author": "cpmeister", "createdAt": "2020-10-24T03:42:56Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359891", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296843", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    removeChannels(items);\n          \n          \n            \n                    removeChannels(List.of(item));", "author": "cpmeister", "createdAt": "2020-10-24T03:43:11Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359823", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300254", "bodyText": "In this circumstance it would be better to synchronize on the client itself rather than 'this'.\nAlso it seems wasteful to remove and re-add yourself as a listener every time you restart the client so I've adjusted the restartStreamingUpdates code accordingly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    synchronized (this) {\n          \n          \n            \n                        stopStreamingUpdates();\n          \n          \n            \n                        startStreamingUpdates();\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized(client){\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-10-24T03:53:05Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM0OTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511349236", "bodyText": "Ok for the synchronized on the client.\nRegarding adding and removing the thing handler as listener, the idea is to be sure to not handle events coming from SSE after you d\u00e9cided to stop it. I prefer to keep this unchanged.", "author": "lolodomo", "createdAt": "2020-10-24T08:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMTc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511501799", "bodyText": "fine by me", "author": "cpmeister", "createdAt": "2020-10-24T18:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300644", "bodyText": "Might as well cover all your bases.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n          \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isDone()) {", "author": "cpmeister", "createdAt": "2020-10-24T03:54:21Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1MjM3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511352373", "bodyText": "Why should I use here a different \"pattern\" from you can already find in hundreds of bindings ?", "author": "lolodomo", "createdAt": "2020-10-24T09:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMjAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511502004", "bodyText": "Well if the prior job finished due to an error then isCancelled would return false, but isDone would return true. I figure if the intent is to restart the future if it is no longer running, isDone is more appropriate in that case.", "author": "cpmeister", "createdAt": "2020-10-24T18:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511303168", "bodyText": "Please cache channelState.toFullString() to a local variable.", "author": "cpmeister", "createdAt": "2020-10-24T04:01:46Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);\n+        } else {\n+            logger.trace(\"Updated remote item {} ignored because item type {} is unchanged\", newItem.name,\n+                    newItem.type);\n+        }\n+    }\n+\n+    private void updateChannelState(String itemName, @Nullable String stateType, String state) {\n+        Channel channel = getThing().getChannel(itemName);\n+        if (channel == null) {\n+            logger.trace(\"No channel for item {}\", itemName);\n+            return;\n+        }\n+        String acceptedItemType = channel.getAcceptedItemType();\n+        if (acceptedItemType == null) {\n+            logger.trace(\"Channel without accepted item type for item {}\", itemName);\n+            return;\n+        }\n+        if (!isLinked(channel.getUID())) {\n+            logger.trace(\"Unlinked channel {}\", channel.getUID());\n+            return;\n+        }\n+        State channelState = null;\n+        if (stateType == null && \"NULL\".equals(state)) {\n+            channelState = UnDefType.NULL;\n+        } else if (stateType == null && \"UNDEF\".equals(state)) {\n+            channelState = UnDefType.UNDEF;\n+        } else if (\"UnDef\".equals(stateType)) {\n+            switch (state) {\n+                case \"NULL\":\n+                    channelState = UnDefType.NULL;\n+                    break;\n+                case \"UNDEF\":\n+                    channelState = UnDefType.UNDEF;\n+                    break;\n+                default:\n+                    logger.debug(\"Invalid UnDef value {} for item {}\", state, itemName);\n+                    break;\n+            }\n+        } else if (acceptedItemType.startsWith(CoreItemFactory.NUMBER + \":\")) {\n+            // Item type Number with dimension\n+            if (checkStateType(itemName, stateType, \"Quantity\")) {\n+                List<Class<? extends State>> stateTypes = Collections.singletonList(QuantityType.class);\n+                channelState = TypeParser.parseState(stateTypes, state);\n+            }\n+        } else {\n+            switch (acceptedItemType) {\n+                case CoreItemFactory.STRING:\n+                    if (checkStateType(itemName, stateType, \"String\")) {\n+                        channelState = new StringType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.NUMBER:\n+                    if (checkStateType(itemName, stateType, \"Decimal\")) {\n+                        channelState = new DecimalType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.SWITCH:\n+                    if (checkStateType(itemName, stateType, \"OnOff\")) {\n+                        channelState = \"ON\".equals(state) ? OnOffType.ON : OnOffType.OFF;\n+                    }\n+                    break;\n+                case CoreItemFactory.CONTACT:\n+                    if (checkStateType(itemName, stateType, \"OpenClosed\")) {\n+                        channelState = \"OPEN\".equals(state) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                    }\n+                    break;\n+                case CoreItemFactory.DIMMER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.COLOR:\n+                    if (checkStateType(itemName, stateType, \"HSB\")) {\n+                        channelState = HSBType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.DATETIME:\n+                    if (checkStateType(itemName, stateType, \"DateTime\")) {\n+                        try {\n+                            channelState = new DateTimeType(ZonedDateTime.parse(state, FORMATTER_DATE));\n+                        } catch (DateTimeParseException e) {\n+                            logger.debug(\"Failed to parse date {} for item {}\", state, itemName);\n+                            channelState = null;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.LOCATION:\n+                    if (checkStateType(itemName, stateType, \"Point\")) {\n+                        channelState = new PointType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.IMAGE:\n+                    if (checkStateType(itemName, stateType, \"Raw\")) {\n+                        channelState = RawType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.PLAYER:\n+                    if (checkStateType(itemName, stateType, \"PlayPause\")) {\n+                        switch (state) {\n+                            case \"PLAY\":\n+                                channelState = PlayPauseType.PLAY;\n+                                break;\n+                            case \"PAUSE\":\n+                                channelState = PlayPauseType.PAUSE;\n+                                break;\n+                            default:\n+                                logger.debug(\"Unexpected value {} for item {}\", state, itemName);\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.ROLLERSHUTTER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"Item type {} is not yet supported\", acceptedItemType);\n+                    break;\n+            }\n+        }\n+        if (channelState != null) {\n+            updateState(channel.getUID(), channelState);\n+            logger.debug(\"updateState {} with {}\", channel.getUID(),\n+                    channelState.toFullString().length() < 50 ? channelState.toFullString()\n+                            : channelState.toFullString().substring(0, 50) + \"...\");", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359744", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305125", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-10-24T04:06:34Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359700", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305701", "bodyText": "I think this javadoc needs to be updated", "author": "cpmeister", "createdAt": "2020-10-24T04:07:45Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "originalCommit": "3dc867e53fe095f9925c318f8b1963318874020d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1NDc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511354767", "bodyText": "You see where was my initial inspiration :)", "author": "lolodomo", "createdAt": "2020-10-24T09:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTYyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359623", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T09:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}], "type": "inlineReview"}, {"oid": "678d76ffde124beb440c5e418f35fc593b5a03e6", "url": "https://github.com/openhab/openhab-addons/commit/678d76ffde124beb440c5e418f35fc593b5a03e6", "message": "Review comment: List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T08:43:56Z", "type": "commit"}, {"oid": "184d00e637e6dd7da2a314c15899a43ebaddd92e", "url": "https://github.com/openhab/openhab-addons/commit/184d00e637e6dd7da2a314c15899a43ebaddd92e", "message": "Review comment: synchronized on restClient rather than thingHandler\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T08:52:31Z", "type": "commit"}, {"oid": "b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "url": "https://github.com/openhab/openhab-addons/commit/b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "message": "Review comment: cache channelState.toFullString() and command.toFullString() to local variables\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:09:21Z", "type": "commit"}, {"oid": "e0f4e3f868826a1d85926fc598fb356d81a55e66", "url": "https://github.com/openhab/openhab-addons/commit/e0f4e3f868826a1d85926fc598fb356d81a55e66", "message": "Review comment: class description (thing handler)\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:17:10Z", "type": "commit"}, {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "url": "https://github.com/openhab/openhab-addons/commit/81f2e2faf5d54ee22f8c579d08c37ef95508e197", "message": "Switch the thing to a bridge to prepare the near future\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T09:59:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517331", "bodyText": "May I ask why? Could that maybe be an optional configuration parameter, if people would like to have encrypted traffic in their local network?", "author": "kaikreuzer", "createdAt": "2020-10-24T21:42:03Z", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521713", "bodyText": "It is just not yet implemented.\nExcept for SSE, I am using HttpUtil.executeUrl to call the REST API. This utility method from the core framework does not work if you pass a HTTPS URL.\nThis would probably require to define a dedicated HttpClient with a SSL context.\nBut this was not my priority.", "author": "lolodomo", "createdAt": "2020-10-24T22:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY0MTY0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511641645", "bodyText": "Ok, I see. I guess this is because of the self-signed certificate, so that the HttpUtil does not consider the connection to be secure.", "author": "kaikreuzer", "createdAt": "2020-10-25T20:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY2Mjk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511662983", "bodyText": "FYI, here is the exception I got. Note that I have no certificate set for my servers. Maybe it will work for users having a real certificate.\norg.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException: Failed to execute the root REST API\n\tat org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient.tryApi(RemoteopenhabRestClient.java:119)\n\tat org.openhab.binding.remoteopenhab.internal.handler.RemoteopenhabBridgeHandler.checkConnection(RemoteopenhabBridgeHandler.java:320)\n\tat org.openhab.binding.remoteopenhab.internal.handler.RemoteopenhabBridgeHandler.lambda$2(RemoteopenhabBridgeHandler.java:352)\n\tat java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)\n\tat java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305)\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\nCaused by: java.io.IOException: java.util.concurrent.ExecutionException: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrlAndGetReponse(HttpUtil.java:260)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrl(HttpUtil.java:156)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrl(HttpUtil.java:131)\n\tat org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient.tryApi(RemoteopenhabRestClient.java:95)\n\t... 8 common frames omitted\nCaused by: java.util.concurrent.ExecutionException: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat org.eclipse.jetty.client.util.FutureResponseListener.getResult(FutureResponseListener.java:118)\n\tat org.eclipse.jetty.client.util.FutureResponseListener.get(FutureResponseListener.java:101)\n\tat org.eclipse.jetty.client.HttpRequest.send(HttpRequest.java:685)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrlAndGetReponse(HttpUtil.java:251)\n\t... 11 common frames omitted\nCaused by: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.ssl.Alert.createSSLException(Alert.java:131)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:326)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:269)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:264)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:645)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.onCertificate(CertificateMessage.java:464)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.consume(CertificateMessage.java:360)\n\tat java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:392)\n\tat java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1074)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1061)\n\tat java.base/java.security.AccessController.doPrivileged(Native Method)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:1008)\n\tat org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.fill(SslConnection.java:526)\n\tat org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:128)\n\tat org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:73)\n\tat org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:133)\n\tat org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:154)\n\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\n\tat org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:426)\n\tat org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:320)\n\tat org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:158)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\n\tat org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:782)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:918)\n\t... 1 common frames omitted\nCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:439)\n\tat java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:306)\n\tat java.base/sun.security.validator.Validator.validate(Validator.java:264)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:313)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:276)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:141)\n\tat org.openhab.core.io.net.http.internal.ExtensibleTrustManagerImpl.checkServerTrusted(ExtensibleTrustManagerImpl.java:119)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:623)\n\t... 23 common frames omitted\nCaused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141)\n\tat java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126)\n\tat java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297)\n\tat java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:434)\n\t... 30 common frames omitted", "author": "lolodomo", "createdAt": "2020-10-25T23:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1ODY0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511758648", "bodyText": "@kaikreuzer : I will allow HTTPS later today mentioning in the documention the requirement of a valid SSL certificate for the remote openHAB server. Will you be able to validate that it works ?", "author": "lolodomo", "createdAt": "2020-10-26T07:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1OTkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511759901", "bodyText": "Yes, that's what I expected, thanks.\nIf we had a hostname at hand, the solution would be to register a component like this one. When using IP addresses, this won't work, though, I'm afraid.\nSo fine for me to stick to HTTP for now and look at HTTPS support as a follow-up.", "author": "kaikreuzer", "createdAt": "2020-10-26T07:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MjMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r519042326", "bodyText": "FYI, I succeeded  with HTTPS. I am waiting for the merge of my second PR to create a third one for HTTPS.", "author": "lolodomo", "createdAt": "2020-11-06T22:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517512", "bodyText": "I would find it much more straight forward to simply have the ip address (or hostname) as a configuration parameter - it is imho much more convenient for users when doing textual configuration. Furthermore, that's the standard way we also identify other devices/services on the network.", "author": "kaikreuzer", "createdAt": "2020-10-24T21:44:53Z", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522015", "bodyText": "This would require another setting for the port + another to choose between HTTP and HTTPS (when HTTPS will be possible).\nAnd the mDNS announcer is even providing the path (\"/rest\").\nSo the REST API URL as configuration setting looks like a good solution, to not say a better solution.\nBut of course, this can be changed.", "author": "lolodomo", "createdAt": "2020-10-24T22:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NTQ4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511555488", "bodyText": "Ok I am finally convinced, I will update in favor or several configuration settings.", "author": "lolodomo", "createdAt": "2020-10-25T06:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3NzgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511577803", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-25T10:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517722", "bodyText": "I'd suggest this change to make it clearer that \"Date\" is just some item name here (and not a type or keyword):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }\n          \n          \n            \n            DateTime MyDate \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:MyDate\" }", "author": "kaikreuzer", "createdAt": "2020-10-24T21:46:29Z", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).\n+\n+## Example\n+\n+### demo.things:\n+\n+```\n+Bridge remoteopenhab:server:oh2 \"OH2 server\" [ restUrl=\"http://192.168.0.100:8080/rest\" ]\n+```\n+\n+### demo.items:\n+\n+```\n+DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjI1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522251", "bodyText": "Changed", "author": "lolodomo", "createdAt": "2020-10-24T22:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517799", "bodyText": "Please at least one line of JavaDoc.", "author": "kaikreuzer", "createdAt": "2020-10-24T21:47:19Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ *", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522705", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T22:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517987", "bodyText": "Don't add the IP to the label, but make it the representation property instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n          \n          \n            \n                        String label = \"openHAB Server\";", "author": "kaikreuzer", "createdAt": "2020-10-24T21:49:47Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzExOA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523118", "bodyText": "If I do that, we will have no way to distinguish servers in the inbox.", "author": "lolodomo", "createdAt": "2020-10-24T22:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524970", "bodyText": "Here is how it looks now:\n\nWith your proposed change, all entries would have the same name \"openHAB server\" in the inbox.", "author": "lolodomo", "createdAt": "2020-10-24T23:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY0MTgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511641825", "bodyText": "Yes, that's exactly the idea - the label should describe the \"what\" it found and the presentation property allows to differentiate identical devices from each other.\n@ghys, it seems then that the presentation property is not yet considered that way in the Inbox. Shall I enter an issue for that?", "author": "kaikreuzer", "createdAt": "2020-10-25T20:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1ODQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511658422", "bodyText": "@kaikreuzer : the representation property was not yet defined. With it added, I see the IP (representation property) on the second line.\n@ghys : don't loose your time ;)", "author": "lolodomo", "createdAt": "2020-10-25T22:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1OTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511659074", "bodyText": "Done (simplified label + representation property added)", "author": "lolodomo", "createdAt": "2020-10-25T22:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n          \n          \n            \n                        logger.debug(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "author": "kaikreuzer", "createdAt": "2020-10-24T21:49:58Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522936", "bodyText": "Ok", "author": "lolodomo", "createdAt": "2020-10-24T22:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODI5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518295", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Remote Server</label>\n          \n          \n            \n            \t\t<label>Remote openHAB Server</label>", "author": "kaikreuzer", "createdAt": "2020-10-24T21:53:00Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,28 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"remoteopenhab\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"server\">\n+\t\t<label>Remote Server</label>", "originalCommit": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523021", "bodyText": "Ok", "author": "lolodomo", "createdAt": "2020-10-24T22:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODI5NQ=="}], "type": "inlineReview"}, {"oid": "761b31eb8795e521e507859e4b4b381028b4d905", "url": "https://github.com/openhab/openhab-addons/commit/761b31eb8795e521e507859e4b4b381028b4d905", "message": "Do not create discovery results for the local server\n\nImproved checking of the configuration setting validity at thing handler initialization\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:15:48Z", "type": "commit"}, {"oid": "9117730f3bd25575e616742680cf13c691bd5c70", "url": "https://github.com/openhab/openhab-addons/commit/9117730f3bd25575e616742680cf13c691bd5c70", "message": "Review comment: Item example changed in the documentation\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:45:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMDg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511520872", "bodyText": "This suggestion will be automated by openhab/static-code-analysis#395:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n          \n          \n            \n            <features name=\"org.openhab.binding.remoteopenhab-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "author": "wborn", "createdAt": "2020-10-24T22:26:20Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523613", "bodyText": "Done.\nI run \"mvn spotless:apply\" too.", "author": "lolodomo", "createdAt": "2020-10-24T23:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMDg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521311", "bodyText": "This can be a one liner in Java 11:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new HashMap<>(1);\n          \n          \n            \n                        properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);\n          \n          \n            \n                        Map<String, Object> properties = Map.of(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "author": "wborn", "createdAt": "2020-10-24T22:32:29Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        // Host address matching a local IP address are ignored\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()\n+                && !matchLocalIpAddress(service.getHostAddresses()[0])) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    private boolean matchLocalIpAddress(String serviceHostAddress) {\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        return localIpAddresses.contains(serviceHostAddress.replaceAll(\"\\\\[|\\\\]\", \"\"));\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n+                    url + restPath);\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523748", "bodyText": "Ok", "author": "lolodomo", "createdAt": "2020-10-24T23:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521556", "bodyText": "Can you turn the magic number 50 into a constant with a descriptive name? It's also used below on line 541.", "author": "wborn", "createdAt": "2020-10-24T22:36:06Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524009", "bodyText": "Done", "author": "lolodomo", "createdAt": "2020-10-24T23:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521784", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Item> items = new ArrayList<>();\n          \n          \n            \n                        items.add(newItem);\n          \n          \n            \n                        createChannels(items, false);\n          \n          \n            \n                        createChannels(List.of(newItem), false);", "author": "wborn", "createdAt": "2020-10-24T22:39:49Z", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                stopStreamingUpdates();\n+                startStreamingUpdates();\n+            }\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        createChannels(List.of(item), false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        removeChannels(List.of(item));\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);", "originalCommit": "761b31eb8795e521e507859e4b4b381028b4d905", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524280", "bodyText": "I already changed 2 just below this morning but forgot this one.\nDone", "author": "lolodomo", "createdAt": "2020-10-24T23:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA=="}], "type": "inlineReview"}, {"oid": "1ca8e3aaf97d29bc08c126f607df1d09634e009a", "url": "https://github.com/openhab/openhab-addons/commit/1ca8e3aaf97d29bc08c126f607df1d09634e009a", "message": "Review comment: description added to class RemoteopenhabChannelTypeProvider\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:52:59Z", "type": "commit"}, {"oid": "ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "url": "https://github.com/openhab/openhab-addons/commit/ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "message": "Review comment: log level in the discovery service\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:56:11Z", "type": "commit"}, {"oid": "8f39558be54080a90cefaa3042ffe703724cd062", "url": "https://github.com/openhab/openhab-addons/commit/8f39558be54080a90cefaa3042ffe703724cd062", "message": "Review comment: change the label of the thing type\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T22:57:59Z", "type": "commit"}, {"oid": "ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "url": "https://github.com/openhab/openhab-addons/commit/ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "message": "Review comment: fix feature.xml\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:05:12Z", "type": "commit"}, {"oid": "f4b108bece16ef4579d391a62a9555f237fe469a", "url": "https://github.com/openhab/openhab-addons/commit/f4b108bece16ef4579d391a62a9555f237fe469a", "message": "Review comment: use Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:08:06Z", "type": "commit"}, {"oid": "41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "url": "https://github.com/openhab/openhab-addons/commit/41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "message": "Review comment: define MAX_STATE_SIZE_FOR_LOGGING\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:10:52Z", "type": "commit"}, {"oid": "d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "url": "https://github.com/openhab/openhab-addons/commit/d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "message": "Review comment: another List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-24T23:13:51Z", "type": "commit"}, {"oid": "6a010df21d2d1863aac75c444c92979d21da911e", "url": "https://github.com/openhab/openhab-addons/commit/6a010df21d2d1863aac75c444c92979d21da911e", "message": "Review comment: Change thing configuration settings\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T10:27:59Z", "type": "commit"}, {"oid": "3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "url": "https://github.com/openhab/openhab-addons/commit/3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "message": "Take into consideration the read only property of an item\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T19:13:09Z", "type": "commit"}, {"oid": "d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "url": "https://github.com/openhab/openhab-addons/commit/d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "message": "Review comment: add the host as representation property and simplify the discovery result label\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T22:39:01Z", "type": "commit"}, {"oid": "d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "url": "https://github.com/openhab/openhab-addons/commit/d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "message": "Restore the use of Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-10-25T22:54:00Z", "type": "commit"}]}