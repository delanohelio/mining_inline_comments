{"pr_number": 7994, "pr_title": "[modbus] Modbus transport API simplification", "pr_createdAt": "2020-06-23T17:55:01Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7994", "timeline": [{"oid": "e78cf011bfbbb8d374547393b93a9ed8bb18d025", "url": "https://github.com/openhab/openhab-addons/commit/e78cf011bfbbb8d374547393b93a9ed8bb18d025", "message": "[modbus] Race condition fix\n\nThe CountDownLatch was used as a guard (latch.await) in many tests to\nwait for callbacks to be called before proceeding with assertions.\n\nSince the latch was countDown() beginning of the callback, we introduced\na race condition with the subsequent assertions and updating the other\ncounters used in the subsequent assertions.\n\nThis commit updates the CountDownLatch as the last step of the callback,\nresolving the race condition.\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-06-24T10:12:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NDU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445154581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Error closing modbus communication interface\", e);\n          \n          \n            \n                        logger.warn(\"Error closing modbus communication interface\", e);", "author": "cpmeister", "createdAt": "2020-06-24T20:32:29Z", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/AbstractModbusEndpointThingHandler.java", "diffHunk": "@@ -92,33 +96,26 @@ public void initialize() {\n \n     @Override\n     public void dispose() {\n-        managerRef.get().removeListener(this);\n-    }\n-\n-    @Override\n-    public @Nullable ModbusSlaveEndpoint asSlaveEndpoint() {\n-        return endpoint;\n+        try {\n+            ModbusCommunicationInterface localComms = comms;\n+            if (localComms != null) {\n+                localComms.close();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Error closing modbus communication interface\", e);", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1Njc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756767", "bodyText": "Coming in via mrbig@5599748", "author": "ssalonen", "createdAt": "2020-07-04T09:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NTI0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445155242", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private BitArray bits;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                private ModbusRegisterArray registers;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                private Exception cause;\n          \n          \n            \n                private @Nullable BitArray bits;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable ModbusRegisterArray registers;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable Exception cause;", "author": "cpmeister", "createdAt": "2020-06-24T20:33:45Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/AsyncModbusReadResult.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.transport.modbus;\n+\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Encapsulates result of modbus read operations\n+ *\n+ * @author Sami Salonen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AsyncModbusReadResult {\n+\n+    private ModbusReadRequestBlueprint request;\n+\n+    @Nullable\n+    private BitArray bits;\n+\n+    @Nullable\n+    private ModbusRegisterArray registers;\n+\n+    @Nullable\n+    private Exception cause;", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445157880", "bodyText": "The Apache commons lang library will no longer be available to bindings in OH3. So we are in the process of migrating code away from using it. Please try to implement your code without that library, or if you really need it you will have to specify the dependency manually in the binding pom.", "author": "cpmeister", "createdAt": "2020-06-24T20:38:48Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusReadRequestBlueprint.java", "diffHunk": "@@ -12,47 +12,121 @@\n  */\n package org.openhab.io.transport.modbus;\n \n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.StandardToStringStyle;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import net.wimpi.modbus.Modbus;\n \n /**\n- * Low-level interface representing a read request\n+ * Implementation of immutable representation of modbus read request\n+ *\n+ * Equals and hashCode implemented keeping {@link PollTask} in mind: two instances of this class are considered the same\n+ * if they have\n+ * the equal parameters (same slave id, start, length, function code and maxTries).\n  *\n  * @author Sami Salonen - Initial contribution\n  *\n  */\n @NonNullByDefault\n-public interface ModbusReadRequestBlueprint extends ModbusRequestBlueprint {\n+public class ModbusReadRequestBlueprint {\n+    private static StandardToStringStyle toStringStyle = new StandardToStringStyle();", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2OTE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445369174", "bodyText": "This PR is not introducing it though.\nI am happy to make this change but perhaps we should move it to separate PR to get this big one going?", "author": "ssalonen", "createdAt": "2020-06-25T07:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNjYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r447336633", "bodyText": "fine by me", "author": "cpmeister", "createdAt": "2020-06-30T00:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1Nzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1ODQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445158497", "bodyText": "Can you change this to use a StringBuilder instead of a StringBuffer?", "author": "cpmeister", "createdAt": "2020-06-24T20:40:00Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/ModbusRegisterArray.java", "diffHunk": "@@ -70,7 +119,7 @@ default String toHexString() {\n      * Appends the register data as hex string to the given StringBuffer\n      *\n      */\n-    default StringBuffer appendHexString(StringBuffer buffer) {\n+    public StringBuffer appendHexString(StringBuffer buffer) {", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2OTUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445369512", "bodyText": "Same comment as above, would prefer this PR to move and introduce these general fixes separately", "author": "ssalonen", "createdAt": "2020-06-25T07:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1ODQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163322", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ScheduledFuture<?> future = executor.schedule(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, pollOperation);\n          \n          \n            \n                        }, 0L, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        ScheduledFuture<?> future = executor.submit(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, pollOperation);\n          \n          \n            \n                        });", "author": "cpmeister", "createdAt": "2020-06-24T20:49:24Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756675", "bodyText": "Coming in via mrbig@67f8eca", "author": "ssalonen", "createdAt": "2020-07-04T09:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163770", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n          \n          \n            \n                            future.cancel(true);\n          \n          \n            \n                            logger.info(\"Poll task {} canceled\", task);\n          \n          \n            \n                            logger.debug(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n          \n          \n            \n                            future.cancel(true);\n          \n          \n            \n                            logger.debug(\"Poll task {} canceled\", task);", "author": "cpmeister", "createdAt": "2020-06-24T20:50:16Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756556", "bodyText": "Coming in via mrbig@e61a970", "author": "ssalonen", "createdAt": "2020-07-04T09:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445163912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ScheduledFuture<?> future = localScheduledThreadPoolExecutor.schedule(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, writeOperation);\n          \n          \n            \n                        }, 0L, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        ScheduledFuture<?> future = localScheduledThreadPoolExecutor.submit(() -> {\n          \n          \n            \n                            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n          \n          \n            \n                            logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n          \n          \n            \n                                    millisInThreadPoolWaiting);\n          \n          \n            \n                            executeOperation(task, true, writeOperation);\n          \n          \n            \n                        });", "author": "cpmeister", "createdAt": "2020-06-24T20:50:33Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -736,123 +740,170 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(PollTask task) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public void registerRegularPoll(@NonNull PollTask task, long pollPeriodMillis, long initialDelayMillis) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n-            }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (Exception e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasksRegisteredByThisCommInterface = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+        private @Nullable EndpointPoolConfiguration configuration;\n \n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            this.configuration = configuration;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (Exception e) {\n+                        // We want to catch all unexpected exceptions since all unhandled exceptions make\n+                        // ScheduledExecutorService halt the polling. It is better to print out the exception, and try\n+                        // again\n+                        // (on next poll cycle)\n+                        logger.warn(\n+                                \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n+                                pollPeriodMillis, task, e);\n+                    }\n+                    long finished = System.currentTimeMillis();\n+                    logger.debug(\n+                            \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n+                            pollPeriodMillis, task, finished, started, finished - started);\n+                }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n+\n+                scheduledPollTasks.put(task, future);\n+                pollTasksRegisteredByThisCommInterface.add(task);\n+                logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                return task;\n             }\n-            logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n-\n-            // Make sure connections to this endpoint are closed when they are returned to pool (which\n-            // is usually pretty soon as transactions should be relatively short-lived)\n-            factory.disconnectOnReturn(task.getEndpoint(), System.currentTimeMillis());\n+        }\n \n-            future.cancel(true);\n+        @SuppressWarnings({ \"null\", \"unused\" })\n+        @Override\n+        public boolean unregisterRegularPoll(PollTask task) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                pollTasksRegisteredByThisCommInterface.remove(task);\n+                ModbusSlaveConnectionFactoryImpl localConnectionFactory = connectionFactory;\n+                Objects.requireNonNull(localConnectionFactory, \"Not activated!\");\n+\n+                // cancel poller\n+                @Nullable\n+                ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n+                if (future == null) {\n+                    // No such poll task\n+                    logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n+                    return false;\n+                }\n+                logger.info(\"Unregistering regular poll task {} (interrupting if necessary)\", task);\n+                future.cancel(true);\n+                logger.info(\"Poll task {} canceled\", task);\n+                return true;\n+            }\n+        }\n \n-            logger.info(\"Poll task {} canceled\", task);\n+        @Override\n+        public ScheduledFuture<?> submitOneTimeWrite(ModbusWriteRequestBlueprint request,\n+                @Nullable ModbusWriteCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService localScheduledThreadPoolExecutor = scheduledThreadPoolExecutor;\n+            Objects.requireNonNull(localScheduledThreadPoolExecutor, \"Not activated!\");\n+            WriteTask task = new BasicWriteTask(endpoint, request, callback);\n+            long scheduleTime = System.currentTimeMillis();\n+            logger.debug(\"Scheduling one-off write task {}\", task);\n+            ScheduledFuture<?> future = localScheduledThreadPoolExecutor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off write task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, writeOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc1NjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r449756456", "bodyText": "Coming in via mrbig@8eb186d", "author": "ssalonen", "createdAt": "2020-07-04T09:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTkyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445165924", "bodyText": "Why are you using assert here? Please remove them or throw a proper exception instead.", "author": "cpmeister", "createdAt": "2020-06-24T20:54:30Z", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -652,7 +653,36 @@ private boolean containsOpenClosed(List<Class<? extends State>> acceptedDataType\n     }\n \n     @Override\n-    public synchronized void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+    public synchronized void handle(AsyncModbusReadResult result) {\n+        if (result.hasError()) {\n+            Exception error = result.getCause();\n+            assert error != null;", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2NzQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367495", "bodyText": "Assert here is guaranteed to work or the API contract is violated, it is there for the developer.\nHowever, your suggestion regarding Optional is good, I think it will resolve this confusion as well.", "author": "ssalonen", "createdAt": "2020-06-25T07:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445167341", "bodyText": "please remove", "author": "cpmeister", "createdAt": "2020-06-24T20:57:09Z", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -72,66 +63,33 @@\n      */\n     private class ReadCallbackDelegator implements ModbusReadCallback {\n \n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils;\n-        private volatile @Nullable AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError;\n+        private volatile @Nullable AtomicStampedValue<AsyncModbusReadResult> lastResult;\n \n         @Override\n-        public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+        public synchronized void handle(AsyncModbusReadResult result) {\n             // Ignore all incoming data and errors if configuration is not correct\n             if (hasConfigurationError() || disposed) {\n                 return;\n             }\n             if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, ModbusRegisterArray> lastRegisters = this.lastRegisters;\n-                if (lastRegisters == null) {\n-                    this.lastRegisters = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, registers);\n+                AtomicStampedValue<AsyncModbusReadResult> localLastResult = this.lastResult;\n+                if (localLastResult == null) {\n+                    this.lastResult = new AtomicStampedValue<>(System.currentTimeMillis(), result);\n                 } else {\n-                    lastRegisters.update(System.currentTimeMillis(), request, registers);\n+                    localLastResult.update(System.currentTimeMillis(), result);\n+                    this.lastResult = localLastResult;\n                 }\n             }\n-            logger.debug(\"Thing {} received registers {} for request {}\", thing.getUID(), registers, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onRegisters(request, registers));\n-        }\n-\n-        @Override\n-        public void onBits(ModbusReadRequestBlueprint request, BitArray coils) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, BitArray> lastCoils = this.lastCoils;\n-                if (lastCoils == null) {\n-                    this.lastCoils = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, coils);\n-                } else {\n-                    lastCoils.update(System.currentTimeMillis(), request, coils);\n-                }\n-            }\n-            logger.debug(\"Thing {} received coils {} for request {}\", thing.getUID(), coils, request);\n-            resetCommunicationError();\n-            childCallbacks.forEach(handler -> handler.onBits(request, coils));\n-        }\n-\n-        @Override\n-        public void onError(ModbusReadRequestBlueprint request, Exception error) {\n-            // Ignore all incoming data and errors if configuration is not correct\n-            if (hasConfigurationError() || disposed) {\n-                return;\n-            }\n-            if (config.getCacheMillis() >= 0) {\n-                AtomicStampedKeyValue<ModbusReadRequestBlueprint, Exception> lastError = this.lastError;\n-                if (lastError == null) {\n-                    this.lastError = new AtomicStampedKeyValue<>(System.currentTimeMillis(), request, error);\n-                } else {\n-                    lastError.update(System.currentTimeMillis(), request, error);\n-                }\n+            logger.debug(\"Thing {} received response {}\", thing.getUID(), result);\n+            childCallbacks.forEach(handler -> handler.handle(result));\n+            if (result.hasError()) {\n+                Exception error = result.getCause();\n+                assert error != null;", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2NzU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367551", "bodyText": "Assert here is guaranteed to work or the API contract is violated, it is there for the developer.\nHowever, your suggestion regarding Optional is good, I think it will resolve this confusion as well.", "author": "ssalonen", "createdAt": "2020-06-25T07:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445170095", "bodyText": "Why not just have getCause() return an optional so you can use it to replace hasError while also avoiding all of the @NonNull casting you are doing?", "author": "cpmeister", "createdAt": "2020-06-24T21:02:39Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -280,30 +256,20 @@ private void modelBlockReceived(ModbusRegisterArray registers) {\n      * @param block\n      */\n     private void readCommonBlock(ModelBlock block) {\n-        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveId,\n                 ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, block.address, // Start address\n                 block.length, // number or words to return\n                 maxTries);\n \n-        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n-\n-            @Override\n-            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n-                parseCommonBlock(registers);\n-            }\n-\n-            @Override\n-            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+        comms.submitOneTimePoll(request, result -> {\n+            if (result.hasError()) {\n+                Exception error = (@NonNull Exception) result.getCause();", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM2Nzg2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445367865", "bodyText": "Makes sense actually...\ud83d\udc4d", "author": "ssalonen", "createdAt": "2020-06-25T07:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r445170262", "bodyText": "same suggestion here", "author": "cpmeister", "createdAt": "2020-06-24T21:03:00Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -158,30 +154,20 @@ public void detectModel() {\n         baseAddress = possibleAddresses.poll();\n         logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n \n-        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveId,\n                 ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n                 SUNSPEC_ID_SIZE, // number or words to return\n                 maxTries);\n \n-        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n-\n-            @Override\n-            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n-                headerReceived(registers);\n-            }\n-\n-            @Override\n-            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+        comms.submitOneTimePoll(request, result -> {\n+            if (result.hasError()) {\n+                Exception error = (@NonNull Exception) result.getCause();\n                 handleError(error);\n-            }\n-\n-            @Override\n-            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n-                // don't care, we don't expect this result\n+            } else {\n+                ModbusRegisterArray registers = (@NonNull ModbusRegisterArray) result.getRegisters();\n+                headerReceived(registers);", "originalCommit": "3a72b756192388fa760c71959ce198482ad25fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20fa36e5a8fe39e1db58b099a5cb3142234787ec", "url": "https://github.com/openhab/openhab-addons/commit/20fa36e5a8fe39e1db58b099a5cb3142234787ec", "message": "[modbus] exceptions moved to their own namespace\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:07Z", "type": "commit"}, {"oid": "f335ec1ba0ababb61f7f9d8a705dd5a1acda4866", "url": "https://github.com/openhab/openhab-addons/commit/f335ec1ba0ababb61f7f9d8a705dd5a1acda4866", "message": "[modbus] read callback refactoring\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "2db2cd28ccd0f44faddf08694e3c5cdf8bd144dd", "url": "https://github.com/openhab/openhab-addons/commit/2db2cd28ccd0f44faddf08694e3c5cdf8bd144dd", "message": "[modbus] Write callbacks converted to Functional\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "a0a39ed00ad6e8d6a40176aa49837641344548c9", "url": "https://github.com/openhab/openhab-addons/commit/a0a39ed00ad6e8d6a40176aa49837641344548c9", "message": "[modbus] Remove abstraction (unnecessary interfaces not meant for exten)\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "9cb3e5905de230d4848fc68e2222a7ac3730f0a4", "url": "https://github.com/openhab/openhab-addons/commit/9cb3e5905de230d4848fc68e2222a7ac3730f0a4", "message": "[modbus] ModbusManagerAPI accepts arguments directly, no Task\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "14fec3c37a2d4cbd766f4d6aefd78dd2d9eeb540", "url": "https://github.com/openhab/openhab-addons/commit/14fec3c37a2d4cbd766f4d6aefd78dd2d9eeb540", "message": "[modbus] ModbusManager indirection (Supplier) removed\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "722e76c1db857ae17a937b3f84885037f2044006", "url": "https://github.com/openhab/openhab-addons/commit/722e76c1db857ae17a937b3f84885037f2044006", "message": "[modbus] BitArray abstractions removed\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "4bb288b957c29bd21cf588eb780732cf094644b3", "url": "https://github.com/openhab/openhab-addons/commit/4bb288b957c29bd21cf588eb780732cf094644b3", "message": "[modbus] ModbusRegister abstractions removed\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "b22a5258b295875236f0c16ac6486d8dd343c019", "url": "https://github.com/openhab/openhab-addons/commit/b22a5258b295875236f0c16ac6486d8dd343c019", "message": "[modbus] ModbusRegisterArray abstraction removed\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "96a895a1d41199334a1afb05f1bf424357d00f5a", "url": "https://github.com/openhab/openhab-addons/commit/96a895a1d41199334a1afb05f1bf424357d00f5a", "message": "[modbus] Write API taking parameters directly\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "6b12304ed18de80287fc87255aa687abedd37545", "url": "https://github.com/openhab/openhab-addons/commit/6b12304ed18de80287fc87255aa687abedd37545", "message": "[modbus] rename classes\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:14:08Z", "type": "commit"}, {"oid": "5e1832636ac83c00cb5c9a493a41f1538c68ae99", "url": "https://github.com/openhab/openhab-addons/commit/5e1832636ac83c00cb5c9a493a41f1538c68ae99", "message": "[modbus] Communication interface to track connection usage\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "de935c854d64fb8fa04a4ade575b12b4f1afeec0", "url": "https://github.com/openhab/openhab-addons/commit/de935c854d64fb8fa04a4ade575b12b4f1afeec0", "message": "[modbus] spotless:apply\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "4019373f4cdb60f35d10ec7ed0ff1d7ad2634073", "url": "https://github.com/openhab/openhab-addons/commit/4019373f4cdb60f35d10ec7ed0ff1d7ad2634073", "message": "[modbus.sunspec] Accomodate to new ModbusCommunicationInterface API\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "4a2574e57c0704726709c557e72efca5a2a50b6f", "url": "https://github.com/openhab/openhab-addons/commit/4a2574e57c0704726709c557e72efca5a2a50b6f", "message": "[modbus] Tests fixed. Removed Modbus Manager Listener\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "bfcf519adf7cc8a7a241676ece80fc0e4cb991a3", "url": "https://github.com/openhab/openhab-addons/commit/bfcf519adf7cc8a7a241676ece80fc0e4cb991a3", "message": "[modbus] Null fix, connection closed. test for connection closing\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "8ced7f75f39db68a86ebda196aac9a4fc27eaa00", "url": "https://github.com/openhab/openhab-addons/commit/8ced7f75f39db68a86ebda196aac9a4fc27eaa00", "message": "[modbus] test tuning (sometimes fails?)\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:28Z", "type": "commit"}, {"oid": "57967b4bfdbe0f57e6276db1fbbe16d49a68a3af", "url": "https://github.com/openhab/openhab-addons/commit/57967b4bfdbe0f57e6276db1fbbe16d49a68a3af", "message": "[modbus][sunspec] Removed unused references from sunspec package (#4)\n\nSigned-off-by: Nagy Attila G\u00e1bor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "d59eed0ab0bfd91037f4f48400a5c544719965ff", "url": "https://github.com/openhab/openhab-addons/commit/d59eed0ab0bfd91037f4f48400a5c544719965ff", "message": "[modbus] avoid memory leaking when unregistering poll tasks\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "81298cc897fdd4b842876bdd7606c4ebd15868ec", "url": "https://github.com/openhab/openhab-addons/commit/81298cc897fdd4b842876bdd7606c4ebd15868ec", "message": "[modbus] logging severity reduced\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "73064c511d8fe881c98fd0c1b089825a8fa95a26", "url": "https://github.com/openhab/openhab-addons/commit/73064c511d8fe881c98fd0c1b089825a8fa95a26", "message": "[modbus] itests: removed unnecessary stubbings\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "284ae82822189f81dbd20353c8912f9ba95dc1a8", "url": "https://github.com/openhab/openhab-addons/commit/284ae82822189f81dbd20353c8912f9ba95dc1a8", "message": "[modbus] test fix (callbacks were counted twice in one test)\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "00525c177e4e1e553cb5c9ca635de4e935c8f2dd", "url": "https://github.com/openhab/openhab-addons/commit/00525c177e4e1e553cb5c9ca635de4e935c8f2dd", "message": "[modbus] tests: increase timeouts, assert before closing comms\n\nClosing comms during assertion might cause race conditions since poll\ntasks interrupted etc.\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "125cc5c530e1d34140a8c52410b3c70c71d3e61f", "url": "https://github.com/openhab/openhab-addons/commit/125cc5c530e1d34140a8c52410b3c70c71d3e61f", "message": "[modbus] readability\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "e72c3c55a604157091911030521bf4dc4e9526c6", "url": "https://github.com/openhab/openhab-addons/commit/e72c3c55a604157091911030521bf4dc4e9526c6", "message": "[modbus] fixed more tests where we want to close comms after assertions\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "52be997352892b25d85d255127365bc81d55162c", "url": "https://github.com/openhab/openhab-addons/commit/52be997352892b25d85d255127365bc81d55162c", "message": "[modbus] test hardening, more clear assertions\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "8cd5aa88ac0ccdbf78593ed58514bb80d2150741", "url": "https://github.com/openhab/openhab-addons/commit/8cd5aa88ac0ccdbf78593ed58514bb80d2150741", "message": "[modbus] connection closing behaviour finetuned\n\nThe binding closes TCP/serial connections connections as per user\nconfiguration. It is either\n- every time, immediately after a transaction (reconnectAfterMillis=0)\n- *after* a read/write transaction, if the connection has been open \"too\n  long\" (configurable with reconnectAfterMillis)\n\nWe have an obvious downside to this simple logic -- the connection\ncan remain open \"indefinitely\" if there are no transactions occurring.\nWith Modbus we are quite often dealing with PLCs and other embedded\nsystems with limited resources, and \"reserving\" the connection is not\nalways something we want.\n\nPreviously (2.5.x branch) connections were also closed when\n- a regular poll task was unregistered (i.e. we stop reading regularly\nfrom a modbus server (\"slave\"). Since most users have regular polling in\nplace, so this ensured that connections do get closed.\n\nIn this commit, the behaviour is adjusted such that connections are\nclosed when last communication interface pointing to the server/serial\nport (i.e. \"endpoint\") is close()'d.\n\nWith modbus binding this basically means when the tcp or serial thing\nis removed / disabled, the connections is closed/freed, but only if it\nis the last thing pointing to that server or serial port.\n\nSince modbus.sunspec binding reuses modbus serial & tcp endpoint things,\nthe same note applies for modbus.sunspec binding.\n\nThis is change in functional behaviour but in a way is logical. We can\nfurther introduce to have \"delayed\"/\"deferred\"/\"debounce\" connection\nclosing connections as per the setting reconnectAfterMillis even in\nsituations where communication interface is still open.\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "9191ccbf63673f9b70b80de13c562306089741ce", "url": "https://github.com/openhab/openhab-addons/commit/9191ccbf63673f9b70b80de13c562306089741ce", "message": "[modbus] Check and disconnect idle connections without transactions\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "96722e419538b7e6a7ea1d7d0a243db79227c27a", "url": "https://github.com/openhab/openhab-addons/commit/96722e419538b7e6a7ea1d7d0a243db79227c27a", "message": "[modbus] mvn spotless:apply\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "6019fceccb228f914471758a3dc33078c459c86e", "url": "https://github.com/openhab/openhab-addons/commit/6019fceccb228f914471758a3dc33078c459c86e", "message": "[modbubs] Fixed log message\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "f24cc1980c5f686617d9b29c0c00696755ad3f4b", "url": "https://github.com/openhab/openhab-addons/commit/f24cc1980c5f686617d9b29c0c00696755ad3f4b", "message": "[modbus] Race condition fix\n\nThe CountDownLatch was used as a guard (latch.await) in many tests to\nwait for callbacks to be called before proceeding with assertions.\n\nSince the latch was countDown() beginning of the callback, we introduced\na race condition with the subsequent assertions and updating the other\ncounters used in the subsequent assertions.\n\nThis commit updates the CountDownLatch as the last step of the callback,\nresolving the race condition.\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "6bcf0a2f4f9894fc497a9d46044b0794f9c2c37f", "url": "https://github.com/openhab/openhab-addons/commit/6bcf0a2f4f9894fc497a9d46044b0794f9c2c37f", "message": "[modbus] small test fix\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "65141e6c974239246b2ec132b9d17be530ce0e7d", "url": "https://github.com/openhab/openhab-addons/commit/65141e6c974239246b2ec132b9d17be530ce0e7d", "message": "[modbus] readcallback changed to nonnull\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "e314ead3a4e8ad6edfc574f591c10845cc61add4", "url": "https://github.com/openhab/openhab-addons/commit/e314ead3a4e8ad6edfc574f591c10845cc61add4", "message": "[modbus] Refactored ModbusCommunicationInterface to have seperate callback for result and failure\n\nHowever I had to dig deep to reach all the affected parts.\nAlso there is a new callback, and a new \"result\" type to communicate\nthe failures.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "3336492e71d3e1b4629fbe8ca6a393403e86a693", "url": "https://github.com/openhab/openhab-addons/commit/3336492e71d3e1b4629fbe8ca6a393403e86a693", "message": "[modbus] SmokeTest refactored to new api\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "498688c585aeac0d4b8e635c70a1bc957ac4750f", "url": "https://github.com/openhab/openhab-addons/commit/498688c585aeac0d4b8e635c70a1bc957ac4750f", "message": "[modbus] Modbus bundle refactored to use the new api\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "53d99b7892d19ec68e9d54dfd0056d33024b57e7", "url": "https://github.com/openhab/openhab-addons/commit/53d99b7892d19ec68e9d54dfd0056d33024b57e7", "message": "[modbus][sunspec] refactored sunspec bundle to use the new modbus API\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:29Z", "type": "commit"}, {"oid": "5c46267d228ed198ca0ab14efdfaa7e36536195b", "url": "https://github.com/openhab/openhab-addons/commit/5c46267d228ed198ca0ab14efdfaa7e36536195b", "message": "[modbus] refactor modbus tests to use the new api\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "17eabd094f77a8792513be12b2ae8a68b83e3f49", "url": "https://github.com/openhab/openhab-addons/commit/17eabd094f77a8792513be12b2ae8a68b83e3f49", "message": "[modbus] Removed ModbusWriteCallback interface from ModbusDataThingHandler\n\nAlso reset ModbusDataThingHandler testWriteHandling generic to it's original form\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "995f84f984fb51adc592e9209e3909681b22c128", "url": "https://github.com/openhab/openhab-addons/commit/995f84f984fb51adc592e9209e3909681b22c128", "message": "[modbus] ModbusDataThingHandler does not implement ModbusReadCallback anymore\n\nInstead it has a public onReadResult method. ModbusPollerThingHandler changed to\nwork with ModbusDataThingHandler children.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "edc0fc28c8cb97ea73626e8e2c4ff454cc440a3f", "url": "https://github.com/openhab/openhab-addons/commit/edc0fc28c8cb97ea73626e8e2c4ff454cc440a3f", "message": "[modbus] Fixed caching in ModbusPollerThingHandler\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "d46a349ff6c00cc36f99a27870575b656273d9ae", "url": "https://github.com/openhab/openhab-addons/commit/d46a349ff6c00cc36f99a27870575b656273d9ae", "message": "[modbus] read modbus data as Optionals\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "95031aaf145465b015f4ba58d5fa3dfcab3da993", "url": "https://github.com/openhab/openhab-addons/commit/95031aaf145465b015f4ba58d5fa3dfcab3da993", "message": "[modbus] toString for PollResult\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "27b0ebd8885f6c5a25a5b5fd64c91b2056091cdd", "url": "https://github.com/openhab/openhab-addons/commit/27b0ebd8885f6c5a25a5b5fd64c91b2056091cdd", "message": "[modbus] fixed confusing variable name\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "100532d83ae5c27fa39c80d024d5e53c425c3810", "url": "https://github.com/openhab/openhab-addons/commit/100532d83ae5c27fa39c80d024d5e53c425c3810", "message": "[modbus] Disallow null callbacks\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "2db4f20a41febac83f47dfd629d26d35af3d3b35", "url": "https://github.com/openhab/openhab-addons/commit/2db4f20a41febac83f47dfd629d26d35af3d3b35", "message": "[modbus] mvn spotless:apply\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "1b2a6ca916aa4a54f31e75417081efe804510763", "url": "https://github.com/openhab/openhab-addons/commit/1b2a6ca916aa4a54f31e75417081efe804510763", "message": "[modbus] Removing Nullable decorations\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "d2d6d71fc45e694a1331ea691fae7acb8a0c4e07", "url": "https://github.com/openhab/openhab-addons/commit/d2d6d71fc45e694a1331ea691fae7acb8a0c4e07", "message": "[modbus] submitOneTimeWrite simplification\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "a988ff55b95e09e9c4b76e6dea492ad85d0faea1", "url": "https://github.com/openhab/openhab-addons/commit/a988ff55b95e09e9c4b76e6dea492ad85d0faea1", "message": "[modbus] Less verbose logging\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "80e7a5f0b8a2796f1c3cad0f21ab8e737e4bb53b", "url": "https://github.com/openhab/openhab-addons/commit/80e7a5f0b8a2796f1c3cad0f21ab8e737e4bb53b", "message": "[modbus] submitOneTimePoll simplification\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "8de2bd3109d701833c8373e9176c29945fde2275", "url": "https://github.com/openhab/openhab-addons/commit/8de2bd3109d701833c8373e9176c29945fde2275", "message": "[modbus] Less verbose logging\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "c65e3a6984a231c64c3f0d7d06db935d5feaccfa", "url": "https://github.com/openhab/openhab-addons/commit/c65e3a6984a231c64c3f0d7d06db935d5feaccfa", "message": "[modbus] Many null warnings removed\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "735d9d6e9c78fd4dfbfcee002ea54a39074d7647", "url": "https://github.com/openhab/openhab-addons/commit/735d9d6e9c78fd4dfbfcee002ea54a39074d7647", "message": "[modbus] Fix: no need for a @NonNull annotation because it is default\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "commit"}, {"oid": "735d9d6e9c78fd4dfbfcee002ea54a39074d7647", "url": "https://github.com/openhab/openhab-addons/commit/735d9d6e9c78fd4dfbfcee002ea54a39074d7647", "message": "[modbus] Fix: no need for a @NonNull annotation because it is default\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:25:30Z", "type": "forcePushed"}, {"oid": "34ade13540612ce5c0305ad884ff3eb68e383409", "url": "https://github.com/openhab/openhab-addons/commit/34ade13540612ce5c0305ad884ff3eb68e383409", "message": "[modbus] Removing unneeded Nullable, using final in immutables\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:36:29Z", "type": "commit"}, {"oid": "1a8df8dd20ea7cb011a029f4c47907188769b921", "url": "https://github.com/openhab/openhab-addons/commit/1a8df8dd20ea7cb011a029f4c47907188769b921", "message": "[modbus] Explicit functional interface\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-06T08:36:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MDE0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r450070149", "bodyText": "Cherry-picked 5bde9d6 during rebase in this commit.", "author": "ssalonen", "createdAt": "2020-07-06T08:39:40Z", "path": "bundles/org.openhab.io.transport.modbus/src/main/java/org/openhab/io/transport/modbus/internal/ModbusManagerImpl.java", "diffHunk": "@@ -739,136 +743,177 @@ private void verifyTaskIsRegistered(PollTask task) throws PollTaskUnregistered {\n         }\n     }\n \n-    @Override\n-    public ScheduledFuture<?> submitOneTimePoll(ModbusSlaveEndpoint endpoint, ModbusReadRequestBlueprint request,\n-            @Nullable ModbusReadCallback callback) {\n-        ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-        Objects.requireNonNull(executor, \"Not activated!\");\n-        long scheduleTime = System.currentTimeMillis();\n-        BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n-        logger.debug(\"Scheduling one-off poll task {}\", task);\n-        ScheduledFuture<?> future = executor.schedule(() -> {\n-            long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n-            logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n-                    millisInThreadPoolWaiting);\n-            executeOperation(task, true, pollOperation);\n-        }, 0L, TimeUnit.MILLISECONDS);\n-        return future;\n-    }\n+    private class ModbusCommunicationInterfaceImpl implements ModbusCommunicationInterface {\n \n-    @Override\n-    public PollTask registerRegularPoll(ModbusSlaveEndpoint endpoint, ModbusReadRequestBlueprint request,\n-            long pollPeriodMillis, long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n-            Objects.requireNonNull(executor, \"Not activated!\");\n-            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n-            logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            if (scheduledPollTasks.containsKey(task)) {\n-                logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n-                unregisterRegularPoll(task);\n+        private volatile ModbusSlaveEndpoint endpoint;\n+        private volatile Set<PollTask> pollTasks = new ConcurrentHashSet<>();\n+        private volatile boolean closed;\n+\n+        @SuppressWarnings(\"null\")\n+        public ModbusCommunicationInterfaceImpl(ModbusSlaveEndpoint endpoint,\n+                @Nullable EndpointPoolConfiguration configuration) {\n+            this.endpoint = endpoint;\n+            connectionFactory.setEndpointPoolConfiguration(endpoint, configuration);\n+            for (ModbusManagerListener listener : listeners) {\n+                listener.onEndpointPoolConfigurationSet(endpoint, configuration);\n             }\n-            ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n-                long started = System.currentTimeMillis();\n-                logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n-                        started);\n-                try {\n-                    executeOperation(task, false, pollOperation);\n-                } catch (RuntimeException e) {\n-                    // We want to catch all unexpected exceptions since all unhandled exceptions make\n-                    // ScheduledExecutorService halt the polling. It is better to print out the exception, and try again\n-                    // (on next poll cycle)\n-                    logger.warn(\n-                            \"Execution of scheduled ({}ms) poll task {} failed unexpectedly. Ignoring exception, polling again according to poll interval.\",\n-                            pollPeriodMillis, task, e);\n-                }\n-                long finished = System.currentTimeMillis();\n-                logger.debug(\n-                        \"Execution of scheduled ({}ms) poll task {} finished at {}. Was started at millis: {} (=duration of {} millis)\",\n-                        pollPeriodMillis, task, finished, started, finished - started);\n-            }, initialDelayMillis, pollPeriodMillis, TimeUnit.MILLISECONDS);\n-\n-            scheduledPollTasks.put(task, future);\n-            logger.trace(\"Registered poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n-                    initialDelayMillis);\n-            return task;\n         }\n-    }\n \n-    @SuppressWarnings({ \"null\", \"unused\" })\n-    @Override\n-    public boolean unregisterRegularPoll(PollTask task) {\n-        synchronized (this) {\n-            ScheduledExecutorService executor = this.scheduledThreadPoolExecutor;\n-            ModbusSlaveConnectionFactoryImpl factory = this.connectionFactory;\n+        @Override\n+        public ScheduledFuture<?> submitOneTimePoll(ModbusReadRequestBlueprint request,\n+                @Nullable ModbusReadCallback callback) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Communication interface is closed already!\");\n+            }\n+            ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n             Objects.requireNonNull(executor, \"Not activated!\");\n-            Objects.requireNonNull(factory, \"Not activated!\");\n+            long scheduleTime = System.currentTimeMillis();\n+            BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+            logger.debug(\"Scheduling one-off poll task {}\", task);\n+            ScheduledFuture<?> future = executor.schedule(() -> {\n+                long millisInThreadPoolWaiting = System.currentTimeMillis() - scheduleTime;\n+                logger.debug(\"Will now execute one-off poll task {}, waited in thread pool for {}\", task,\n+                        millisInThreadPoolWaiting);\n+                executeOperation(task, true, pollOperation);\n+            }, 0L, TimeUnit.MILLISECONDS);\n+            return future;\n+        }\n \n-            // cancel poller\n-            @Nullable\n-            ScheduledFuture<?> future = scheduledPollTasks.remove(task);\n-            if (future == null) {\n-                // No such poll task\n-                logger.warn(\"Caller tried to unregister nonexisting poll task {}\", task);\n-                return false;\n+        @Override\n+        public PollTask registerRegularPoll(ModbusReadRequestBlueprint request, long pollPeriodMillis,\n+                long initialDelayMillis, @Nullable ModbusReadCallback callback) {\n+            synchronized (ModbusManagerImpl.this) {\n+                if (closed) {\n+                    throw new IllegalStateException(\"Communication interface is closed already!\");\n+                }\n+                ScheduledExecutorService executor = scheduledThreadPoolExecutor;\n+                Objects.requireNonNull(executor, \"Not activated!\");\n+                BasicPollTask task = new BasicPollTask(endpoint, request, callback);\n+                logger.trace(\"Registering poll task {} with period {} using initial delay {}\", task, pollPeriodMillis,\n+                        initialDelayMillis);\n+                if (scheduledPollTasks.containsKey(task)) {\n+                    logger.trace(\"Unregistering previous poll task (possibly with different period)\");\n+                    unregisterRegularPoll(task);\n+                }\n+                ScheduledFuture<?> future = executor.scheduleWithFixedDelay(() -> {\n+                    long started = System.currentTimeMillis();\n+                    logger.debug(\"Executing scheduled ({}ms) poll task {}. Current millis: {}\", pollPeriodMillis, task,\n+                            started);\n+                    try {\n+                        executeOperation(task, false, pollOperation);\n+                    } catch (RuntimeException e) {", "originalCommit": "5e1832636ac83c00cb5c9a493a41f1538c68ae99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMjI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451122280", "bodyText": "Could you return a Collection.emptyMap() here?", "author": "cpmeister", "createdAt": "2020-07-07T20:24:59Z", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/internal/handler/ModbusDataThingHandler.java", "diffHunk": "@@ -805,7 +820,13 @@ public synchronized void onWriteResponse(ModbusWriteRequestBlueprint request, Mo\n      * @return updated channel data\n      */\n     private Map<ChannelUID, State> processUpdatedValue(State numericState, boolean boolValue) {\n-        Map<@NonNull ChannelUID, @NonNull State> states = new HashMap<>();\n+        Transformation localReadTransformation = readTransformation;\n+        if (localReadTransformation == null) {\n+            // We should always have transformation available if thing is initalized properly\n+            logger.trace(\"No transformation available, aborting processUpdatedValue\");\n+            return new HashMap<ChannelUID, State>();", "originalCommit": "1a8df8dd20ea7cb011a029f4c47907188769b921", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451370030", "bodyText": "Yup. 6a46de1", "author": "ssalonen", "createdAt": "2020-07-08T08:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451123128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable\n          \n          \n            \n                    public final AsyncModbusReadResult result;\n          \n          \n            \n                    @Nullable\n          \n          \n            \n                    public final AsyncModbusFailure<ModbusReadRequestBlueprint> failure;\n          \n          \n            \n                    public final @Nullable AsyncModbusReadResult result;\n          \n          \n            \n                    public final @Nullable AsyncModbusFailure<ModbusReadRequestBlueprint> failure;", "author": "cpmeister", "createdAt": "2020-07-07T20:26:33Z", "path": "bundles/org.openhab.binding.modbus/src/main/java/org/openhab/binding/modbus/handler/ModbusPollerThingHandler.java", "diffHunk": "@@ -246,21 +177,48 @@ public ModbusPollerReadRequest(ModbusPollerConfiguration config,\n         }\n     }\n \n-    private final Logger logger = LoggerFactory.getLogger(ModbusPollerThingHandlerImpl.class);\n+    /**\n+     * Immutable data object to cache the results of a poll request\n+     */\n+    private class PollResult {\n+        @Nullable\n+        public final AsyncModbusReadResult result;\n+        @Nullable\n+        public final AsyncModbusFailure<ModbusReadRequestBlueprint> failure;", "originalCommit": "1a8df8dd20ea7cb011a029f4c47907188769b921", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7994#discussion_r451369779", "bodyText": "Resolved this, and many others in 00b7f76", "author": "ssalonen", "createdAt": "2020-07-08T08:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzEyOA=="}], "type": "inlineReview"}, {"oid": "00b7f764be87d957e6b81354b54d7bdeb33cb818", "url": "https://github.com/openhab/openhab-addons/commit/00b7f764be87d957e6b81354b54d7bdeb33cb818", "message": "[modbus] @Nullable and @NonNullByDefault aligned with coding conventions\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-08T08:20:54Z", "type": "commit"}, {"oid": "6a46de1e2f5329b0839c2aaaf1cceb55da22dd38", "url": "https://github.com/openhab/openhab-addons/commit/6a46de1e2f5329b0839c2aaaf1cceb55da22dd38", "message": "[modbus] Collections.emptyMap instead of allocating new map every time.\n\nSigned-off-by: Sami Salonen <ssalonen@gmail.com>", "committedDate": "2020-07-08T08:23:16Z", "type": "commit"}]}