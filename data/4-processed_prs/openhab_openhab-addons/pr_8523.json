{"pr_number": 8523, "pr_title": "[tr064] Initial contribution", "pr_createdAt": "2020-09-21T17:00:28Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8523", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r494504322", "bodyText": "Why is this synchronized?", "author": "cpmeister", "createdAt": "2020-09-24T17:53:22Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNjczMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499126732", "bodyText": "IIRC there was a problem when several requests are executed at the same time and return 401. It was not poissble to get the re-auth working in that case.", "author": "J-N-K", "createdAt": "2020-10-03T08:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNzc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r494507776", "bodyText": "Make sure to include cause exceptions in when rethrowing new exceptions.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new PostProcessingException(\"Failed to get call list from URL \" + state.toString());\n          \n          \n            \n                        throw new PostProcessingException(e, \"Failed to get call list from URL \" + state.toString());", "author": "cpmeister", "createdAt": "2020-09-24T17:59:16Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n+            try {\n+                Method method = SOAPValueConverter.class.getDeclaredMethod(postProcessor, State.class,\n+                        Tr064ChannelConfig.class);\n+                Object o = method.invoke(this, state, channelConfig);\n+                if (o instanceof State) {\n+                    return (State) o;\n+                }\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                logger.warn(\"Postprocessor {} not found, this most likely is a programming error\", postProcessor, e);\n+            } catch (InvocationTargetException e) {\n+                logger.info(\"Postprocessor {} failed: {}\", postProcessor, e.getCause().getMessage());\n+            }\n+            return null;\n+        }).or(Optional::empty);\n+    }\n+\n+    /**\n+     * post processor for answering machine new messages channel\n+     *\n+     * @param state the message list URL\n+     * @param channelConfig channel config of the TAM new message channel\n+     * @return the number of new messages\n+     * @throws PostProcessingException if the message list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processTamListURL(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString()).timeout(1000, TimeUnit.MILLISECONDS)\n+                    .send();\n+            String responseContent = response.getContentAsString();\n+            int messageCount = responseContent.split(\"<New>1</New>\").length - 1;\n+\n+            return new DecimalType(messageCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new PostProcessingException(\"Failed to get TAM list from URL \" + state.toString());\n+        }\n+    }\n+\n+    /**\n+     * post processor for missed calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the missed call channel (contains day number)\n+     * @return the number of missed calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processMissedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"2\");\n+    }\n+\n+    /**\n+     * post processor for inbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the inbound call channel (contains day number)\n+     * @return the number of inbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processInboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"1\");\n+    }\n+\n+    /**\n+     * post processor for rejected calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the rejected call channel (contains day number)\n+     * @return the number of rejected calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processRejectedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"3\");\n+    }\n+\n+    /**\n+     * post processor for outbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the outbound call channel (contains day number)\n+     * @return the number of outbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processOutboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"4\");\n+    }\n+\n+    /**\n+     * internal helper for call list post processors\n+     *\n+     * @param state the call list URL\n+     * @param days number of days to get\n+     * @param type type of call (1=missed 2=inbound 3=rejected 4=outbund)\n+     * @return the quantity of calls of the given type within the given number of days\n+     * @throws PostProcessingException if the call list could not be retrieved\n+     */\n+    private State processCallList(State state, @Nullable String days, String type) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString() + \"&days=\" + days)\n+                    .timeout(5000, TimeUnit.MILLISECONDS).send();\n+            String responseContent = response.getContentAsString();\n+            int callCount = responseContent.split(\"<Type>\" + type + \"</Type>\").length - 1;\n+\n+            return new DecimalType(callCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.trace(\"Received {}:\", e.getClass(), e);\n+            throw new PostProcessingException(\"Failed to get call list from URL \" + state.toString());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499013933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"Could not convert {} to unit {}\", command, unit);\n          \n          \n            \n                            logger.debug(\"Could not convert {} to unit {}\", command, unit);", "author": "cpmeister", "createdAt": "2020-10-02T19:35:20Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127025", "bodyText": "This hides the message, I would like to keep it visible to the user. This is clearly a mis-function, we could discuss if that is warn.", "author": "J-N-K", "createdAt": "2020-10-03T08:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxNDEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515514126", "bodyText": "If it is something that we want to make the admin aware of, I'd usually indeed prefer a warn.", "author": "kaikreuzer", "createdAt": "2020-10-31T16:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499016027", "bodyText": "This removes a bit of code duplication.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (channelConfig == null\n          \n          \n            \n                                || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n          \n          \n            \n                            return state;\n          \n          \n            \n                        }\n          \n          \n            \n                        String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n          \n          \n            \n                        String postProcessor = channelConfig != null ? channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() : null;\n          \n          \n            \n                        if(postProcessor == null){\n          \n          \n            \n                            return state;\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-10-02T19:40:21Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127146", "bodyText": "Agreed that this will reduce code, but IMO the \"original\" version is much easier to understand.", "author": "J-N-K", "createdAt": "2020-10-03T08:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499170845", "bodyText": "Up to you then, I just hate duplicate code.", "author": "cpmeister", "createdAt": "2020-10-03T18:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499017384", "bodyText": "Please cache channelConfig.getChannelTypeDescription().getGetAction() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-10-02T19:43:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n+    }\n+\n+    /**\n+     * get a value from the remote device - updates state cache for all possible channels\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param channelConfigMap map of all channels in the device\n+     * @param stateCache the ExpiringCacheMap for states of the device\n+     * @return the value for the requested channel\n+     */\n+    public State getChannelStateFromDevice(final Tr064ChannelConfig channelConfig,\n+            Map<ChannelUID, Tr064ChannelConfig> channelConfigMap, ExpiringCacheMap<ChannelUID, State> stateCache) {\n+        try {\n+            final SCPDActionType getAction = channelConfig.getGetAction();\n+            if (getAction == null) {\n+                // channel has no get action, return a default\n+                switch (channelConfig.getDataType()) {\n+                    case \"boolean\":\n+                        return OnOffType.OFF;\n+                    case \"string\":\n+                        return StringType.EMPTY;\n+                    default:\n+                        return UnDefType.UNDEF;\n+                }\n+            }\n+\n+            // get value(s) from remote device\n+            Map<String, String> arguments = new HashMap<>();\n+            String parameter = channelConfig.getParameter();\n+            if (parameter != null\n+                    && !channelConfig.getChannelTypeDescription().getGetAction().getParameter().isInternalOnly()) {\n+                arguments.put(channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499019266", "bodyText": "Should this value be configurable? Maybe at the very least store it in a static constant.", "author": "cpmeister", "createdAt": "2020-10-02T19:48:13Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n+            try {\n+                Method method = SOAPValueConverter.class.getDeclaredMethod(postProcessor, State.class,\n+                        Tr064ChannelConfig.class);\n+                Object o = method.invoke(this, state, channelConfig);\n+                if (o instanceof State) {\n+                    return (State) o;\n+                }\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                logger.warn(\"Postprocessor {} not found, this most likely is a programming error\", postProcessor, e);\n+            } catch (InvocationTargetException e) {\n+                logger.info(\"Postprocessor {} failed: {}\", postProcessor, e.getCause().getMessage());\n+            }\n+            return null;\n+        }).or(Optional::empty);\n+    }\n+\n+    /**\n+     * post processor for answering machine new messages channel\n+     *\n+     * @param state the message list URL\n+     * @param channelConfig channel config of the TAM new message channel\n+     * @return the number of new messages\n+     * @throws PostProcessingException if the message list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processTamListURL(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString()).timeout(1000, TimeUnit.MILLISECONDS)\n+                    .send();\n+            String responseContent = response.getContentAsString();\n+            int messageCount = responseContent.split(\"<New>1</New>\").length - 1;\n+\n+            return new DecimalType(messageCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new PostProcessingException(\"Failed to get TAM list from URL \" + state.toString());\n+        }\n+    }\n+\n+    /**\n+     * post processor for missed calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the missed call channel (contains day number)\n+     * @return the number of missed calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processMissedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"2\");\n+    }\n+\n+    /**\n+     * post processor for inbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the inbound call channel (contains day number)\n+     * @return the number of inbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processInboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"1\");\n+    }\n+\n+    /**\n+     * post processor for rejected calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the rejected call channel (contains day number)\n+     * @return the number of rejected calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processRejectedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"3\");\n+    }\n+\n+    /**\n+     * post processor for outbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the outbound call channel (contains day number)\n+     * @return the number of outbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processOutboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"4\");\n+    }\n+\n+    /**\n+     * internal helper for call list post processors\n+     *\n+     * @param state the call list URL\n+     * @param days number of days to get\n+     * @param type type of call (1=missed 2=inbound 3=rejected 4=outbund)\n+     * @return the quantity of calls of the given type within the given number of days\n+     * @throws PostProcessingException if the call list could not be retrieved\n+     */\n+    private State processCallList(State state, @Nullable String days, String type) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString() + \"&days=\" + days)\n+                    .timeout(5000, TimeUnit.MILLISECONDS).send();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyOTk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499129983", "bodyText": "Made it a constant. I don't think there is a usecase for having that configurable. If the calllist is not available after 5s, it'll probably never be.", "author": "J-N-K", "createdAt": "2020-10-03T08:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyMDY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499020675", "bodyText": "What about the representation property?", "author": "cpmeister", "createdAt": "2020-10-02T19:51:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DiscoveryService.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064DiscoveryService} discovers sub devices of a root device.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064DiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {\n+    private static final int SEARCH_TIME = 5;\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_SUBDEVICE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064DiscoveryService.class);\n+    private @Nullable Tr064RootHandler bridgeHandler;\n+\n+    public Tr064DiscoveryService() {\n+        super(SEARCH_TIME);\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof Tr064RootHandler) {\n+            this.bridgeHandler = (Tr064RootHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        removeOlderResults(new Date().getTime(), bridgeHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        Tr064RootHandler bridgeHandler = this.bridgeHandler;\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Could not start discovery, bridge handler not set\");\n+            return;\n+        }\n+        List<SCPDDeviceType> devices = bridgeHandler.getAllSubDevices();\n+        ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+        devices.forEach(device -> {\n+            logger.trace(\"Trying to add {} to discovery results on {}\", device, bridgeUID);\n+            String udn = device.getUDN();\n+            if (udn != null) {\n+                ThingTypeUID thingTypeUID;\n+                if (\"urn:dslforum-org:device:LANDevice:1\".equals(device.getDeviceType())) {\n+                    thingTypeUID = THING_TYPE_SUBDEVICE_LAN;\n+                } else {\n+                    thingTypeUID = THING_TYPE_SUBDEVICE;\n+                }\n+                ThingUID thingUID = new ThingUID(thingTypeUID, bridgeUID, UIDUtils.encode(udn));\n+\n+                Map<String, Object> properties = new HashMap<>(2);\n+                properties.put(\"uuid\", udn);\n+                properties.put(\"deviceType\", device.getDeviceType());\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(device.getFriendlyName())\n+                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties).build();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499024948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class }, immediate = true)\n          \n          \n            \n            @Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class })", "author": "cpmeister", "createdAt": "2020-10-02T20:02:01Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064ChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.CHANNEL_TYPES;\n+\n+import java.util.Collection;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064ChannelTypeProvider} is used for providing dynamic channel types\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class }, immediate = true)", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Tr064DynamicStateDescriptionProvider.class }, immediate = true)\n          \n          \n            \n                    Tr064DynamicStateDescriptionProvider.class })", "author": "cpmeister", "createdAt": "2020-10-02T20:02:15Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Dynamic channel state description provider.\n+ * Overrides the state description for the controls, which receive its configuration in the runtime.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DynamicStateDescriptionProvider.class,\n+        Tr064DynamicStateDescriptionProvider.class }, immediate = true)", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTE1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025159", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(immediate = true, service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n          \n          \n            \n            @Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")", "author": "cpmeister", "createdAt": "2020-10-02T20:02:33Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,\n          \n          \n            \n            @Component(service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,", "author": "cpmeister", "createdAt": "2020-10-02T20:03:07Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfileFactory.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.ConfigOptionProvider;\n+import org.openhab.core.config.core.ParameterOption;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.Profile;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileFactory;\n+import org.openhab.core.thing.profiles.ProfileType;\n+import org.openhab.core.thing.profiles.ProfileTypeBuilder;\n+import org.openhab.core.thing.profiles.ProfileTypeProvider;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfileFactory} class is used to create phonebook profiles\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTYxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025618", "bodyText": "Maybe this should be a constant instead?", "author": "cpmeister", "createdAt": "2020-10-02T20:03:42Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfileFactory.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.ConfigOptionProvider;\n+import org.openhab.core.config.core.ParameterOption;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.Profile;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileFactory;\n+import org.openhab.core.thing.profiles.ProfileType;\n+import org.openhab.core.thing.profiles.ProfileTypeBuilder;\n+import org.openhab.core.thing.profiles.ProfileTypeProvider;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfileFactory} class is used to create phonebook profiles\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,\n+        ConfigOptionProvider.class })\n+public class PhonebookProfileFactory implements ProfileFactory, ProfileTypeProvider, ConfigOptionProvider {\n+    private final Logger logger = LoggerFactory.getLogger(PhonebookProfileFactory.class);\n+    private final Map<ThingUID, PhonebookProvider> phonebookProviders = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public @Nullable Profile createProfile(ProfileTypeUID profileTypeUID, ProfileCallback callback,\n+            ProfileContext profileContext) {\n+        return new PhonebookProfile(callback, profileContext, phonebookProviders);\n+    }\n+\n+    @Override\n+    public Collection<ProfileTypeUID> getSupportedProfileTypeUIDs() {\n+        return Collections.singleton(PhonebookProfile.PHONEBOOK_PROFILE_TYPE_UID);\n+    }\n+\n+    @Override\n+    public Collection<ProfileType> getProfileTypes(@Nullable Locale locale) {\n+        return Collections.singleton(\n+                ProfileTypeBuilder.newState(PhonebookProfile.PHONEBOOK_PROFILE_TYPE_UID, \"Phonebook\").build());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzkxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499043913", "bodyText": "Could this be an enum instead?", "author": "cpmeister", "createdAt": "2020-10-02T20:49:19Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/dto/scpd/service/SCPDArgumentType.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.tr064.internal.dto.scpd.service;\n+\n+import java.io.Serializable;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlType;\n+\n+/**\n+ * <p>\n+ * Java class for argumentType complex type.\n+ * \n+ * <p>\n+ * The following schema fragment specifies the expected content contained within this class.\n+ * \n+ * <pre>\n+ * &lt;complexType name=\"argumentType\"&gt;\n+ *   &lt;complexContent&gt;\n+ *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\"&gt;\n+ *       &lt;sequence&gt;\n+ *         &lt;element name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *         &lt;element name=\"direction\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *         &lt;element name=\"relatedStateVariable\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *       &lt;/sequence&gt;\n+ *     &lt;/restriction&gt;\n+ *   &lt;/complexContent&gt;\n+ * &lt;/complexType&gt;\n+ * </pre>\n+ * \n+ * \n+ */\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlType(name = \"argumentType\", propOrder = { \"name\", \"direction\", \"relatedStateVariable\" })\n+public class SCPDArgumentType implements Serializable {\n+\n+    private final static long serialVersionUID = 1L;\n+    protected String name;\n+    protected String direction;", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499046220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                parameters.removeIf(param -> !allowedValues.contains(param));\n          \n          \n            \n                                parameters.retainAll(allowedValues);", "author": "cpmeister", "createdAt": "2020-10-02T20:55:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDArgumentType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDStateVariableType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    public static ThingBuilder checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = thing.getThingTypeUID().equals(THING_TYPE_FRITZBOX)\n+                ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> actionName.equals(action.getName())).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Action '\" + actionName + \"' not found\"));\n+                            SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                    .filter(argument -> argument.getName().equals(argumentName)\n+                                            && argument.getDirection().equals(\"out\"))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Argument '\" + argumentName + \"' not found\"));\n+                            SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                    .filter(stateVariable -> stateVariable.getName()\n+                                            .equals(scpdArgument.getRelatedStateVariable()))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                            + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                            parameters.addAll(\n+                                    getAndCheckParameters(channelId, getAction, scpdAction, serviceRoot, thingConfig));\n+\n+                            channelConfig.setGetAction(scpdAction);\n+                            channelConfig.setDataType(relatedStateVariable.getDataType());\n+                        }\n+\n+                        // check set action\n+                        ActionType setAction = channelTypeDescription.getSetAction();\n+                        if (setAction != null) {\n+                            String actionName = setAction.getName();\n+                            String argumentName = setAction.getArgument();\n+\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> action.getName().equals(actionName)).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Set-Action '\" + actionName + \"' not found\"));\n+                            if (argumentName != null) {\n+                                SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                        .filter(argument -> argument.getName().equals(argumentName)\n+                                                && argument.getDirection().equals(\"in\"))\n+                                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                                \"Set-Argument '\" + argumentName + \"' not found\"));\n+                                SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                        .filter(stateVariable -> stateVariable.getName()\n+                                                .equals(scpdArgument.getRelatedStateVariable()))\n+                                        .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                                + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                                if (channelConfig.getDataType().isEmpty()) {\n+                                    channelConfig.setDataType(relatedStateVariable.getDataType());\n+                                } else if (!channelConfig.getDataType().equals(relatedStateVariable.getDataType())) {\n+                                    throw new ChannelConfigException(\"dataType of set and get action are different\");\n+                                }\n+                            }\n+                        }\n+\n+                        // everything is available, create the channel\n+                        ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID,\n+                                channelTypeDescription.getName());\n+                        if (parameters.isEmpty()) {\n+                            // we have no parameters, so create a single channel\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            ChannelBuilder channelBuilder = ChannelBuilder\n+                                    .create(channelUID, channelTypeDescription.getItem().getType())\n+                                    .withType(channelTypeUID);\n+                            thingBuilder.withChannel(channelBuilder.build());\n+                            channels.put(channelUID, channelConfig);\n+                        } else {\n+                            // create a channel for each parameter\n+                            parameters.forEach(parameter -> {\n+                                String normalizedParameter = UIDUtils.encode(parameter);\n+                                ChannelUID channelUID = new ChannelUID(thing.getUID(),\n+                                        channelId + \"_\" + normalizedParameter);\n+                                ChannelBuilder channelBuilder = ChannelBuilder\n+                                        .create(channelUID, channelTypeDescription.getItem().getType())\n+                                        .withType(channelTypeUID)\n+                                        .withLabel(channelTypeDescription.getLabel() + \" \" + parameter);\n+                                thingBuilder.withChannel(channelBuilder.build());\n+                                Tr064ChannelConfig channelConfig1 = new Tr064ChannelConfig(channelConfig);\n+                                channelConfig1.setParameter(parameter);\n+                                channels.put(channelUID, channelConfig1);\n+                            });\n+                        }\n+                    } catch (ChannelConfigException e) {\n+                        LOGGER.debug(\"Channel {} not available: {}\", channelId, e.getMessage());\n+                    }\n+                });\n+        return thingBuilder;\n+    }\n+\n+    private static Set<String> getAndCheckParameters(String channelId, ActionType action, SCPDActionType scpdAction,\n+            SCPDScpdType serviceRoot, Tr064BaseThingConfiguration thingConfig) throws ChannelConfigException {\n+        ParameterType parameter = action.getParameter();\n+        if (parameter == null) {\n+            return Collections.emptySet();\n+        }\n+        try {\n+            Set<String> parameters = new HashSet<>();\n+\n+            // get parameters by reflection from thing config\n+            Field paramField = thingConfig.getClass().getField(parameter.getThingParameter());\n+            Object rawFieldValue = paramField.get(thingConfig);\n+            if ((rawFieldValue instanceof List<?>)) {\n+                ((List<?>) rawFieldValue).forEach(obj -> {\n+                    if (obj instanceof String) {\n+                        parameters.add((String) obj);\n+                    }\n+                });\n+            }\n+\n+            // validate parameter against pattern\n+            String parameterPattern = parameter.getPattern();\n+            if (parameterPattern != null) {\n+                parameters.removeIf(param -> !param.matches(parameterPattern));\n+            }\n+\n+            // validate parameter against SCPD (if not internal only)\n+            if (!parameter.isInternalOnly()) {\n+                SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                        .filter(argument -> argument.getName().equals(parameter.getName())\n+                                && argument.getDirection().equals(\"in\"))\n+                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                \"Get-Parameter '\" + parameter.getName() + \"' not found\"));\n+                SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                        .filter(stateVariable -> stateVariable.getName().equals(scpdArgument.getRelatedStateVariable()))\n+                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                \"StateVariable '\" + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                if (relatedStateVariable.getAllowedValueRange() != null) {\n+                    int paramMin = relatedStateVariable.getAllowedValueRange().getMinimum();\n+                    int paramMax = relatedStateVariable.getAllowedValueRange().getMaximum();\n+                    int paramStep = relatedStateVariable.getAllowedValueRange().getStep();\n+                    Set<String> allowedValues = Stream.iterate(paramMin, i -> i <= paramMax, i -> i + paramStep)\n+                            .map(String::valueOf).collect(Collectors.toSet());\n+                    parameters.removeIf(param -> !allowedValues.contains(param));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMDUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499130507", "bodyText": "Nice, Thanks.", "author": "J-N-K", "createdAt": "2020-10-03T09:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499050432", "bodyText": "See if you can refactor this into another function since it looks like there is similar code is used in 2 other places.", "author": "cpmeister", "createdAt": "2020-10-02T21:06:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDArgumentType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDStateVariableType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    public static ThingBuilder checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = thing.getThingTypeUID().equals(THING_TYPE_FRITZBOX)\n+                ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> actionName.equals(action.getName())).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Action '\" + actionName + \"' not found\"));\n+                            SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                    .filter(argument -> argument.getName().equals(argumentName)\n+                                            && argument.getDirection().equals(\"out\"))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Argument '\" + argumentName + \"' not found\"));\n+                            SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                    .filter(stateVariable -> stateVariable.getName()\n+                                            .equals(scpdArgument.getRelatedStateVariable()))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                            + scpdArgument.getRelatedStateVariable() + \"' not found\"));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTA5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499051097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" unit=\"s\">", "author": "cpmeister", "createdAt": "2020-10-02T21:08:02Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,140 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tr064\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"generic\">\n+\t\t<label>Generic CPE</label>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"fritzbox\">\n+\t\t<label>FritzBox</label>\n+\t\t<description>A physical FritzBox Device.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499051314", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" unit=\"s\">", "author": "cpmeister", "createdAt": "2020-10-02T21:08:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,140 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tr064\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"generic\">\n+\t\t<label>Generic CPE</label>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"fritzbox\">\n+\t\t<label>FritzBox</label>\n+\t\t<description>A physical FritzBox Device.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tamIndices\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>TAM</label>\n+\t\t\t\t<description>List of answering machines (starting with 0).</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"callDeflectionIndices\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Call Deflection</label>\n+\t\t\t\t<description>List of call deflection IDs (starting with 0).</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"missedCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Missed Call Days</label>\n+\t\t\t\t<description>List of days for which missed calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"rejectedCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Rejected Call Days</label>\n+\t\t\t\t<description>List of days for which rejected calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inboundCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Inbound Call Days</label>\n+\t\t\t\t<description>List of days for which inbound calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"outboundCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Outbound Call Days</label>\n+\t\t\t\t<description>List of days for which outbound calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"phonebookInterval\" type=\"integer\" min=\"0\" unit=\"s\">\n+\t\t\t\t<label>Phonebook Interval</label>\n+\t\t\t\t<description>The interval for refreshing the phonebook (disabled = 0)</description>\n+\t\t\t\t<default>600</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"subdevice\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"generic\"/>\n+\t\t\t<bridge-type-ref id=\"fritzbox\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Sub-Device</label>\n+\t\t<description>A virtual sub-device.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"uuid\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>UUID</label>\n+\t\t\t\t<description>UUID of the sub-device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499051376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" unit=\"s\">", "author": "cpmeister", "createdAt": "2020-10-02T21:08:53Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,140 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tr064\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"generic\">\n+\t\t<label>Generic CPE</label>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"fritzbox\">\n+\t\t<label>FritzBox</label>\n+\t\t<description>A physical FritzBox Device.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tamIndices\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>TAM</label>\n+\t\t\t\t<description>List of answering machines (starting with 0).</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"callDeflectionIndices\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Call Deflection</label>\n+\t\t\t\t<description>List of call deflection IDs (starting with 0).</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"missedCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Missed Call Days</label>\n+\t\t\t\t<description>List of days for which missed calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"rejectedCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Rejected Call Days</label>\n+\t\t\t\t<description>List of days for which rejected calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inboundCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Inbound Call Days</label>\n+\t\t\t\t<description>List of days for which inbound calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"outboundCallDays\" type=\"text\" multiple=\"true\">\n+\t\t\t\t<label>Outbound Call Days</label>\n+\t\t\t\t<description>List of days for which outbound calls should be calculated.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"phonebookInterval\" type=\"integer\" min=\"0\" unit=\"s\">\n+\t\t\t\t<label>Phonebook Interval</label>\n+\t\t\t\t<description>The interval for refreshing the phonebook (disabled = 0)</description>\n+\t\t\t\t<default>600</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"subdevice\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"generic\"/>\n+\t\t\t<bridge-type-ref id=\"fritzbox\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Sub-Device</label>\n+\t\t<description>A virtual sub-device.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"uuid\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>UUID</label>\n+\t\t\t\t<description>UUID of the sub-device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<thing-type id=\"subdeviceLan\" listed=\"false\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"generic\"/>\n+\t\t\t<bridge-type-ref id=\"fritzbox\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Sub-Device (LAN)</label>\n+\t\t<description>A virtual Sub-Device (LAN).</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"uuid\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>UUID</label>\n+\t\t\t\t<description>UUID of the sub-device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MTU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499051588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" unit=\"s\">", "author": "cpmeister", "createdAt": "2020-10-02T21:09:28Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,140 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tr064\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"generic\">\n+\t\t<label>Generic CPE</label>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<description>Host name or IP address.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"user\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<default>dslf-config</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499052543", "bodyText": "Is there period needed? Or is it short for Maximum?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<channel name=\"wanMaxDownstreamRate\" label=\"Max. Downstream Rate\">\n          \n          \n            \n            \t<channel name=\"wanMaxDownstreamRate\" label=\"Max Downstream Rate\">", "author": "cpmeister", "createdAt": "2020-10-02T21:12:15Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/channels.xml", "diffHunk": "@@ -0,0 +1,242 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n+<channels xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"channelconfig\"\n+\txsi:noNamespaceSchemaLocation=\"xsd/channeltypes.xsd\">\n+\t<!-- Root Device -->\n+\t<channel name=\"securityPort\" label=\"Security Port\"\n+\t\tdescription=\"The port for connecting via HTTPS to the TR-064 service.\" advanced=\"true\">\n+\t\t<item type=\"Number\"></item>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"></service>\n+\t\t<getAction name=\"GetSecurityPort\" argument=\"NewSecurityPort\"/>\n+\t</channel>\n+\t<channel name=\"uptime\" label=\"Uptime\">\n+\t\t<item type=\"Number:Time\" unit=\"s\" statePattern=\"%d s\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewUpTime\"/>\n+\t</channel>\n+\t<channel name=\"deviceLog\" label=\"Device Log\" description=\"A string containing the last log messages.\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewDeviceLog\"/>\n+\t</channel>\n+\t<channel name=\"reboot\" label=\"Reboot\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceConfig-com:serviceId:DeviceConfig1\"/>\n+\t\t<setAction name=\"Reboot\"/>\n+\t</channel>\n+\t<channel name=\"tamEnable\" label=\"TAM\" description=\"Enable/Disable the answering machine with the given index.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_TAM-com:serviceId:X_AVM-DE_TAM1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</getAction>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</setAction>\n+\t</channel>\n+\t<channel name=\"tamNewMessages\" label=\"TAM New Messages\"\n+\t\tdescription=\"The number of new messages of the given answering machine.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_TAM-com:serviceId:X_AVM-DE_TAM1\"/>\n+\t\t<getAction name=\"GetMessageList\" argument=\"NewURL\" postProcessor=\"processTamListURL\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"callDeflectionEnable\" label=\"Call Deflection\"\n+\t\tdescription=\"Enable/Disable the call deflection setup with the given index.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetDeflection\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewDeflectionId\" thingParameter=\"callDeflectionIndices\"/>\n+\t\t</getAction>\n+\t\t<setAction name=\"SetDeflectionEnable\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewDeflectionId\" thingParameter=\"callDeflectionIndices\"/>\n+\t\t</setAction>\n+\t</channel>\n+\t<channel name=\"missedCalls\" label=\"Missed Calls\"\n+\t\tdescription=\"Number of missed calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processMissedCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"missedCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"rejectedCalls\" label=\"Rejected Calls\"\n+\t\tdescription=\"Number of rejected calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processRejectedCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"rejectedCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"inboundCalls\" label=\"Inbound Calls\"\n+\t\tdescription=\"Number of inbound calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processInboundCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"inboundCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"outboundCalls\" label=\"Outbound Calls\"\n+\t\tdescription=\"Number of outbound calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processOutboundCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"outboundCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\n+\t<!-- LAN Device -->\n+\t<channel name=\"wifi24GHzEnable\" label=\"WiFi 2.4 GHz\" description=\"Enable/Disable the 2.4 GHz WiFi device.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"wifi5GHzEnable\" label=\"WiFi 5 GHz\" description=\"Enable/Disable the 5.0 GHz WiFi device.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration2\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"wifiGuestEnable\" label=\"WiFi Guest\" description=\"Enable/Disable the guest WiFi.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration3\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"macOnline\" label=\"MAC Online\" description=\"Online status of the device with the given MAC\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\" serviceId=\"urn:LanDeviceHosts-com:serviceId:Hosts1\"/>\n+\t\t<getAction name=\"GetSpecificHostEntry\" argument=\"NewActive\">\n+\t\t\t<parameter name=\"NewMACAddress\" thingParameter=\"macOnline\" pattern=\"([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}\"/>\n+\t\t</getAction>\n+\t</channel>\n+\n+\t<!-- WAN Device -->\n+\t<channel name=\"wanAccessType\" label=\"Access Type\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:WANDevice:1\"\n+\t\t\tserviceId=\"urn:WANCIfConfig-com:serviceId:WANCommonInterfaceConfig1\"/>\n+\t\t<getAction name=\"GetCommonLinkProperties\" argument=\"NewWANAccessType\"/>\n+\t</channel>\n+\t<channel name=\"wanPhysicalLinkStatus\" label=\"Link Status\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:WANDevice:1\"\n+\t\t\tserviceId=\"urn:WANCIfConfig-com:serviceId:WANCommonInterfaceConfig1\"/>\n+\t\t<getAction name=\"GetCommonLinkProperties\" argument=\"NewPhysicalLinkStatus\"/>\n+\t</channel>\n+\t<channel name=\"wanMaxDownstreamRate\" label=\"Max. Downstream Rate\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MjgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499052806", "bodyText": "Same question\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<channel name=\"wanMaxUpstreamRate\" label=\"Max. Upstream Rate\">\n          \n          \n            \n            \t<channel name=\"wanMaxUpstreamRate\" label=\"Max Upstream Rate\">", "author": "cpmeister", "createdAt": "2020-10-02T21:13:03Z", "path": "bundles/org.openhab.binding.tr064/src/main/resources/channels.xml", "diffHunk": "@@ -0,0 +1,242 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n+<channels xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"channelconfig\"\n+\txsi:noNamespaceSchemaLocation=\"xsd/channeltypes.xsd\">\n+\t<!-- Root Device -->\n+\t<channel name=\"securityPort\" label=\"Security Port\"\n+\t\tdescription=\"The port for connecting via HTTPS to the TR-064 service.\" advanced=\"true\">\n+\t\t<item type=\"Number\"></item>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"></service>\n+\t\t<getAction name=\"GetSecurityPort\" argument=\"NewSecurityPort\"/>\n+\t</channel>\n+\t<channel name=\"uptime\" label=\"Uptime\">\n+\t\t<item type=\"Number:Time\" unit=\"s\" statePattern=\"%d s\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewUpTime\"/>\n+\t</channel>\n+\t<channel name=\"deviceLog\" label=\"Device Log\" description=\"A string containing the last log messages.\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewDeviceLog\"/>\n+\t</channel>\n+\t<channel name=\"reboot\" label=\"Reboot\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:DeviceConfig-com:serviceId:DeviceConfig1\"/>\n+\t\t<setAction name=\"Reboot\"/>\n+\t</channel>\n+\t<channel name=\"tamEnable\" label=\"TAM\" description=\"Enable/Disable the answering machine with the given index.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_TAM-com:serviceId:X_AVM-DE_TAM1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</getAction>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</setAction>\n+\t</channel>\n+\t<channel name=\"tamNewMessages\" label=\"TAM New Messages\"\n+\t\tdescription=\"The number of new messages of the given answering machine.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_TAM-com:serviceId:X_AVM-DE_TAM1\"/>\n+\t\t<getAction name=\"GetMessageList\" argument=\"NewURL\" postProcessor=\"processTamListURL\">\n+\t\t\t<parameter name=\"NewIndex\" thingParameter=\"tamIndices\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"callDeflectionEnable\" label=\"Call Deflection\"\n+\t\tdescription=\"Enable/Disable the call deflection setup with the given index.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetDeflection\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewDeflectionId\" thingParameter=\"callDeflectionIndices\"/>\n+\t\t</getAction>\n+\t\t<setAction name=\"SetDeflectionEnable\" argument=\"NewEnable\">\n+\t\t\t<parameter name=\"NewDeflectionId\" thingParameter=\"callDeflectionIndices\"/>\n+\t\t</setAction>\n+\t</channel>\n+\t<channel name=\"missedCalls\" label=\"Missed Calls\"\n+\t\tdescription=\"Number of missed calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processMissedCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"missedCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"rejectedCalls\" label=\"Rejected Calls\"\n+\t\tdescription=\"Number of rejected calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processRejectedCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"rejectedCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"inboundCalls\" label=\"Inbound Calls\"\n+\t\tdescription=\"Number of inbound calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processInboundCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"inboundCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\t<channel name=\"outboundCalls\" label=\"Outbound Calls\"\n+\t\tdescription=\"Number of outbound calls within the given number of days.\">\n+\t\t<item type=\"Number\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:InternetGatewayDevice:1\"\n+\t\t\tserviceId=\"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\"/>\n+\t\t<getAction name=\"GetCallList\" argument=\"NewCallListURL\" postProcessor=\"processOutboundCalls\">\n+\t\t\t<parameter name=\"CallDays\" thingParameter=\"outboundCallDays\" pattern=\"[0-9]+\" internalOnly=\"true\"/>\n+\t\t</getAction>\n+\t</channel>\n+\n+\t<!-- LAN Device -->\n+\t<channel name=\"wifi24GHzEnable\" label=\"WiFi 2.4 GHz\" description=\"Enable/Disable the 2.4 GHz WiFi device.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration1\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"wifi5GHzEnable\" label=\"WiFi 5 GHz\" description=\"Enable/Disable the 5.0 GHz WiFi device.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration2\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"wifiGuestEnable\" label=\"WiFi Guest\" description=\"Enable/Disable the guest WiFi.\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\"\n+\t\t\tserviceId=\"urn:WLANConfiguration-com:serviceId:WLANConfiguration3\"/>\n+\t\t<getAction name=\"GetInfo\" argument=\"NewEnable\"/>\n+\t\t<setAction name=\"SetEnable\" argument=\"NewEnable\"/>\n+\t</channel>\n+\t<channel name=\"macOnline\" label=\"MAC Online\" description=\"Online status of the device with the given MAC\">\n+\t\t<item type=\"Switch\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:LANDevice:1\" serviceId=\"urn:LanDeviceHosts-com:serviceId:Hosts1\"/>\n+\t\t<getAction name=\"GetSpecificHostEntry\" argument=\"NewActive\">\n+\t\t\t<parameter name=\"NewMACAddress\" thingParameter=\"macOnline\" pattern=\"([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}\"/>\n+\t\t</getAction>\n+\t</channel>\n+\n+\t<!-- WAN Device -->\n+\t<channel name=\"wanAccessType\" label=\"Access Type\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:WANDevice:1\"\n+\t\t\tserviceId=\"urn:WANCIfConfig-com:serviceId:WANCommonInterfaceConfig1\"/>\n+\t\t<getAction name=\"GetCommonLinkProperties\" argument=\"NewWANAccessType\"/>\n+\t</channel>\n+\t<channel name=\"wanPhysicalLinkStatus\" label=\"Link Status\">\n+\t\t<item type=\"String\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:WANDevice:1\"\n+\t\t\tserviceId=\"urn:WANCIfConfig-com:serviceId:WANCommonInterfaceConfig1\"/>\n+\t\t<getAction name=\"GetCommonLinkProperties\" argument=\"NewPhysicalLinkStatus\"/>\n+\t</channel>\n+\t<channel name=\"wanMaxDownstreamRate\" label=\"Max. Downstream Rate\">\n+\t\t<item type=\"Number:DataTransferRate\" unit=\"bit/s\" statePattern=\"%.1f Mbit/s\"/>\n+\t\t<service deviceType=\"urn:dslforum-org:device:WANDevice:1\"\n+\t\t\tserviceId=\"urn:WANCIfConfig-com:serviceId:WANCommonInterfaceConfig1\"/>\n+\t\t<getAction name=\"GetCommonLinkProperties\" argument=\"NewLayer1DownstreamMaxBitRate\"/>\n+\t</channel>\n+\t<channel name=\"wanMaxUpstreamRate\" label=\"Max. Upstream Rate\">", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMDgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499130810", "bodyText": "Guess that is a german thing to use a dot to mark a shortened word.... removed.", "author": "J-N-K", "createdAt": "2020-10-03T09:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1Njk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499056950", "bodyText": "Should those generated sources be included in this PR or generated on demand as part of the maven build? \ud83e\udd14", "author": "cpmeister", "createdAt": "2020-10-02T21:25:12Z", "path": "tools/static-code-analysis/checkstyle/suppressions.xml", "diffHunk": "@@ -20,4 +20,7 @@\n     <suppress files=\".+org.openhab.binding.yeelight.+\" checks=\"OutsideOfLibExternalLibrariesCheck\" />\n     <!-- suppress header checks for imported and patched apache commons-io files in logreader binding -->\n     <suppress files=\".+org.openhab.binding.logreader.internal.thirdparty.commonsio.+\" checks=\"ParameterizedRegexpHeaderCheck|AuthorTagCheck\" />\n+\t<!-- suppress author tag checks for generated sources in tr064 binding -->\n+    <suppress files=\".+org.openhab.binding.tr064.internal.dto.+\" checks=\"AuthorTagCheck\" />", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMDc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499130743", "bodyText": "See my comment above. I would prefer to have them generated during the build (which is not an additional step but done on-the-fly). This would remove the need to manually add the headers and also remove the need to have the author tag-check-excluded.", "author": "J-N-K", "createdAt": "2020-10-03T09:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1Njk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MDQ0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499060447", "bodyText": "Minor adjustment to refactor the callback.sendUpdate.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        match.ifPresentOrElse(name -> callback.sendUpdate(new StringType(name)), () -> {\n          \n          \n            \n                            logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n          \n          \n            \n                                    thingUID);\n          \n          \n            \n                            callback.sendUpdate(state);\n          \n          \n            \n                        });\n          \n          \n            \n                        State newState = match.map(name -> (State) new StringType(name)).orElse(state);\n          \n          \n            \n                        if(newState == state) {\n          \n          \n            \n                             logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n          \n          \n            \n                                    thingUID);\n          \n          \n            \n                        }\n          \n          \n            \n                        callback.sendUpdate(newState);", "author": "cpmeister", "createdAt": "2020-10-02T21:35:26Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfile.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.thing.profiles.StateProfile;\n+import org.openhab.core.transform.TransformationService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfile} class provides a profile for resolving phone number strings to names\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PhonebookProfile implements StateProfile {\n+    public static final ProfileTypeUID PHONEBOOK_PROFILE_TYPE_UID = new ProfileTypeUID(\n+            TransformationService.TRANSFORM_PROFILE_SCOPE, \"PHONEBOOK\");\n+\n+    public static final String PHONEBOOK_PARAM = \"phonebook\";\n+    private static final String MATCH_COUNT_PARAM = \"matchCount\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(PhonebookProfile.class);\n+\n+    private final ProfileCallback callback;\n+\n+    private final @Nullable String phonebookName;\n+    private final @Nullable ThingUID thingUID;\n+    private final Map<ThingUID, PhonebookProvider> phonebookProviders;\n+    private final int matchCount;\n+\n+    public PhonebookProfile(ProfileCallback callback, ProfileContext context,\n+            Map<ThingUID, PhonebookProvider> phonebookProviders) {\n+        this.callback = callback;\n+        this.phonebookProviders = phonebookProviders;\n+\n+        Configuration configuration = context.getConfiguration();\n+        Object phonebookParam = configuration.get(PHONEBOOK_PARAM);\n+        Object matchCountParam = configuration.get(MATCH_COUNT_PARAM);\n+\n+        logger.debug(\"Profile configured with '{}'='{}', '{}'='{}'\", PHONEBOOK_PARAM, phonebookParam, MATCH_COUNT_PARAM,\n+                matchCountParam);\n+\n+        ThingUID thingUID;\n+        String phonebookName = null;\n+        int matchCount = 0;\n+\n+        try {\n+            if (!(phonebookParam instanceof String)\n+                    || ((matchCountParam != null) && !(matchCountParam instanceof String))) {\n+                throw new IllegalArgumentException(\"Parameters need to be Strings\");\n+            }\n+            String[] phonebookParams = ((String) phonebookParam).split(\":\");\n+            if (phonebookParams.length > 2) {\n+                throw new IllegalArgumentException(\"Could not split 'phonebook' parameter\");\n+            }\n+            thingUID = new ThingUID(UIDUtils.decode(phonebookParams[0]));\n+            if (phonebookParams.length == 2) {\n+                phonebookName = UIDUtils.decode(phonebookParams[1]);\n+            }\n+            if (matchCountParam != null) {\n+                matchCount = Integer.parseInt((String) matchCountParam);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not initialize PHONEBOOK transformation profile: {}. Profile will be inactive.\",\n+                    e.getMessage());\n+            thingUID = null;\n+        }\n+\n+        this.thingUID = thingUID;\n+        this.phonebookName = phonebookName;\n+        this.matchCount = matchCount;\n+    }\n+\n+    @Override\n+    public void onCommandFromItem(Command command) {\n+    }\n+\n+    @Override\n+    public void onCommandFromHandler(Command command) {\n+    }\n+\n+    @Override\n+    public void onStateUpdateFromHandler(State state) {\n+        if (state instanceof StringType) {\n+            PhonebookProvider provider = phonebookProviders.get(thingUID);\n+            if (provider == null) {\n+                logger.warn(\"Could not get phonebook provider with thing UID '{}'.\", thingUID);\n+                return;\n+            }\n+            final String phonebookName = this.phonebookName;\n+            Optional<String> match;\n+            if (phonebookName != null) {\n+                match = provider.getPhonebookByName(phonebookName).or(() -> {\n+                    logger.warn(\"Could not get phonebook '{}' from provider '{}'\", phonebookName, thingUID);\n+                    return Optional.empty();\n+                }).flatMap(phonebook -> phonebook.lookupNumber(state.toString(), matchCount));\n+            } else {\n+                match = provider.getPhonebooks().stream().map(p -> p.lookupNumber(state.toString(), matchCount))\n+                        .filter(Optional::isPresent).map(Optional::get).findAny();\n+            }\n+            match.ifPresentOrElse(name -> callback.sendUpdate(new StringType(name)), () -> {\n+                logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n+                        thingUID);\n+                callback.sendUpdate(state);\n+            });", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499063639", "bodyText": "Why do you need to keep track of the linked channels? Can't you use isLinked instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (linkedChannels.contains(channelUID)) {\n          \n          \n            \n                        if (isLinked(channelUID)) {", "author": "cpmeister", "createdAt": "2020-10-02T21:45:41Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            isInitialized = true;\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+        isInitialized = false;\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499131695", "bodyText": "I guess a set-lookup is faster, but changed.", "author": "J-N-K", "createdAt": "2020-10-03T09:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Mzg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499063864", "bodyText": "refactor this into its own method", "author": "cpmeister", "createdAt": "2020-10-02T21:46:28Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            isInitialized = true;\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499064140", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"One or more mandatory configuration field is empty\");\n          \n          \n            \n                                \"One or more mandatory configuration fields are empty\");\n          \n      \n    \n    \n  \n\nIt would also be more beneficial to the user if you could specify which required fields were blank.", "author": "cpmeister", "createdAt": "2020-10-02T21:47:25Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499131952", "bodyText": "This can only happen if the user decides to use textual configuration. So he/she'll probably be an advanced user and be able to figure it out. The UI doesn't allow to save an invalid config.  It would require removing the valid-check in the configuration classes and IMO the code is much clearer this way.", "author": "J-N-K", "createdAt": "2020-10-03T09:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499064720", "bodyText": "Should this be logged as a warn? What could the user do about this if this happens? And how would they know to do it?", "author": "cpmeister", "createdAt": "2020-10-02T21:49:33Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MjgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499162823", "bodyText": "This happens if handleCommand is called before it is fully initialized. This should be prevented by the framework. However the null-check is necessary, because the field is @Nullable.", "author": "J-N-K", "createdAt": "2020-10-03T16:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499077943", "bodyText": "The previous logic really irked me because field assignment was getting performed inside of the streaming lambdas which I'd prefer to occur outside of your lambda logic. I went ahead and rearranged the logic but even now I'm not sure that it looks all that great. This logic should probably be refactored into several different methods.\nOh, I also noticed that you were not checking for null values in your final phonebook list so I fixed that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scpdUtil.getDevice(\"\").ifPresent(deviceType -> deviceType.getServiceList().stream()\n          \n          \n            \n                            .filter(service -> service.getServiceId().equals(serviceId)).findFirst().ifPresent(scpdService -> {\n          \n          \n            \n                                try {\n          \n          \n            \n                                    SOAPMessage soapMessagePhonebookList = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                            \"GetPhonebookList\", Collections.emptyMap());\n          \n          \n            \n                                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                                    phonebooks = soapValueConverter\n          \n          \n            \n                                            .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n          \n          \n            \n                                            .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")).map(index -> {\n          \n          \n            \n                                                try {\n          \n          \n            \n                                                    SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                                            \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n          \n          \n            \n                                                    return soapValueConverter\n          \n          \n            \n                                                            .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n          \n          \n            \n                                                            .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n          \n          \n            \n                                                                    url.toString()))\n          \n          \n            \n                                                            .orElse(null);\n          \n          \n            \n                                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                                    logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n          \n          \n            \n                                                }\n          \n          \n            \n                                                return null;\n          \n          \n            \n                                            }).collect(Collectors.toList())).orElse(Collections.emptyList());\n          \n          \n            \n                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                    phonebooks = Collections.emptyList();\n          \n          \n            \n                                }\n          \n          \n            \n                            }));\n          \n          \n            \n                    phonebooks = scpdUtil.getDevice(\"\")\n          \n          \n            \n                        .flatMap(deviceType -> deviceType.getServiceList().stream()\n          \n          \n            \n                            .filter(service -> service.getServiceId().equals(serviceId))\n          \n          \n            \n                            .findFirst())\n          \n          \n            \n                        .map(scpdService -> {\n          \n          \n            \n                            try {\n          \n          \n            \n                                return soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                         \"GetPhonebookList\", Collections.emptyMap());\n          \n          \n            \n                            } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                return null;\n          \n          \n            \n                            }\n          \n          \n            \n                        }).map(soapMessagePhonebookList -> {\n          \n          \n            \n                                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                                    return soapValueConverter\n          \n          \n            \n                                            .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n          \n          \n            \n                                            .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")))\n          \n          \n            \n                                            .orElse(Streams.empty())\n          \n          \n            \n                                            .map(index -> {\n          \n          \n            \n                                                try {\n          \n          \n            \n                                                    SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                                            \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n          \n          \n            \n                                                    return soapValueConverter\n          \n          \n            \n                                                            .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n          \n          \n            \n                                                            .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n          \n          \n            \n                                                                    url.toString()))\n          \n          \n            \n                                                            .orElse(null);\n          \n          \n            \n                                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                                    logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n          \n          \n            \n                                                }\n          \n          \n            \n                                                return null;\n          \n          \n            \n                                            })\n          \n          \n            \n                                            .filter(Objects:nonNull)\n          \n          \n            \n                                            .collect(Collectors.toList());\n          \n          \n            \n                            }).orElse(Collections.emptyList());", "author": "cpmeister", "createdAt": "2020-10-02T22:40:38Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID,\n+                        () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * establish the connection - get secure port (if avallable), install authentication, get device properties\n+     *\n+     * @return true if successful\n+     */\n+    private boolean establishSecureConnectionAndUpdateProperties() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        if (scpdUtil != null) {\n+            try {\n+                SCPDDeviceType device = scpdUtil.getDevice(\"\")\n+                        .orElseThrow(() -> new SCPDException(\"Root device not found\"));\n+                SCPDServiceType deviceService = device.getServiceList().stream()\n+                        .filter(service -> service.getServiceId().equals(\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"))\n+                        .findFirst().orElseThrow(() -> new SCPDException(\n+                                \"service 'urn:DeviceInfo-com:serviceId:DeviceInfo1' not found\"));\n+\n+                this.deviceType = device.getDeviceType();\n+\n+                // try to get security (https) port\n+                SOAPMessage soapResponse = soapConnector.doSOAPRequest(deviceService, \"GetSecurityPort\",\n+                        Collections.emptyMap());\n+                if (!soapResponse.getSOAPBody().hasFault()) {\n+                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                    soapValueConverter.getStateFromSOAPValue(soapResponse, \"NewSecurityPort\", null)\n+                            .ifPresentOrElse(port -> {\n+                                endpointBaseURL = \"https://\" + config.host + \":\" + port.toString();\n+                                soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+                                logger.debug(\"endpointBaseURL is now '{}'\", endpointBaseURL);\n+                            }, () -> logger.warn(\"Could not determine secure port, disabling https\"));\n+                } else {\n+                    logger.warn(\"Could not determine secure port, disabling https\");\n+                }\n+\n+                // clear auth cache and force re-auth\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                AuthenticationStore auth = httpClient.getAuthenticationStore();\n+                auth.addAuthentication(new DigestAuthentication(new URI(endpointBaseURL), Authentication.ANY_REALM,\n+                        config.user, config.password));\n+\n+                // check & update properties\n+                SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n+                        .orElseThrow(() -> new SCPDException(\n+                                \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n+                        .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n+                        .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));\n+                SOAPMessage soapResponse1 = soapConnector.doSOAPRequest(deviceService, getInfoAction.getName(),\n+                        Collections.emptyMap());\n+                SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                Map<String, String> properties = editProperties();\n+                PROPERTY_ARGUMENTS.forEach(argumentName -> getInfoAction.getArgumentList().stream()\n+                        .filter(argument -> argument.getName().equals(argumentName)).findFirst()\n+                        .ifPresent(argument -> soapValueConverter\n+                                .getStateFromSOAPValue(soapResponse1, argumentName, null).ifPresent(value -> properties\n+                                        .put(argument.getRelatedStateVariable(), value.toString()))));\n+                properties.put(\"deviceType\", device.getDeviceType());\n+                updateProperties(properties);\n+\n+                return true;\n+            } catch (SCPDException | SOAPException | Tr064CommunicationException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * get all sub devices of this root device (used for discovery)\n+     *\n+     * @return the list\n+     */\n+    public List<SCPDDeviceType> getAllSubDevices() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        return (scpdUtil == null) ? Collections.emptyList() : scpdUtil.getAllSubDevices();\n+    }\n+\n+    /**\n+     * get the SOAP connector (used by sub devices for communication with the remote device)\n+     *\n+     * @return the SOAP connector\n+     */\n+    public SOAPConnector getSOAPConnector() {\n+        return soapConnector;\n+    }\n+\n+    /**\n+     * get the SCPD processing utility\n+     *\n+     * @return the SCPD utility (or null if not available)\n+     */\n+    public @Nullable SCPDUtil getSCPDUtil() {\n+        return scpdUtil;\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        linkedChannels.add(channelUID);\n+        super.channelLinked(channelUID);\n+        logger.debug(\"Channel {} linked\", channelUID);\n+    }\n+\n+    @Override\n+    public void channelUnlinked(ChannelUID channelUID) {\n+        super.channelUnlinked(channelUID);\n+        linkedChannels.remove(channelUID);\n+        logger.debug(\"Channel {} unlinked\", channelUID);\n+    }\n+\n+    /**\n+     * uninstall the polling\n+     */\n+    private void uninstallPolling() {\n+        final ScheduledFuture<?> pollFuture = this.pollFuture;\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+            this.pollFuture = null;\n+        }\n+        final ScheduledFuture<?> phonebookFuture = this.phonebookFuture;\n+        if (phonebookFuture != null) {\n+            phonebookFuture.cancel(true);\n+            this.phonebookFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * install the polling\n+     */\n+    private void installPolling() {\n+        uninstallPolling();\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 0, config.refresh, TimeUnit.SECONDS);\n+        if (config.phonebookInterval > 0) {\n+            phonebookFuture = scheduler.scheduleWithFixedDelay(this::retrievePhonebooks, 0, config.phonebookInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void retrievePhonebooks() {\n+        String serviceId = \"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\";\n+        scpdUtil.getDevice(\"\").ifPresent(deviceType -> deviceType.getServiceList().stream()\n+                .filter(service -> service.getServiceId().equals(serviceId)).findFirst().ifPresent(scpdService -> {\n+                    try {\n+                        SOAPMessage soapMessagePhonebookList = soapConnector.doSOAPRequest(scpdService,\n+                                \"GetPhonebookList\", Collections.emptyMap());\n+                        SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                        phonebooks = soapValueConverter\n+                                .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n+                                .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")).map(index -> {\n+                                    try {\n+                                        SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n+                                                \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n+                                        return soapValueConverter\n+                                                .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n+                                                .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n+                                                        url.toString()))\n+                                                .orElse(null);\n+                                    } catch (Tr064CommunicationException e) {\n+                                        logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n+                                    }\n+                                    return null;\n+                                }).collect(Collectors.toList())).orElse(Collections.emptyList());\n+                    } catch (Tr064CommunicationException e) {\n+                        phonebooks = Collections.emptyList();\n+                    }\n+                }));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0MDcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499140716", "bodyText": "I tried something similiar before. Unfortunately this will not work. scpdService is no longer available in l. 354 if you re-arrange the code like that.", "author": "J-N-K", "createdAt": "2020-10-03T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0NzcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499147704", "bodyText": "I refactored the code, WDYT?", "author": "J-N-K", "createdAt": "2020-10-03T13:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499185502", "bodyText": "Looks better than before at least. \ud83d\ude04", "author": "cpmeister", "createdAt": "2020-10-03T22:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3ODU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499078556", "bodyText": "same linked channels question as above", "author": "cpmeister", "createdAt": "2020-10-02T22:43:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MDgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499080820", "bodyText": "Might be worth it add logic here so that the thing is only updated if the channels would change.", "author": "cpmeister", "createdAt": "2020-10-02T22:53:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzNTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499135734", "bodyText": "The problem is that Channel does not implement equals, so it's difficult to check if the channels are really the same. Checking the channelUID is not enough, since the configuration could be different.", "author": "J-N-K", "createdAt": "2020-10-03T10:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTI1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081251", "bodyText": "should this be logged as debug instead?", "author": "cpmeister", "createdAt": "2020-10-02T22:55:29Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n+    }\n+\n+    /**\n+     * get a value from the remote device - updates state cache for all possible channels\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param channelConfigMap map of all channels in the device\n+     * @param stateCache the ExpiringCacheMap for states of the device\n+     * @return the value for the requested channel\n+     */\n+    public State getChannelStateFromDevice(final Tr064ChannelConfig channelConfig,\n+            Map<ChannelUID, Tr064ChannelConfig> channelConfigMap, ExpiringCacheMap<ChannelUID, State> stateCache) {\n+        try {\n+            final SCPDActionType getAction = channelConfig.getGetAction();\n+            if (getAction == null) {\n+                // channel has no get action, return a default\n+                switch (channelConfig.getDataType()) {\n+                    case \"boolean\":\n+                        return OnOffType.OFF;\n+                    case \"string\":\n+                        return StringType.EMPTY;\n+                    default:\n+                        return UnDefType.UNDEF;\n+                }\n+            }\n+\n+            // get value(s) from remote device\n+            Map<String, String> arguments = new HashMap<>();\n+            String parameter = channelConfig.getParameter();\n+            if (parameter != null\n+                    && !channelConfig.getChannelTypeDescription().getGetAction().getParameter().isInternalOnly()) {\n+                arguments.put(channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                        parameter);\n+            }\n+            SOAPMessage soapResponse = doSOAPRequest(channelConfig.getService(), getAction.getName(), arguments);\n+\n+            String argumentName = channelConfig.getChannelTypeDescription().getGetAction().getArgument();\n+            // find all other channels with the same action that are already in cache, so we can update them\n+            Map<ChannelUID, Tr064ChannelConfig> channelsInRequest = channelConfigMap.entrySet().stream()\n+                    .filter(map -> getAction.equals(map.getValue().getGetAction())\n+                            && stateCache.containsKey(map.getKey())\n+                            && !argumentName\n+                                    .equals(map.getValue().getChannelTypeDescription().getGetAction().getArgument()))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            channelsInRequest\n+                    .forEach(\n+                            (channelUID,\n+                                    channelConfig1) -> soapValueConverter\n+                                            .getStateFromSOAPValue(soapResponse,\n+                                                    channelConfig1.getChannelTypeDescription().getGetAction()\n+                                                            .getArgument(),\n+                                                    channelConfig1)\n+                                            .ifPresent(state -> stateCache.putValue(channelUID, state)));\n+\n+            return soapValueConverter.getStateFromSOAPValue(soapResponse, argumentName, channelConfig)\n+                    .orElseThrow(() -> new Tr064CommunicationException(\"failed to transform '\"\n+                            + channelConfig.getChannelTypeDescription().getGetAction().getArgument() + \"'\"));\n+        } catch (Tr064CommunicationException e) {\n+            logger.info(\"Failed to get {}: {}\", channelConfig, e.getMessage());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n          \n          \n            \n                            }, () -> logger.debug(\"Could not convert {} to SOAP value\", command));\n          \n      \n    \n    \n  \n\nShould this also put the thing offline?", "author": "cpmeister", "createdAt": "2020-10-02T22:56:00Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzM1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127357", "bodyText": "See above: this should not happen during normal opertaion and indicates a fault. it is more likely warn than debug.", "author": "J-N-K", "createdAt": "2020-10-03T08:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081520", "bodyText": "Should this put the thing offline?", "author": "cpmeister", "createdAt": "2020-10-02T22:56:20Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081753", "bodyText": "Just to be consistent.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                    this.soapValueConverter = new SOAPValueConverter(httpClient);", "author": "cpmeister", "createdAt": "2020-10-02T22:57:17Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MjExNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499082116", "bodyText": "Shouldn't you dump them in a different source directory dedicated for generated sources?", "author": "cpmeister", "createdAt": "2020-10-02T22:58:42Z", "path": "bundles/org.openhab.binding.tr064/pom.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.tr064</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: TR-064 Binding</name>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.jvnet.jaxb2.maven2</groupId>\n+        <artifactId>maven-jaxb2-plugin</artifactId>\n+        <version>0.14.0</version>\n+        <executions>\n+          <execution>\n+            <id>generate-jaxb-sources</id>\n+            <phase>none</phase>\n+            <goals>\n+              <goal>generate</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+        <configuration>\n+          <schemaDirectory>src/main/resources/xsd</schemaDirectory>\n+          <generateDirectory>src/main/java</generateDirectory>", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzU1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127555", "bodyText": "Good question. IMO generated sources should not be checked in at all. They can be generated on-the-fly in the target directory (which is the default anyway). This also removes the need for excluding them for some code-checks. @kaikreuzer thinks they should be checked in and then it's easier to have them here.\nAs a middle way I put them in the dto package.", "author": "J-N-K", "createdAt": "2020-10-03T08:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MjExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MjE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499162165", "bodyText": "If with the new \"import as Maven project\" we also manage to have code generation automatically run after the import (see also #8641 (comment)), I'd be fine with NOT checking them into the repo anymore. But in any case, I agree that the generated sources must not be in src/main/java, but rather in src/generated/java.", "author": "kaikreuzer", "createdAt": "2020-10-03T16:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499086788", "bodyText": "I wonder if it is worth it to make utility methods for these frequently used name lookups...\nprivate Function<SCPDActionType, Optional<SCPDArgumentType> getArgument(String argumentName, String direction){\n    return (action) -> action.getArgumentList().stream()\n                                        .filter(argument -> argument.getName().equals(argumentName)\n                                                && argument.getDirection().equals(direction))\n                                        .findFirst();\n}\n\nprivate Function<SCPDServiceType,  Optional<SCPDActionType>> getAction(String actionName){\n    return (service) -> service.getActionList().stream().filter(action -> action.getName().equals(actionName)).findFirst();\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\n          \n          \n            \n                                            \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n          \n          \n            \n                                    .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));\n          \n          \n            \n                            SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\n          \n          \n            \n                                            \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n          \n          \n            \n                                    .flatMap(getAction(\"GetInfo\"))\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));", "author": "cpmeister", "createdAt": "2020-10-02T23:23:05Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID,\n+                        () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * establish the connection - get secure port (if avallable), install authentication, get device properties\n+     *\n+     * @return true if successful\n+     */\n+    private boolean establishSecureConnectionAndUpdateProperties() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        if (scpdUtil != null) {\n+            try {\n+                SCPDDeviceType device = scpdUtil.getDevice(\"\")\n+                        .orElseThrow(() -> new SCPDException(\"Root device not found\"));\n+                SCPDServiceType deviceService = device.getServiceList().stream()\n+                        .filter(service -> service.getServiceId().equals(\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"))\n+                        .findFirst().orElseThrow(() -> new SCPDException(\n+                                \"service 'urn:DeviceInfo-com:serviceId:DeviceInfo1' not found\"));\n+\n+                this.deviceType = device.getDeviceType();\n+\n+                // try to get security (https) port\n+                SOAPMessage soapResponse = soapConnector.doSOAPRequest(deviceService, \"GetSecurityPort\",\n+                        Collections.emptyMap());\n+                if (!soapResponse.getSOAPBody().hasFault()) {\n+                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                    soapValueConverter.getStateFromSOAPValue(soapResponse, \"NewSecurityPort\", null)\n+                            .ifPresentOrElse(port -> {\n+                                endpointBaseURL = \"https://\" + config.host + \":\" + port.toString();\n+                                soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+                                logger.debug(\"endpointBaseURL is now '{}'\", endpointBaseURL);\n+                            }, () -> logger.warn(\"Could not determine secure port, disabling https\"));\n+                } else {\n+                    logger.warn(\"Could not determine secure port, disabling https\");\n+                }\n+\n+                // clear auth cache and force re-auth\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                AuthenticationStore auth = httpClient.getAuthenticationStore();\n+                auth.addAuthentication(new DigestAuthentication(new URI(endpointBaseURL), Authentication.ANY_REALM,\n+                        config.user, config.password));\n+\n+                // check & update properties\n+                SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n+                        .orElseThrow(() -> new SCPDException(\n+                                \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n+                        .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n+                        .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyOTc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499129749", "bodyText": "Where do you see a benefit here? It's only used in this place AFAIK.", "author": "J-N-K", "createdAt": "2020-10-03T08:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MTEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499161100", "bodyText": "It is used in several places in the Util class. But frankly I'm not sure my suggestion provides enough benefit to be worth the time to do it anyway.", "author": "cpmeister", "createdAt": "2020-10-03T16:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA=="}], "type": "inlineReview"}, {"oid": "28368f9b4932845750ff83e34fcc3bdb38495521", "url": "https://github.com/openhab/openhab-addons/commit/28368f9b4932845750ff83e34fcc3bdb38495521", "message": "refactor phonebook retrieval\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-03T14:54:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MDMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499160339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .withRepresentationProperty(device.getUDN()).build();\n          \n          \n            \n                                    .withRepresentationProperty(\"uuid\").build();", "author": "cpmeister", "createdAt": "2020-10-03T16:09:59Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DiscoveryService.java", "diffHunk": "@@ -96,7 +96,8 @@ public void startScan() {\n                 properties.put(\"deviceType\", device.getDeviceType());\n \n                 DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(device.getFriendlyName())\n-                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties).build();\n+                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties)\n+                        .withRepresentationProperty(device.getUDN()).build();", "originalCommit": "04fc473ab4bdc70c55e8c6ab5fa7df2d764fd4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4Njc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499186783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .concat(org.openhab.binding.tr064.internal.Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),\n          \n          \n            \n                        .concat(Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),", "author": "cpmeister", "createdAt": "2020-10-03T22:25:10Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n+public class Tr064HandlerFactory extends BaseThingHandlerFactory {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream\n+            .concat(org.openhab.binding.tr064.internal.Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4Nzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499187773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final ScheduledFuture<?> connectFuture = this.connectFuture;\n          \n          \n            \n                        if (connectFuture != null) {\n          \n          \n            \n                            connectFuture.cancel(true);\n          \n          \n            \n                            this.connectFuture = null;\n          \n          \n            \n                        }\n          \n          \n            \n                        removeConnectScheduler();", "author": "cpmeister", "createdAt": "2020-10-03T22:43:32Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration fields are empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            removeConnectScheduler();\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+\n+            isInitialized = true;\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    private void removeConnectScheduler() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        removeConnectScheduler();\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+        isInitialized = false;\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (isLinked(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                        : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * get device properties from remote device\n+     *\n+     * @param scpdUtil the SCPD util of this device\n+     * @return true if successfull\n+     */\n+    private boolean checkProperties(SCPDUtil scpdUtil) {\n+        try {\n+            SCPDDeviceType device = scpdUtil.getDevice(config.uuid)\n+                    .orElseThrow(() -> new SCPDException(\"Could not find device \" + config.uuid));\n+            String deviceType = device.getDeviceType();\n+            if (deviceType == null) {\n+                throw new SCPDException(\"deviceType can't be null \");\n+            }\n+            this.deviceType = deviceType;\n+\n+            Map<String, String> properties = editProperties();\n+            properties.put(\"deviceType\", deviceType);\n+            updateProperties(properties);\n+\n+            return true;\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update device properties: \" + e.getMessage());\n+\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (!bridgeStatusInfo.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(true);\n+                this.connectFuture = null;\n+            }", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NzkyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499187922", "bodyText": "refactor this into its own method. Same as what was done in Tr064SubHandler.", "author": "cpmeister", "createdAt": "2020-10-03T22:46:14Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499188421", "bodyText": "This forEach is only used for logging. Wrap all this with a isTraceEnabled check.", "author": "cpmeister", "createdAt": "2020-10-03T22:56:09Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        this.soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89f8a646de034956ad72614516782381c6ebb8f6", "url": "https://github.com/openhab/openhab-addons/commit/89f8a646de034956ad72614516782381c6ebb8f6", "message": "improvments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-06T14:39:21Z", "type": "forcePushed"}, {"oid": "554708dd9f8c481026bf55200f2bbf93e85bd778", "url": "https://github.com/openhab/openhab-addons/commit/554708dd9f8c481026bf55200f2bbf93e85bd778", "message": "fixes and code improvements\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T09:32:38Z", "type": "forcePushed"}, {"oid": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "url": "https://github.com/openhab/openhab-addons/commit/9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "message": "Initial contribution\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T16:46:23Z", "type": "commit"}, {"oid": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "url": "https://github.com/openhab/openhab-addons/commit/9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "message": "Initial contribution\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T16:46:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMzk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515513983", "bodyText": "Add-ons must not have dependencies on tp features - could you instead please add one (or two?) features to the openhab-core feature and make use of this instead?", "author": "kaikreuzer", "createdAt": "2020-10-31T16:33:10Z", "path": "bundles/org.openhab.binding.tr064/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.tr064-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-tr064\" description=\"TR-064 Binding\" version=\"${project.version}\">\n+\t\t<feature>openhab-runtime-base</feature>\n+\t\t<feature>openhab.tp-jaxb</feature>", "originalCommit": "270937dc13607810a8b2019ece91b50a6cdd448b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzMzY1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515533657", "bodyText": "A lot of bindings violate that: avmfritz, boschindego, chromecast, denonmarantz, dlinksmarthome, groheondus, icalendar, ipcamera, lgwebos, tellstick, xmltv, homekit, jinja, pollytts with openhab.tp-jaxb, openhab.tp-netty, openhab.tp-jackson, openhab.tp-jaxws.\nWouldn't it make more sense to fix them all at once after we discussed where such features should live? When the jaxb and jaxws features were introduced with openhab/openhab-core#920 the feature-names were changed from my original  proposal openhab-jaxb and openhab-jaxws (cf. openhab/openhab-core#684) to openhab.tp-jaxb and openhab.tp-jaxws. What is different now?", "author": "J-N-K", "createdAt": "2020-10-31T20:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MDk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515540977", "bodyText": "Ok, maybe you are right - we haven't really clearly defined anywhere how to deal with \"common\" dependencies that are used by multiple add-ons, so clearly the way for them is to use the tp-features right now.\nIndeed, the features within the openhab-core Karaf feature are all containing some openhab-core bundles as well, what makes them somewhat different.\nI'd like to ask you though to declare the dependency on tp-features in the same way as it is done from the openhab-core features - i.e. declaring a requirement and only add the feature with dependency=\"true\", so that it is only installed, if the requirement isn't already satisfied in some other way.\n\t\t<requirement>openhab.tp;filter:=\"(feature=jaxb)\"</requirement>\n\t\t<feature dependency=\"true\">openhab.tp-jaxb</feature>\n\t\t<requirement>openhab.tp;filter:=\"(feature=jax-ws)\"</requirement>\n\t\t<feature dependency=\"true\">openhab.tp-jaxws</feature>", "author": "kaikreuzer", "createdAt": "2020-10-31T21:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU5MDQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515590466", "bodyText": "Good point. Done.", "author": "J-N-K", "createdAt": "2020-11-01T09:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxOTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515519291", "bodyText": "Didn't the phonebooks only exist on Fritzboxes, so you should register it only if it is a THING_TYPE_FRITZBOX?", "author": "kaikreuzer", "createdAt": "2020-10-31T17:26:42Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n+public class Tr064HandlerFactory extends BaseThingHandlerFactory {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream\n+            .of(Tr064RootHandler.SUPPORTED_THING_TYPES, Tr064SubHandler.SUPPORTED_THING_TYPES).flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n+\n+    private final HttpClient httpClient;\n+    private final PhonebookProfileFactory phonebookProfileFactory;\n+\n+    // the Tr064ChannelTypeProvider is needed for creating the channels and\n+    // referenced here to make sure it is available before things are\n+    // initialized\n+    @SuppressWarnings(\"unused\")\n+    private final Tr064ChannelTypeProvider channelTypeProvider;\n+\n+    @Activate\n+    public Tr064HandlerFactory(@Reference HttpClientFactory httpClientFactory,\n+            @Reference Tr064ChannelTypeProvider channelTypeProvider,\n+            @Reference PhonebookProfileFactory phonebookProfileFactory) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.phonebookProfileFactory = phonebookProfileFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (Tr064RootHandler.SUPPORTED_THING_TYPES.contains(thingTypeUID)) {\n+            Tr064RootHandler handler = new Tr064RootHandler((Bridge) thing, httpClient);\n+            phonebookProfileFactory.registerPhonebookProvider(handler);", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUyMDA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515520077", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the `PHONEBOOK` transformation shall be used, it is necessary to retrieve the phonebooks from the FritzBox.\n          \n          \n            \n            If the `PHONEBOOK` profile shall be used, it is necessary to retrieve the phonebooks from the FritzBox.", "author": "kaikreuzer", "createdAt": "2020-10-31T17:35:22Z", "path": "bundles/org.openhab.binding.tr064/README.md", "diffHunk": "@@ -0,0 +1,122 @@\n+# TR-064 Binding\n+\n+This binding brings support for internet gateway devices that support the TR-064 protocol.\n+It can be used to gather information from the device and/or re-configure it.\n+\n+## Supported Things\n+\n+Four thing types are supported:\n+\n+- `generic`: the internet gateway device itself (generic device)\n+- `fritzbox`: similar to `generic` with extensions for AVM FritzBox devices\n+- `subDevice`: a sub-device of a `rootDevice` (e.g. a WAN interface) \n+- `subDeviceLan`: a special type of sub-device that supports MAC-detection\n+\n+## Discovery\n+\n+The gateway device needs to be added manually.\n+After that, sub-devices are detected automatically.\n+\n+## Thing Configuration\n+\n+All thing types have a `refresh` parameter.\n+It sets the refresh-interval in seconds for each device channel.\n+The default value is 60.\n+\n+### `generic`, `fritzbox`\n+\n+The `host` parameter is required to communicate with the device.\n+It can be a hostname or an IP address.\n+\n+For accessing the device you need to supply credentials.\n+If you only configured password authentication for your device, the `user` parameter must be skipped and it will default to `dslf-config`.\n+The second credential parameter is `password`, which is mandatory.\n+For security reasons it is highly recommended to set both, username and password.\n+\n+\n+### `fritzbox`\n+\n+All additional parameters for `fritzbox` devices (i.e. except those that are shared with `generic`) are advanced parameters.\n+\n+One or more TAM (telephone answering machines) are supported by most devices.\n+By setting the `tamIndices` parameter you can instruct the binding to add channels for these devices to the thing.\n+Values start with `0`.\n+This is an optional parameter and multiple values are allowed.\n+\n+Most devices allow to configure call deflections.\n+If the `callDeflectionIndices` parameter is set, channels for the status of the pre-configured call deflections are added.\n+Values start with `0`, including the number of \"Call Blocks\" (two configured call-blocks -> first deflection is `2`).\n+This is an optional parameter and multiple values are allowed.\n+\n+Most devices support call lists.\n+The binding can analyze these call lists and provide channels for the number of missed calls, inbound calls, outbound calls and rejected (blocked) calls.\n+The days for which this analysis takes place can be controlled with the `missedCallDays`, `rejectedCallDays`, `inboundCallDays` and `outboundCallDays`\n+This is an optional parameter and multiple values are allowed.\n+\n+Since FritzOS! 7.20 WAN access of local devices can be controlled by their IPs.\n+If the `wanBlockIPs` parameter is set, a channel for each IP is created to block/unblock WAN access for this IP.\n+Values need to be IPv4 addresses in the format `a.b.c.d`.\n+This is an optional parameter and multiple values are allowed.\n+\n+If the `PHONEBOOK` transformation shall be used, it is necessary to retrieve the phonebooks from the FritzBox.", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzMzIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515533236", "bodyText": "With your latest eea changes do you need to do this nullable thing here?", "author": "cpmeister", "createdAt": "2020-10-31T19:57:45Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/SCPDUtil.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.tr064.internal.SCPDException;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDRootType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SCPDUtil} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SCPDUtil {\n+    private final Logger logger = LoggerFactory.getLogger(SCPDUtil.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private SCPDRootType scpdRoot;\n+    private final List<SCPDDeviceType> scpdDevicesList = new ArrayList<>();\n+    private final Map<String, @Nullable SCPDScpdType> serviceMap = new HashMap<>();", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzMzM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515533356", "bodyText": "Not worth logging? At least leave a comment here then.", "author": "cpmeister", "createdAt": "2020-10-31T19:59:15Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.Tr064RootHandler;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    /**\n+     * read the channel config from the resource file (static initialization)\n+     * \n+     * @return a list of all available channel configurations\n+     */\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    /**\n+     * Extract an argument from an SCPD action definition\n+     * \n+     * @param scpdAction the action object\n+     * @param argumentName the argument's name\n+     * @param direction the direction (in or out)\n+     * @return the requested argument object\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDArgumentType getArgument(SCPDActionType scpdAction, String argumentName, SCPDDirection direction)\n+            throws ChannelConfigException {\n+        return scpdAction.getArgumentList().stream()\n+                .filter(argument -> argument.getName().equals(argumentName) && argument.getDirection() == direction)\n+                .findFirst()\n+                .orElseThrow(() -> new ChannelConfigException(\n+                        (direction == SCPDDirection.IN ? \"Set-Argument '\" : \"Get-Argument '\") + argumentName\n+                                + \"' not found\"));\n+    }\n+\n+    /**\n+     * Extract the related state variable from the service root for a given argument\n+     * \n+     * @param serviceRoot the service root object\n+     * @param scpdArgument the argument object\n+     * @return the related state variable object for this argument\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDStateVariableType getStateVariable(SCPDScpdType serviceRoot, SCPDArgumentType scpdArgument)\n+            throws ChannelConfigException {\n+        return serviceRoot.getServiceStateTable().stream()\n+                .filter(stateVariable -> stateVariable.getName().equals(scpdArgument.getRelatedStateVariable()))\n+                .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                        \"StateVariable '\" + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+    }\n+\n+    /**\n+     * Extract an action from the service root\n+     * \n+     * @param serviceRoot the service root object\n+     * @param actionName the action name\n+     * @param actionType \"Get-Action\" or \"Set-Action\" (for exception string only)\n+     * @return the requested action object\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDActionType getAction(SCPDScpdType serviceRoot, String actionName, String actionType)\n+            throws ChannelConfigException {\n+        return serviceRoot.getActionList().stream().filter(action -> actionName.equals(action.getName())).findFirst()\n+                .orElseThrow(() -> new ChannelConfigException(actionType + \" '\" + actionName + \"' not found\"));\n+    }\n+\n+    /**\n+     * check and add available channels on a thing\n+     *\n+     * @param thing the Thing\n+     * @param thingBuilder the ThingBuilder (needs to be passed as editThing is only available in the handler)\n+     * @param scpdUtil the SCPDUtil instance for this thing\n+     * @param deviceId the device id for this thing\n+     * @param deviceType the (SCPD) device-type for this thing\n+     * @param channels a (mutable) channel list for storing all channels\n+     */\n+    public static void checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = Tr064RootHandler.SUPPORTED_THING_TYPES\n+                .contains(thing.getThingTypeUID()) ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                        : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        channels.clear();\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = getAction(serviceRoot, actionName, \"Get-Action\");\n+                            SCPDArgumentType scpdArgument = getArgument(scpdAction, argumentName, SCPDDirection.OUT);\n+                            SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot, scpdArgument);\n+                            parameters.addAll(\n+                                    getAndCheckParameters(channelId, getAction, scpdAction, serviceRoot, thingConfig));\n+\n+                            channelConfig.setGetAction(scpdAction);\n+                            channelConfig.setDataType(relatedStateVariable.getDataType());\n+                        }\n+\n+                        // check set action\n+                        ActionType setAction = channelTypeDescription.getSetAction();\n+                        if (setAction != null) {\n+                            String actionName = setAction.getName();\n+                            String argumentName = setAction.getArgument();\n+\n+                            SCPDActionType scpdAction = getAction(serviceRoot, actionName, \"Set-Action\");\n+                            if (argumentName != null) {\n+                                SCPDArgumentType scpdArgument = getArgument(scpdAction, argumentName, SCPDDirection.IN);\n+                                SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot,\n+                                        scpdArgument);\n+                                if (channelConfig.getDataType().isEmpty()) {\n+                                    channelConfig.setDataType(relatedStateVariable.getDataType());\n+                                } else if (!channelConfig.getDataType().equals(relatedStateVariable.getDataType())) {\n+                                    throw new ChannelConfigException(\"dataType of set and get action are different\");\n+                                }\n+                            }\n+                        }\n+\n+                        // everything is available, create the channel\n+                        ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID,\n+                                channelTypeDescription.getName());\n+                        if (parameters.isEmpty()) {\n+                            // we have no parameters, so create a single channel\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            ChannelBuilder channelBuilder = ChannelBuilder\n+                                    .create(channelUID, channelTypeDescription.getItem().getType())\n+                                    .withType(channelTypeUID);\n+                            thingBuilder.withChannel(channelBuilder.build());\n+                            channels.put(channelUID, channelConfig);\n+                        } else {\n+                            // create a channel for each parameter\n+                            parameters.forEach(parameter -> {\n+                                String normalizedParameter = UIDUtils.encode(parameter);\n+                                ChannelUID channelUID = new ChannelUID(thing.getUID(),\n+                                        channelId + \"_\" + normalizedParameter);\n+                                ChannelBuilder channelBuilder = ChannelBuilder\n+                                        .create(channelUID, channelTypeDescription.getItem().getType())\n+                                        .withType(channelTypeUID)\n+                                        .withLabel(channelTypeDescription.getLabel() + \" \" + parameter);\n+                                thingBuilder.withChannel(channelBuilder.build());\n+                                Tr064ChannelConfig channelConfig1 = new Tr064ChannelConfig(channelConfig);\n+                                channelConfig1.setParameter(parameter);\n+                                channels.put(channelUID, channelConfig1);\n+                            });\n+                        }\n+                    } catch (ChannelConfigException e) {\n+                        LOGGER.debug(\"Channel {} not available: {}\", channelId, e.getMessage());\n+                    }\n+                });\n+    }\n+\n+    private static Set<String> getAndCheckParameters(String channelId, ActionType action, SCPDActionType scpdAction,\n+            SCPDScpdType serviceRoot, Tr064BaseThingConfiguration thingConfig) throws ChannelConfigException {\n+        ParameterType parameter = action.getParameter();\n+        if (parameter == null) {\n+            return Collections.emptySet();\n+        }\n+        try {\n+            Set<String> parameters = new HashSet<>();\n+\n+            // get parameters by reflection from thing config\n+            Field paramField = thingConfig.getClass().getField(parameter.getThingParameter());\n+            Object rawFieldValue = paramField.get(thingConfig);\n+            if ((rawFieldValue instanceof List<?>)) {\n+                ((List<?>) rawFieldValue).forEach(obj -> {\n+                    if (obj instanceof String) {\n+                        parameters.add((String) obj);\n+                    }\n+                });\n+            }\n+\n+            // validate parameter against pattern\n+            String parameterPattern = parameter.getPattern();\n+            if (parameterPattern != null) {\n+                parameters.removeIf(param -> !param.matches(parameterPattern));\n+            }\n+\n+            // validate parameter against SCPD (if not internal only)\n+            if (!parameter.isInternalOnly()) {\n+                SCPDArgumentType scpdArgument = getArgument(scpdAction, parameter.getName(), SCPDDirection.IN);\n+                SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot, scpdArgument);\n+                if (relatedStateVariable.getAllowedValueRange() != null) {\n+                    int paramMin = relatedStateVariable.getAllowedValueRange().getMinimum();\n+                    int paramMax = relatedStateVariable.getAllowedValueRange().getMaximum();\n+                    int paramStep = relatedStateVariable.getAllowedValueRange().getStep();\n+                    Set<String> allowedValues = Stream.iterate(paramMin, i -> i <= paramMax, i -> i + paramStep)\n+                            .map(String::valueOf).collect(Collectors.toSet());\n+                    parameters.retainAll(allowedValues);\n+                }\n+            }\n+\n+            // check we have at least one valid parameter left\n+            if (parameters.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+            return parameters;\n+        } catch (NoSuchFieldException | IllegalAccessException | IllegalArgumentException e) {\n+            throw new ChannelConfigException(\"Could not get required parameter '\" + channelId\n+                    + \"' from thing config (missing, empty or invalid)\");\n+        }\n+    }\n+\n+    public static Optional<String> getSOAPElement(SOAPMessage soapMessage, String elementName) {\n+        try {\n+            NodeList nodeList = soapMessage.getSOAPBody().getElementsByTagName(elementName);\n+            if (nodeList != null && nodeList.getLength() > 0) {\n+                return Optional.of(nodeList.item(0).getTextContent());\n+            }\n+        } catch (SOAPException e) {\n+        }", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67bcc2427ab047189969eb141d451517a64ffcc5", "url": "https://github.com/openhab/openhab-addons/commit/67bcc2427ab047189969eb141d451517a64ffcc5", "message": "address review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T20:08:09Z", "type": "commit"}, {"oid": "f60b025025ccec34c568aa4def3c908d10c0c6eb", "url": "https://github.com/openhab/openhab-addons/commit/f60b025025ccec34c568aa4def3c908d10c0c6eb", "message": "address review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T20:13:06Z", "type": "commit"}, {"oid": "5180bd3c48340eb056f4ad7718d6e31250f3e52c", "url": "https://github.com/openhab/openhab-addons/commit/5180bd3c48340eb056f4ad7718d6e31250f3e52c", "message": "address last review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-11-01T08:08:04Z", "type": "commit"}]}