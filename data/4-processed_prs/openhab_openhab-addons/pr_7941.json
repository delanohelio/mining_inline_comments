{"pr_number": 7941, "pr_title": "[upnpcontrol] UPnP control binding initial contribution", "pr_createdAt": "2020-06-18T21:38:03Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7941", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2NzM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442667364", "bodyText": "Maybe make this a table as is done with most bindings:\n\n\n\nChannel\nDescription\n\n\n\n\nvolume\nplayback volume\n\n\n...", "author": "Hilbrand", "createdAt": "2020-06-19T07:03:18Z", "path": "bundles/org.openhab.binding.upnpcontrol/README.md", "diffHunk": "@@ -0,0 +1,164 @@\n+# UpnpControl Binding\n+\n+This binding acts as a UPnP control point to control UPnP AV media servers and media renderers as defined by the [UPnP Forum](https://openconnectivity.org/developer/specifications/upnp-resources/upnp/).\n+It discovers UPnP media servers and renderers in the local network.\n+UPnP AV media servers generally allow selecting content from a content directory.\n+UPnP AV media renderers take care of playback of the content.\n+\n+You can select a renderer to play the media served from a server.\n+The full content hierarchy of the media on the server can be browsed hierarchically.\n+Searching the media library is also supported using uPnP search syntax.\n+\n+Controls are available to control the playback of the media on the renderer.\n+Each discovered renderer will also be registered as an openHAB audio sink.\n+\n+## Supported Things\n+\n+Two thing types are supported, a server thing, `upnpserver`, and a renderer thing, `upnprenderer`.\n+\n+The binding has been tested with the AV Media Server and AV Media Renderer from Intel Developer Tools for UPnP Technology, available [here](https://www.meshcommander.com/upnptools).\n+A second test set included a [TVersity Media Server](http://tversity.com/).\n+It complies with part of the UPnP AV Media standard, but has not been verified to comply with the full specification.\n+Tests have focused on the playback of audio, but if the server and renderer support it, other media types should play as well.\n+\n+\n+## Discovery\n+\n+UPnP media servers and media renderers in the network will be discovered automatically.\n+\n+\n+## Thing Configuration\n+\n+Both the  `upnprenderer` and `upnpserver` thing require a configuration parameter, `udn` (Universal Device Name).\n+This `udn` uniquely defines the UPnP device.\n+It can be retrieved from the thing ID when using auto discovery.\n+\n+Additionally, a `upnpserver` device has the following optional configuration parameters:\n+\n+* `filter`: when true, only list content that is playable on the renderer, default is `false`.\n+* `sortcriteria`: Sort criteria for the titles in the selection list and when sending for playing to a renderer.\n+The criteria are defined in UPnP sort criteria format, examples: `+dc:title`, `-dc:creator`, `+upnp:album`.\n+Support for sort criteria will depend on the media server.\n+The default is to sort ascending on title, `+dc:title`.\n+\n+The full syntax for manual configuration is:\n+\n+```\n+Thing upnpcontrol:upnpserver:<serverId> [udn=\"<udn of media server>\"]\n+Thing upnpcontrol:upnprenderer:<rendererId> [udn=\"<udn of media renderer>\", filter=<true/false>, sortcriteria=\"<sort criteria string>\"]\n+```\n+\n+## Channels\n+\n+The `upnpserver` has the following channels:\n+\n+* `upnprenderer`: The renderer to send the media content to for playback.\n+The channel allows selecting from all discovered media renderers.\n+This list is dynamically adjusted as media renderers are being added/removed.\n+* `currentid`: Current ID of media container or entry ready for playback.\n+This channel can be used to skip to a specific container or entry in the content directory.\n+This is especially useful in rules.\n+* `browse`: Browse and serve media content.\n+The browsing will start at the top of the content directory tree and allows you to go down and up (represented by ..) in the tree.\n+The list of containers (directories) and media entries for selection in the content hierarchy is updated dynamically when selecting a container or entry.\n+All media in the selection list, playable on the currently selected `upnprenderer` channel, are automatically queued to the renderer as next media for playback.\n+* `search`: Search for media content on the server.\n+Search criteria are defined in UPnP search criteria format.\n+Examples: `dc:title contains \"song\"`, `dc:creator contains \"SpringSteen\"`, `unp:class = \"object.item.audioItem\"`, `upnp:album contains \"Born in\"`.\n+The search starts at the value of the `currentid` channel and searches down from there.\n+When no `currentid` is selected, the search starts at the top.\n+All media in the search result list, playable on the current selected `upnprenderer` channel, are automatically queued to the renderer as next media for playback.\n+\n+The `upnprenderer` has the following channels:\n+\n+* `volume`: playback volume\n+* `mute`: mute playback\n+* `control`: play, pause, next, previous control\n+* `stop`: stop media playback\n+* `title`: media title (read only)\n+* `album`: media album (read only)\n+* `albumart`: image for media album (read only)\n+* `creator`: media creator (read only)\n+* `artist`: media artist (read only)\n+* `publisher`: media publisher (read only)\n+* `genre`: media genre (read only)\n+* `tracknumber`: track number of current track in album (read only)\n+* `trackduration`: track duration of current track in album (read only)\n+* `trackposition`: current position in track during playback or pause of media (read only)", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2ODU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442668568", "bodyText": "I don't think @NonNullByDefault should be used here. It's probably to get rid of the warning related to the Set? I think you should just remove the annotation. Same for method below.", "author": "Hilbrand", "createdAt": "2020-06-19T07:06:25Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpAudioSink.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.audio.AudioHTTPServer;\n+import org.eclipse.smarthome.core.audio.AudioSink;\n+import org.eclipse.smarthome.core.audio.AudioStream;\n+import org.eclipse.smarthome.core.audio.FixedLengthAudioStream;\n+import org.eclipse.smarthome.core.audio.URLAudioStream;\n+import org.eclipse.smarthome.core.audio.UnsupportedAudioFormatException;\n+import org.eclipse.smarthome.core.audio.UnsupportedAudioStreamException;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UpnpAudioSink implements AudioSink {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpAudioSink.class);\n+\n+    private static final Set<Class<? extends AudioStream>> SUPPORTED_STREAMS = Stream\n+            .of(AudioStream.class, FixedLengthAudioStream.class).collect(Collectors.toSet());\n+    private UpnpRendererHandler handler;\n+    private AudioHTTPServer audioHTTPServer;\n+    private String callbackUrl;\n+\n+    public UpnpAudioSink(UpnpRendererHandler handler, AudioHTTPServer audioHTTPServer, String callbackUrl) {\n+        this.handler = handler;\n+        this.audioHTTPServer = audioHTTPServer;\n+        this.callbackUrl = callbackUrl;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return handler.getThing().getUID().toString();\n+    }\n+\n+    @Override\n+    public @Nullable String getLabel(@Nullable Locale locale) {\n+        return handler.getThing().getLabel();\n+    }\n+\n+    @Override\n+    public void process(@Nullable AudioStream audioStream)\n+            throws UnsupportedAudioFormatException, UnsupportedAudioStreamException {\n+        if (audioStream == null) {\n+            stopMedia();\n+            return;\n+        }\n+\n+        String url = null;\n+        if (audioStream instanceof URLAudioStream) {\n+            URLAudioStream urlAudioStream = (URLAudioStream) audioStream;\n+            url = urlAudioStream.getURL();\n+        } else if (!callbackUrl.isEmpty()) {\n+            String relativeUrl = audioStream instanceof FixedLengthAudioStream\n+                    ? audioHTTPServer.serve((FixedLengthAudioStream) audioStream, 20)\n+                    : audioHTTPServer.serve(audioStream);\n+            url = String.valueOf(this.callbackUrl) + relativeUrl;\n+        } else {\n+            logger.warn(\"We do not have any callback url, so {} cannot play the audio stream!\", handler.getUDN());\n+            return;\n+        }\n+        playMedia(url);\n+    }\n+\n+    @Override\n+    @NonNullByDefault(value = {})", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r443051227", "bodyText": "I don't remember anymore, probably done for some reason a while ago. But Eclipse does not give warnings anymore when removing, so removed.", "author": "mherwege", "createdAt": "2020-06-19T21:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2ODU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2OTM3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442669374", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void registerAudioSink(UpnpRendererHandler handler);\n          \n          \n            \n                void registerAudioSink(UpnpRendererHandler handler);", "author": "Hilbrand", "createdAt": "2020-06-19T07:08:34Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpAudioSinkReg.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface UpnpAudioSinkReg {\n+\n+    public void registerAudioSink(UpnpRendererHandler handler);", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2OTY2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442669666", "bodyText": "You also might want to add a bit of javadoc either to the interface or method about what this interface/method does.", "author": "Hilbrand", "createdAt": "2020-06-19T07:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2OTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2OTkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442669915", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.upnpcontrol\")\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.upnpcontrol\")", "author": "Hilbrand", "createdAt": "2020-06-19T07:10:00Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpControlHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioHTTPServer;\n+import org.eclipse.smarthome.core.audio.AudioSink;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpServerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpControlHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.upnpcontrol\")", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MDUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442670511", "bodyText": "Put the annotations inline:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private UpnpIOService upnpIOService;\n          \n          \n            \n                private @NonNullByDefault({}) UpnpIOService upnpIOService;\n          \n      \n    \n    \n  \n\nSame for fields below.", "author": "Hilbrand", "createdAt": "2020-06-19T07:11:31Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpControlHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioHTTPServer;\n+import org.eclipse.smarthome.core.audio.AudioSink;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpServerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpControlHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.upnpcontrol\")\n+@NonNullByDefault\n+public class UpnpControlHandlerFactory extends BaseThingHandlerFactory implements UpnpAudioSinkReg {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    private ConcurrentMap<String, ServiceRegistration<AudioSink>> audioSinkRegistrations = new ConcurrentHashMap<>();\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers = new ConcurrentHashMap<>();\n+    private ConcurrentMap<String, UpnpServerHandler> upnpServers = new ConcurrentHashMap<>();\n+\n+    @NonNullByDefault(value = {})\n+    private UpnpIOService upnpIOService;", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MjY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442672662", "bodyText": "All these services can also be passed via the constructor. Then they can be made final. This is in general preferred in openHAB.\n@Activate\npublic UpnpControlHandlerFactory(final @Reference UpnpIOService upnpIOService, ....", "author": "Hilbrand", "createdAt": "2020-06-19T07:16:41Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpControlHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioHTTPServer;\n+import org.eclipse.smarthome.core.audio.AudioSink;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpServerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpControlHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.upnpcontrol\")\n+@NonNullByDefault\n+public class UpnpControlHandlerFactory extends BaseThingHandlerFactory implements UpnpAudioSinkReg {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    private ConcurrentMap<String, ServiceRegistration<AudioSink>> audioSinkRegistrations = new ConcurrentHashMap<>();\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers = new ConcurrentHashMap<>();\n+    private ConcurrentMap<String, UpnpServerHandler> upnpServers = new ConcurrentHashMap<>();\n+\n+    @NonNullByDefault(value = {})\n+    private UpnpIOService upnpIOService;\n+    @NonNullByDefault(value = {})\n+    private AudioHTTPServer audioHTTPServer;\n+    @NonNullByDefault(value = {})\n+    private NetworkAddressService networkAddressService;\n+    @NonNullByDefault(value = {})\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    @NonNullByDefault(value = {})\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    private String callbackUrl = \"\";\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RENDERER)) {\n+            return addRenderer(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_SERVER)) {\n+            return addServer(thing);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void unregisterHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        String key = thing.getUID().toString();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RENDERER)) {\n+            removeRenderer(key);\n+        } else if (thingTypeUID.equals(THING_TYPE_SERVER)) {\n+            removeServer(key);\n+        }\n+        super.unregisterHandler(thing);\n+    }\n+\n+    private UpnpServerHandler addServer(Thing thing) {\n+        UpnpServerHandler handler = new UpnpServerHandler(thing, upnpIOService, upnpRenderers,\n+                upnpStateDescriptionProvider, upnpCommandDescriptionProvider);\n+        String key = thing.getUID().toString();\n+        upnpServers.put(key, handler);\n+        logger.debug(\"Media server handler created for {}\", thing.getLabel());\n+        return handler;\n+    }\n+\n+    private UpnpRendererHandler addRenderer(Thing thing) {\n+        callbackUrl = createCallbackUrl();\n+        UpnpRendererHandler handler = new UpnpRendererHandler(thing, upnpIOService, this);\n+        String key = thing.getUID().toString();\n+        upnpRenderers.put(key, handler);\n+        upnpServers.forEach((thingId, value) -> value.addRendererOption(key));\n+        logger.debug(\"Media renderer handler created for {}\", thing.getLabel());\n+\n+        return handler;\n+    }\n+\n+    private void removeServer(String key) {\n+        logger.debug(\"Removing media server handler for {}\", upnpServers.get(key).getThing().getLabel());\n+        upnpServers.remove(key);\n+    }\n+\n+    private void removeRenderer(String key) {\n+        logger.debug(\"Removing media renderer handler for {}\", upnpRenderers.get(key).getThing().getLabel());\n+        if (audioSinkRegistrations.containsKey(key)) {\n+            logger.debug(\"Removing audio sink registration for {}\", upnpRenderers.get(key).getThing().getLabel());\n+            ServiceRegistration<AudioSink> reg = audioSinkRegistrations.get(key);\n+            reg.unregister();\n+            audioSinkRegistrations.remove(key);\n+        }\n+        upnpServers.forEach((thingId, value) -> value.removeRendererOption(key));\n+        upnpRenderers.remove(key);\n+    }\n+\n+    @Override\n+    public void registerAudioSink(UpnpRendererHandler handler) {\n+        if (!(callbackUrl.isEmpty())) {\n+            UpnpAudioSink audioSink = new UpnpAudioSink(handler, audioHTTPServer, callbackUrl);\n+            @SuppressWarnings(\"unchecked\")\n+            ServiceRegistration<AudioSink> reg = (ServiceRegistration<AudioSink>) bundleContext\n+                    .registerService(AudioSink.class.getName(), audioSink, new Hashtable<String, Object>());\n+            Thing thing = handler.getThing();\n+            audioSinkRegistrations.put(thing.getUID().toString(), reg);\n+            logger.debug(\"Audio sink added for media renderer {}\", thing.getLabel());\n+        }\n+    }\n+\n+    private String createCallbackUrl() {\n+        if (!callbackUrl.isEmpty()) {\n+            return callbackUrl;\n+        }\n+        NetworkAddressService nwaService = networkAddressService;\n+        String ipAddress = nwaService.getPrimaryIpv4HostAddress();\n+        if (ipAddress == null) {\n+            logger.warn(\"No network interface could be found.\");\n+            return \"\";\n+        }\n+        int port = HttpServiceUtil.getHttpServicePort(bundleContext);\n+        if (port == -1) {\n+            logger.warn(\"Cannot find port of the http service.\");\n+            return \"\";\n+        }\n+        return \"http://\" + ipAddress + \":\" + port;\n+    }\n+\n+    @Reference\n+    protected void setUpnpIOService(UpnpIOService upnpIOService) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442674473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(getClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "author": "Hilbrand", "createdAt": "2020-06-19T07:20:48Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpDynamicCommandDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.type.DynamicCommandDescriptionProvider;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { DynamicCommandDescriptionProvider.class, UpnpDynamicCommandDescriptionProvider.class })\n+@NonNullByDefault\n+public class UpnpDynamicCommandDescriptionProvider implements DynamicCommandDescriptionProvider {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442674564", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<ChannelUID, @Nullable CommandDescription> descriptions = new ConcurrentHashMap<>();\n          \n          \n            \n                private final Map<ChannelUID, @Nullable CommandDescription> descriptions = new ConcurrentHashMap<>();", "author": "Hilbrand", "createdAt": "2020-06-19T07:21:01Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpDynamicCommandDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.type.DynamicCommandDescriptionProvider;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { DynamicCommandDescriptionProvider.class, UpnpDynamicCommandDescriptionProvider.class })\n+@NonNullByDefault\n+public class UpnpDynamicCommandDescriptionProvider implements DynamicCommandDescriptionProvider {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    private Map<ChannelUID, @Nullable CommandDescription> descriptions = new ConcurrentHashMap<>();", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442674827", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(getClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "author": "Hilbrand", "createdAt": "2020-06-19T07:21:37Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.type.DynamicStateDescriptionProvider;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, UpnpDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class UpnpDynamicStateDescriptionProvider implements DynamicStateDescriptionProvider {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY4MTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442681485", "bodyText": "With streams:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<String> protocolList = new ArrayList<>();\n          \n          \n            \n                    for (UpnpEntryRes entryRes : resList) {\n          \n          \n            \n                        protocolList.add(entryRes.getProtocolInfo());\n          \n          \n            \n                    }\n          \n          \n            \n                    return protocolList;\n          \n          \n            \n                    return resList.stream().map(UpnpEntryRes::getProtocolInfo).collect(Collectors.toList());", "author": "Hilbrand", "createdAt": "2020-06-19T07:36:18Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpEntry.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpEntry {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+\n+    private String id;\n+    private String refId;\n+    private String parentId;\n+    private String upnpClass;\n+    private String title = \"\";\n+    private List<UpnpEntryRes> resList = new ArrayList<>();\n+    private String album = \"\";\n+    private String albumArtUri = \"\";\n+    private String creator = \"\";\n+    private String artist = \"\";\n+    private String publisher = \"\";\n+    private String genre = \"\";\n+    private @Nullable Integer originalTrackNumber;\n+\n+    public UpnpEntry(String id, String refId, String parentId, String upnpClass) {\n+        this.id = id;\n+        this.refId = refId;\n+        this.parentId = parentId;\n+        this.upnpClass = upnpClass;\n+    }\n+\n+    public UpnpEntry withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbum(String album) {\n+        this.album = album;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbumArtUri(String albumArtUri) {\n+        this.albumArtUri = albumArtUri;\n+        return this;\n+    }\n+\n+    public UpnpEntry withCreator(String creator) {\n+        this.creator = creator;\n+        return this;\n+    }\n+\n+    public UpnpEntry withArtist(String artist) {\n+        this.artist = artist;\n+        return this;\n+    }\n+\n+    public UpnpEntry withPublisher(String publisher) {\n+        this.publisher = publisher;\n+        return this;\n+    }\n+\n+    public UpnpEntry withGenre(String genre) {\n+        this.genre = genre;\n+        return this;\n+    }\n+\n+    public UpnpEntry withResList(List<UpnpEntryRes> resList) {\n+        this.resList = resList;\n+        return this;\n+    }\n+\n+    public UpnpEntry withTrackNumber(@Nullable Integer originalTrackNumber) {\n+        this.originalTrackNumber = originalTrackNumber;\n+        return this;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    @Override\n+    public String toString() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the unique identifier of this entry.\n+     */\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the identifier of the entry this reference intry refers to.\n+     */\n+    public String getRefId() {\n+        return refId;\n+    }\n+\n+    /**\n+     * @return the unique identifier of the parent of this entry.\n+     */\n+    public String getParentId() {\n+        return parentId.isEmpty() ? DIRECTORY_ROOT : parentId;\n+    }\n+\n+    /**\n+     * @return a URI for this entry. Thumbnail resources are not considered.\n+     */\n+    public String getRes() {\n+        UpnpEntryRes resource;\n+        try {\n+            resource = resList.stream().filter(res -> !res.isThumbnailRes()).findFirst().get();\n+        } catch (NoSuchElementException e) {\n+            return \"\";\n+        }\n+        return resource.getRes();\n+    }\n+\n+    public List<String> getProtocolList() {\n+        List<String> protocolList = new ArrayList<>();\n+        for (UpnpEntryRes entryRes : resList) {\n+            protocolList.add(entryRes.getProtocolInfo());\n+        }\n+        return protocolList;", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY4MTkxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442681917", "bodyText": "The pattern can be a final field as it doesn't change.", "author": "Hilbrand", "createdAt": "2020-06-19T07:37:12Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpEntry.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpEntry {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+\n+    private String id;\n+    private String refId;\n+    private String parentId;\n+    private String upnpClass;\n+    private String title = \"\";\n+    private List<UpnpEntryRes> resList = new ArrayList<>();\n+    private String album = \"\";\n+    private String albumArtUri = \"\";\n+    private String creator = \"\";\n+    private String artist = \"\";\n+    private String publisher = \"\";\n+    private String genre = \"\";\n+    private @Nullable Integer originalTrackNumber;\n+\n+    public UpnpEntry(String id, String refId, String parentId, String upnpClass) {\n+        this.id = id;\n+        this.refId = refId;\n+        this.parentId = parentId;\n+        this.upnpClass = upnpClass;\n+    }\n+\n+    public UpnpEntry withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbum(String album) {\n+        this.album = album;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbumArtUri(String albumArtUri) {\n+        this.albumArtUri = albumArtUri;\n+        return this;\n+    }\n+\n+    public UpnpEntry withCreator(String creator) {\n+        this.creator = creator;\n+        return this;\n+    }\n+\n+    public UpnpEntry withArtist(String artist) {\n+        this.artist = artist;\n+        return this;\n+    }\n+\n+    public UpnpEntry withPublisher(String publisher) {\n+        this.publisher = publisher;\n+        return this;\n+    }\n+\n+    public UpnpEntry withGenre(String genre) {\n+        this.genre = genre;\n+        return this;\n+    }\n+\n+    public UpnpEntry withResList(List<UpnpEntryRes> resList) {\n+        this.resList = resList;\n+        return this;\n+    }\n+\n+    public UpnpEntry withTrackNumber(@Nullable Integer originalTrackNumber) {\n+        this.originalTrackNumber = originalTrackNumber;\n+        return this;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    @Override\n+    public String toString() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the unique identifier of this entry.\n+     */\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the identifier of the entry this reference intry refers to.\n+     */\n+    public String getRefId() {\n+        return refId;\n+    }\n+\n+    /**\n+     * @return the unique identifier of the parent of this entry.\n+     */\n+    public String getParentId() {\n+        return parentId.isEmpty() ? DIRECTORY_ROOT : parentId;\n+    }\n+\n+    /**\n+     * @return a URI for this entry. Thumbnail resources are not considered.\n+     */\n+    public String getRes() {\n+        UpnpEntryRes resource;\n+        try {\n+            resource = resList.stream().filter(res -> !res.isThumbnailRes()).findFirst().get();\n+        } catch (NoSuchElementException e) {\n+            return \"\";\n+        }\n+        return resource.getRes();\n+    }\n+\n+    public List<String> getProtocolList() {\n+        List<String> protocolList = new ArrayList<>();\n+        for (UpnpEntryRes entryRes : resList) {\n+            protocolList.add(entryRes.getProtocolInfo());\n+        }\n+        return protocolList;\n+    }\n+\n+    /**\n+     * @return the UPnP classname for this entry.\n+     */\n+    public String getUpnpClass() {\n+        return upnpClass;\n+    }\n+\n+    public boolean isContainer() {\n+        Pattern pattern = Pattern.compile(\"object.container\");", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5MjE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442692196", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new HashMap<String, String>();\n          \n          \n            \n                        return Collections.emptyMap();", "author": "Hilbrand", "createdAt": "2020-06-19T07:58:28Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpXMLParser.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpXMLParser {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpnpXMLParser.class);\n+\n+    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n+            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n+                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n+                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n+                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n+                    + \"<upnp:class>{3}</upnp:class>\" + \"<upnp:album>{4}</upnp:album>\"\n+                    + \"<upnp:albumArtURI>{5}</upnp:albumArtURI>\" + \"<dc:creator>{6}</dc:creator>\"\n+                    + \"<upnp:artist>{7}</upnp:artist>\" + \"<dc:publisher>{8}</dc:publisher>\"\n+                    + \"<upnp:genre>{9}</upnp:genre>\" + \"<upnp:originalTrackNumber>{10}</upnp:originalTrackNumber>\"\n+                    + \"</item></DIDL-Lite>\");\n+\n+    private enum Element {\n+        TITLE,\n+        CLASS,\n+        ALBUM,\n+        ALBUM_ART_URI,\n+        CREATOR,\n+        ARTIST,\n+        PUBLISHER,\n+        GENRE,\n+        TRACK_NUMBER,\n+        RES\n+    }\n+\n+    public static Map<String, String> getAVTransportFromXML(String xml) {\n+        if (xml.isEmpty()) {\n+            LOGGER.debug(\"Could not parse AV Transport from empty xml\");\n+            return new HashMap<String, String>();", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442701786", "bodyText": "These if statements can be a switch.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if ((\"container\".equals(qName) || \"item\".equals(qName))) {\n          \n          \n            \n                        switch (qName) {\n          \n          \n            \n                        case \"container\":\n          \n          \n            \n                        case \"item\":\n          \n          \n            \n                        ...", "author": "Hilbrand", "createdAt": "2020-06-19T08:18:04Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpXMLParser.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpXMLParser {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpnpXMLParser.class);\n+\n+    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n+            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n+                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n+                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n+                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n+                    + \"<upnp:class>{3}</upnp:class>\" + \"<upnp:album>{4}</upnp:album>\"\n+                    + \"<upnp:albumArtURI>{5}</upnp:albumArtURI>\" + \"<dc:creator>{6}</dc:creator>\"\n+                    + \"<upnp:artist>{7}</upnp:artist>\" + \"<dc:publisher>{8}</dc:publisher>\"\n+                    + \"<upnp:genre>{9}</upnp:genre>\" + \"<upnp:originalTrackNumber>{10}</upnp:originalTrackNumber>\"\n+                    + \"</item></DIDL-Lite>\");\n+\n+    private enum Element {\n+        TITLE,\n+        CLASS,\n+        ALBUM,\n+        ALBUM_ART_URI,\n+        CREATOR,\n+        ARTIST,\n+        PUBLISHER,\n+        GENRE,\n+        TRACK_NUMBER,\n+        RES\n+    }\n+\n+    public static Map<String, String> getAVTransportFromXML(String xml) {\n+        if (xml.isEmpty()) {\n+            LOGGER.debug(\"Could not parse AV Transport from empty xml\");\n+            return new HashMap<String, String>();\n+        }\n+        AVTransportEventHandler handler = new AVTransportEventHandler();\n+        try {\n+            SAXParserFactory factory = SAXParserFactory.newInstance();\n+            SAXParser saxParser = factory.newSAXParser();\n+            saxParser.parse(new InputSource(new StringReader(xml)), handler);\n+        } catch (IOException e) {\n+            // This should never happen - we're not performing I/O!\n+            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml, e);\n+        } catch (SAXException | ParserConfigurationException s) {\n+            LOGGER.debug(\"Could not parse AV Transport from string '{}'\", xml, s);\n+        }\n+        return handler.getChanges();\n+    }\n+\n+    /**\n+     * @param xml\n+     * @return a list of Entries from the given xml string.\n+     * @throws IOException\n+     * @throws SAXException\n+     */\n+    public static List<UpnpEntry> getEntriesFromXML(String xml) {\n+        if (xml.isEmpty()) {\n+            LOGGER.debug(\"Could not parse Entries from empty xml\");\n+            return new ArrayList<UpnpEntry>();\n+        }\n+        EntryHandler handler = new EntryHandler();\n+        try {\n+            SAXParserFactory factory = SAXParserFactory.newInstance();\n+            SAXParser saxParser = factory.newSAXParser();\n+            saxParser.parse(new InputSource(new StringReader(xml)), handler);\n+        } catch (IOException e) {\n+            // This should never happen - we're not performing I/O!\n+            LOGGER.error(\"Could not parse Entries from string '{}'\", xml, e);\n+        } catch (SAXException | ParserConfigurationException s) {\n+            LOGGER.debug(\"Could not parse Entries from string '{}'\", xml, s);\n+        }\n+        return handler.getEntries();\n+    }\n+\n+    @NonNullByDefault\n+    private static class AVTransportEventHandler extends DefaultHandler {\n+\n+        private final Map<String, String> changes = new HashMap<String, String>();\n+\n+        AVTransportEventHandler() {\n+            // shouldn't be used outside of this package.\n+        }\n+\n+        @Override\n+        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n+                @Nullable Attributes atts) throws SAXException {\n+            /*\n+             * The events are all of the form <qName val=\"value\"/> so we can get all\n+             * the info we need from here.\n+             */\n+            if ((qName != null) && (atts != null) && (atts.getValue(\"val\") != null)) {\n+                changes.put(qName, atts.getValue(\"val\"));\n+            }\n+        }\n+\n+        public Map<String, String> getChanges() {\n+            return changes;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    private static class EntryHandler extends DefaultHandler {\n+\n+        // Maintain a set of elements it is not useful to complain about.\n+        // This list will be initialized on the first failure case.\n+        private static List<String> ignore = new ArrayList<String>();\n+\n+        private String id = \"\";\n+        private String refId = \"\";\n+        private String parentId = \"\";\n+        private StringBuilder upnpClass = new StringBuilder();\n+        private List<UpnpEntryRes> resList = new ArrayList<>();\n+        private StringBuilder res = new StringBuilder();\n+        private StringBuilder title = new StringBuilder();\n+        private StringBuilder album = new StringBuilder();\n+        private StringBuilder albumArtUri = new StringBuilder();\n+        private StringBuilder creator = new StringBuilder();\n+        private StringBuilder artist = new StringBuilder();\n+        private List<String> artistList = new ArrayList<>();\n+        private StringBuilder publisher = new StringBuilder();\n+        private StringBuilder genre = new StringBuilder();\n+        private StringBuilder trackNumber = new StringBuilder();\n+        private @Nullable Element element = null;\n+\n+        private List<UpnpEntry> entries = new ArrayList<>();\n+\n+        EntryHandler() {\n+            // shouldn't be used outside of this package.\n+        }\n+\n+        @Override\n+        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n+                @Nullable Attributes attributes) throws SAXException {\n+            if ((\"container\".equals(qName) || \"item\".equals(qName))) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjI3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442702274", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { UpnpDiscoveryParticipant.class }, immediate = true)\n          \n          \n            \n            @Component(service = { UpnpDiscoveryParticipant.class })", "author": "Hilbrand", "createdAt": "2020-06-19T08:19:03Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/discovery/UpnpControlDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.discovery;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { UpnpDiscoveryParticipant.class }, immediate = true)", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjM0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442702342", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(getClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "author": "Hilbrand", "createdAt": "2020-06-19T08:19:14Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/discovery/UpnpControlDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.discovery;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { UpnpDiscoveryParticipant.class }, immediate = true)\n+@NonNullByDefault\n+public class UpnpControlDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442702581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new Object[] { deviceType, manufacturer, model, serialNumber });\n          \n          \n            \n                            deviceType, manufacturer, model, serialNumber);", "author": "Hilbrand", "createdAt": "2020-06-19T08:19:43Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/discovery/UpnpControlDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.discovery;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@Component(service = { UpnpDiscoveryParticipant.class }, immediate = true)\n+@NonNullByDefault\n+public class UpnpControlDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(RemoteDevice device) {\n+        DiscoveryResult result = null;\n+        ThingUID thingUid = getThingUID(device);\n+        if (thingUid != null) {\n+            String label = device.getDetails().getFriendlyName().isEmpty() ? device.getDisplayString()\n+                    : device.getDetails().getFriendlyName();\n+            Map<String, Object> properties = new HashMap<>();\n+            properties.put(\"ipAddress\", device.getIdentity().getDescriptorURL().getHost());\n+            properties.put(\"udn\", device.getIdentity().getUdn().getIdentifierString());\n+            result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withProperties(properties)\n+                    .withRepresentationProperty(\"udn\").build();\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(RemoteDevice device) {\n+        ThingUID result = null;\n+        String deviceType = device.getType().getType();\n+        String manufacturer = device.getDetails().getManufacturerDetails().getManufacturer();\n+        String model = device.getDetails().getModelDetails().getModelName();\n+        String serialNumber = device.getDetails().getSerialNumber();\n+\n+        logger.debug(\"Device type {}, manufacturer {}, model {}, SN# {}\",\n+                new Object[] { deviceType, manufacturer, model, serialNumber });", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNDE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442704146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Filter content</label>\n          \n          \n            \n            \t\t\t\t<label>Filter Content</label>", "author": "Hilbrand", "createdAt": "2020-06-19T08:22:49Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,174 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter content</label>", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNDIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442704234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Sort criteria</label>\n          \n          \n            \n            \t\t\t\t<label>Sort Criteria</label>", "author": "Hilbrand", "createdAt": "2020-06-19T08:23:01Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,174 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter content</label>\n+\t\t\t\t<description>Only list content which is playable on the selected renderer</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>false</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sortcriteria\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Sort criteria</label>", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442704403", "bodyText": "This seems to be strangely formatted.", "author": "Hilbrand", "createdAt": "2020-06-19T08:23:20Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,174 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter content</label>\n+\t\t\t\t<description>Only list content which is playable on the selected renderer</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>false</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sortcriteria\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Sort criteria</label>\n+\t\t\t\t<description>Sort criteria for the titles in the selection list and when sending for playing to a renderer.\n+\t\t\t\t\tThe", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNDg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442704878", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Current media id</label>\n          \n          \n            \n            \t\t<label>Current Media Id</label>", "author": "Hilbrand", "createdAt": "2020-06-19T08:24:20Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,174 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter content</label>\n+\t\t\t\t<description>Only list content which is playable on the selected renderer</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>false</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sortcriteria\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Sort criteria</label>\n+\t\t\t\t<description>Sort criteria for the titles in the selection list and when sending for playing to a renderer.\n+\t\t\t\t\tThe\n+\t\t\t\t\tcriteria are defined in UPnP sort criteria format. Examples: +dc:title, -dc:creator, +upnp:album.\n+\t\t\t\t\tSupported sort\n+\t\t\t\t\tcriteria will depend on the media server</description>\n+\t\t\t\t<default>+dc:title</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel Types -->\n+\t<channel-type id=\"volume\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Volume</label>\n+\t\t<description>Set or get the master volume</description>\n+\t\t<category>SoundVolume</category>\n+\t</channel-type>\n+\t<channel-type id=\"mute\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Mute</label>\n+\t\t<description>Set or get the mute state</description>\n+\t</channel-type>\n+\t<channel-type id=\"control\">\n+\t\t<item-type>Player</item-type>\n+\t\t<label>Control</label>\n+\t\t<description>Control the player, e.g. start/stop/next/previous/ffward/rewind</description>\n+\t\t<category>Player</category>\n+\t</channel-type>\n+\t<channel-type id=\"stop\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Stop</label>\n+\t\t<description>Stop the player</description>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\t<channel-type id=\"title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title</label>\n+\t\t<description>Now playing title</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"album\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Album</label>\n+\t\t<description>Now playing album</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"albumart\">\n+\t\t<item-type>Image</item-type>\n+\t\t<label>Album Art</label>\n+\t\t<description>Now playing album art</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"creator\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Creator</label>\n+\t\t<description>Now playing creator</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"artist\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Artist</label>\n+\t\t<description>Now playing artist</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"publisher\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Publisher</label>\n+\t\t<description>Now playing publisher</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"genre\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Genre</label>\n+\t\t<description>Now playing genre</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"tracknumber\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Track Number</label>\n+\t\t<description>Now playing track number</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"trackduration\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Track Duration</label>\n+\t\t<description>Now playing track duration</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"trackposition\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Track Position</label>\n+\t\t<description>Now playing track position</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"upnprenderer\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Renderer</label>\n+\t\t<description>Select AV renderer</description>\n+\t</channel-type>\n+\t<channel-type id=\"currentid\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Current media id</label>", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNTI4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442705288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ChannelUID rendererChannelUID;\n          \n          \n            \n                private @NonNullByDefault({}) ChannelUID rendererChannelUID;", "author": "Hilbrand", "createdAt": "2020-06-19T08:25:09Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,457 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    @NonNullByDefault({})\n+    private ChannelUID rendererChannelUID;", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442720148", "bodyText": "static fields should be above other fields.", "author": "Hilbrand", "createdAt": "2020-06-19T09:02:17Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,457 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    @NonNullByDefault({})\n+    private ChannelUID rendererChannelUID;\n+    @NonNullByDefault({})\n+    private ChannelUID currentTitleChannelUID;\n+\n+    private static final String DIRECTORY_ROOT = \"0\";", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczODg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442738858", "bodyText": "You can put the id's and refId in a set, which is faster. With a list it needs to iterate over all elements. Create the set before the forEach:\nfinal Set<String> idSet = list.stream().map(UpnpEntry::getId).collect(Collectors.toSet());\n\nAnd then do !idSet.contains(refId) here.\nThe refIdList can used as is, only be replaced by a Set.", "author": "Hilbrand", "createdAt": "2020-06-19T09:41:01Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,457 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    @NonNullByDefault({})\n+    private ChannelUID rendererChannelUID;\n+    @NonNullByDefault({})\n+    private ChannelUID currentTitleChannelUID;\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile Map<String, UpnpEntry> entryMap = new HashMap<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    public UpnpServerHandler(Thing thing, UpnpIOService upnpIOService,\n+            ConcurrentMap<String, UpnpRendererHandler> upnpRenderers,\n+            UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider,\n+            UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider) {\n+        super(thing, upnpIOService);\n+        this.upnpRenderers = upnpRenderers;\n+        this.upnpStateDescriptionProvider = upnpStateDescriptionProvider;\n+        this.upnpCommandDescriptionProvider = upnpCommandDescriptionProvider;\n+\n+        // put root as highest level in parent map\n+        parentMap.put(currentEntry.getId(), currentEntry);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media server device {}\", thing.getLabel());\n+\n+        rendererChannelUID = thing.getChannel(UPNPRENDERER).getUID();\n+        currentTitleChannelUID = thing.getChannel(BROWSE).getUID();\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initServer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    private void initServer() {\n+        rendererStateOptionList = new ArrayList<>();\n+        upnpRenderers.forEach((key, value) -> {\n+            StateOption stateOption = new StateOption(key, value.getThing().getLabel());\n+            rendererStateOptionList.add(stateOption);\n+        });\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+\n+        getProtocolInfo();\n+\n+        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on server {}\", command, channelUID, thing.getLabel());\n+\n+        switch (channelUID.getId()) {\n+            case UPNPRENDERER:\n+                if (command instanceof StringType) {\n+                    currentRendererHandler = (upnpRenderers.get(((StringType) command).toString()));\n+                    if (Boolean.parseBoolean(getConfig().get(CONFIG_FILTER).toString())) {\n+                        // only refresh title list if filtering by renderer capabilities\n+                        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\",\n+                                getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                } else if ((command instanceof RefreshType) && (currentRendererHandler != null)) {\n+                    updateState(channelUID, StringType.valueOf(currentRendererHandler.getThing().getLabel()));\n+                }\n+                break;\n+            case CURRENTID:\n+                String currentId = \"\";\n+                if (command instanceof StringType) {\n+                    currentId = String.valueOf(command);\n+                } else if (command instanceof RefreshType) {\n+                    currentId = currentEntry.getId();\n+                    updateState(channelUID, StringType.valueOf(currentId));\n+                }\n+                logger.debug(\"Setting currentId to {}\", currentId);\n+                if (!currentId.isEmpty()) {\n+                    browse(currentId, \"BrowseDirectChildren\", \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+                }\n+            case BROWSE:\n+                if (command instanceof StringType) {\n+                    String browseTarget = command.toString();\n+                    if (browseTarget != null) {\n+                        if (UP.equals(browseTarget)) {\n+                            // Move up in tree\n+                            browseTarget = currentEntry.getParentId();\n+                            if (browseTarget.isEmpty()) {\n+                                // No parent found, so make it the root directory\n+                                browseTarget = DIRECTORY_ROOT;\n+                            }\n+                            currentEntry = parentMap.get(browseTarget);\n+                        } else {\n+                            currentEntry = entryMap.get(browseTarget);\n+                        }\n+                        updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(currentEntry.getId()));\n+                        logger.debug(\"Browse target {}\", browseTarget);\n+                        browse(browseTarget, \"BrowseDirectChildren\", \"*\", \"0\", \"0\",\n+                                getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                }\n+                break;\n+            case SEARCH:\n+                if (command instanceof StringType) {\n+                    String criteria = command.toString();\n+                    if (criteria != null) {\n+                        String searchContainer = \"\";\n+                        if (currentEntry.isContainer()) {\n+                            searchContainer = currentEntry.getId();\n+                        } else {\n+                            searchContainer = currentEntry.getParentId();\n+                        }\n+                        if (searchContainer.isEmpty()) {\n+                            // No parent found, so make it the root directory\n+                            searchContainer = DIRECTORY_ROOT;\n+                        }\n+                        updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(currentEntry.getId()));\n+                        logger.debug(\"Search container {} for {}\", searchContainer, criteria);\n+                        search(searchContainer, criteria, \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Add a renderer to the renderer channel state option list.\n+     * This method is called from the {@link UpnpControlHandlerFactory} class when creating a renderer handler.\n+     *\n+     * @param key\n+     */\n+    public void addRendererOption(String key) {\n+        rendererStateOptionList.add(new StateOption(key, upnpRenderers.get(key).getThing().getLabel()));\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+        logger.debug(\"Renderer option {} added to {}\", key, thing.getLabel());\n+    }\n+\n+    /**\n+     * Remove a renderer from the renderer channel state option list.\n+     * This method is called from the {@link UpnpControlHandlerFactory} class when removing a renderer handler.\n+     *\n+     * @param key\n+     */\n+    public void removeRendererOption(String key) {\n+        UpnpRendererHandler handler = currentRendererHandler;\n+        if ((handler != null) && (handler.getThing().getUID().toString().equals(key))) {\n+            currentRendererHandler = null;\n+            updateState(rendererChannelUID, UnDefType.UNDEF);\n+        }\n+        rendererStateOptionList.removeIf(stateOption -> (stateOption.getValue().equals(key)));\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+        logger.debug(\"Renderer option {} removed from {}\", key, thing.getLabel());\n+    }\n+\n+    private void updateTitleSelection(List<UpnpEntry> titleList) {\n+        logger.debug(\"Navigating to node {} on server {}\", currentEntry.getId(), thing.getLabel());\n+\n+        // Optionally, filter only items that can be played on the renderer\n+        String filter = getConfig().get(CONFIG_FILTER).toString();\n+        logger.debug(\"Filtering content on server {}: {}\", thing.getLabel(), filter);\n+        List<UpnpEntry> resultList = Boolean.parseBoolean(filter) ? filterEntries(titleList, true) : titleList;\n+\n+        List<CommandOption> commandOptionList = new ArrayList<>();\n+        // Add a directory up selector if not in the directory root\n+        if ((!resultList.isEmpty() && !(DIRECTORY_ROOT.equals(resultList.get(0).getParentId())))\n+                || (resultList.isEmpty() && !DIRECTORY_ROOT.equals(currentEntry.getId()))) {\n+            CommandOption commandOption = new CommandOption(UP, UP);\n+            commandOptionList.add(commandOption);\n+            logger.debug(\"UP added to selection list on server {}\", thing.getLabel());\n+        }\n+\n+        entryMap.clear(); // always only keep the current selection in the entry map to keep memory usage down\n+        resultList.forEach((value) -> {\n+            CommandOption commandOption = new CommandOption(value.getId(), value.getTitle());\n+            commandOptionList.add(commandOption);\n+            logger.trace(\"{} added to selection list on server {}\", value.getId(), thing.getLabel());\n+\n+            // Keep the entries in a map so we can find the parent and container for the current selection to go back up\n+            if (value.isContainer()) {\n+                parentMap.put(value.getId(), value);\n+            }\n+            entryMap.put(value.getId(), value);\n+        });\n+\n+        // Set the currentId to the parent of the first entry in the list\n+        if (!resultList.isEmpty()) {\n+            updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(resultList.get(0).getId()));\n+        }\n+\n+        logger.debug(\"{} entries added to selection list on server {}\", commandOptionList.size(), thing.getLabel());\n+        updateCommandDescription(currentTitleChannelUID, commandOptionList);\n+\n+        serveMedia();\n+    }\n+\n+    /**\n+     * Filter a list of media and only keep the media that are playable on the currently selected renderer.\n+     *\n+     * @param resultList\n+     * @param includeContainers\n+     * @return\n+     */\n+    private List<UpnpEntry> filterEntries(List<UpnpEntry> resultList, boolean includeContainers) {\n+        logger.debug(\"Raw result list {}\", resultList);\n+        List<UpnpEntry> list = new ArrayList<>();\n+        if (currentRendererHandler != null) {\n+            List<String> sink = currentRendererHandler.getSink();\n+            list = resultList.stream()\n+                    .filter(entry -> (includeContainers && entry.isContainer())\n+                            || UpnpProtocolMatcher.testProtocolList(entry.getProtocolList(), sink))\n+                    .collect(Collectors.toList());\n+        }\n+        logger.debug(\"Filtered result list {}\", list);\n+        return list;\n+    }\n+\n+    private void updateStateDescription(ChannelUID channelUID, List<StateOption> stateOptionList) {\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withReadOnly(false)\n+                .withOptions(stateOptionList).build().toStateDescription();\n+        upnpStateDescriptionProvider.setDescription(channelUID, stateDescription);\n+    }\n+\n+    private void updateCommandDescription(ChannelUID channelUID, List<CommandOption> commandOptionList) {\n+        CommandDescription commandDescription = CommandDescriptionBuilder.create().withCommandOptions(commandOptionList)\n+                .build();\n+        upnpCommandDescriptionProvider.setDescription(channelUID, commandDescription);\n+    }\n+\n+    /**\n+     * Method that does a UPnP browse on a content directory. Results will be retrieved in the {@link onValueReceived}\n+     * method.\n+     *\n+     * @param objectID content directory object\n+     * @param browseFlag BrowseMetaData or BrowseDirectChildren\n+     * @param filter properties to be returned\n+     * @param startingIndex starting index of objects to return\n+     * @param requestedCount number of objects to return, 0 for all\n+     * @param sortCriteria sort criteria, example: +dc:title\n+     */\n+    public void browse(String objectID, String browseFlag, String filter, String startingIndex, String requestedCount,\n+            String sortCriteria) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"ObjectID\", objectID);\n+        inputs.put(\"BrowseFlag\", browseFlag);\n+        inputs.put(\"Filter\", filter);\n+        inputs.put(\"StartingIndex\", startingIndex);\n+        inputs.put(\"RequestedCount\", requestedCount);\n+        inputs.put(\"SortCriteria\", sortCriteria);\n+\n+        invokeAction(\"ContentDirectory\", \"Browse\", inputs);\n+    }\n+\n+    /**\n+     * Method that does a UPnP search on a content directory. Results will be retrieved in the {@link onValueReceived}\n+     * method.\n+     *\n+     * @param containerID content directory container\n+     * @param searchCriteria search criteria, examples:\n+     *            dc:title contains \"song\"\n+     *            dc:creator contains \"Springsteen\"\n+     *            upnp:class = \"object.item.audioItem\"\n+     *            upnp:album contains \"Born in\"\n+     * @param filter properties to be returned\n+     * @param startingIndex starting index of objects to return\n+     * @param requestedCount number of objects to return, 0 for all\n+     * @param sortCriteria sort criteria, example: +dc:title\n+     */\n+    public void search(String containerID, String searchCriteria, String filter, String startingIndex,\n+            String requestedCount, String sortCriteria) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"ContainerID\", containerID);\n+        inputs.put(\"SearchCriteria\", searchCriteria);\n+        inputs.put(\"Filter\", filter);\n+        inputs.put(\"StartingIndex\", startingIndex);\n+        inputs.put(\"RequestedCount\", requestedCount);\n+        inputs.put(\"SortCriteria\", sortCriteria);\n+\n+        invokeAction(\"ContentDirectory\", \"Search\", inputs);\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Server status changed to {}\", status);\n+        if (status) {\n+            initServer();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(), variable,\n+                value, service);\n+        if (variable == null) {\n+            return;\n+        }\n+        switch (variable) {\n+            case \"Result\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateTitleSelection(removeDuplicates(UpnpXMLParser.getEntriesFromXML(value)));\n+                } else {\n+                    updateTitleSelection(new ArrayList<UpnpEntry>());\n+                }\n+                break;\n+            case \"NumberReturned\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    numberReturned = Integer.parseInt(value);\n+                }\n+                break;\n+            case \"TotalMatches\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    totalMatches = Integer.parseInt(value);\n+                }\n+                break;\n+            case \"UpdateID\":\n+                break;\n+            case \"Source\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    source.clear();\n+                    source.addAll(Arrays.asList(value.split(\",\")));\n+                }\n+                break;\n+            default:\n+                super.onValueReceived(variable, value, service);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Remove double entries by checking the refId if it exists as Id in the list and only keeping the original entry if\n+     * available. If the original entry is not in the list, only keep one referring entry.\n+     *\n+     * @param list\n+     * @return filtered list\n+     */\n+    private List<UpnpEntry> removeDuplicates(List<UpnpEntry> list) {\n+        List<UpnpEntry> newList = new ArrayList<>();\n+        List<String> refIdList = new ArrayList<>();\n+        list.forEach(entry -> {\n+            String refId = entry.getRefId();\n+            if (refId.isEmpty()\n+                    || (list.stream().noneMatch(any -> (refId.equals(any.getId()))) && !refIdList.contains(refId))) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0MTExOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442741119", "bodyText": "You can use a singleton, also safes on space as initial hashmap size is bigger than 1 entry.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n          \n          \n            \n                    Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));", "author": "Hilbrand", "createdAt": "2020-06-19T09:45:29Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0MTgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442741809", "bodyText": "Prefer to put constant on left side of equals. In eclipse put the cursor on equals and Ctlr-1 gives option to swap variables:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (transportState.equals(\"PLAYING\")) {\n          \n          \n            \n                                if (\"PLAYING\".equals(transportState)) {", "author": "Hilbrand", "createdAt": "2020-06-19T09:46:50Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0MjUzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442742537", "bodyText": "Prefer to iterate over entrySet because keySet makes a copy of the values to a new list.", "author": "Hilbrand", "createdAt": "2020-06-19T09:48:10Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (transportState.equals(\"STOPPED\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (transportState.equals(\"PAUSED_PLAYBACK\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            if (subscriptionRefreshJob != null) {\n+                subscriptionRefreshJob.cancel(true);\n+            }\n+            subscriptionRefreshJob = null;\n+            upnpSubscribed = false;\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (String parsedValue : parsedValues.keySet()) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NDYzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442744635", "bodyText": "This can probably just be a ArrayList or just pass values() (in which case filterEntries should accept a Collection?", "author": "Hilbrand", "createdAt": "2020-06-19T09:52:24Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,457 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    @NonNullByDefault({})\n+    private ChannelUID rendererChannelUID;\n+    @NonNullByDefault({})\n+    private ChannelUID currentTitleChannelUID;\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile Map<String, UpnpEntry> entryMap = new HashMap<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    public UpnpServerHandler(Thing thing, UpnpIOService upnpIOService,\n+            ConcurrentMap<String, UpnpRendererHandler> upnpRenderers,\n+            UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider,\n+            UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider) {\n+        super(thing, upnpIOService);\n+        this.upnpRenderers = upnpRenderers;\n+        this.upnpStateDescriptionProvider = upnpStateDescriptionProvider;\n+        this.upnpCommandDescriptionProvider = upnpCommandDescriptionProvider;\n+\n+        // put root as highest level in parent map\n+        parentMap.put(currentEntry.getId(), currentEntry);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media server device {}\", thing.getLabel());\n+\n+        rendererChannelUID = thing.getChannel(UPNPRENDERER).getUID();\n+        currentTitleChannelUID = thing.getChannel(BROWSE).getUID();\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initServer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    private void initServer() {\n+        rendererStateOptionList = new ArrayList<>();\n+        upnpRenderers.forEach((key, value) -> {\n+            StateOption stateOption = new StateOption(key, value.getThing().getLabel());\n+            rendererStateOptionList.add(stateOption);\n+        });\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+\n+        getProtocolInfo();\n+\n+        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on server {}\", command, channelUID, thing.getLabel());\n+\n+        switch (channelUID.getId()) {\n+            case UPNPRENDERER:\n+                if (command instanceof StringType) {\n+                    currentRendererHandler = (upnpRenderers.get(((StringType) command).toString()));\n+                    if (Boolean.parseBoolean(getConfig().get(CONFIG_FILTER).toString())) {\n+                        // only refresh title list if filtering by renderer capabilities\n+                        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\",\n+                                getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                } else if ((command instanceof RefreshType) && (currentRendererHandler != null)) {\n+                    updateState(channelUID, StringType.valueOf(currentRendererHandler.getThing().getLabel()));\n+                }\n+                break;\n+            case CURRENTID:\n+                String currentId = \"\";\n+                if (command instanceof StringType) {\n+                    currentId = String.valueOf(command);\n+                } else if (command instanceof RefreshType) {\n+                    currentId = currentEntry.getId();\n+                    updateState(channelUID, StringType.valueOf(currentId));\n+                }\n+                logger.debug(\"Setting currentId to {}\", currentId);\n+                if (!currentId.isEmpty()) {\n+                    browse(currentId, \"BrowseDirectChildren\", \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+                }\n+            case BROWSE:\n+                if (command instanceof StringType) {\n+                    String browseTarget = command.toString();\n+                    if (browseTarget != null) {\n+                        if (UP.equals(browseTarget)) {\n+                            // Move up in tree\n+                            browseTarget = currentEntry.getParentId();\n+                            if (browseTarget.isEmpty()) {\n+                                // No parent found, so make it the root directory\n+                                browseTarget = DIRECTORY_ROOT;\n+                            }\n+                            currentEntry = parentMap.get(browseTarget);\n+                        } else {\n+                            currentEntry = entryMap.get(browseTarget);\n+                        }\n+                        updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(currentEntry.getId()));\n+                        logger.debug(\"Browse target {}\", browseTarget);\n+                        browse(browseTarget, \"BrowseDirectChildren\", \"*\", \"0\", \"0\",\n+                                getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                }\n+                break;\n+            case SEARCH:\n+                if (command instanceof StringType) {\n+                    String criteria = command.toString();\n+                    if (criteria != null) {\n+                        String searchContainer = \"\";\n+                        if (currentEntry.isContainer()) {\n+                            searchContainer = currentEntry.getId();\n+                        } else {\n+                            searchContainer = currentEntry.getParentId();\n+                        }\n+                        if (searchContainer.isEmpty()) {\n+                            // No parent found, so make it the root directory\n+                            searchContainer = DIRECTORY_ROOT;\n+                        }\n+                        updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(currentEntry.getId()));\n+                        logger.debug(\"Search container {} for {}\", searchContainer, criteria);\n+                        search(searchContainer, criteria, \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Add a renderer to the renderer channel state option list.\n+     * This method is called from the {@link UpnpControlHandlerFactory} class when creating a renderer handler.\n+     *\n+     * @param key\n+     */\n+    public void addRendererOption(String key) {\n+        rendererStateOptionList.add(new StateOption(key, upnpRenderers.get(key).getThing().getLabel()));\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+        logger.debug(\"Renderer option {} added to {}\", key, thing.getLabel());\n+    }\n+\n+    /**\n+     * Remove a renderer from the renderer channel state option list.\n+     * This method is called from the {@link UpnpControlHandlerFactory} class when removing a renderer handler.\n+     *\n+     * @param key\n+     */\n+    public void removeRendererOption(String key) {\n+        UpnpRendererHandler handler = currentRendererHandler;\n+        if ((handler != null) && (handler.getThing().getUID().toString().equals(key))) {\n+            currentRendererHandler = null;\n+            updateState(rendererChannelUID, UnDefType.UNDEF);\n+        }\n+        rendererStateOptionList.removeIf(stateOption -> (stateOption.getValue().equals(key)));\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+        logger.debug(\"Renderer option {} removed from {}\", key, thing.getLabel());\n+    }\n+\n+    private void updateTitleSelection(List<UpnpEntry> titleList) {\n+        logger.debug(\"Navigating to node {} on server {}\", currentEntry.getId(), thing.getLabel());\n+\n+        // Optionally, filter only items that can be played on the renderer\n+        String filter = getConfig().get(CONFIG_FILTER).toString();\n+        logger.debug(\"Filtering content on server {}: {}\", thing.getLabel(), filter);\n+        List<UpnpEntry> resultList = Boolean.parseBoolean(filter) ? filterEntries(titleList, true) : titleList;\n+\n+        List<CommandOption> commandOptionList = new ArrayList<>();\n+        // Add a directory up selector if not in the directory root\n+        if ((!resultList.isEmpty() && !(DIRECTORY_ROOT.equals(resultList.get(0).getParentId())))\n+                || (resultList.isEmpty() && !DIRECTORY_ROOT.equals(currentEntry.getId()))) {\n+            CommandOption commandOption = new CommandOption(UP, UP);\n+            commandOptionList.add(commandOption);\n+            logger.debug(\"UP added to selection list on server {}\", thing.getLabel());\n+        }\n+\n+        entryMap.clear(); // always only keep the current selection in the entry map to keep memory usage down\n+        resultList.forEach((value) -> {\n+            CommandOption commandOption = new CommandOption(value.getId(), value.getTitle());\n+            commandOptionList.add(commandOption);\n+            logger.trace(\"{} added to selection list on server {}\", value.getId(), thing.getLabel());\n+\n+            // Keep the entries in a map so we can find the parent and container for the current selection to go back up\n+            if (value.isContainer()) {\n+                parentMap.put(value.getId(), value);\n+            }\n+            entryMap.put(value.getId(), value);\n+        });\n+\n+        // Set the currentId to the parent of the first entry in the list\n+        if (!resultList.isEmpty()) {\n+            updateState(thing.getChannel(CURRENTID).getUID(), StringType.valueOf(resultList.get(0).getId()));\n+        }\n+\n+        logger.debug(\"{} entries added to selection list on server {}\", commandOptionList.size(), thing.getLabel());\n+        updateCommandDescription(currentTitleChannelUID, commandOptionList);\n+\n+        serveMedia();\n+    }\n+\n+    /**\n+     * Filter a list of media and only keep the media that are playable on the currently selected renderer.\n+     *\n+     * @param resultList\n+     * @param includeContainers\n+     * @return\n+     */\n+    private List<UpnpEntry> filterEntries(List<UpnpEntry> resultList, boolean includeContainers) {\n+        logger.debug(\"Raw result list {}\", resultList);\n+        List<UpnpEntry> list = new ArrayList<>();\n+        if (currentRendererHandler != null) {\n+            List<String> sink = currentRendererHandler.getSink();\n+            list = resultList.stream()\n+                    .filter(entry -> (includeContainers && entry.isContainer())\n+                            || UpnpProtocolMatcher.testProtocolList(entry.getProtocolList(), sink))\n+                    .collect(Collectors.toList());\n+        }\n+        logger.debug(\"Filtered result list {}\", list);\n+        return list;\n+    }\n+\n+    private void updateStateDescription(ChannelUID channelUID, List<StateOption> stateOptionList) {\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withReadOnly(false)\n+                .withOptions(stateOptionList).build().toStateDescription();\n+        upnpStateDescriptionProvider.setDescription(channelUID, stateDescription);\n+    }\n+\n+    private void updateCommandDescription(ChannelUID channelUID, List<CommandOption> commandOptionList) {\n+        CommandDescription commandDescription = CommandDescriptionBuilder.create().withCommandOptions(commandOptionList)\n+                .build();\n+        upnpCommandDescriptionProvider.setDescription(channelUID, commandDescription);\n+    }\n+\n+    /**\n+     * Method that does a UPnP browse on a content directory. Results will be retrieved in the {@link onValueReceived}\n+     * method.\n+     *\n+     * @param objectID content directory object\n+     * @param browseFlag BrowseMetaData or BrowseDirectChildren\n+     * @param filter properties to be returned\n+     * @param startingIndex starting index of objects to return\n+     * @param requestedCount number of objects to return, 0 for all\n+     * @param sortCriteria sort criteria, example: +dc:title\n+     */\n+    public void browse(String objectID, String browseFlag, String filter, String startingIndex, String requestedCount,\n+            String sortCriteria) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"ObjectID\", objectID);\n+        inputs.put(\"BrowseFlag\", browseFlag);\n+        inputs.put(\"Filter\", filter);\n+        inputs.put(\"StartingIndex\", startingIndex);\n+        inputs.put(\"RequestedCount\", requestedCount);\n+        inputs.put(\"SortCriteria\", sortCriteria);\n+\n+        invokeAction(\"ContentDirectory\", \"Browse\", inputs);\n+    }\n+\n+    /**\n+     * Method that does a UPnP search on a content directory. Results will be retrieved in the {@link onValueReceived}\n+     * method.\n+     *\n+     * @param containerID content directory container\n+     * @param searchCriteria search criteria, examples:\n+     *            dc:title contains \"song\"\n+     *            dc:creator contains \"Springsteen\"\n+     *            upnp:class = \"object.item.audioItem\"\n+     *            upnp:album contains \"Born in\"\n+     * @param filter properties to be returned\n+     * @param startingIndex starting index of objects to return\n+     * @param requestedCount number of objects to return, 0 for all\n+     * @param sortCriteria sort criteria, example: +dc:title\n+     */\n+    public void search(String containerID, String searchCriteria, String filter, String startingIndex,\n+            String requestedCount, String sortCriteria) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"ContainerID\", containerID);\n+        inputs.put(\"SearchCriteria\", searchCriteria);\n+        inputs.put(\"Filter\", filter);\n+        inputs.put(\"StartingIndex\", startingIndex);\n+        inputs.put(\"RequestedCount\", requestedCount);\n+        inputs.put(\"SortCriteria\", sortCriteria);\n+\n+        invokeAction(\"ContentDirectory\", \"Search\", inputs);\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Server status changed to {}\", status);\n+        if (status) {\n+            initServer();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(), variable,\n+                value, service);\n+        if (variable == null) {\n+            return;\n+        }\n+        switch (variable) {\n+            case \"Result\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateTitleSelection(removeDuplicates(UpnpXMLParser.getEntriesFromXML(value)));\n+                } else {\n+                    updateTitleSelection(new ArrayList<UpnpEntry>());\n+                }\n+                break;\n+            case \"NumberReturned\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    numberReturned = Integer.parseInt(value);\n+                }\n+                break;\n+            case \"TotalMatches\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    totalMatches = Integer.parseInt(value);\n+                }\n+                break;\n+            case \"UpdateID\":\n+                break;\n+            case \"Source\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    source.clear();\n+                    source.addAll(Arrays.asList(value.split(\",\")));\n+                }\n+                break;\n+            default:\n+                super.onValueReceived(variable, value, service);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Remove double entries by checking the refId if it exists as Id in the list and only keeping the original entry if\n+     * available. If the original entry is not in the list, only keep one referring entry.\n+     *\n+     * @param list\n+     * @return filtered list\n+     */\n+    private List<UpnpEntry> removeDuplicates(List<UpnpEntry> list) {\n+        List<UpnpEntry> newList = new ArrayList<>();\n+        List<String> refIdList = new ArrayList<>();\n+        list.forEach(entry -> {\n+            String refId = entry.getRefId();\n+            if (refId.isEmpty()\n+                    || (list.stream().noneMatch(any -> (refId.equals(any.getId()))) && !refIdList.contains(refId))) {\n+                newList.add(entry);\n+            }\n+            if (!refId.isEmpty()) {\n+                refIdList.add(refId);\n+            }\n+        });\n+        return newList;\n+    }\n+\n+    private void serveMedia() {\n+        UpnpRendererHandler handler = currentRendererHandler;\n+        if (handler != null) {\n+            LinkedList<UpnpEntry> mediaQueue = new LinkedList<>();\n+            mediaQueue.addAll(filterEntries(new LinkedList<UpnpEntry>(entryMap.values()), false));", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442748805", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (list.size() > 0) {\n          \n          \n            \n                                if (!list.isEmpty()) {", "author": "Hilbrand", "createdAt": "2020-06-19T10:00:39Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (transportState.equals(\"STOPPED\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (transportState.equals(\"PAUSED_PLAYBACK\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            if (subscriptionRefreshJob != null) {\n+                subscriptionRefreshJob.cancel(true);\n+            }\n+            subscriptionRefreshJob = null;\n+            upnpSubscribed = false;\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (String parsedValue : parsedValues.keySet()) {\n+                            // Update the transport state after the update of the media information\n+                            // to not break the notification mechanism\n+                            if (!parsedValue.equals(\"TransportState\")) {\n+                                onValueReceived(parsedValue, parsedValues.get(parsedValue), service);\n+                            }\n+                            if (parsedValue.equals(\"AVTransportURI\")) {\n+                                onValueReceived(\"CurrentTrackURI\", parsedValues.get(parsedValue), service);\n+                            } else if (parsedValue.equals(\"AVTransportURIMetaData\")) {\n+                                onValueReceived(\"CurrentTrackMetaData\", parsedValues.get(parsedValue), service);\n+                            }\n+                        }\n+                        if (parsedValues.get(\"TransportState\") != null) {\n+                            onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n+                        }\n+                    }\n+                }\n+                break;\n+            case \"TransportState\":\n+                transportState = (value == null) ? \"\" : value;\n+                if (\"STOPPED\".equals(value)) {\n+                    // This allows us to identify if we played to the end of an entry. We should then move to the next\n+                    // entry if the queue is not at the end already.\n+                    if (playerStopped) {\n+                        playing = false;\n+                        // Stop command came from openHAB, so don't move to next\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        cancelTrackPositionRefresh();\n+                    } else if (playing) {\n+                        // Only go to next for first STOP command, then wait until we received PLAYING before moving\n+                        // to next (avoids issues with renderers sending multiple stop states)\n+                        playing = false;\n+                        serveNext();\n+                    }\n+                } else if (\"PLAYING\".equals(value)) {\n+                    playerStopped = false;\n+                    playing = true;\n+                    updateState(CONTROL, PlayPauseType.PLAY);\n+                    scheduleTrackPositionRefresh();\n+                }\n+                break;\n+            case \"CurrentTrackURI\":\n+                if ((queuePosition < (currentQueue.size() - 1)\n+                        && !currentQueue.get(queuePosition).getRes().equals(value)\n+                        && currentQueue.get(queuePosition + 1).getRes().equals(value))) {\n+                    // Renderer advanced to next entry independent of openHAB UPnP control point.\n+                    // Advance in the queue to keep proper position status.\n+                    // Make the next entry available to renderers that support it.\n+                    updateMetaDataState(currentQueue.get(queuePosition + 1));\n+                    if (++queuePosition < (currentQueue.size() - 1)) {\n+                        UpnpEntry next = currentQueue.get(queuePosition + 1);\n+                        setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackMetaData\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+                    if (list.size() > 0) {", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1MDU0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442750548", "bodyText": "Pattern can be made a field.", "author": "Hilbrand", "createdAt": "2020-06-19T10:04:16Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (transportState.equals(\"STOPPED\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (transportState.equals(\"PAUSED_PLAYBACK\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            if (subscriptionRefreshJob != null) {\n+                subscriptionRefreshJob.cancel(true);\n+            }\n+            subscriptionRefreshJob = null;\n+            upnpSubscribed = false;\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (String parsedValue : parsedValues.keySet()) {\n+                            // Update the transport state after the update of the media information\n+                            // to not break the notification mechanism\n+                            if (!parsedValue.equals(\"TransportState\")) {\n+                                onValueReceived(parsedValue, parsedValues.get(parsedValue), service);\n+                            }\n+                            if (parsedValue.equals(\"AVTransportURI\")) {\n+                                onValueReceived(\"CurrentTrackURI\", parsedValues.get(parsedValue), service);\n+                            } else if (parsedValue.equals(\"AVTransportURIMetaData\")) {\n+                                onValueReceived(\"CurrentTrackMetaData\", parsedValues.get(parsedValue), service);\n+                            }\n+                        }\n+                        if (parsedValues.get(\"TransportState\") != null) {\n+                            onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n+                        }\n+                    }\n+                }\n+                break;\n+            case \"TransportState\":\n+                transportState = (value == null) ? \"\" : value;\n+                if (\"STOPPED\".equals(value)) {\n+                    // This allows us to identify if we played to the end of an entry. We should then move to the next\n+                    // entry if the queue is not at the end already.\n+                    if (playerStopped) {\n+                        playing = false;\n+                        // Stop command came from openHAB, so don't move to next\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        cancelTrackPositionRefresh();\n+                    } else if (playing) {\n+                        // Only go to next for first STOP command, then wait until we received PLAYING before moving\n+                        // to next (avoids issues with renderers sending multiple stop states)\n+                        playing = false;\n+                        serveNext();\n+                    }\n+                } else if (\"PLAYING\".equals(value)) {\n+                    playerStopped = false;\n+                    playing = true;\n+                    updateState(CONTROL, PlayPauseType.PLAY);\n+                    scheduleTrackPositionRefresh();\n+                }\n+                break;\n+            case \"CurrentTrackURI\":\n+                if ((queuePosition < (currentQueue.size() - 1)\n+                        && !currentQueue.get(queuePosition).getRes().equals(value)\n+                        && currentQueue.get(queuePosition + 1).getRes().equals(value))) {\n+                    // Renderer advanced to next entry independent of openHAB UPnP control point.\n+                    // Advance in the queue to keep proper position status.\n+                    // Make the next entry available to renderers that support it.\n+                    updateMetaDataState(currentQueue.get(queuePosition + 1));\n+                    if (++queuePosition < (currentQueue.size() - 1)) {\n+                        UpnpEntry next = currentQueue.get(queuePosition + 1);\n+                        setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackMetaData\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+                    if (list.size() > 0) {\n+                        updateMetaDataState(list.get(0));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackDuration\":\n+                updateState(TRACK_DURATION, StringType.valueOf(value));\n+                trackDuration = value != null ? value : \"00:00:00\";\n+            case \"RelTime\":\n+                updateState(TRACK_POSITION, StringType.valueOf(trackPosition));\n+                trackPosition = value != null ? value : \"00:00:00\";\n+            default:\n+                super.onValueReceived(variable, value, service);\n+                break;\n+        }\n+    }\n+\n+    private void updateProtocolInfo(String value) {\n+        sink.clear();\n+        supportedAudioFormats.clear();\n+        audioSupport = false;\n+\n+        sink.addAll(Arrays.asList(value.split(\",\")));\n+\n+        Pattern pattern = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1MDgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442750819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            audioSupport = audioSupport ? audioSupport : Pattern.matches(\"audio.*\", format);\n          \n          \n            \n                            audioSupport = audioSupport || Pattern.matches(\"audio.*\", format);", "author": "Hilbrand", "createdAt": "2020-06-19T10:04:49Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (transportState.equals(\"STOPPED\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (transportState.equals(\"PAUSED_PLAYBACK\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            if (subscriptionRefreshJob != null) {\n+                subscriptionRefreshJob.cancel(true);\n+            }\n+            subscriptionRefreshJob = null;\n+            upnpSubscribed = false;\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (String parsedValue : parsedValues.keySet()) {\n+                            // Update the transport state after the update of the media information\n+                            // to not break the notification mechanism\n+                            if (!parsedValue.equals(\"TransportState\")) {\n+                                onValueReceived(parsedValue, parsedValues.get(parsedValue), service);\n+                            }\n+                            if (parsedValue.equals(\"AVTransportURI\")) {\n+                                onValueReceived(\"CurrentTrackURI\", parsedValues.get(parsedValue), service);\n+                            } else if (parsedValue.equals(\"AVTransportURIMetaData\")) {\n+                                onValueReceived(\"CurrentTrackMetaData\", parsedValues.get(parsedValue), service);\n+                            }\n+                        }\n+                        if (parsedValues.get(\"TransportState\") != null) {\n+                            onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n+                        }\n+                    }\n+                }\n+                break;\n+            case \"TransportState\":\n+                transportState = (value == null) ? \"\" : value;\n+                if (\"STOPPED\".equals(value)) {\n+                    // This allows us to identify if we played to the end of an entry. We should then move to the next\n+                    // entry if the queue is not at the end already.\n+                    if (playerStopped) {\n+                        playing = false;\n+                        // Stop command came from openHAB, so don't move to next\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        cancelTrackPositionRefresh();\n+                    } else if (playing) {\n+                        // Only go to next for first STOP command, then wait until we received PLAYING before moving\n+                        // to next (avoids issues with renderers sending multiple stop states)\n+                        playing = false;\n+                        serveNext();\n+                    }\n+                } else if (\"PLAYING\".equals(value)) {\n+                    playerStopped = false;\n+                    playing = true;\n+                    updateState(CONTROL, PlayPauseType.PLAY);\n+                    scheduleTrackPositionRefresh();\n+                }\n+                break;\n+            case \"CurrentTrackURI\":\n+                if ((queuePosition < (currentQueue.size() - 1)\n+                        && !currentQueue.get(queuePosition).getRes().equals(value)\n+                        && currentQueue.get(queuePosition + 1).getRes().equals(value))) {\n+                    // Renderer advanced to next entry independent of openHAB UPnP control point.\n+                    // Advance in the queue to keep proper position status.\n+                    // Make the next entry available to renderers that support it.\n+                    updateMetaDataState(currentQueue.get(queuePosition + 1));\n+                    if (++queuePosition < (currentQueue.size() - 1)) {\n+                        UpnpEntry next = currentQueue.get(queuePosition + 1);\n+                        setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackMetaData\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+                    if (list.size() > 0) {\n+                        updateMetaDataState(list.get(0));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackDuration\":\n+                updateState(TRACK_DURATION, StringType.valueOf(value));\n+                trackDuration = value != null ? value : \"00:00:00\";\n+            case \"RelTime\":\n+                updateState(TRACK_POSITION, StringType.valueOf(trackPosition));\n+                trackPosition = value != null ? value : \"00:00:00\";\n+            default:\n+                super.onValueReceived(variable, value, service);\n+                break;\n+        }\n+    }\n+\n+    private void updateProtocolInfo(String value) {\n+        sink.clear();\n+        supportedAudioFormats.clear();\n+        audioSupport = false;\n+\n+        sink.addAll(Arrays.asList(value.split(\",\")));\n+\n+        Pattern pattern = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+        for (String protocol : sink) {\n+            Matcher matcher = pattern.matcher(protocol);\n+            if (matcher.find()) {\n+                String format = matcher.group(1);\n+                switch (format) {\n+                    case \"audio/mpeg3\":\n+                    case \"audio/mp3\":\n+                    case \"audio/mpeg\":\n+                        supportedAudioFormats.add(AudioFormat.MP3);\n+                        break;\n+                    case \"audio/wav\":\n+                    case \"audio/wave\":\n+                        supportedAudioFormats.add(AudioFormat.WAV);\n+                        break;\n+                }\n+                audioSupport = audioSupport ? audioSupport : Pattern.matches(\"audio.*\", format);", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442756394", "bodyText": "Not sure why this is a LinkedList. No specific linked list functionality is used. So it probably can just be a ArrayList.\nThe list is used to walk over this list, and the index is kept for that. This can also be achived by using a listIterator() (It's a method on for example ArrayList or LinkedList). And then you can simply use next() and previous() and it will maintain the position. (Also you can use hasNext to see if you're at the end of the list).", "author": "Hilbrand", "createdAt": "2020-06-19T10:16:39Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2MDk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446260970", "bodyText": "This one was a challenge. It looked simple at first, but a ListIterator does not keep a position. The result of next() and previous() depends on the previous command. But I was down a path implementing it, and unfortunately, did not put the rest in a separate commit, so couldn't easily go back. Here is the Stackflow article I used as a basis for my solution.", "author": "mherwege", "createdAt": "2020-06-26T15:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442756452", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n          \n          \n            \n                protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();", "author": "Hilbrand", "createdAt": "2020-06-19T10:16:46Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1Njk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442756984", "bodyText": "Use time unit in name to easily understand the time it represents\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int SUBSCRIPTION_DURATION = 3600;\n          \n          \n            \n                private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;", "author": "Hilbrand", "createdAt": "2020-06-19T10:17:50Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1ODQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r442758414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                                soundMute = OnOffType.from(Boolean.parseBoolean(value));", "author": "Hilbrand", "createdAt": "2020-06-19T10:20:50Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION = 3600;\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<AudioFormat>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile LinkedList<UpnpEntry> currentQueue = new LinkedList<>();\n+    private volatile int queuePosition = -1;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+    };\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (subscriptionRefreshJob != null) {\n+            subscriptionRefreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+        removeSubscription(\"AVTransport\");\n+        upnpSubscribed = false;\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh, SUBSCRIPTION_DURATION / 2,\n+                    SUBSCRIPTION_DURATION / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (transportState.equals(\"PLAYING\")) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (transportState.equals(\"STOPPED\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (transportState.equals(\"PAUSED_PLAYBACK\")) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            if (subscriptionRefreshJob != null) {\n+                subscriptionRefreshJob.cancel(true);\n+            }\n+            subscriptionRefreshJob = null;\n+            upnpSubscribed = false;\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = (Boolean.valueOf(value) ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "bc68c1f206fce62e09728aef18e73df705120eb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM2Nzc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446367793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        trackPositionRefresh = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        trackPositionRefresh = scheduler.scheduleWithFixedDelay(this::getPositionInfo, 1, 1, TimeUnit.SECONDS);", "author": "Hilbrand", "createdAt": "2020-06-26T19:21:43Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,868 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n+\n+    // UPnP protocol pattern\n+    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile ArrayList<UpnpEntry> currentQueue = new ArrayList<>();\n+    private volatile UpnpIterator<UpnpEntry> queueIterator = new UpnpIterator<>(currentQueue.listIterator());\n+    private volatile @Nullable UpnpEntry currentEntry = null;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+    };\n+\n+    /**\n+     * The {@link ListIterator} class does not keep a cursor position and therefore will not give the previous element\n+     * when next was called before, or give the next element when previous was called before. This iterator will always\n+     * go to previous/next.\n+     */\n+    private static class UpnpIterator<T> {\n+        private final ListIterator<T> listIterator;\n+\n+        private boolean nextWasCalled = false;\n+        private boolean previousWasCalled = false;\n+\n+        public UpnpIterator(ListIterator<T> listIterator) {\n+            this.listIterator = listIterator;\n+        }\n+\n+        public T next() {\n+            if (previousWasCalled) {\n+                previousWasCalled = false;\n+                listIterator.next();\n+            }\n+            nextWasCalled = true;\n+            return listIterator.next();\n+        }\n+\n+        public T previous() {\n+            if (nextWasCalled) {\n+                nextWasCalled = false;\n+                listIterator.previous();\n+            }\n+            previousWasCalled = true;\n+            return listIterator.previous();\n+        }\n+\n+        public boolean hasNext() {\n+            if (previousWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasNext();\n+            }\n+        }\n+\n+        public boolean hasPrevious() {\n+            if (previousIndex() < 0) {\n+                return false;\n+            } else if (nextWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasPrevious();\n+            }\n+        }\n+\n+        public int nextIndex() {\n+            if (previousWasCalled) {\n+                return listIterator.nextIndex() + 1;\n+            } else {\n+                return listIterator.nextIndex();\n+            }\n+        }\n+\n+        public int previousIndex() {\n+            if (nextWasCalled) {\n+                return listIterator.previousIndex() - 1;\n+            } else {\n+                return listIterator.previousIndex();\n+            }\n+        }\n+    }\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelSubscriptionRefreshJob();\n+        removeSubscription(\"AVTransport\");\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void cancelSubscriptionRefreshJob() {\n+        ScheduledFuture<?> refreshJob = subscriptionRefreshJob;\n+\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+\n+        upnpSubscribed = false;\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh,\n+                    SUBSCRIPTION_DURATION_SECONDS / 2, SUBSCRIPTION_DURATION_SECONDS / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (\"PLAYING\".equals(transportState)) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (\"STOPPED\".equals(transportState)) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            cancelSubscriptionRefreshJob();\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = OnOffType.from(Boolean.parseBoolean(value));\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n+                            // Update the transport state after the update of the media information\n+                            // to not break the notification mechanism\n+                            if (!\"TransportState\".equals(entrySet.getKey())) {\n+                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n+                            }\n+                            if (\"AVTransportURI\".equals(entrySet.getKey())) {\n+                                onValueReceived(\"CurrentTrackURI\", entrySet.getValue(), service);\n+                            } else if (\"AVTransportURIMetaData\".equals(entrySet.getKey())) {\n+                                onValueReceived(\"CurrentTrackMetaData\", entrySet.getValue(), service);\n+                            }\n+                        }\n+                        if (parsedValues.get(\"TransportState\") != null) {\n+                            onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n+                        }\n+                    }\n+                }\n+                break;\n+            case \"TransportState\":\n+                transportState = (value == null) ? \"\" : value;\n+                if (\"STOPPED\".equals(value)) {\n+                    // This allows us to identify if we played to the end of an entry. We should then move to the next\n+                    // entry if the queue is not at the end already.\n+                    if (playerStopped) {\n+                        playing = false;\n+                        // Stop command came from openHAB, so don't move to next\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        cancelTrackPositionRefresh();\n+                    } else if (playing) {\n+                        // Only go to next for first STOP command, then wait until we received PLAYING before moving\n+                        // to next (avoids issues with renderers sending multiple stop states)\n+                        playing = false;\n+                        serveNext();\n+                    }\n+                } else if (\"PLAYING\".equals(value)) {\n+                    playerStopped = false;\n+                    playing = true;\n+                    updateState(CONTROL, PlayPauseType.PLAY);\n+                    scheduleTrackPositionRefresh();\n+                }\n+                break;\n+            case \"CurrentTrackURI\":\n+                if (queueIterator.hasNext() && (currentEntry != null) && !currentEntry.getRes().equals(value)\n+                        && currentQueue.get(queueIterator.nextIndex()).getRes().equals(value)) {\n+                    // Renderer advanced to next entry independent of openHAB UPnP control point.\n+                    // Advance in the queue to keep proper position status.\n+                    // Make the next entry available to renderers that support it.\n+                    updateMetaDataState(currentQueue.get(queueIterator.nextIndex()));\n+                    logger.trace(\"Renderer moved from '{}' to next entry '{}' in queue\", currentEntry,\n+                            currentQueue.get(queueIterator.nextIndex()));\n+                    currentEntry = queueIterator.next();\n+                    if (queueIterator.hasNext()) {\n+                        UpnpEntry next = currentQueue.get(queueIterator.nextIndex());\n+                        setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackMetaData\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+                    if (!list.isEmpty()) {\n+                        updateMetaDataState(list.get(0));\n+                    }\n+                }\n+                break;\n+            case \"CurrentTrackDuration\":\n+                trackDuration = value != null ? value : \"00:00:00\";\n+                updateState(TRACK_DURATION, StringType.valueOf(trackDuration));\n+            case \"RelTime\":\n+                trackPosition = value != null ? value : \"00:00:00\";\n+                updateState(TRACK_POSITION, StringType.valueOf(trackPosition));\n+            default:\n+                super.onValueReceived(variable, value, service);\n+                break;\n+        }\n+    }\n+\n+    private void updateProtocolInfo(String value) {\n+        sink.clear();\n+        supportedAudioFormats.clear();\n+        audioSupport = false;\n+\n+        sink.addAll(Arrays.asList(value.split(\",\")));\n+\n+        for (String protocol : sink) {\n+            Matcher matcher = PROTOCOL_PATTERN.matcher(protocol);\n+            if (matcher.find()) {\n+                String format = matcher.group(1);\n+                switch (format) {\n+                    case \"audio/mpeg3\":\n+                    case \"audio/mp3\":\n+                    case \"audio/mpeg\":\n+                        supportedAudioFormats.add(AudioFormat.MP3);\n+                        break;\n+                    case \"audio/wav\":\n+                    case \"audio/wave\":\n+                        supportedAudioFormats.add(AudioFormat.WAV);\n+                        break;\n+                }\n+                audioSupport = audioSupport || Pattern.matches(\"audio.*\", format);\n+            }\n+        }\n+\n+        if (audioSupport) {\n+            logger.debug(\"Device {} supports audio\", thing.getLabel());\n+            registerAudioSink();\n+        }\n+    }\n+\n+    private void registerAudioSink() {\n+        if (audioSinkRegistered) {\n+            logger.debug(\"Audio Sink already registered for renderer {}\", thing.getLabel());\n+            return;\n+        } else if (!service.isRegistered(this)) {\n+            logger.debug(\"Audio Sink registration for renderer {} failed, no service\", thing.getLabel());\n+            return;\n+        }\n+        logger.debug(\"Registering Audio Sink for renderer {}\", thing.getLabel());\n+        audioSinkReg.registerAudioSink(this);\n+        audioSinkRegistered = true;\n+    }\n+\n+    private void clearCurrentEntry() {\n+        updateState(TITLE, UnDefType.UNDEF);\n+        updateState(ALBUM, UnDefType.UNDEF);\n+        updateState(ALBUM_ART, UnDefType.UNDEF);\n+        updateState(CREATOR, UnDefType.UNDEF);\n+        updateState(ARTIST, UnDefType.UNDEF);\n+        updateState(PUBLISHER, UnDefType.UNDEF);\n+        updateState(GENRE, UnDefType.UNDEF);\n+        updateState(TRACK_NUMBER, UnDefType.UNDEF);\n+        updateState(TRACK_DURATION, UnDefType.UNDEF);\n+        updateState(TRACK_POSITION, UnDefType.UNDEF);\n+\n+        currentEntry = null;\n+    }\n+\n+    /**\n+     * Register a new queue with media entries to the renderer. Set the next position at the first entry in the list.\n+     * If the renderer is currently playing, set the first entry in the list as the next media. If not playing, set it\n+     * as current media.\n+     *\n+     * @param queue\n+     */\n+    public void registerQueue(ArrayList<UpnpEntry> queue) {\n+        logger.debug(\"Registering queue on renderer {}\", thing.getLabel());\n+        currentQueue = queue;\n+        queueIterator = new UpnpIterator<>(currentQueue.listIterator());\n+        if (playing) {\n+            if (queueIterator.hasNext()) {\n+                // make the next entry available to renderers that support it\n+                logger.trace(\"Still playing, set new queue as next entry\");\n+                UpnpEntry next = currentQueue.get(queueIterator.nextIndex());\n+                setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+            }\n+        } else {\n+            if (queueIterator.hasNext()) {\n+                UpnpEntry entry = queueIterator.next();\n+                updateMetaDataState(entry);\n+                setCurrentURI(entry.getRes(), UpnpXMLParser.compileMetadataString(entry));\n+                currentEntry = entry;\n+            } else {\n+                clearCurrentEntry();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Move to next position in queue and start playing.\n+     */\n+    private void serveNext() {\n+        if (queueIterator.hasNext()) {\n+            currentEntry = queueIterator.next();\n+            logger.debug(\"Serve next media '{}' from queue on renderer {}\", currentEntry, thing.getLabel());\n+            serve();\n+        } else {\n+            logger.debug(\"Cannot serve next, end of queue on renderer {}\", thing.getLabel());\n+            cancelTrackPositionRefresh();\n+            stop();\n+            queueIterator = new UpnpIterator<>(currentQueue.listIterator()); // reset to beginning of queue\n+            if (currentQueue.isEmpty()) {\n+                clearCurrentEntry();\n+            } else {\n+                updateMetaDataState(currentQueue.get(queueIterator.nextIndex()));\n+                currentEntry = queueIterator.next();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Move to previous position in queue and start playing.\n+     */\n+    private void servePrevious() {\n+        if (queueIterator.hasPrevious()) {\n+            currentEntry = queueIterator.previous();\n+            logger.debug(\"Serve previous media '{}' from queue on renderer {}\", currentEntry, thing.getLabel());\n+            serve();\n+        } else {\n+            logger.debug(\"Cannot serve previous, already at start of queue on renderer {}\", thing.getLabel());\n+            cancelTrackPositionRefresh();\n+            stop();\n+            queueIterator = new UpnpIterator<>(currentQueue.listIterator()); // reset to beginning of queue\n+            if (currentQueue.isEmpty()) {\n+                clearCurrentEntry();\n+            } else {\n+                updateMetaDataState(currentQueue.get(queueIterator.nextIndex()));\n+                currentEntry = queueIterator.next();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Play media.\n+     *\n+     * @param media\n+     */\n+    private void serve() {\n+        UpnpEntry entry = currentEntry;\n+        if (entry != null) {\n+            logger.trace(\"Ready to play '{}' from queue\", currentEntry);\n+            updateMetaDataState(entry);\n+            String res = entry.getRes();\n+            if (res.isEmpty()) {\n+                logger.debug(\"Cannot serve media '{}', no URI\", currentEntry);\n+                return;\n+            }\n+            setCurrentURI(entry.getRes(), UpnpXMLParser.compileMetadataString(entry));\n+            play();\n+            scheduleTrackPositionRefresh();\n+\n+            // make the next entry available to renderers that support it\n+            if (queueIterator.hasNext()) {\n+                UpnpEntry next = currentQueue.get(queueIterator.nextIndex());\n+                setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the current track position every second if the channel is linked.\n+     */\n+    private void scheduleTrackPositionRefresh() {\n+        cancelTrackPositionRefresh();\n+        if (!isLinked(TRACK_POSITION)) {\n+            return;\n+        }\n+        if (trackDuration.equals(\"00:00:00\") || trackDuration.equals(\"NOT_IMPLEMENTED\")) {\n+            return;\n+        }\n+        if (trackPositionRefresh == null) {\n+            trackPositionRefresh = scheduler.scheduleWithFixedDelay(() -> {", "originalCommit": "8bccd6c78b8e9c9a53777e89046fb97c2dc664da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MDg1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446370855", "bodyText": "Shouldn't this be a trigger channel? It's not for keeping state, just to initiate a stop?", "author": "Hilbrand", "createdAt": "2020-06-26T19:29:08Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,172 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter Content</label>\n+\t\t\t\t<description>Only list content which is playable on the selected renderer</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>false</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sortcriteria\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Sort Criteria</label>\n+\t\t\t\t<description>Sort criteria for the titles in the selection list and when sending for playing to a renderer. The\n+\t\t\t\t\tcriteria are defined in UPnP sort criteria format. Examples: +dc:title, -dc:creator, +upnp:album. Supported sort\n+\t\t\t\t\tcriteria will depend on the media server</description>\n+\t\t\t\t<default>+dc:title</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel Types -->\n+\t<channel-type id=\"volume\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Volume</label>\n+\t\t<description>Set or get the master volume</description>\n+\t\t<category>SoundVolume</category>\n+\t</channel-type>\n+\t<channel-type id=\"mute\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Mute</label>\n+\t\t<description>Set or get the mute state</description>\n+\t</channel-type>\n+\t<channel-type id=\"control\">\n+\t\t<item-type>Player</item-type>\n+\t\t<label>Control</label>\n+\t\t<description>Control the player, e.g. start/stop/next/previous/ffward/rewind</description>\n+\t\t<category>Player</category>\n+\t</channel-type>\n+\t<channel-type id=\"stop\">\n+\t\t<item-type>Switch</item-type>", "originalCommit": "8bccd6c78b8e9c9a53777e89046fb97c2dc664da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NjQwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446396400", "bodyText": "I am not sure about this. I did the same as in the Sonos binding. I also saw this in the Squeezebox binding, and I believe most bindings modelling a player type of device do the same. You still would want to attach an item to it to model a button in a UI. So far, I have only seen examples of trigger channels directly used from rules, without items attached to it.", "author": "mherwege", "createdAt": "2020-06-26T20:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MDg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwODY4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446408680", "bodyText": "i think you are right. It's mostly used for triggers from devices to pass to a binding.", "author": "Hilbrand", "createdAt": "2020-06-26T21:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MDg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NTcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446375718", "bodyText": "The config variables should be stored in a variable in the initialize() method. You can define a class with the variables and use getConfigAs.", "author": "Hilbrand", "createdAt": "2020-06-26T19:41:06Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) ChannelUID rendererChannelUID;\n+    private @NonNullByDefault({}) ChannelUID currentTitleChannelUID;\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile List<UpnpEntry> entries = new ArrayList<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    public UpnpServerHandler(Thing thing, UpnpIOService upnpIOService,\n+            ConcurrentMap<String, UpnpRendererHandler> upnpRenderers,\n+            UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider,\n+            UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider) {\n+        super(thing, upnpIOService);\n+        this.upnpRenderers = upnpRenderers;\n+        this.upnpStateDescriptionProvider = upnpStateDescriptionProvider;\n+        this.upnpCommandDescriptionProvider = upnpCommandDescriptionProvider;\n+\n+        // put root as highest level in parent map\n+        parentMap.put(currentEntry.getId(), currentEntry);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media server device {}\", thing.getLabel());\n+\n+        rendererChannelUID = thing.getChannel(UPNPRENDERER).getUID();\n+        currentTitleChannelUID = thing.getChannel(BROWSE).getUID();\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initServer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    private void initServer() {\n+        rendererStateOptionList = new ArrayList<>();\n+        upnpRenderers.forEach((key, value) -> {\n+            StateOption stateOption = new StateOption(key, value.getThing().getLabel());\n+            rendererStateOptionList.add(stateOption);\n+        });\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+\n+        getProtocolInfo();\n+\n+        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", getConfig().get(SORT_CRITERIA).toString());", "originalCommit": "8bccd6c78b8e9c9a53777e89046fb97c2dc664da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NzA4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446377081", "bodyText": "These should probably not be logged to error as it indicates a problem with the data, not specifically with the binding. Error logging in openHAB is intended for severe errors.\nWhen the exception would be thrown, dioes it still make sense to call invokeAction? otherwise the call (and map) should be inside the try-catch.", "author": "Hilbrand", "createdAt": "2020-06-26T19:44:20Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,868 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n+\n+    // UPnP protocol pattern\n+    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile ArrayList<UpnpEntry> currentQueue = new ArrayList<>();\n+    private volatile UpnpIterator<UpnpEntry> queueIterator = new UpnpIterator<>(currentQueue.listIterator());\n+    private volatile @Nullable UpnpEntry currentEntry = null;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+    };\n+\n+    /**\n+     * The {@link ListIterator} class does not keep a cursor position and therefore will not give the previous element\n+     * when next was called before, or give the next element when previous was called before. This iterator will always\n+     * go to previous/next.\n+     */\n+    private static class UpnpIterator<T> {\n+        private final ListIterator<T> listIterator;\n+\n+        private boolean nextWasCalled = false;\n+        private boolean previousWasCalled = false;\n+\n+        public UpnpIterator(ListIterator<T> listIterator) {\n+            this.listIterator = listIterator;\n+        }\n+\n+        public T next() {\n+            if (previousWasCalled) {\n+                previousWasCalled = false;\n+                listIterator.next();\n+            }\n+            nextWasCalled = true;\n+            return listIterator.next();\n+        }\n+\n+        public T previous() {\n+            if (nextWasCalled) {\n+                nextWasCalled = false;\n+                listIterator.previous();\n+            }\n+            previousWasCalled = true;\n+            return listIterator.previous();\n+        }\n+\n+        public boolean hasNext() {\n+            if (previousWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasNext();\n+            }\n+        }\n+\n+        public boolean hasPrevious() {\n+            if (previousIndex() < 0) {\n+                return false;\n+            } else if (nextWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasPrevious();\n+            }\n+        }\n+\n+        public int nextIndex() {\n+            if (previousWasCalled) {\n+                return listIterator.nextIndex() + 1;\n+            } else {\n+                return listIterator.nextIndex();\n+            }\n+        }\n+\n+        public int previousIndex() {\n+            if (nextWasCalled) {\n+                return listIterator.previousIndex() - 1;\n+            } else {\n+                return listIterator.previousIndex();\n+            }\n+        }\n+    }\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelSubscriptionRefreshJob();\n+        removeSubscription(\"AVTransport\");\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void cancelSubscriptionRefreshJob() {\n+        ScheduledFuture<?> refreshJob = subscriptionRefreshJob;\n+\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+\n+        upnpSubscribed = false;\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh,\n+                    SUBSCRIPTION_DURATION_SECONDS / 2, SUBSCRIPTION_DURATION_SECONDS / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());", "originalCommit": "8bccd6c78b8e9c9a53777e89046fb97c2dc664da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NzM2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r446377363", "bodyText": "Same comment about error here as above.", "author": "Hilbrand", "createdAt": "2020-06-26T19:44:59Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,868 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n+\n+    // UPnP protocol pattern\n+    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile ArrayList<UpnpEntry> currentQueue = new ArrayList<>();\n+    private volatile UpnpIterator<UpnpEntry> queueIterator = new UpnpIterator<>(currentQueue.listIterator());\n+    private volatile @Nullable UpnpEntry currentEntry = null;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+    };\n+\n+    /**\n+     * The {@link ListIterator} class does not keep a cursor position and therefore will not give the previous element\n+     * when next was called before, or give the next element when previous was called before. This iterator will always\n+     * go to previous/next.\n+     */\n+    private static class UpnpIterator<T> {\n+        private final ListIterator<T> listIterator;\n+\n+        private boolean nextWasCalled = false;\n+        private boolean previousWasCalled = false;\n+\n+        public UpnpIterator(ListIterator<T> listIterator) {\n+            this.listIterator = listIterator;\n+        }\n+\n+        public T next() {\n+            if (previousWasCalled) {\n+                previousWasCalled = false;\n+                listIterator.next();\n+            }\n+            nextWasCalled = true;\n+            return listIterator.next();\n+        }\n+\n+        public T previous() {\n+            if (nextWasCalled) {\n+                nextWasCalled = false;\n+                listIterator.previous();\n+            }\n+            previousWasCalled = true;\n+            return listIterator.previous();\n+        }\n+\n+        public boolean hasNext() {\n+            if (previousWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasNext();\n+            }\n+        }\n+\n+        public boolean hasPrevious() {\n+            if (previousIndex() < 0) {\n+                return false;\n+            } else if (nextWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasPrevious();\n+            }\n+        }\n+\n+        public int nextIndex() {\n+            if (previousWasCalled) {\n+                return listIterator.nextIndex() + 1;\n+            } else {\n+                return listIterator.nextIndex();\n+            }\n+        }\n+\n+        public int previousIndex() {\n+            if (nextWasCalled) {\n+                return listIterator.previousIndex() - 1;\n+            } else {\n+                return listIterator.previousIndex();\n+            }\n+        }\n+    }\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelSubscriptionRefreshJob();\n+        removeSubscription(\"AVTransport\");\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void cancelSubscriptionRefreshJob() {\n+        ScheduledFuture<?> refreshJob = subscriptionRefreshJob;\n+\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+\n+        upnpSubscribed = false;\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh,\n+                    SUBSCRIPTION_DURATION_SECONDS / 2, SUBSCRIPTION_DURATION_SECONDS / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+\n+        invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        } catch (NumberFormatException ex) {\n+            logger.error(\"Action Invalid Value Format Exception {}\", ex.getMessage());", "originalCommit": "8bccd6c78b8e9c9a53777e89046fb97c2dc664da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "url": "https://github.com/openhab/openhab-addons/commit/4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "message": "Further adjustments after code review.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-06-29T08:14:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM2MjI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452362265", "bodyText": "Is this special capitalization?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Searching the media library is also supported using uPnP search syntax.\n          \n          \n            \n            Searching the media library is also supported using UPnP search syntax.", "author": "fwolter", "createdAt": "2020-07-09T17:01:36Z", "path": "bundles/org.openhab.binding.upnpcontrol/README.md", "diffHunk": "@@ -0,0 +1,165 @@\n+# UpnpControl Binding\n+\n+This binding acts as a UPnP control point to control UPnP AV media servers and media renderers as defined by the [UPnP Forum](https://openconnectivity.org/developer/specifications/upnp-resources/upnp/).\n+It discovers UPnP media servers and renderers in the local network.\n+UPnP AV media servers generally allow selecting content from a content directory.\n+UPnP AV media renderers take care of playback of the content.\n+\n+You can select a renderer to play the media served from a server.\n+The full content hierarchy of the media on the server can be browsed hierarchically.\n+Searching the media library is also supported using uPnP search syntax.", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM2NDk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452364963", "bodyText": "Is the format specified in the protocol? Then, you could make this Number:Time.", "author": "fwolter", "createdAt": "2020-07-09T17:06:19Z", "path": "bundles/org.openhab.binding.upnpcontrol/README.md", "diffHunk": "@@ -0,0 +1,165 @@\n+# UpnpControl Binding\n+\n+This binding acts as a UPnP control point to control UPnP AV media servers and media renderers as defined by the [UPnP Forum](https://openconnectivity.org/developer/specifications/upnp-resources/upnp/).\n+It discovers UPnP media servers and renderers in the local network.\n+UPnP AV media servers generally allow selecting content from a content directory.\n+UPnP AV media renderers take care of playback of the content.\n+\n+You can select a renderer to play the media served from a server.\n+The full content hierarchy of the media on the server can be browsed hierarchically.\n+Searching the media library is also supported using uPnP search syntax.\n+\n+Controls are available to control the playback of the media on the renderer.\n+Each discovered renderer will also be registered as an openHAB audio sink.\n+\n+## Supported Things\n+\n+Two thing types are supported, a server thing, `upnpserver`, and a renderer thing, `upnprenderer`.\n+\n+The binding has been tested with the AV Media Server and AV Media Renderer from Intel Developer Tools for UPnP Technology, available [here](https://www.meshcommander.com/upnptools).\n+A second test set included a [TVersity Media Server](http://tversity.com/).\n+It complies with part of the UPnP AV Media standard, but has not been verified to comply with the full specification.\n+Tests have focused on the playback of audio, but if the server and renderer support it, other media types should play as well.\n+\n+\n+## Discovery\n+\n+UPnP media servers and media renderers in the network will be discovered automatically.\n+\n+\n+## Thing Configuration\n+\n+Both the  `upnprenderer` and `upnpserver` thing require a configuration parameter, `udn` (Universal Device Name).\n+This `udn` uniquely defines the UPnP device.\n+It can be retrieved from the thing ID when using auto discovery.\n+\n+Additionally, a `upnpserver` device has the following optional configuration parameters:\n+\n+* `filter`: when true, only list content that is playable on the renderer, default is `false`.\n+* `sortcriteria`: Sort criteria for the titles in the selection list and when sending for playing to a renderer.\n+The criteria are defined in UPnP sort criteria format, examples: `+dc:title`, `-dc:creator`, `+upnp:album`.\n+Support for sort criteria will depend on the media server.\n+The default is to sort ascending on title, `+dc:title`.\n+\n+The full syntax for manual configuration is:\n+\n+```\n+Thing upnpcontrol:upnpserver:<serverId> [udn=\"<udn of media server>\"]\n+Thing upnpcontrol:upnprenderer:<rendererId> [udn=\"<udn of media renderer>\", filter=<true/false>, sortcriteria=\"<sort criteria string>\"]\n+```\n+\n+## Channels\n+\n+The `upnpserver` has the following channels:\n+\n+* `upnprenderer`: The renderer to send the media content to for playback.\n+The channel allows selecting from all discovered media renderers.\n+This list is dynamically adjusted as media renderers are being added/removed.\n+* `currentid`: Current ID of media container or entry ready for playback.\n+This channel can be used to skip to a specific container or entry in the content directory.\n+This is especially useful in rules.\n+* `browse`: Browse and serve media content.\n+The browsing will start at the top of the content directory tree and allows you to go down and up (represented by ..) in the tree.\n+The list of containers (directories) and media entries for selection in the content hierarchy is updated dynamically when selecting a container or entry.\n+All media in the selection list, playable on the currently selected `upnprenderer` channel, are automatically queued to the renderer as next media for playback.\n+* `search`: Search for media content on the server.\n+Search criteria are defined in UPnP search criteria format.\n+Examples: `dc:title contains \"song\"`, `dc:creator contains \"SpringSteen\"`, `unp:class = \"object.item.audioItem\"`, `upnp:album contains \"Born in\"`.\n+The search starts at the value of the `currentid` channel and searches down from there.\n+When no `currentid` is selected, the search starts at the top.\n+All media in the search result list, playable on the current selected `upnprenderer` channel, are automatically queued to the renderer as next media for playback.\n+\n+The `upnprenderer` has the following channels:\n+\n+| Channel Type ID | Item Type | Access Mode | Description                                        |\n+|-----------------|-----------|-------------|----------------------------------------------------|\n+| `volume`        | Dimmer    |      RW     | playback volume                                    |\n+| `control`       | Player    |      RW     | play, pause, next, previous control                |\n+| `stop`          | Switch    |      RW     | stop media playback                                |\n+| `title`         | String    |      R      | media title                                        |\n+| `album`         | String    |      R      | media album                                        |\n+| `albumart`      | Image     |      R      | image for media album                              |\n+| `creator`       | String    |      R      | media creator                                      |\n+| `artist`        | String    |      R      | media artist                                       |\n+| `publisher`     | String    |      R      | media publisher                                    |\n+| `genre`         | String    |      R      | media genre                                        |\n+| `tracknumber`   | Number    |      R      | track number of current track in album             |\n+| `trackduration` | String    |      R      | track duration of current track in album           |", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUwODQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453508457", "bodyText": "Done, but will be more useful with OH3 when PR #1470 is available.", "author": "mherwege", "createdAt": "2020-07-13T09:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM2NDk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3MzYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452373636", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    UpnpEntryRes resource;\n          \n          \n            \n                    try {\n          \n          \n            \n                        resource = resList.stream().filter(res -> !res.isThumbnailRes()).findFirst().get();\n          \n          \n            \n                    } catch (NoSuchElementException e) {\n          \n          \n            \n                        return \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    return resource.getRes();\n          \n          \n            \n                    return resList.stream().filter(res -> !res.isThumbnailRes()).map(UpnpEntryRes::getRes).findAny().orElse(\"\");", "author": "fwolter", "createdAt": "2020-07-09T17:21:17Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpEntry.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpEntry {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+\n+    private static final Pattern CONTAINER_PATTERN = Pattern.compile(\"object.container\");\n+\n+    private String id;\n+    private String refId;\n+    private String parentId;\n+    private String upnpClass;\n+    private String title = \"\";\n+    private List<UpnpEntryRes> resList = new ArrayList<>();\n+    private String album = \"\";\n+    private String albumArtUri = \"\";\n+    private String creator = \"\";\n+    private String artist = \"\";\n+    private String publisher = \"\";\n+    private String genre = \"\";\n+    private @Nullable Integer originalTrackNumber;\n+\n+    public UpnpEntry(String id, String refId, String parentId, String upnpClass) {\n+        this.id = id;\n+        this.refId = refId;\n+        this.parentId = parentId;\n+        this.upnpClass = upnpClass;\n+    }\n+\n+    public UpnpEntry withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbum(String album) {\n+        this.album = album;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbumArtUri(String albumArtUri) {\n+        this.albumArtUri = albumArtUri;\n+        return this;\n+    }\n+\n+    public UpnpEntry withCreator(String creator) {\n+        this.creator = creator;\n+        return this;\n+    }\n+\n+    public UpnpEntry withArtist(String artist) {\n+        this.artist = artist;\n+        return this;\n+    }\n+\n+    public UpnpEntry withPublisher(String publisher) {\n+        this.publisher = publisher;\n+        return this;\n+    }\n+\n+    public UpnpEntry withGenre(String genre) {\n+        this.genre = genre;\n+        return this;\n+    }\n+\n+    public UpnpEntry withResList(List<UpnpEntryRes> resList) {\n+        this.resList = resList;\n+        return this;\n+    }\n+\n+    public UpnpEntry withTrackNumber(@Nullable Integer originalTrackNumber) {\n+        this.originalTrackNumber = originalTrackNumber;\n+        return this;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    @Override\n+    public String toString() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the unique identifier of this entry.\n+     */\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the identifier of the entry this reference intry refers to.\n+     */\n+    public String getRefId() {\n+        return refId;\n+    }\n+\n+    /**\n+     * @return the unique identifier of the parent of this entry.\n+     */\n+    public String getParentId() {\n+        return parentId.isEmpty() ? DIRECTORY_ROOT : parentId;\n+    }\n+\n+    /**\n+     * @return a URI for this entry. Thumbnail resources are not considered.\n+     */\n+    public String getRes() {\n+        UpnpEntryRes resource;\n+        try {\n+            resource = resList.stream().filter(res -> !res.isThumbnailRes()).findFirst().get();\n+        } catch (NoSuchElementException e) {\n+            return \"\";\n+        }\n+        return resource.getRes();", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NTUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452375507", "bodyText": "Apache Commons won't be available in OH3 by default. @cweitkamp Is there a replacement function for (un)escaping XML?", "author": "fwolter", "createdAt": "2020-07-09T17:24:42Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpEntry.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpEntry {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+\n+    private static final Pattern CONTAINER_PATTERN = Pattern.compile(\"object.container\");\n+\n+    private String id;\n+    private String refId;\n+    private String parentId;\n+    private String upnpClass;\n+    private String title = \"\";\n+    private List<UpnpEntryRes> resList = new ArrayList<>();\n+    private String album = \"\";\n+    private String albumArtUri = \"\";\n+    private String creator = \"\";\n+    private String artist = \"\";\n+    private String publisher = \"\";\n+    private String genre = \"\";\n+    private @Nullable Integer originalTrackNumber;\n+\n+    public UpnpEntry(String id, String refId, String parentId, String upnpClass) {\n+        this.id = id;\n+        this.refId = refId;\n+        this.parentId = parentId;\n+        this.upnpClass = upnpClass;\n+    }\n+\n+    public UpnpEntry withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbum(String album) {\n+        this.album = album;\n+        return this;\n+    }\n+\n+    public UpnpEntry withAlbumArtUri(String albumArtUri) {\n+        this.albumArtUri = albumArtUri;\n+        return this;\n+    }\n+\n+    public UpnpEntry withCreator(String creator) {\n+        this.creator = creator;\n+        return this;\n+    }\n+\n+    public UpnpEntry withArtist(String artist) {\n+        this.artist = artist;\n+        return this;\n+    }\n+\n+    public UpnpEntry withPublisher(String publisher) {\n+        this.publisher = publisher;\n+        return this;\n+    }\n+\n+    public UpnpEntry withGenre(String genre) {\n+        this.genre = genre;\n+        return this;\n+    }\n+\n+    public UpnpEntry withResList(List<UpnpEntryRes> resList) {\n+        this.resList = resList;\n+        return this;\n+    }\n+\n+    public UpnpEntry withTrackNumber(@Nullable Integer originalTrackNumber) {\n+        this.originalTrackNumber = originalTrackNumber;\n+        return this;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    @Override\n+    public String toString() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the unique identifier of this entry.\n+     */\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the title of the entry.\n+     */\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    /**\n+     * @return the identifier of the entry this reference intry refers to.\n+     */\n+    public String getRefId() {\n+        return refId;\n+    }\n+\n+    /**\n+     * @return the unique identifier of the parent of this entry.\n+     */\n+    public String getParentId() {\n+        return parentId.isEmpty() ? DIRECTORY_ROOT : parentId;\n+    }\n+\n+    /**\n+     * @return a URI for this entry. Thumbnail resources are not considered.\n+     */\n+    public String getRes() {\n+        UpnpEntryRes resource;\n+        try {\n+            resource = resList.stream().filter(res -> !res.isThumbnailRes()).findFirst().get();\n+        } catch (NoSuchElementException e) {\n+            return \"\";\n+        }\n+        return resource.getRes();\n+    }\n+\n+    public List<String> getProtocolList() {\n+        return resList.stream().map(UpnpEntryRes::getProtocolInfo).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * @return the UPnP classname for this entry.\n+     */\n+    public String getUpnpClass() {\n+        return upnpClass;\n+    }\n+\n+    public boolean isContainer() {\n+        Matcher matcher = CONTAINER_PATTERN.matcher(getUpnpClass());\n+        return (matcher.find());\n+    }\n+\n+    /**\n+     * @return the name of the album.\n+     */\n+    public String getAlbum() {\n+        return album;\n+    }\n+\n+    /**\n+     * @return the URI for the album art.\n+     */\n+    public String getAlbumArtUri() {\n+        return StringEscapeUtils.unescapeXml(albumArtUri);", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzNTg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452435860", "bodyText": "I am afraid there is not (see #7722 (comment)).\nTL;DR I am not aware of a Java 8 equivalent. My proposal is to add a util class in OHC.", "author": "cweitkamp", "createdAt": "2020-07-09T19:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMwMDY2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453300661", "bodyText": "@fwolter I copied this from the Sonos binding. So can I leave it for now? Multiple bindings will have to be adjusted the same way later I assume.", "author": "mherwege", "createdAt": "2020-07-12T10:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3Njc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453876760", "bodyText": "I see no other way at the moment. Please add a dependency for Apache Commons to your pom.xml and the NOTICE file to be able to compile it with OH3, too.", "author": "fwolter", "createdAt": "2020-07-13T19:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0MDM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453940350", "bodyText": "No. It's still available and will be replaced with openHAB 3 with something provided by core. For now it's ok to use. We should not add depdencirs like this.", "author": "Hilbrand", "createdAt": "2020-07-13T21:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452379933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new ArrayList<UpnpEntry>();\n          \n          \n            \n                        return Collections.emptyList();", "author": "fwolter", "createdAt": "2020-07-09T17:32:26Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpXMLParser.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpXMLParser {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpnpXMLParser.class);\n+\n+    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n+            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n+                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n+                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n+                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n+                    + \"<upnp:class>{3}</upnp:class>\" + \"<upnp:album>{4}</upnp:album>\"\n+                    + \"<upnp:albumArtURI>{5}</upnp:albumArtURI>\" + \"<dc:creator>{6}</dc:creator>\"\n+                    + \"<upnp:artist>{7}</upnp:artist>\" + \"<dc:publisher>{8}</dc:publisher>\"\n+                    + \"<upnp:genre>{9}</upnp:genre>\" + \"<upnp:originalTrackNumber>{10}</upnp:originalTrackNumber>\"\n+                    + \"</item></DIDL-Lite>\");\n+\n+    private enum Element {\n+        TITLE,\n+        CLASS,\n+        ALBUM,\n+        ALBUM_ART_URI,\n+        CREATOR,\n+        ARTIST,\n+        PUBLISHER,\n+        GENRE,\n+        TRACK_NUMBER,\n+        RES\n+    }\n+\n+    public static Map<String, String> getAVTransportFromXML(String xml) {\n+        if (xml.isEmpty()) {\n+            LOGGER.debug(\"Could not parse AV Transport from empty xml\");\n+            return Collections.emptyMap();\n+        }\n+        AVTransportEventHandler handler = new AVTransportEventHandler();\n+        try {\n+            SAXParserFactory factory = SAXParserFactory.newInstance();\n+            SAXParser saxParser = factory.newSAXParser();\n+            saxParser.parse(new InputSource(new StringReader(xml)), handler);\n+        } catch (IOException e) {\n+            // This should never happen - we're not performing I/O!\n+            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml, e);\n+        } catch (SAXException | ParserConfigurationException s) {\n+            LOGGER.debug(\"Could not parse AV Transport from string '{}'\", xml, s);\n+        }\n+        return handler.getChanges();\n+    }\n+\n+    /**\n+     * @param xml\n+     * @return a list of Entries from the given xml string.\n+     * @throws IOException\n+     * @throws SAXException\n+     */\n+    public static List<UpnpEntry> getEntriesFromXML(String xml) {\n+        if (xml.isEmpty()) {\n+            LOGGER.debug(\"Could not parse Entries from empty xml\");\n+            return new ArrayList<UpnpEntry>();", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452397456", "bodyText": "When the configuration changed, this class will be re-used. To reload the configuration, getConfigAs() should be called in initialize().", "author": "fwolter", "createdAt": "2020-07-09T18:04:58Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpHandler} is the base class for {@link UpnpRendererHandler} and {@link UpnpServerHandler}.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public abstract class UpnpHandler extends BaseThingHandler implements UpnpIOParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpHandler.class);\n+\n+    protected UpnpIOService service;\n+    protected volatile String transportState = \"\";\n+    protected volatile int connectionId;\n+    protected volatile int avTransportId;\n+    protected volatile int rcsId;\n+    protected UpnpControlConfiguration config = getConfigAs(UpnpControlConfiguration.class);", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452398375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return;", "author": "fwolter", "createdAt": "2020-07-09T18:06:38Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOParticipant;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpHandler} is the base class for {@link UpnpRendererHandler} and {@link UpnpServerHandler}.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public abstract class UpnpHandler extends BaseThingHandler implements UpnpIOParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpHandler.class);\n+\n+    protected UpnpIOService service;\n+    protected volatile String transportState = \"\";\n+    protected volatile int connectionId;\n+    protected volatile int avTransportId;\n+    protected volatile int rcsId;\n+    protected UpnpControlConfiguration config = getConfigAs(UpnpControlConfiguration.class);\n+\n+    public UpnpHandler(Thing thing, UpnpIOService upnpIOService) {\n+        super(thing);\n+\n+        upnpIOService.registerParticipant(this);\n+        this.service = upnpIOService;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        service.registerParticipant(this);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        service.unregisterParticipant(this);\n+    }\n+\n+    /**\n+     * Invoke PrepareForConnection on the UPnP Connection Manager.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param remoteProtocolInfo\n+     * @param peerConnectionManager\n+     * @param peerConnectionId\n+     * @param direction\n+     */\n+    protected void prepareForConnection(String remoteProtocolInfo, String peerConnectionManager, int peerConnectionId,\n+            String direction) {\n+        HashMap<String, String> inputs = new HashMap<String, String>();\n+        inputs.put(\"RemoteProtocolInfo\", remoteProtocolInfo);\n+        inputs.put(\"PeerConnectionManager\", peerConnectionManager);\n+        inputs.put(\"PeerConnectionID\", Integer.toString(peerConnectionId));\n+        inputs.put(\"Direction\", direction);\n+\n+        invokeAction(\"ConnectionManager\", \"PrepareForConnection\", inputs);\n+    }\n+\n+    /**\n+     * Invoke ConnectionComplete on UPnP Connection Manager.\n+     *\n+     * @param connectionId\n+     */\n+    protected void connectionComplete(int connectionId) {\n+        HashMap<String, String> inputs = new HashMap<String, String>();\n+        inputs.put(\"ConnectionID\", String.valueOf(connectionId));\n+\n+        invokeAction(\"ConnectionManager\", \"ConnectionComplete\", inputs);\n+    }\n+\n+    /**\n+     * Invoke GetTransportState on UPnP AV Transport.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getTransportState() {\n+        HashMap<String, String> inputs = new HashMap<String, String>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"GetTransportInfo\", inputs);\n+    }\n+\n+    /**\n+     * Invoke GetProtocolInfo on UPnP Connection Manager.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getProtocolInfo() {\n+        Map<String, String> inputs = new HashMap<>();\n+\n+        invokeAction(\"ConnectionManager\", \"GetProtocolInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void onServiceSubscribed(@Nullable String service, boolean succeeded) {\n+        logger.debug(\"Upnp device {} received subscription reply {} from service {}\", thing.getLabel(), succeeded,\n+                service);\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        if (status) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable String getUDN() {\n+        return config.udn;\n+    }\n+\n+    /**\n+     * This method wraps {@link org.eclipse.smarthome.io.transport.upnp.UpnpIOService.invokeAction}. It schedules and\n+     * submits the call and calls {@link onValueReceived} upon completion. All state updates or other actions depending\n+     * on the results should be triggered from {@link onValueReceived} because the class fields with results will be\n+     * filled asynchronously.\n+     *\n+     * @param serviceId\n+     * @param actionId\n+     * @param inputs\n+     */\n+    protected void invokeAction(String serviceId, String actionId, Map<String, String> inputs) {\n+        scheduler.submit(() -> {\n+            Map<String, String> result = service.invokeAction(this, serviceId, actionId, inputs);\n+            if (logger.isDebugEnabled() && !\"GetPositionInfo\".equals(actionId)) {\n+                // don't log position info refresh every second\n+                logger.debug(\"Upnp device {} invoke upnp action {} on service {} with inputs {}\", thing.getLabel(),\n+                        actionId, serviceId, inputs);\n+                logger.debug(\"Upnp device {} invoke upnp action {} on service {} reply {}\", thing.getLabel(), actionId,\n+                        serviceId, result);\n+            }\n+            for (String variable : result.keySet()) {\n+                onValueReceived(variable, result.get(variable), serviceId);\n+            }\n+        });\n+        return;", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMTk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452401996", "bodyText": "This will eliminate the compiler warning.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (parsedValues.get(\"TransportState\") != null) {\n          \n          \n            \n                                    if (parsedValues.containsKey(\"TransportState\")) {", "author": "fwolter", "createdAt": "2020-07-09T18:13:22Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,866 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n+\n+    // UPnP protocol pattern\n+    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile ArrayList<UpnpEntry> currentQueue = new ArrayList<>();\n+    private volatile UpnpIterator<UpnpEntry> queueIterator = new UpnpIterator<>(currentQueue.listIterator());\n+    private volatile @Nullable UpnpEntry currentEntry = null;\n+    private volatile boolean playerStopped;\n+    private volatile boolean playing;\n+    private volatile String trackDuration = \"00:00:00\";\n+    private volatile String trackPosition = \"00:00:00\";\n+    private volatile @Nullable ScheduledFuture<?> trackPositionRefresh;\n+\n+    private volatile @Nullable ScheduledFuture<?> subscriptionRefreshJob;\n+    private final Runnable subscriptionRefresh = () -> {\n+        removeSubscription(\"AVTransport\");\n+        addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+    };\n+\n+    /**\n+     * The {@link ListIterator} class does not keep a cursor position and therefore will not give the previous element\n+     * when next was called before, or give the next element when previous was called before. This iterator will always\n+     * go to previous/next.\n+     */\n+    private static class UpnpIterator<T> {\n+        private final ListIterator<T> listIterator;\n+\n+        private boolean nextWasCalled = false;\n+        private boolean previousWasCalled = false;\n+\n+        public UpnpIterator(ListIterator<T> listIterator) {\n+            this.listIterator = listIterator;\n+        }\n+\n+        public T next() {\n+            if (previousWasCalled) {\n+                previousWasCalled = false;\n+                listIterator.next();\n+            }\n+            nextWasCalled = true;\n+            return listIterator.next();\n+        }\n+\n+        public T previous() {\n+            if (nextWasCalled) {\n+                nextWasCalled = false;\n+                listIterator.previous();\n+            }\n+            previousWasCalled = true;\n+            return listIterator.previous();\n+        }\n+\n+        public boolean hasNext() {\n+            if (previousWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasNext();\n+            }\n+        }\n+\n+        public boolean hasPrevious() {\n+            if (previousIndex() < 0) {\n+                return false;\n+            } else if (nextWasCalled) {\n+                return true;\n+            } else {\n+                return listIterator.hasPrevious();\n+            }\n+        }\n+\n+        public int nextIndex() {\n+            if (previousWasCalled) {\n+                return listIterator.nextIndex() + 1;\n+            } else {\n+                return listIterator.nextIndex();\n+            }\n+        }\n+\n+        public int previousIndex() {\n+            if (nextWasCalled) {\n+                return listIterator.previousIndex() - 1;\n+            } else {\n+                return listIterator.previousIndex();\n+            }\n+        }\n+    }\n+\n+    public UpnpRendererHandler(Thing thing, UpnpIOService upnpIOService, UpnpAudioSinkReg audioSinkReg) {\n+        super(thing, upnpIOService);\n+\n+        this.audioSinkReg = audioSinkReg;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media renderer device {}\", thing.getLabel());\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initRenderer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelSubscriptionRefreshJob();\n+        removeSubscription(\"AVTransport\");\n+\n+        cancelTrackPositionRefresh();\n+\n+        super.dispose();\n+    }\n+\n+    private void cancelSubscriptionRefreshJob() {\n+        ScheduledFuture<?> refreshJob = subscriptionRefreshJob;\n+\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+        }\n+        subscriptionRefreshJob = null;\n+\n+        upnpSubscribed = false;\n+    }\n+\n+    private void initRenderer() {\n+        if (!upnpSubscribed) {\n+            addSubscription(\"AVTransport\", SUBSCRIPTION_DURATION_SECONDS);\n+            upnpSubscribed = true;\n+\n+            subscriptionRefreshJob = scheduler.scheduleWithFixedDelay(subscriptionRefresh,\n+                    SUBSCRIPTION_DURATION_SECONDS / 2, SUBSCRIPTION_DURATION_SECONDS / 2, TimeUnit.SECONDS);\n+        }\n+        getProtocolInfo();\n+        getTransportState();\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Invoke Stop on UPnP AV Transport.\n+     */\n+    public void stop() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Stop\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Play on UPnP AV Transport.\n+     */\n+    public void play() {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"Speed\", \"1\");\n+\n+        invokeAction(\"AVTransport\", \"Play\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Pause on UPnP AV Transport.\n+     */\n+    public void pause() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Pause\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Next on UPnP AV Transport.\n+     */\n+    protected void next() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Next\", inputs);\n+    }\n+\n+    /**\n+     * Invoke Previous on UPnP AV Transport.\n+     */\n+    protected void previous() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"Previous\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param URI\n+     * @param URIMetaData\n+     */\n+    public void setCurrentURI(String URI, String URIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"CurrentURI\", URI);\n+            inputs.put(\"CurrentURIMetaData\", URIMetaData);\n+\n+            invokeAction(\"AVTransport\", \"SetAVTransportURI\", inputs);\n+        } catch (NumberFormatException ex) {\n+            logger.debug(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Invoke SetNextAVTransportURI on UPnP AV Transport.\n+     *\n+     * @param nextURI\n+     * @param nextURIMetaData\n+     */\n+    public void setNextURI(String nextURI, String nextURIMetaData) {\n+        Map<String, String> inputs = new HashMap<>();\n+        try {\n+            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+            inputs.put(\"NextURI\", nextURI);\n+            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+\n+            invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n+        } catch (NumberFormatException ex) {\n+            logger.debug(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Retrieves the current audio channel ('Master' by default).\n+     *\n+     * @return current audio channel\n+     */\n+    public String getCurrentChannel() {\n+        return UPNP_CHANNEL;\n+    }\n+\n+    /**\n+     * Retrieves the current volume known to the control point, gets updated by GENA events or after UPnP Rendering\n+     * Control GetVolume call. This method is used to retrieve volume by {@link UpnpAudioSink.getVolume}.\n+     *\n+     * @return current volume\n+     */\n+    public PercentType getCurrentVolume() {\n+        return soundVolume;\n+    }\n+\n+    /**\n+     * Invoke GetVolume on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getVolume(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetVolume on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param volume\n+     */\n+    public void setVolume(String channel, PercentType volume) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredVolume\", String.valueOf(volume.intValue()));\n+\n+        invokeAction(\"RenderingControl\", \"SetVolume\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getMute(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setMute(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getPositionInfo on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getPositionInfo() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+\n+        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String transportState;\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    getVolume(getCurrentChannel());\n+                    break;\n+                case MUTE:\n+                    getMute(getCurrentChannel());\n+                    break;\n+                case CONTROL:\n+                    transportState = this.transportState;\n+                    State newState = UnDefType.UNDEF;\n+                    if (\"PLAYING\".equals(transportState)) {\n+                        newState = PlayPauseType.PLAY;\n+                    } else if (\"STOPPED\".equals(transportState)) {\n+                        newState = PlayPauseType.PAUSE;\n+                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n+                        newState = PlayPauseType.PAUSE;\n+                    }\n+                    updateState(channelUID, newState);\n+                    break;\n+            }\n+            return;\n+        } else {\n+            switch (channelUID.getId()) {\n+                case VOLUME:\n+                    setVolume(getCurrentChannel(), (PercentType) command);\n+                    break;\n+                case MUTE:\n+                    setMute(getCurrentChannel(), (OnOffType) command);\n+                    break;\n+                case STOP:\n+                    if (command == OnOffType.ON) {\n+                        updateState(CONTROL, PlayPauseType.PAUSE);\n+                        playerStopped = true;\n+                        stop();\n+                        updateState(TRACK_POSITION, StringType.valueOf(\"00:00:00\"));\n+                    }\n+                    break;\n+                case CONTROL:\n+                    playerStopped = false;\n+                    if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            play();\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            pause();\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            playerStopped = true;\n+                            serveNext();\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            playerStopped = true;\n+                            servePrevious();\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                    }\n+                    break;\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void onStatusChanged(boolean status) {\n+        logger.debug(\"Renderer status changed to {}\", status);\n+        if (status) {\n+            initRenderer();\n+        } else {\n+            cancelSubscriptionRefreshJob();\n+\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Communication lost with \" + thing.getLabel());\n+        }\n+        super.onStatusChanged(status);\n+    }\n+\n+    @Override\n+    public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n+        if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n+                || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n+                || \"TrackDuration\".equals(variable))) {\n+            // don't log all variables received when updating the track position every second\n+            logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                    variable, value, service);\n+        }\n+        if (variable == null) {\n+            return;\n+        }\n+\n+        switch (variable) {\n+            case \"CurrentMute\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundMute = OnOffType.from(Boolean.parseBoolean(value));\n+                    updateState(MUTE, soundMute);\n+                }\n+                break;\n+            case \"CurrentVolume\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    soundVolume = PercentType.valueOf(value);\n+                    updateState(VOLUME, soundVolume);\n+                }\n+                break;\n+            case \"Sink\":\n+                if (!((value == null) || (value.isEmpty()))) {\n+                    updateProtocolInfo(value);\n+                }\n+                break;\n+            case \"LastChange\":\n+                // pre-process some variables, eg XML processing\n+                if (!((value == null) || value.isEmpty())) {\n+                    if (\"AVTransport\".equals(service) && \"LastChange\".equals(variable)) {\n+                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                        for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n+                            // Update the transport state after the update of the media information\n+                            // to not break the notification mechanism\n+                            if (!\"TransportState\".equals(entrySet.getKey())) {\n+                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n+                            }\n+                            if (\"AVTransportURI\".equals(entrySet.getKey())) {\n+                                onValueReceived(\"CurrentTrackURI\", entrySet.getValue(), service);\n+                            } else if (\"AVTransportURIMetaData\".equals(entrySet.getKey())) {\n+                                onValueReceived(\"CurrentTrackMetaData\", entrySet.getValue(), service);\n+                            }\n+                        }\n+                        if (parsedValues.get(\"TransportState\") != null) {", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452410265", "bodyText": "Are you aware that volatile doesn't make it synchronized? If I see correctly, onValueReceived() can be invoked concurrently, so these should be synchronized.", "author": "fwolter", "createdAt": "2020-07-09T18:28:14Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -0,0 +1,866 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.audio.AudioFormat;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSink;\n+import org.openhab.binding.upnpcontrol.internal.UpnpAudioSinkReg;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpRendererHandler} is responsible for handling commands sent to the UPnP Renderer. It extends\n+ * {@link UpnpHandler} with UPnP renderer specific logic.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpRendererHandler extends UpnpHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n+\n+    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n+\n+    // UPnP protocol pattern\n+    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n+\n+    private volatile boolean audioSupport;\n+    protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n+    private volatile boolean audioSinkRegistered;\n+\n+    private volatile UpnpAudioSinkReg audioSinkReg;\n+\n+    private volatile boolean upnpSubscribed;\n+\n+    private static final String UPNP_CHANNEL = \"Master\";\n+\n+    private volatile OnOffType soundMute = OnOffType.OFF;\n+    private volatile PercentType soundVolume = new PercentType();\n+    private volatile List<String> sink = new ArrayList<>();\n+\n+    private volatile ArrayList<UpnpEntry> currentQueue = new ArrayList<>();", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2NTc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453365776", "bodyText": "I am aware of this. But I am not good at it at all and always struggle to know where and how to use synchronization. I had not run into issues so far, so ignored it. I probably should not have.\nonValueReceived could indeed, in theory, be called concurrently. However, each call would come from a media server and/or renderer device in sequence, so in practice, I have not seen issues so far.\nHow could I best proceed?", "author": "mherwege", "createdAt": "2020-07-12T21:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5MjE2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453892160", "bodyText": "If an object can be modified while another thread reads/writes it, the operation shall be thread-safe, although if it's very unlikely the two threads accessing the same resource concurrently. You could write the following to make it thread-safe:\nprivate ArrayList<UpnpEntry> currentQueue = Collections.synchronizedList(new ArrayList<>());\n\nThe volatile can be omitted, since the reference currentQueue is only set during class initialization.\nIf you loop over the list, the whole operation shall be synchronized:\nsynchronized (currentQueue) {\n   currentQueue.forEach(...);\n}", "author": "fwolter", "createdAt": "2020-07-13T19:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEyMzY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r454123681", "bodyText": "@fwolter Thank you for this explanation.\nWhen I look at the specific example, currentQueue is actually not only set during class initialization. In the class initialization, it is just initialized with an empty ArrayList default. It actually is set in the registerQueue method (L696 of UpnpRendererHandler), where a new queue is passed in and completely replaces the previous one. No writes are done inside the currentQueue anywhere in the code, except full replacement of the full queue. All the rest is only reads. Do I still need synchronization for this? That's also why I think volatile is required.\nI am going through the code again and looking for other potential synchronization issues.", "author": "mherwege", "createdAt": "2020-07-14T06:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxODMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r456018336", "bodyText": "Your arguments are correct. Synchronization is not needed, then, and volatile is ok.", "author": "fwolter", "createdAt": "2020-07-16T19:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMTE3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452411176", "bodyText": "Can these be removed?", "author": "fwolter", "createdAt": "2020-07-09T18:29:50Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) ChannelUID rendererChannelUID;\n+    private @NonNullByDefault({}) ChannelUID currentTitleChannelUID;\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMjM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452412377", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-07-09T18:32:10Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) ChannelUID rendererChannelUID;\n+    private @NonNullByDefault({}) ChannelUID currentTitleChannelUID;\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile List<UpnpEntry> entries = new ArrayList<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    protected UpnpControlServerConfiguration config = getConfigAs(UpnpControlServerConfiguration.class);", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMzE4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452413189", "bodyText": "getChannel() can return null. Same for below.", "author": "fwolter", "createdAt": "2020-07-09T18:33:42Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) ChannelUID rendererChannelUID;\n+    private @NonNullByDefault({}) ChannelUID currentTitleChannelUID;\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile List<UpnpEntry> entries = new ArrayList<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    protected UpnpControlServerConfiguration config = getConfigAs(UpnpControlServerConfiguration.class);\n+\n+    public UpnpServerHandler(Thing thing, UpnpIOService upnpIOService,\n+            ConcurrentMap<String, UpnpRendererHandler> upnpRenderers,\n+            UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider,\n+            UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider) {\n+        super(thing, upnpIOService);\n+        this.upnpRenderers = upnpRenderers;\n+        this.upnpStateDescriptionProvider = upnpStateDescriptionProvider;\n+        this.upnpCommandDescriptionProvider = upnpCommandDescriptionProvider;\n+\n+        // put root as highest level in parent map\n+        parentMap.put(currentEntry.getId(), currentEntry);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media server device {}\", thing.getLabel());\n+\n+        rendererChannelUID = thing.getChannel(UPNPRENDERER).getUID();\n+        currentTitleChannelUID = thing.getChannel(BROWSE).getUID();", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2MjAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453362019", "bodyText": "@fwolter These channels are statically defined in the thing-types.xml file. According to the method declaration, they would only return null if no channel with the ID exists. Can there be a situation where the statically defined channel does not exist yet at this point in the code? Wouldn't that be an error in OH core?", "author": "mherwege", "createdAt": "2020-07-12T20:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3OTE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r453879191", "bodyText": "It will return null if one of these Channels would be renamed or removed in further versions and the user wants to continue using his Things.", "author": "fwolter", "createdAt": "2020-07-13T19:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDExNDkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r454114932", "bodyText": "OK. I changed it. But wouldn't the same argument apply when calling updateState(String, String) where the first argument is the channel ID string? I don't do a check in that case either.", "author": "mherwege", "createdAt": "2020-07-14T05:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNjQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r456016429", "bodyText": "Calling updateState(String, String) on a non-existent ChannelUID is safe. See org.eclipse.smarthome.core.thing.internal.CommunicationManager:483.", "author": "fwolter", "createdAt": "2020-07-16T19:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r452414013", "bodyText": "It's bad practice to catch unchecked exceptions. You could use ifPresent() to execute the code in a lambda or isPresent() to check via an if.", "author": "fwolter", "createdAt": "2020-07-09T18:35:20Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.handler;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.CommandDescription;\n+import org.eclipse.smarthome.core.types.CommandDescriptionBuilder;\n+import org.eclipse.smarthome.core.types.CommandOption;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.StateDescription;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\n+import org.openhab.binding.upnpcontrol.internal.UpnpControlHandlerFactory;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpEntry;\n+import org.openhab.binding.upnpcontrol.internal.UpnpProtocolMatcher;\n+import org.openhab.binding.upnpcontrol.internal.UpnpXMLParser;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UpnpServerHandler} is responsible for handling commands sent to the UPnP Server.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ * @author Karel Goderis - Based on UPnP logic in Sonos binding\n+ */\n+@NonNullByDefault\n+public class UpnpServerHandler extends UpnpHandler {\n+\n+    private static final String DIRECTORY_ROOT = \"0\";\n+    private static final String UP = \"..\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpServerHandler.class);\n+\n+    private ConcurrentMap<String, UpnpRendererHandler> upnpRenderers;\n+    private volatile @Nullable UpnpRendererHandler currentRendererHandler;\n+    private volatile List<StateOption> rendererStateOptionList = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) ChannelUID rendererChannelUID;\n+    private @NonNullByDefault({}) ChannelUID currentTitleChannelUID;\n+\n+    private volatile int numberReturned;\n+    private volatile int totalMatches;\n+\n+    private volatile UpnpEntry currentEntry = new UpnpEntry(DIRECTORY_ROOT, DIRECTORY_ROOT, DIRECTORY_ROOT,\n+            \"object.container\");\n+    private volatile List<UpnpEntry> entries = new ArrayList<>(); // current entry list in selection\n+    private volatile Map<String, UpnpEntry> parentMap = new HashMap<>(); // store parents in hierarchy separately to be\n+                                                                         // able to move up in directory structure\n+\n+    private List<String> source = new ArrayList<>();\n+\n+    private UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider;\n+    private UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider;\n+\n+    protected UpnpControlServerConfiguration config = getConfigAs(UpnpControlServerConfiguration.class);\n+\n+    public UpnpServerHandler(Thing thing, UpnpIOService upnpIOService,\n+            ConcurrentMap<String, UpnpRendererHandler> upnpRenderers,\n+            UpnpDynamicStateDescriptionProvider upnpStateDescriptionProvider,\n+            UpnpDynamicCommandDescriptionProvider upnpCommandDescriptionProvider) {\n+        super(thing, upnpIOService);\n+        this.upnpRenderers = upnpRenderers;\n+        this.upnpStateDescriptionProvider = upnpStateDescriptionProvider;\n+        this.upnpCommandDescriptionProvider = upnpCommandDescriptionProvider;\n+\n+        // put root as highest level in parent map\n+        parentMap.put(currentEntry.getId(), currentEntry);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"Initializing handler for media server device {}\", thing.getLabel());\n+\n+        rendererChannelUID = thing.getChannel(UPNPRENDERER).getUID();\n+        currentTitleChannelUID = thing.getChannel(BROWSE).getUID();\n+\n+        if (config.udn != null) {\n+            if (service.isRegistered(this)) {\n+                initServer();\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Communication cannot be established with \" + thing.getLabel());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"No UDN configured for \" + thing.getLabel());\n+        }\n+    }\n+\n+    private void initServer() {\n+        rendererStateOptionList = new ArrayList<>();\n+        upnpRenderers.forEach((key, value) -> {\n+            StateOption stateOption = new StateOption(key, value.getThing().getLabel());\n+            rendererStateOptionList.add(stateOption);\n+        });\n+        updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+\n+        getProtocolInfo();\n+\n+        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", config.sortcriteria);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on server {}\", command, channelUID, thing.getLabel());\n+\n+        switch (channelUID.getId()) {\n+            case UPNPRENDERER:\n+                if (command instanceof StringType) {\n+                    currentRendererHandler = (upnpRenderers.get(((StringType) command).toString()));\n+                    if (config.filter) {\n+                        // only refresh title list if filtering by renderer capabilities\n+                        browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", config.sortcriteria);\n+                    }\n+                } else if ((command instanceof RefreshType) && (currentRendererHandler != null)) {\n+                    updateState(channelUID, StringType.valueOf(currentRendererHandler.getThing().getLabel()));\n+                }\n+                break;\n+            case CURRENTID:\n+                String currentId = \"\";\n+                if (command instanceof StringType) {\n+                    currentId = String.valueOf(command);\n+                } else if (command instanceof RefreshType) {\n+                    currentId = currentEntry.getId();\n+                    updateState(channelUID, StringType.valueOf(currentId));\n+                }\n+                logger.debug(\"Setting currentId to {}\", currentId);\n+                if (!currentId.isEmpty()) {\n+                    browse(currentId, \"BrowseDirectChildren\", \"*\", \"0\", \"0\", config.sortcriteria);\n+                }\n+            case BROWSE:\n+                if (command instanceof StringType) {\n+                    String browseTarget = command.toString();\n+                    if (browseTarget != null) {\n+                        if (!UP.equals(browseTarget)) {\n+                            final String target = browseTarget;\n+                            try {\n+                                currentEntry = entries.stream().filter(entry -> target.equals(entry.getId()))\n+                                        .findFirst().get();\n+                            } catch (NoSuchElementException e) {", "originalCommit": "4d1f60e91aa0b7310f14ff1f0bb25b140ef52697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwOTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r462509502", "bodyText": "Do you mean break?", "author": "fwolter", "createdAt": "2020-07-29T18:41:28Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -244,11 +246,23 @@ public void stop() {\n      * Invoke Play on UPnP AV Transport.\n      */\n     public void play() {\n-        Map<String, String> inputs = new HashMap<>();\n-        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n-        inputs.put(\"Speed\", \"1\");\n+        // wait for maximum 1s until the media URI is set before playing\n+        for (int i = 0; isSettingURI && (i < 4); i++) {\n+            try {\n+                Thread.sleep(250);\n+            } catch (InterruptedException e) {\n+                continue;", "originalCommit": "7df833f5ca1125e994812680db625da3200dde4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzODcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r467138705", "bodyText": "Yes. But I now solved it differently with a CompletableFuture.", "author": "mherwege", "createdAt": "2020-08-07T16:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwOTUwMg=="}], "type": "inlineReview"}, {"oid": "9b71da7a6ee17ab97bc4ca5d255e3ab76c27b136", "url": "https://github.com/openhab/openhab-addons/commit/9b71da7a6ee17ab97bc4ca5d255e3ab76c27b136", "message": "Update version.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T06:42:45Z", "type": "forcePushed"}, {"oid": "6238e12eb63f76f220ebcefdab10e1bdd87abb18", "url": "https://github.com/openhab/openhab-addons/commit/6238e12eb63f76f220ebcefdab10e1bdd87abb18", "message": "Initial implementation uPnP control point.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:44:53Z", "type": "commit"}, {"oid": "a5e49fdf03aaf805d2c29ca5bf3312b07731f3cc", "url": "https://github.com/openhab/openhab-addons/commit/a5e49fdf03aaf805d2c29ca5bf3312b07731f3cc", "message": "First implementation content browser\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:07Z", "type": "commit"}, {"oid": "6dbd257ee5f61d429ed03533239491c2bf8ceef7", "url": "https://github.com/openhab/openhab-addons/commit/6dbd257ee5f61d429ed03533239491c2bf8ceef7", "message": "Fix audio sink not registered. Rename binding to upnpcontrol.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:19Z", "type": "commit"}, {"oid": "19bd19498f82be0b8ae46e601f4ea1cd329875a8", "url": "https://github.com/openhab/openhab-addons/commit/19bd19498f82be0b8ae46e601f4ea1cd329875a8", "message": "Interface for audio sink registration.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:27Z", "type": "commit"}, {"oid": "4ccc3276b5fce90bbeb8040dab1fd9310b1de3dd", "url": "https://github.com/openhab/openhab-addons/commit/4ccc3276b5fce90bbeb8040dab1fd9310b1de3dd", "message": "Fine tuning.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:36Z", "type": "commit"}, {"oid": "087800e0ca7724b709c736f367425413cdf729cc", "url": "https://github.com/openhab/openhab-addons/commit/087800e0ca7724b709c736f367425413cdf729cc", "message": "Improve logging.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:43Z", "type": "commit"}, {"oid": "cfdaa0320dba09ae86f7d624ea988b373166c20a", "url": "https://github.com/openhab/openhab-addons/commit/cfdaa0320dba09ae86f7d624ea988b373166c20a", "message": "Small code check corrections.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:45:52Z", "type": "commit"}, {"oid": "ae4cc374e9acf01da7a404fc09a1aae3ea1a781f", "url": "https://github.com/openhab/openhab-addons/commit/ae4cc374e9acf01da7a404fc09a1aae3ea1a781f", "message": "Code analysis improvements.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:02Z", "type": "commit"}, {"oid": "18d738ddb9cb58c9ca42a779d464a4ca2bbc6be5", "url": "https://github.com/openhab/openhab-addons/commit/18d738ddb9cb58c9ca42a779d464a4ca2bbc6be5", "message": "Check sink response before setting audio.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:12Z", "type": "commit"}, {"oid": "b92d23ef8cbc6b7c09d24601bcefa8954b3e66f9", "url": "https://github.com/openhab/openhab-addons/commit/b92d23ef8cbc6b7c09d24601bcefa8954b3e66f9", "message": "Implement protocol matcher.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:22Z", "type": "commit"}, {"oid": "d584f2839a1317c2132415eff57c2dce16de88e8", "url": "https://github.com/openhab/openhab-addons/commit/d584f2839a1317c2132415eff57c2dce16de88e8", "message": "Initial commit server query.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:32Z", "type": "commit"}, {"oid": "08f13ae389675297e0b146a57bac4391ba8a2e44", "url": "https://github.com/openhab/openhab-addons/commit/08f13ae389675297e0b146a57bac4391ba8a2e44", "message": "Implemented directory search.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:43Z", "type": "commit"}, {"oid": "7707bfed3a89a9966a2a65109b5e916e0320f9d5", "url": "https://github.com/openhab/openhab-addons/commit/7707bfed3a89a9966a2a65109b5e916e0320f9d5", "message": "Correction channel refresh.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:46:50Z", "type": "commit"}, {"oid": "5db57cd0a31d51939e6175213dcf79f25e70c6c5", "url": "https://github.com/openhab/openhab-addons/commit/5db57cd0a31d51939e6175213dcf79f25e70c6c5", "message": "Added sorting, improvements in server browse and search.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:00Z", "type": "commit"}, {"oid": "557ae78c563dada46e37a2283524acc616b1fc2d", "url": "https://github.com/openhab/openhab-addons/commit/557ae78c563dada46e37a2283524acc616b1fc2d", "message": "Made size a Long.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:10Z", "type": "commit"}, {"oid": "c9027310ee934017cbe55225a717a64ee990458e", "url": "https://github.com/openhab/openhab-addons/commit/c9027310ee934017cbe55225a717a64ee990458e", "message": "Put unavailable device offline. Log empty xml.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:18Z", "type": "commit"}, {"oid": "3e0eca01eaf0c435dcc25dbadcb951cc314e94be", "url": "https://github.com/openhab/openhab-addons/commit/3e0eca01eaf0c435dcc25dbadcb951cc314e94be", "message": "Renderer fixes, improved java doc, added current track position.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:27Z", "type": "commit"}, {"oid": "1679c050dc940428d1a88b8aac2d34ef940c2c3d", "url": "https://github.com/openhab/openhab-addons/commit/1679c050dc940428d1a88b8aac2d34ef940c2c3d", "message": "No downloading of albumArt for empty URI.\nImproved logging.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:36Z", "type": "commit"}, {"oid": "4a95f745f4c85ea7052f6389706362596e70e608", "url": "https://github.com/openhab/openhab-addons/commit/4a95f745f4c85ea7052f6389706362596e70e608", "message": "Fix track position refresh.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:47:45Z", "type": "commit"}, {"oid": "11a686b6ac8e35d8185451b2b0bc32c4827edbcf", "url": "https://github.com/openhab/openhab-addons/commit/11a686b6ac8e35d8185451b2b0bc32c4827edbcf", "message": "Migrate to bnd.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:48:02Z", "type": "commit"}, {"oid": "97e2a18597b12966b2cdc27269d6516c5af050cc", "url": "https://github.com/openhab/openhab-addons/commit/97e2a18597b12966b2cdc27269d6516c5af050cc", "message": "Update license headers.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:48:19Z", "type": "commit"}, {"oid": "869b9b355e7d1e8bf3e063419241741a917776a3", "url": "https://github.com/openhab/openhab-addons/commit/869b9b355e7d1e8bf3e063419241741a917776a3", "message": "Improvements.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:48:32Z", "type": "commit"}, {"oid": "e20d245fc4d0468aa235119b091e8e66c8ce9400", "url": "https://github.com/openhab/openhab-addons/commit/e20d245fc4d0468aa235119b091e8e66c8ce9400", "message": "POM update.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:48:49Z", "type": "commit"}, {"oid": "2dfec38f8f2a01cf5ac7fcf6bfd8b20653a67789", "url": "https://github.com/openhab/openhab-addons/commit/2dfec38f8f2a01cf5ac7fcf6bfd8b20653a67789", "message": "Update license headers.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:49:06Z", "type": "commit"}, {"oid": "c16a8f2ae4b9c59ee9bbf6638a73dcfef63a8c9a", "url": "https://github.com/openhab/openhab-addons/commit/c16a8f2ae4b9c59ee9bbf6638a73dcfef63a8c9a", "message": "Correct null audiostream behavior.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:49:22Z", "type": "commit"}, {"oid": "253f7d8b853662299ec460b3adcdbf59f4f1686e", "url": "https://github.com/openhab/openhab-addons/commit/253f7d8b853662299ec460b3adcdbf59f4f1686e", "message": "Cleanup.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:49:37Z", "type": "commit"}, {"oid": "79b0430018eb6256520be985d15a11df7824104b", "url": "https://github.com/openhab/openhab-addons/commit/79b0430018eb6256520be985d15a11df7824104b", "message": "Fix Audiosink registration. Fix SAX exception.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:49:54Z", "type": "commit"}, {"oid": "098163ed3ecfb160d455f2191f692dc3e91478b0", "url": "https://github.com/openhab/openhab-addons/commit/098163ed3ecfb160d455f2191f692dc3e91478b0", "message": "Some cleanup.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:50:12Z", "type": "commit"}, {"oid": "e776cdc79754c1d6846d271a76f03973d0636360", "url": "https://github.com/openhab/openhab-addons/commit/e776cdc79754c1d6846d271a76f03973d0636360", "message": "Log upnp invoke action response.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:50:26Z", "type": "commit"}, {"oid": "a57dfc08593fcf60db0e08a1d7604eb80ba9780b", "url": "https://github.com/openhab/openhab-addons/commit/a57dfc08593fcf60db0e08a1d7604eb80ba9780b", "message": "Formatting updates.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:50:42Z", "type": "commit"}, {"oid": "c26d758d6577850323d0174fe9fa310c96c92d7c", "url": "https://github.com/openhab/openhab-addons/commit/c26d758d6577850323d0174fe9fa310c96c92d7c", "message": "Stop track position refresh when losing connection.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:50:58Z", "type": "commit"}, {"oid": "4aaa29f9beb78698fa5b0d751f47ea90a5f16736", "url": "https://github.com/openhab/openhab-addons/commit/4aaa29f9beb78698fa5b0d751f47ea90a5f16736", "message": "Used DynamicCommandDescriptionProvider where appropriate.\nPut selection in queue immediately upon selecting.\nReduced internal entryMap size by not keeping full hierarchy.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:10Z", "type": "commit"}, {"oid": "3a52f7f012bc178a8d1081be19a60331b245447f", "url": "https://github.com/openhab/openhab-addons/commit/3a52f7f012bc178a8d1081be19a60331b245447f", "message": "Added currentid channel on server.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:16Z", "type": "commit"}, {"oid": "9d2ccc0e6c3379704fe29cdfb689e83d3390b093", "url": "https://github.com/openhab/openhab-addons/commit/9d2ccc0e6c3379704fe29cdfb689e83d3390b093", "message": "Created README.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:24Z", "type": "commit"}, {"oid": "acd10a7007119790e5f1357e939f0c51dc347b2e", "url": "https://github.com/openhab/openhab-addons/commit/acd10a7007119790e5f1357e939f0c51dc347b2e", "message": "Corrections after code check.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:33Z", "type": "commit"}, {"oid": "6721ea4429252836f79425ba8df5ee05ba9e71c9", "url": "https://github.com/openhab/openhab-addons/commit/6721ea4429252836f79425ba8df5ee05ba9e71c9", "message": "Adjustments after review.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:41Z", "type": "commit"}, {"oid": "d189da9357833c62717c41833737de00c4fa9579", "url": "https://github.com/openhab/openhab-addons/commit/d189da9357833c62717c41833737de00c4fa9579", "message": "Fix code check issues.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:51:49Z", "type": "commit"}, {"oid": "9689af6923647f0ccc8c52e814a47d8634b121ba", "url": "https://github.com/openhab/openhab-addons/commit/9689af6923647f0ccc8c52e814a47d8634b121ba", "message": "Further adjustments after code review.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:52:00Z", "type": "commit"}, {"oid": "9dca9cafb922424823a58a0a645269dff3e83640", "url": "https://github.com/openhab/openhab-addons/commit/9dca9cafb922424823a58a0a645269dff3e83640", "message": "Addressed review comments.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:52:09Z", "type": "commit"}, {"oid": "566e37a6963ff4270a9e9221c03abaa00117f477", "url": "https://github.com/openhab/openhab-addons/commit/566e37a6963ff4270a9e9221c03abaa00117f477", "message": "Synchronization\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:52:19Z", "type": "commit"}, {"oid": "74986cd63dca3d7f6ed4f0b6024d12156eb7a9fb", "url": "https://github.com/openhab/openhab-addons/commit/74986cd63dca3d7f6ed4f0b6024d12156eb7a9fb", "message": "Fix playing of streams.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:52:37Z", "type": "commit"}, {"oid": "e8102a81991e5afb57ea56a3c7ead2132454635c", "url": "https://github.com/openhab/openhab-addons/commit/e8102a81991e5afb57ea56a3c7ead2132454635c", "message": "Always make received stop visible.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:52:55Z", "type": "commit"}, {"oid": "3d95b86bdeb5668340ae9ae0b14a3f35e3252ba1", "url": "https://github.com/openhab/openhab-addons/commit/3d95b86bdeb5668340ae9ae0b14a3f35e3252ba1", "message": "Replace wait loop with Future, make external pause signal visible.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T07:53:15Z", "type": "commit"}, {"oid": "28121f7c41528c1c1e6fb3c31fb25424321c1862", "url": "https://github.com/openhab/openhab-addons/commit/28121f7c41528c1c1e6fb3c31fb25424321c1862", "message": "Rebase.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T08:22:22Z", "type": "commit"}, {"oid": "28121f7c41528c1c1e6fb3c31fb25424321c1862", "url": "https://github.com/openhab/openhab-addons/commit/28121f7c41528c1c1e6fb3c31fb25424321c1862", "message": "Rebase.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T08:22:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2ODQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r467768497", "bodyText": "Typo?: ffward", "author": "martinvw", "createdAt": "2020-08-10T08:53:51Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,172 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"upnpcontrol\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<thing-type id=\"upnprenderer\">\n+\t\t<label>UPnPRenderer</label>\n+\t\t<description>UPnP AV Renderer</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"volume\" typeId=\"volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"mute\"/>\n+\t\t\t<channel id=\"control\" typeId=\"control\"/>\n+\t\t\t<channel id=\"stop\" typeId=\"stop\"/>\n+\t\t\t<channel id=\"title\" typeId=\"title\"/>\n+\t\t\t<channel id=\"album\" typeId=\"album\"/>\n+\t\t\t<channel id=\"albumart\" typeId=\"albumart\"/>\n+\t\t\t<channel id=\"creator\" typeId=\"creator\"/>\n+\t\t\t<channel id=\"artist\" typeId=\"artist\"/>\n+\t\t\t<channel id=\"publisher\" typeId=\"publisher\"/>\n+\t\t\t<channel id=\"genre\" typeId=\"genre\"/>\n+\t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n+\t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n+\t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\t<thing-type id=\"upnpserver\">\n+\t\t<label>UPnPServer</label>\n+\t\t<description>UPnP AV Server</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n+\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"browse\" typeId=\"browse\"/>\n+\t\t\t<channel id=\"search\" typeId=\"search\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Unique Device Name</label>\n+\t\t\t\t<description>The UDN identifies the UPnP Media Server</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"filter\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Filter Content</label>\n+\t\t\t\t<description>Only list content which is playable on the selected renderer</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>false</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sortcriteria\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Sort Criteria</label>\n+\t\t\t\t<description>Sort criteria for the titles in the selection list and when sending for playing to a renderer. The\n+\t\t\t\t\tcriteria are defined in UPnP sort criteria format. Examples: +dc:title, -dc:creator, +upnp:album. Supported sort\n+\t\t\t\t\tcriteria will depend on the media server</description>\n+\t\t\t\t<default>+dc:title</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel Types -->\n+\t<channel-type id=\"volume\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Volume</label>\n+\t\t<description>Set or get the master volume</description>\n+\t\t<category>SoundVolume</category>\n+\t</channel-type>\n+\t<channel-type id=\"mute\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Mute</label>\n+\t\t<description>Set or get the mute state</description>\n+\t</channel-type>\n+\t<channel-type id=\"control\">\n+\t\t<item-type>Player</item-type>\n+\t\t<label>Control</label>\n+\t\t<description>Control the player, e.g. start/stop/next/previous/ffward/rewind</description>", "originalCommit": "28121f7c41528c1c1e6fb3c31fb25424321c1862", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4MzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r467783672", "bodyText": "Abbreviation for fast forward, but looking at this again, a few of these channels should be replaced by their system state channel type, so I don't need this channel type definition. I will push a commit.", "author": "mherwege", "createdAt": "2020-08-10T09:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2ODQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4NzQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7941#discussion_r467787406", "bodyText": "NP, problem I was checking out your channel definitions for a modeling problem I was facing, good luck.", "author": "martinvw", "createdAt": "2020-08-10T09:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2ODQ5Nw=="}], "type": "inlineReview"}, {"oid": "e4a204a62d74fc9560968c98c465f544c311439f", "url": "https://github.com/openhab/openhab-addons/commit/e4a204a62d74fc9560968c98c465f544c311439f", "message": "Replace channel types by system channel type equivalents.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-10T09:26:40Z", "type": "commit"}, {"oid": "3661ccd5c2cf3c3fb729acbfe639fac22ad3b682", "url": "https://github.com/openhab/openhab-addons/commit/3661ccd5c2cf3c3fb729acbfe639fac22ad3b682", "message": "Formatting Fix.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-08-13T06:16:04Z", "type": "commit"}]}