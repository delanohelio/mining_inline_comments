{"pr_number": 8437, "pr_title": "[openwebnet] add support for WHO=2 Automation", "pr_createdAt": "2020-09-09T19:10:51Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8437", "timeline": [{"oid": "99f41014dac076f3e2175d04c2f0231fad9bde29", "url": "https://github.com/openhab/openhab-addons/commit/99f41014dac076f3e2175d04c2f0231fad9bde29", "message": "[openwebnet] add support for WHO=2 Automation, update openwebnet4j to 0.3.0. Fixes #8436\n\nSigned-off-by: Massimo Valla <mvcode00@gmail.com>", "committedDate": "2020-09-09T19:08:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MDk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485860948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n          \n          \n            \n                private static final SimpleDateFormat FORMATTER = new SimpleDateFormat(\"ss.SSS\");", "author": "Hilbrand", "createdAt": "2020-09-09T19:28:56Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MjU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485862573", "bodyText": "It's a user error and also set in the status so it should be log to debug.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n          \n          \n            \n                        logger.debug(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",", "author": "Hilbrand", "createdAt": "2020-09-09T19:31:04Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MzU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485863590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());\n          \n          \n            \n                                logger.debug(\"Unsupported command {} for thing {}\", command, thing.getUID());", "author": "Hilbrand", "createdAt": "2020-09-09T19:32:27Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n+                    OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN, AUTO_CALIBRATION);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"@text/offline.wrong-configuration\");\n+            shutterRun = SHUTTER_RUN_UNDEFINED;\n+        }\n+        updateState(CHANNEL_SHUTTER, UnDefType.UNDEF);\n+        positionEstimation = POSITION_UNKNOWN;\n+    }\n+\n+    @Override\n+    protected void requestChannelState(ChannelUID channel) {\n+        logger.debug(\"requestChannelState() thingUID={} channel={}\", thing.getUID(), channel.getId());\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            try {\n+                send(Automation.requestStatus(w.value()));\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while requesting channel {} state: {}\", channel, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleChannelCommand(ChannelUID channel, Command command) {\n+        switch (channel.getId()) {\n+            case CHANNEL_SHUTTER:\n+                handleShutterCommand(command);\n+                break;\n+            default: {\n+                logger.warn(\"Unsupported channel UID {}\", channel);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation Roller shutter command (UP/DOWN, STOP/MOVE, PERCENT xx%)\n+     */\n+    private void handleShutterCommand(Command command) {\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            calibrating = CALIBRATION_INACTIVE; // cancel calibration if we receive a command\n+            commandRequestedWhileMoving = null;\n+            try {\n+                if (StopMoveType.STOP.equals(command)) {\n+                    send(Automation.requestStop(w.value()));\n+                } else if (command instanceof UpDownType || command instanceof PercentType) {\n+                    if (movingState == MOVING_STATE_MOVING_UP || movingState == MOVING_STATE_MOVING_DOWN) { // already\n+                                                                                                            // moving\n+                        logger.debug(\"# {} # already moving, STOP then defer command\", deviceWhere);\n+                        commandRequestedWhileMoving = command;\n+                        sendHighPriority(Automation.requestStop(w.value()));\n+                        return;\n+                    } else {\n+                        if (command instanceof UpDownType) {\n+                            if (UpDownType.UP.equals(command)) {\n+                                send(Automation.requestMoveUp(w.value()));\n+                            } else {\n+                                send(Automation.requestMoveDown(w.value()));\n+                            }\n+                        } else if (command instanceof PercentType) {\n+                            handlePercentCommand((PercentType) command, w.value());\n+                        }\n+                    }\n+                } else {\n+                    logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NDE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485864157", "bodyText": "If this would indicate a problem with the binding you should also log the stacktrace:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n          \n          \n            \n                            logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage(), e);\n          \n      \n    \n    \n  \n\nAlso applies to other locations this similar log warning is done.", "author": "Hilbrand", "createdAt": "2020-09-09T19:33:17Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n+                    OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN, AUTO_CALIBRATION);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"@text/offline.wrong-configuration\");\n+            shutterRun = SHUTTER_RUN_UNDEFINED;\n+        }\n+        updateState(CHANNEL_SHUTTER, UnDefType.UNDEF);\n+        positionEstimation = POSITION_UNKNOWN;\n+    }\n+\n+    @Override\n+    protected void requestChannelState(ChannelUID channel) {\n+        logger.debug(\"requestChannelState() thingUID={} channel={}\", thing.getUID(), channel.getId());\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            try {\n+                send(Automation.requestStatus(w.value()));\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while requesting channel {} state: {}\", channel, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleChannelCommand(ChannelUID channel, Command command) {\n+        switch (channel.getId()) {\n+            case CHANNEL_SHUTTER:\n+                handleShutterCommand(command);\n+                break;\n+            default: {\n+                logger.warn(\"Unsupported channel UID {}\", channel);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation Roller shutter command (UP/DOWN, STOP/MOVE, PERCENT xx%)\n+     */\n+    private void handleShutterCommand(Command command) {\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            calibrating = CALIBRATION_INACTIVE; // cancel calibration if we receive a command\n+            commandRequestedWhileMoving = null;\n+            try {\n+                if (StopMoveType.STOP.equals(command)) {\n+                    send(Automation.requestStop(w.value()));\n+                } else if (command instanceof UpDownType || command instanceof PercentType) {\n+                    if (movingState == MOVING_STATE_MOVING_UP || movingState == MOVING_STATE_MOVING_DOWN) { // already\n+                                                                                                            // moving\n+                        logger.debug(\"# {} # already moving, STOP then defer command\", deviceWhere);\n+                        commandRequestedWhileMoving = command;\n+                        sendHighPriority(Automation.requestStop(w.value()));\n+                        return;\n+                    } else {\n+                        if (command instanceof UpDownType) {\n+                            if (UpDownType.UP.equals(command)) {\n+                                send(Automation.requestMoveUp(w.value()));\n+                            } else {\n+                                send(Automation.requestMoveDown(w.value()));\n+                            }\n+                        } else if (command instanceof PercentType) {\n+                            handlePercentCommand((PercentType) command, w.value());\n+                        }\n+                    }\n+                } else {\n+                    logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());\n+                }\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r486055984", "bodyText": "It may happen in case of communications problems with the gateway, so I lowered it to DEBUG", "author": "mvalla", "createdAt": "2020-09-10T04:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485865960", "bodyText": "Shouldn't this set the status to offline? The user should not have to look in the log to find out about the problem reported here,", "author": "Hilbrand", "createdAt": "2020-09-09T19:35:40Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n+                    OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN, AUTO_CALIBRATION);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"@text/offline.wrong-configuration\");\n+            shutterRun = SHUTTER_RUN_UNDEFINED;\n+        }\n+        updateState(CHANNEL_SHUTTER, UnDefType.UNDEF);\n+        positionEstimation = POSITION_UNKNOWN;\n+    }\n+\n+    @Override\n+    protected void requestChannelState(ChannelUID channel) {\n+        logger.debug(\"requestChannelState() thingUID={} channel={}\", thing.getUID(), channel.getId());\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            try {\n+                send(Automation.requestStatus(w.value()));\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while requesting channel {} state: {}\", channel, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleChannelCommand(ChannelUID channel, Command command) {\n+        switch (channel.getId()) {\n+            case CHANNEL_SHUTTER:\n+                handleShutterCommand(command);\n+                break;\n+            default: {\n+                logger.warn(\"Unsupported channel UID {}\", channel);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation Roller shutter command (UP/DOWN, STOP/MOVE, PERCENT xx%)\n+     */\n+    private void handleShutterCommand(Command command) {\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            calibrating = CALIBRATION_INACTIVE; // cancel calibration if we receive a command\n+            commandRequestedWhileMoving = null;\n+            try {\n+                if (StopMoveType.STOP.equals(command)) {\n+                    send(Automation.requestStop(w.value()));\n+                } else if (command instanceof UpDownType || command instanceof PercentType) {\n+                    if (movingState == MOVING_STATE_MOVING_UP || movingState == MOVING_STATE_MOVING_DOWN) { // already\n+                                                                                                            // moving\n+                        logger.debug(\"# {} # already moving, STOP then defer command\", deviceWhere);\n+                        commandRequestedWhileMoving = command;\n+                        sendHighPriority(Automation.requestStop(w.value()));\n+                        return;\n+                    } else {\n+                        if (command instanceof UpDownType) {\n+                            if (UpDownType.UP.equals(command)) {\n+                                send(Automation.requestMoveUp(w.value()));\n+                            } else {\n+                                send(Automation.requestMoveDown(w.value()));\n+                            }\n+                        } else if (command instanceof PercentType) {\n+                            handlePercentCommand((PercentType) command, w.value());\n+                        }\n+                    }\n+                } else {\n+                    logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());\n+                }\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation PERCENT xx% command\n+     */\n+    private void handlePercentCommand(PercentType command, String w) {\n+        int percent = command.intValue();\n+        if (percent == positionEstimation) {\n+            logger.debug(\"# {} # handlePercentCommand() Command {}% == positionEstimation -> nothing to do\", w,\n+                    percent);\n+            return;\n+        }\n+        try {\n+            if (percent == POSITION_DOWN) { // GO TO 100%\n+                send(Automation.requestMoveDown(w));\n+            } else if (percent == POSITION_UP) { // GO TO 0%\n+                send(Automation.requestMoveUp(w));\n+            } else { // GO TO XX%\n+                logger.debug(\"# {} # {}% requested\", deviceWhere, percent);\n+                if (shutterRun == SHUTTER_RUN_UNDEFINED) {\n+                    logger.debug(\"& {} & CALIBRATION - shutterRun not configured, starting CALIBRATION...\",\n+                            deviceWhere);\n+                    calibrating = CALIBRATION_ACTIVATED;\n+                    send(Automation.requestMoveUp(w));\n+                    positionRequested = percent;\n+                } else if (shutterRun > 0 && positionEstimation != POSITION_UNKNOWN) {\n+                    // these two must be known to calculate moveTime.\n+                    // Calculate how much time we have to move and set a deadline to stop after that time\n+                    int moveTime = Math\n+                            .round(((float) Math.abs(percent - positionEstimation) / POSITION_MAX_STEPS * shutterRun));\n+                    logger.debug(\"# {} # target moveTime={}\", deviceWhere, moveTime);\n+                    if (moveTime > MIN_STEP_TIME_MSEC) {\n+                        ScheduledFuture<?> mSch = moveSchedule;\n+                        if (mSch != null && !mSch.isDone()) {\n+                            // a moveSchedule was already scheduled and is not done... let's cancel the schedule\n+                            mSch.cancel(false);\n+                            logger.warn(\"# {} # new XX% requested, old moveSchedule cancelled\", deviceWhere);\n+                        }\n+                        // send a requestFirmwareVersion message to BUS gateways to wake up the CMD connection before\n+                        // sending further cmds\n+                        OpenWebNetBridgeHandler h = bridgeHandler;\n+                        if (h != null && h.isBusGateway()) {\n+                            OpenGateway gw = h.gateway;\n+                            if (gw != null) {\n+                                if (!gw.isCmdConnectionReady()) {\n+                                    logger.debug(\"# {} # waking-up CMD connection...\", deviceWhere);\n+                                    send(GatewayMgmt.requestFirmwareVersion());\n+                                }\n+                            }\n+                        }\n+                        // REMINDER: start the schedule BEFORE sending the command, because the synch command waits for\n+                        // ACK and can take some 300ms\n+                        logger.debug(\"# {} # Starting schedule...\", deviceWhere);\n+                        moveSchedule = scheduler.schedule(() -> {\n+                            logger.debug(\"# {} # moveSchedule expired, sending STOP...\", deviceWhere);\n+                            try {\n+                                sendHighPriority(Automation.requestStop(w));\n+                            } catch (OWNException ex) {\n+                                logger.warn(\"Exception while sending request for command {}: {}\", command,\n+                                        ex.getMessage());\n+                            }\n+                        }, moveTime, TimeUnit.MILLISECONDS);\n+                        logger.debug(\"# {} # ...schedule started, now sending highPriority command...\", deviceWhere);\n+                        if (percent < positionEstimation) {\n+                            sendHighPriority(Automation.requestMoveUp(w));\n+                        } else {\n+                            sendHighPriority(Automation.requestMoveDown(w));\n+                        }\n+                        logger.debug(\"# {} # ...gateway.sendHighPriority() returned\", deviceWhere);\n+                    } else {\n+                        logger.debug(\"# {} # moveTime <= MIN_STEP_TIME_MSEC ---> do nothing\", deviceWhere);\n+                    }\n+                } else {\n+                    logger.info(", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MTcwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r486061708", "bodyText": "In fact no: the Thing can still be used for UP/DOWN commands, but a POSITION% command cannot be executed until shutterRun config param is set correctly (>=1000) or the position of the shutter becomes known, for example by rolling it fully up/down. So I would not put the Thing offline, but just give using INFO this information so the user can check it.", "author": "mvalla", "createdAt": "2020-09-10T04:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NjM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485866340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            configuration.put(org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN,\n          \n          \n            \n                            configuration.put(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN,", "author": "Hilbrand", "createdAt": "2020-09-09T19:36:09Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n+                    OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN, AUTO_CALIBRATION);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"@text/offline.wrong-configuration\");\n+            shutterRun = SHUTTER_RUN_UNDEFINED;\n+        }\n+        updateState(CHANNEL_SHUTTER, UnDefType.UNDEF);\n+        positionEstimation = POSITION_UNKNOWN;\n+    }\n+\n+    @Override\n+    protected void requestChannelState(ChannelUID channel) {\n+        logger.debug(\"requestChannelState() thingUID={} channel={}\", thing.getUID(), channel.getId());\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            try {\n+                send(Automation.requestStatus(w.value()));\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while requesting channel {} state: {}\", channel, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleChannelCommand(ChannelUID channel, Command command) {\n+        switch (channel.getId()) {\n+            case CHANNEL_SHUTTER:\n+                handleShutterCommand(command);\n+                break;\n+            default: {\n+                logger.warn(\"Unsupported channel UID {}\", channel);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation Roller shutter command (UP/DOWN, STOP/MOVE, PERCENT xx%)\n+     */\n+    private void handleShutterCommand(Command command) {\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            calibrating = CALIBRATION_INACTIVE; // cancel calibration if we receive a command\n+            commandRequestedWhileMoving = null;\n+            try {\n+                if (StopMoveType.STOP.equals(command)) {\n+                    send(Automation.requestStop(w.value()));\n+                } else if (command instanceof UpDownType || command instanceof PercentType) {\n+                    if (movingState == MOVING_STATE_MOVING_UP || movingState == MOVING_STATE_MOVING_DOWN) { // already\n+                                                                                                            // moving\n+                        logger.debug(\"# {} # already moving, STOP then defer command\", deviceWhere);\n+                        commandRequestedWhileMoving = command;\n+                        sendHighPriority(Automation.requestStop(w.value()));\n+                        return;\n+                    } else {\n+                        if (command instanceof UpDownType) {\n+                            if (UpDownType.UP.equals(command)) {\n+                                send(Automation.requestMoveUp(w.value()));\n+                            } else {\n+                                send(Automation.requestMoveDown(w.value()));\n+                            }\n+                        } else if (command instanceof PercentType) {\n+                            handlePercentCommand((PercentType) command, w.value());\n+                        }\n+                    }\n+                } else {\n+                    logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());\n+                }\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation PERCENT xx% command\n+     */\n+    private void handlePercentCommand(PercentType command, String w) {\n+        int percent = command.intValue();\n+        if (percent == positionEstimation) {\n+            logger.debug(\"# {} # handlePercentCommand() Command {}% == positionEstimation -> nothing to do\", w,\n+                    percent);\n+            return;\n+        }\n+        try {\n+            if (percent == POSITION_DOWN) { // GO TO 100%\n+                send(Automation.requestMoveDown(w));\n+            } else if (percent == POSITION_UP) { // GO TO 0%\n+                send(Automation.requestMoveUp(w));\n+            } else { // GO TO XX%\n+                logger.debug(\"# {} # {}% requested\", deviceWhere, percent);\n+                if (shutterRun == SHUTTER_RUN_UNDEFINED) {\n+                    logger.debug(\"& {} & CALIBRATION - shutterRun not configured, starting CALIBRATION...\",\n+                            deviceWhere);\n+                    calibrating = CALIBRATION_ACTIVATED;\n+                    send(Automation.requestMoveUp(w));\n+                    positionRequested = percent;\n+                } else if (shutterRun > 0 && positionEstimation != POSITION_UNKNOWN) {\n+                    // these two must be known to calculate moveTime.\n+                    // Calculate how much time we have to move and set a deadline to stop after that time\n+                    int moveTime = Math\n+                            .round(((float) Math.abs(percent - positionEstimation) / POSITION_MAX_STEPS * shutterRun));\n+                    logger.debug(\"# {} # target moveTime={}\", deviceWhere, moveTime);\n+                    if (moveTime > MIN_STEP_TIME_MSEC) {\n+                        ScheduledFuture<?> mSch = moveSchedule;\n+                        if (mSch != null && !mSch.isDone()) {\n+                            // a moveSchedule was already scheduled and is not done... let's cancel the schedule\n+                            mSch.cancel(false);\n+                            logger.warn(\"# {} # new XX% requested, old moveSchedule cancelled\", deviceWhere);\n+                        }\n+                        // send a requestFirmwareVersion message to BUS gateways to wake up the CMD connection before\n+                        // sending further cmds\n+                        OpenWebNetBridgeHandler h = bridgeHandler;\n+                        if (h != null && h.isBusGateway()) {\n+                            OpenGateway gw = h.gateway;\n+                            if (gw != null) {\n+                                if (!gw.isCmdConnectionReady()) {\n+                                    logger.debug(\"# {} # waking-up CMD connection...\", deviceWhere);\n+                                    send(GatewayMgmt.requestFirmwareVersion());\n+                                }\n+                            }\n+                        }\n+                        // REMINDER: start the schedule BEFORE sending the command, because the synch command waits for\n+                        // ACK and can take some 300ms\n+                        logger.debug(\"# {} # Starting schedule...\", deviceWhere);\n+                        moveSchedule = scheduler.schedule(() -> {\n+                            logger.debug(\"# {} # moveSchedule expired, sending STOP...\", deviceWhere);\n+                            try {\n+                                sendHighPriority(Automation.requestStop(w));\n+                            } catch (OWNException ex) {\n+                                logger.warn(\"Exception while sending request for command {}: {}\", command,\n+                                        ex.getMessage());\n+                            }\n+                        }, moveTime, TimeUnit.MILLISECONDS);\n+                        logger.debug(\"# {} # ...schedule started, now sending highPriority command...\", deviceWhere);\n+                        if (percent < positionEstimation) {\n+                            sendHighPriority(Automation.requestMoveUp(w));\n+                        } else {\n+                            sendHighPriority(Automation.requestMoveDown(w));\n+                        }\n+                        logger.debug(\"# {} # ...gateway.sendHighPriority() returned\", deviceWhere);\n+                    } else {\n+                        logger.debug(\"# {} # moveTime <= MIN_STEP_TIME_MSEC ---> do nothing\", deviceWhere);\n+                    }\n+                } else {\n+                    logger.info(\n+                            \"Command {} cannot be executed: unknown position or shutterRun configuration params not set (thing={})\",\n+                            command, thing.getUID());\n+                }\n+            }\n+        } catch (OWNException e) {\n+            logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected String ownIdPrefix() {\n+        return Who.AUTOMATION.value().toString();\n+    }\n+\n+    @Override\n+    protected void handleMessage(BaseOpenMessage msg) {\n+        updateAutomationState((Automation) msg);\n+        // REMINDER: update state, then update thing status in the super method, to avoid delays\n+        super.handleMessage(msg);\n+    }\n+\n+    /**\n+     * Updates automation device state based on the Automation message received from OWN network\n+     *\n+     * @param msg the Automation message\n+     */\n+    private void updateAutomationState(Automation msg) {\n+        logger.debug(\"updateAutomationState() - msg={} what={}\", msg, msg.getWhat());\n+        try {\n+            if (msg.isCommandTranslation()) {\n+                logger.debug(\"msg is command translation, ignoring it\");\n+                return;\n+            }\n+        } catch (FrameException fe) {\n+            logger.warn(\"Exception while checking WHERE command translation for frame {}: {}, ignoring it\", msg,\n+                    fe.getMessage());\n+        }\n+        if (msg.isUp()) {\n+            updateMovingState(MOVING_STATE_MOVING_UP);\n+            if (calibrating == CALIBRATION_ACTIVATED) {\n+                calibrating = CALIBRATION_GOING_UP;\n+                logger.debug(\"& {} & CALIBRATION - started going ALL UP...\", deviceWhere);\n+            }\n+        } else if (msg.isDown()) {\n+            updateMovingState(MOVING_STATE_MOVING_DOWN);\n+            if (calibrating == CALIBRATION_ACTIVATED) {\n+                calibrating = CALIBRATION_GOING_DOWN;\n+                logger.debug(\"& {} & CALIBRATION - started going ALL DOWN...\", deviceWhere);\n+            }\n+        } else if (msg.isStop()) {\n+            long stoppedAt = System.currentTimeMillis();\n+            if (calibrating == CALIBRATION_GOING_DOWN && shutterRun == SHUTTER_RUN_UNDEFINED) {\n+                shutterRun = (int) (stoppedAt - startedMovingAt);\n+                logger.debug(\"& {} & CALIBRATION - reached DOWN ---> shutterRun={}\", deviceWhere, shutterRun);\n+                updateMovingState(MOVING_STATE_STOPPED);\n+                logger.debug(\"& {} & CALIBRATION - COMPLETED, now going to {}%\", deviceWhere, positionRequested);\n+                handleShutterCommand(new PercentType(positionRequested));\n+                Configuration configuration = editConfiguration();\n+                configuration.put(org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN,", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NjcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8437#discussion_r485866719", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Frame {} not supported for thing {}, ignoring it.\", msg, thing.getUID());\n          \n          \n            \n                        logger.debug(\"Frame {} not supported for thing {}, ignoring it.\", msg, thing.getUID());", "author": "Hilbrand", "createdAt": "2020-09-09T19:36:36Z", "path": "bundles/org.openhab.binding.openwebnet/src/main/java/org/openhab/binding/openwebnet/handler/OpenWebNetAutomationHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openwebnet.handler;\n+\n+import static org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CHANNEL_SHUTTER;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.openwebnet.OpenWebNetBindingConstants;\n+import org.openwebnet4j.OpenGateway;\n+import org.openwebnet4j.communication.OWNException;\n+import org.openwebnet4j.message.Automation;\n+import org.openwebnet4j.message.BaseOpenMessage;\n+import org.openwebnet4j.message.FrameException;\n+import org.openwebnet4j.message.GatewayMgmt;\n+import org.openwebnet4j.message.Where;\n+import org.openwebnet4j.message.Who;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenWebNetAutomationHandler} is responsible for handling commands/messages for an Automation OpenWebNet\n+ * device. It extends the abstract {@link OpenWebNetThingHandler}.\n+ *\n+ * @author Massimo Valla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenWebNetAutomationHandler extends OpenWebNetThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenWebNetAutomationHandler.class);\n+\n+    private static final SimpleDateFormat formatter = new SimpleDateFormat(\"ss.SSS\");\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = OpenWebNetBindingConstants.AUTOMATION_SUPPORTED_THING_TYPES;\n+\n+    // moving states\n+    public static final int MOVING_STATE_STOPPED = 0;\n+    public static final int MOVING_STATE_MOVING_UP = 1;\n+    public static final int MOVING_STATE_MOVING_DOWN = 2;\n+    public static final int MOVING_STATE_UNKNOWN = -1;\n+\n+    // calibration states\n+    public static final int CALIBRATION_INACTIVE = -1;\n+    public static final int CALIBRATION_ACTIVATED = 0;\n+    public static final int CALIBRATION_GOING_UP = 1;\n+    public static final int CALIBRATION_GOING_DOWN = 2;\n+\n+    // positions\n+    public static final int POSITION_MAX_STEPS = 100;\n+    public static final int POSITION_DOWN = 100;\n+    public static final int POSITION_UP = 0;\n+    public static final int POSITION_UNKNOWN = -1;\n+\n+    public static final int SHUTTER_RUN_UNDEFINED = -1;\n+    private int shutterRun = SHUTTER_RUN_UNDEFINED;\n+    private static final String AUTO_CALIBRATION = \"AUTO\";\n+\n+    private long startedMovingAt = -1;\n+    private int movingState = MOVING_STATE_UNKNOWN;\n+    private int positionEstimation = POSITION_UNKNOWN;\n+    private @Nullable ScheduledFuture<?> moveSchedule;\n+    private int positionRequested = POSITION_UNKNOWN;\n+    private int calibrating = CALIBRATION_INACTIVE;\n+    private static final int MIN_STEP_TIME_MSEC = 50;\n+    private @Nullable Command commandRequestedWhileMoving = null;\n+\n+    public OpenWebNetAutomationHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        Object shutterRunConfig = getConfig().get(OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN);\n+        try {\n+            if (shutterRunConfig == null) {\n+                shutterRunConfig = AUTO_CALIBRATION;\n+                logger.debug(\"shutterRun null --> default to AUTO\");\n+            } else if (shutterRunConfig instanceof String) {\n+                if (AUTO_CALIBRATION.equalsIgnoreCase(((String) shutterRunConfig))) {\n+                    logger.debug(\"shutterRun set to AUTO via configuration\");\n+                    shutterRun = SHUTTER_RUN_UNDEFINED; // reset shutterRun\n+                } else { // try to parse int>=1000\n+                    int shutterRunInt = Integer.parseInt((String) shutterRunConfig);\n+                    if (shutterRunInt < 1000) {\n+                        throw new NumberFormatException();\n+                    }\n+                    shutterRun = shutterRunInt;\n+                    logger.debug(\"shutterRun set to {} via configuration\", shutterRun);\n+                }\n+            } else {\n+                throw new NumberFormatException();\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Wrong configuration: {} setting must be {} or an integer >= 1000\",\n+                    OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN, AUTO_CALIBRATION);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"@text/offline.wrong-configuration\");\n+            shutterRun = SHUTTER_RUN_UNDEFINED;\n+        }\n+        updateState(CHANNEL_SHUTTER, UnDefType.UNDEF);\n+        positionEstimation = POSITION_UNKNOWN;\n+    }\n+\n+    @Override\n+    protected void requestChannelState(ChannelUID channel) {\n+        logger.debug(\"requestChannelState() thingUID={} channel={}\", thing.getUID(), channel.getId());\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            try {\n+                send(Automation.requestStatus(w.value()));\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while requesting channel {} state: {}\", channel, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleChannelCommand(ChannelUID channel, Command command) {\n+        switch (channel.getId()) {\n+            case CHANNEL_SHUTTER:\n+                handleShutterCommand(command);\n+                break;\n+            default: {\n+                logger.warn(\"Unsupported channel UID {}\", channel);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation Roller shutter command (UP/DOWN, STOP/MOVE, PERCENT xx%)\n+     */\n+    private void handleShutterCommand(Command command) {\n+        Where w = deviceWhere;\n+        if (w != null) {\n+            calibrating = CALIBRATION_INACTIVE; // cancel calibration if we receive a command\n+            commandRequestedWhileMoving = null;\n+            try {\n+                if (StopMoveType.STOP.equals(command)) {\n+                    send(Automation.requestStop(w.value()));\n+                } else if (command instanceof UpDownType || command instanceof PercentType) {\n+                    if (movingState == MOVING_STATE_MOVING_UP || movingState == MOVING_STATE_MOVING_DOWN) { // already\n+                                                                                                            // moving\n+                        logger.debug(\"# {} # already moving, STOP then defer command\", deviceWhere);\n+                        commandRequestedWhileMoving = command;\n+                        sendHighPriority(Automation.requestStop(w.value()));\n+                        return;\n+                    } else {\n+                        if (command instanceof UpDownType) {\n+                            if (UpDownType.UP.equals(command)) {\n+                                send(Automation.requestMoveUp(w.value()));\n+                            } else {\n+                                send(Automation.requestMoveDown(w.value()));\n+                            }\n+                        } else if (command instanceof PercentType) {\n+                            handlePercentCommand((PercentType) command, w.value());\n+                        }\n+                    }\n+                } else {\n+                    logger.warn(\"Unsupported command {} for thing {}\", command, thing.getUID());\n+                }\n+            } catch (OWNException e) {\n+                logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles Automation PERCENT xx% command\n+     */\n+    private void handlePercentCommand(PercentType command, String w) {\n+        int percent = command.intValue();\n+        if (percent == positionEstimation) {\n+            logger.debug(\"# {} # handlePercentCommand() Command {}% == positionEstimation -> nothing to do\", w,\n+                    percent);\n+            return;\n+        }\n+        try {\n+            if (percent == POSITION_DOWN) { // GO TO 100%\n+                send(Automation.requestMoveDown(w));\n+            } else if (percent == POSITION_UP) { // GO TO 0%\n+                send(Automation.requestMoveUp(w));\n+            } else { // GO TO XX%\n+                logger.debug(\"# {} # {}% requested\", deviceWhere, percent);\n+                if (shutterRun == SHUTTER_RUN_UNDEFINED) {\n+                    logger.debug(\"& {} & CALIBRATION - shutterRun not configured, starting CALIBRATION...\",\n+                            deviceWhere);\n+                    calibrating = CALIBRATION_ACTIVATED;\n+                    send(Automation.requestMoveUp(w));\n+                    positionRequested = percent;\n+                } else if (shutterRun > 0 && positionEstimation != POSITION_UNKNOWN) {\n+                    // these two must be known to calculate moveTime.\n+                    // Calculate how much time we have to move and set a deadline to stop after that time\n+                    int moveTime = Math\n+                            .round(((float) Math.abs(percent - positionEstimation) / POSITION_MAX_STEPS * shutterRun));\n+                    logger.debug(\"# {} # target moveTime={}\", deviceWhere, moveTime);\n+                    if (moveTime > MIN_STEP_TIME_MSEC) {\n+                        ScheduledFuture<?> mSch = moveSchedule;\n+                        if (mSch != null && !mSch.isDone()) {\n+                            // a moveSchedule was already scheduled and is not done... let's cancel the schedule\n+                            mSch.cancel(false);\n+                            logger.warn(\"# {} # new XX% requested, old moveSchedule cancelled\", deviceWhere);\n+                        }\n+                        // send a requestFirmwareVersion message to BUS gateways to wake up the CMD connection before\n+                        // sending further cmds\n+                        OpenWebNetBridgeHandler h = bridgeHandler;\n+                        if (h != null && h.isBusGateway()) {\n+                            OpenGateway gw = h.gateway;\n+                            if (gw != null) {\n+                                if (!gw.isCmdConnectionReady()) {\n+                                    logger.debug(\"# {} # waking-up CMD connection...\", deviceWhere);\n+                                    send(GatewayMgmt.requestFirmwareVersion());\n+                                }\n+                            }\n+                        }\n+                        // REMINDER: start the schedule BEFORE sending the command, because the synch command waits for\n+                        // ACK and can take some 300ms\n+                        logger.debug(\"# {} # Starting schedule...\", deviceWhere);\n+                        moveSchedule = scheduler.schedule(() -> {\n+                            logger.debug(\"# {} # moveSchedule expired, sending STOP...\", deviceWhere);\n+                            try {\n+                                sendHighPriority(Automation.requestStop(w));\n+                            } catch (OWNException ex) {\n+                                logger.warn(\"Exception while sending request for command {}: {}\", command,\n+                                        ex.getMessage());\n+                            }\n+                        }, moveTime, TimeUnit.MILLISECONDS);\n+                        logger.debug(\"# {} # ...schedule started, now sending highPriority command...\", deviceWhere);\n+                        if (percent < positionEstimation) {\n+                            sendHighPriority(Automation.requestMoveUp(w));\n+                        } else {\n+                            sendHighPriority(Automation.requestMoveDown(w));\n+                        }\n+                        logger.debug(\"# {} # ...gateway.sendHighPriority() returned\", deviceWhere);\n+                    } else {\n+                        logger.debug(\"# {} # moveTime <= MIN_STEP_TIME_MSEC ---> do nothing\", deviceWhere);\n+                    }\n+                } else {\n+                    logger.info(\n+                            \"Command {} cannot be executed: unknown position or shutterRun configuration params not set (thing={})\",\n+                            command, thing.getUID());\n+                }\n+            }\n+        } catch (OWNException e) {\n+            logger.warn(\"Exception while sending request for command {}: {}\", command, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected String ownIdPrefix() {\n+        return Who.AUTOMATION.value().toString();\n+    }\n+\n+    @Override\n+    protected void handleMessage(BaseOpenMessage msg) {\n+        updateAutomationState((Automation) msg);\n+        // REMINDER: update state, then update thing status in the super method, to avoid delays\n+        super.handleMessage(msg);\n+    }\n+\n+    /**\n+     * Updates automation device state based on the Automation message received from OWN network\n+     *\n+     * @param msg the Automation message\n+     */\n+    private void updateAutomationState(Automation msg) {\n+        logger.debug(\"updateAutomationState() - msg={} what={}\", msg, msg.getWhat());\n+        try {\n+            if (msg.isCommandTranslation()) {\n+                logger.debug(\"msg is command translation, ignoring it\");\n+                return;\n+            }\n+        } catch (FrameException fe) {\n+            logger.warn(\"Exception while checking WHERE command translation for frame {}: {}, ignoring it\", msg,\n+                    fe.getMessage());\n+        }\n+        if (msg.isUp()) {\n+            updateMovingState(MOVING_STATE_MOVING_UP);\n+            if (calibrating == CALIBRATION_ACTIVATED) {\n+                calibrating = CALIBRATION_GOING_UP;\n+                logger.debug(\"& {} & CALIBRATION - started going ALL UP...\", deviceWhere);\n+            }\n+        } else if (msg.isDown()) {\n+            updateMovingState(MOVING_STATE_MOVING_DOWN);\n+            if (calibrating == CALIBRATION_ACTIVATED) {\n+                calibrating = CALIBRATION_GOING_DOWN;\n+                logger.debug(\"& {} & CALIBRATION - started going ALL DOWN...\", deviceWhere);\n+            }\n+        } else if (msg.isStop()) {\n+            long stoppedAt = System.currentTimeMillis();\n+            if (calibrating == CALIBRATION_GOING_DOWN && shutterRun == SHUTTER_RUN_UNDEFINED) {\n+                shutterRun = (int) (stoppedAt - startedMovingAt);\n+                logger.debug(\"& {} & CALIBRATION - reached DOWN ---> shutterRun={}\", deviceWhere, shutterRun);\n+                updateMovingState(MOVING_STATE_STOPPED);\n+                logger.debug(\"& {} & CALIBRATION - COMPLETED, now going to {}%\", deviceWhere, positionRequested);\n+                handleShutterCommand(new PercentType(positionRequested));\n+                Configuration configuration = editConfiguration();\n+                configuration.put(org.openhab.binding.openwebnet.OpenWebNetBindingConstants.CONFIG_PROPERTY_SHUTTER_RUN,\n+                        Integer.toString(shutterRun));\n+                updateConfiguration(configuration);\n+                logger.debug(\"& {} & CALIBRATION - configuration updated: shutterRun = {}ms\", deviceWhere, shutterRun);\n+            } else if (calibrating == CALIBRATION_GOING_UP) {\n+                updateMovingState(MOVING_STATE_STOPPED);\n+                logger.debug(\"& {} & CALIBRATION - reached UP, now sending DOWN command...\", deviceWhere);\n+                calibrating = CALIBRATION_ACTIVATED;\n+                if (deviceWhere != null) {\n+                    String w = deviceWhere.value();\n+                    try {\n+                        send(Automation.requestMoveDown(w));\n+                    } catch (OWNException e) {\n+                        logger.warn(\"Exception while sending DOWN command during calibration: {}\", e.getMessage());\n+                        calibrating = CALIBRATION_INACTIVE;\n+                    }\n+                }\n+            } else {\n+                updateMovingState(MOVING_STATE_STOPPED);\n+                // do deferred command, if present\n+                Command cmd = commandRequestedWhileMoving;\n+                if (cmd != null) {\n+                    handleShutterCommand(cmd);\n+                }\n+            }\n+        } else {\n+            logger.info(\"Frame {} not supported for thing {}, ignoring it.\", msg, thing.getUID());", "originalCommit": "99f41014dac076f3e2175d04c2f0231fad9bde29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4ed02bbed4b92f1ff3e02b855149554eb6a5a4fd", "url": "https://github.com/openhab/openhab-addons/commit/4ed02bbed4b92f1ff3e02b855149554eb6a5a4fd", "message": "changes to log msgs after PR review\n\nSigned-off-by: Massimo Valla <mvcode00@gmail.com>", "committedDate": "2020-09-10T04:53:25Z", "type": "commit"}]}