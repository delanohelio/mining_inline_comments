{"pr_number": 9081, "pr_title": "[upnpcontrol] Rework and extension of binding.", "pr_createdAt": "2020-11-20T16:53:50Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9081", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3MjEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528072132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    playlistSubscriptions.forEach(l -> l.playlistsListChanged());\n          \n          \n            \n                    playlistSubscriptions.forEach(UpnpPlaylistsListener::playlistsListChanged);", "author": "cpmeister", "createdAt": "2020-11-21T04:50:01Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/util/UpnpControlUtil.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.util;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlBindingConfigurationListener;\n+import org.openhab.binding.upnpcontrol.internal.queue.UpnpPlaylistsListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class with some static utility methods for the upnpcontrol binding.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public final class UpnpControlUtil implements UpnpControlBindingConfigurationListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpnpControlUtil.class);\n+\n+    private static volatile List<String> playlistList = new ArrayList<>();\n+    private static List<UpnpPlaylistsListener> playlistSubscriptions = new ArrayList<>();\n+\n+    public static void updatePlaylistsList(@Nullable String path) {\n+        playlistList = list(path, PLAYLIST_FILE_EXTENSION);\n+        playlistSubscriptions.forEach(l -> l.playlistsListChanged());", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3MjM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528072383", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static List<UpnpPlaylistsListener> playlistSubscriptions = new ArrayList<>();\n          \n          \n            \n                private static final Set<UpnpPlaylistsListener> playlistSubscriptions = new CopyOnWriteArraySet<>();", "author": "cpmeister", "createdAt": "2020-11-21T04:52:35Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/util/UpnpControlUtil.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.util;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.*;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlBindingConfigurationListener;\n+import org.openhab.binding.upnpcontrol.internal.queue.UpnpPlaylistsListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class with some static utility methods for the upnpcontrol binding.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public final class UpnpControlUtil implements UpnpControlBindingConfigurationListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpnpControlUtil.class);\n+\n+    private static volatile List<String> playlistList = new ArrayList<>();\n+    private static List<UpnpPlaylistsListener> playlistSubscriptions = new ArrayList<>();", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3MjkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528072904", "bodyText": "You can find a reference to these channel types directly in DefaultSystemChannelTypeProvider.", "author": "cpmeister", "createdAt": "2020-11-21T04:58:21Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpControlBindingConstants.java", "diffHunk": "@@ -57,14 +78,45 @@\n     public static final String TRACK_NUMBER = \"tracknumber\";\n     public static final String TRACK_DURATION = \"trackduration\";\n     public static final String TRACK_POSITION = \"trackposition\";\n+    public static final String REL_TRACK_POSITION = \"reltrackposition\";\n \n     public static final String UPNPRENDERER = \"upnprenderer\";\n-    public static final String CURRENTID = \"currentid\";\n+    public static final String CURRENTTITLE = \"currenttitle\";\n     public static final String BROWSE = \"browse\";\n     public static final String SEARCH = \"search\";\n     public static final String SERVE = \"serve\";\n+    public static final String PLAYLIST_SELECT = \"playlistselect\";\n+    public static final String PLAYLIST = \"playlist\";\n+    public static final String PLAYLIST_ACTION = \"playlistaction\";\n \n-    // Thing config properties\n-    public static final String CONFIG_FILTER = \"filter\";\n-    public static final String SORT_CRITERIA = \"sortcriteria\";\n+    // Type constants for dynamic renderer channels\n+    public static final String CHANNEL_TYPE_VOLUME = (new ChannelTypeUID(\"system\", \"volume\")).toString();\n+    public static final String CHANNEL_TYPE_MUTE = (new ChannelTypeUID(\"system\", \"mute\")).toString();", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3Mjk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528072967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<String> SERVER_CONTROL_CHANNELS = Stream.of(VOLUME, MUTE, CONTROL, STOP)\n          \n          \n            \n                        .collect(Collectors.toSet());\n          \n          \n            \n                public static final Set<String> SERVER_CONTROL_CHANNELS = Set.of(VOLUME, MUTE, CONTROL, STOP);", "author": "cpmeister", "createdAt": "2020-11-21T04:59:28Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/UpnpControlBindingConstants.java", "diffHunk": "@@ -57,14 +78,45 @@\n     public static final String TRACK_NUMBER = \"tracknumber\";\n     public static final String TRACK_DURATION = \"trackduration\";\n     public static final String TRACK_POSITION = \"trackposition\";\n+    public static final String REL_TRACK_POSITION = \"reltrackposition\";\n \n     public static final String UPNPRENDERER = \"upnprenderer\";\n-    public static final String CURRENTID = \"currentid\";\n+    public static final String CURRENTTITLE = \"currenttitle\";\n     public static final String BROWSE = \"browse\";\n     public static final String SEARCH = \"search\";\n     public static final String SERVE = \"serve\";\n+    public static final String PLAYLIST_SELECT = \"playlistselect\";\n+    public static final String PLAYLIST = \"playlist\";\n+    public static final String PLAYLIST_ACTION = \"playlistaction\";\n \n-    // Thing config properties\n-    public static final String CONFIG_FILTER = \"filter\";\n-    public static final String SORT_CRITERIA = \"sortcriteria\";\n+    // Type constants for dynamic renderer channels\n+    public static final String CHANNEL_TYPE_VOLUME = (new ChannelTypeUID(\"system\", \"volume\")).toString();\n+    public static final String CHANNEL_TYPE_MUTE = (new ChannelTypeUID(\"system\", \"mute\")).toString();\n+    public static final String CHANNEL_TYPE_LOUDNESS = (new ChannelTypeUID(BINDING_ID, \"loudness\")).toString();\n+\n+    public static final String ITEM_TYPE_VOLUME = \"Dimmer\";\n+    public static final String ITEM_TYPE_MUTE = \"Switch\";\n+    public static final String ITEM_TYPE_LOUDNESS = \"Switch\";\n+\n+    // Command options for playlist and favorite actions\n+    public static final String RESTORE = \"RESTORE\";\n+    public static final String SAVE = \"SAVE\";\n+    public static final String APPEND = \"APPEND\";\n+    public static final String DELETE = \"DELETE\";\n+\n+    // Channels that are duplicated on server to control current renderer\n+    public static final Set<String> SERVER_CONTROL_CHANNELS = Stream.of(VOLUME, MUTE, CONTROL, STOP)\n+            .collect(Collectors.toSet());", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3MzU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528073574", "bodyText": "Please add description for class.", "author": "cpmeister", "createdAt": "2020-11-21T05:06:01Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/audiosink/UpnpNotificationAudioSink.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.audiosink;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.NOTIFICATION_AUDIOSINK_EXTENSION;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.upnpcontrol.internal.handler.UpnpRendererHandler;\n+import org.openhab.core.audio.AudioHTTPServer;\n+import org.openhab.core.library.types.PercentType;\n+\n+/**\n+ *", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3NDEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528074120", "bodyText": "Can you change your config parameter names to camelcase?", "author": "cpmeister", "createdAt": "2020-11-21T05:12:22Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/config/UpnpControlRendererConfiguration.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UpnpControlRendererConfiguration extends UpnpControlConfiguration {\n+    public int notificationvolumeadjustment = 10;\n+    public int maxnotificationduration = 15;\n+    public int seekstep = 5;", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3NDQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528074406", "bodyText": "If you are going to add a javadoc, please fill it out, otherwise remove it.", "author": "cpmeister", "createdAt": "2020-11-21T05:16:08Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/util/UpnpXMLParser.java", "diffHunk": "@@ -138,6 +170,31 @@ public void startElement(@Nullable String uri, @Nullable String localName, @Null\n         }\n     }\n \n+    /**\n+     * @param xml\n+     * @return a list of Entries from the given xml string.\n+     * @throws IOException\n+     * @throws SAXException", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3NTAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528075022", "bodyText": "This is a new list, so you can remove this clear here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    masterList.clear();", "author": "cpmeister", "createdAt": "2020-11-21T05:23:24Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/queue/UpnpEntryQueue.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.queue;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.PLAYLIST_FILE_EXTENSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The class {@link UpnpEntryQueue} represents a queue of UPnP media entries to be played on a renderer. It keeps track\n+ * of a current index in the queue. It has convenience methods to play previous/next entries, whereby the queue can be\n+ * organized to play from first to last (with no repetition), to restart at the start when the end is reached (in a\n+ * continuous loop), or to random shuffle the entries. Repeat and shuffle are off by default, but can be set using the\n+ * {@link setRepeat} and {@link setShuffle} methods.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class UpnpEntryQueue {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpEntryQueue.class);\n+\n+    private volatile boolean repeat = false;\n+    private volatile boolean shuffle = false;\n+\n+    private volatile int currentIndex = -1;\n+\n+    private class Playlist {\n+        @SuppressWarnings(\"unused\")\n+        String name; // Used in serialization\n+        volatile Map<String, List<UpnpEntry>> masterList;\n+\n+        Playlist(String name, Map<String, List<UpnpEntry>> masterList) {\n+            this.name = name;\n+            this.masterList = masterList;\n+        }\n+    }\n+\n+    private volatile Playlist playlist;\n+\n+    private volatile List<UpnpEntry> currentQueue;\n+    private volatile List<UpnpEntry> shuffledQueue = Collections.emptyList();\n+\n+    private final Gson gson = new Gson();\n+\n+    public UpnpEntryQueue() {\n+        this(Collections.emptyList());\n+    }\n+\n+    /**\n+     * @param queue\n+     */\n+    public UpnpEntryQueue(List<UpnpEntry> queue) {\n+        this(queue, \"\");\n+    }\n+\n+    /**\n+     * @param queue\n+     * @param udn Defines the UPnP media server source of the queue, could be used to re-query the server if URL\n+     *            resources are out of date.\n+     */\n+    public UpnpEntryQueue(List<UpnpEntry> queue, @Nullable String udn) {\n+        String serverUdn = (udn != null) ? udn : \"\";\n+        Map<String, List<UpnpEntry>> masterList = Collections.synchronizedMap(new HashMap<>());\n+        masterList.clear();", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3NjE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528076174", "bodyText": "At this point you should copy the list queue provided in the constructor so that the list couldn't be manipulated outside of this class.", "author": "cpmeister", "createdAt": "2020-11-21T05:36:07Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/queue/UpnpEntryQueue.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.upnpcontrol.internal.queue;\n+\n+import static org.openhab.binding.upnpcontrol.internal.UpnpControlBindingConstants.PLAYLIST_FILE_EXTENSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The class {@link UpnpEntryQueue} represents a queue of UPnP media entries to be played on a renderer. It keeps track\n+ * of a current index in the queue. It has convenience methods to play previous/next entries, whereby the queue can be\n+ * organized to play from first to last (with no repetition), to restart at the start when the end is reached (in a\n+ * continuous loop), or to random shuffle the entries. Repeat and shuffle are off by default, but can be set using the\n+ * {@link setRepeat} and {@link setShuffle} methods.\n+ *\n+ * @author Mark Herwege - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class UpnpEntryQueue {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UpnpEntryQueue.class);\n+\n+    private volatile boolean repeat = false;\n+    private volatile boolean shuffle = false;\n+\n+    private volatile int currentIndex = -1;\n+\n+    private class Playlist {\n+        @SuppressWarnings(\"unused\")\n+        String name; // Used in serialization\n+        volatile Map<String, List<UpnpEntry>> masterList;\n+\n+        Playlist(String name, Map<String, List<UpnpEntry>> masterList) {\n+            this.name = name;\n+            this.masterList = masterList;\n+        }\n+    }\n+\n+    private volatile Playlist playlist;\n+\n+    private volatile List<UpnpEntry> currentQueue;\n+    private volatile List<UpnpEntry> shuffledQueue = Collections.emptyList();\n+\n+    private final Gson gson = new Gson();\n+\n+    public UpnpEntryQueue() {\n+        this(Collections.emptyList());\n+    }\n+\n+    /**\n+     * @param queue\n+     */\n+    public UpnpEntryQueue(List<UpnpEntry> queue) {\n+        this(queue, \"\");\n+    }\n+\n+    /**\n+     * @param queue\n+     * @param udn Defines the UPnP media server source of the queue, could be used to re-query the server if URL\n+     *            resources are out of date.\n+     */\n+    public UpnpEntryQueue(List<UpnpEntry> queue, @Nullable String udn) {\n+        String serverUdn = (udn != null) ? udn : \"\";\n+        Map<String, List<UpnpEntry>> masterList = Collections.synchronizedMap(new HashMap<>());\n+        masterList.clear();\n+        masterList.put(serverUdn, queue);", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3NjM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528076389", "bodyText": "Why does this list need to be synchronized?", "author": "cpmeister", "createdAt": "2020-11-21T05:39:02Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -470,7 +724,7 @@ public void onValueReceived(@Nullable String variable, @Nullable String value, @\n     private void serveMedia() {\n         UpnpRendererHandler handler = currentRendererHandler;\n         if (handler != null) {\n-            ArrayList<UpnpEntry> mediaQueue = new ArrayList<>();\n+            List<UpnpEntry> mediaQueue = Collections.synchronizedList(new ArrayList<>());", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3ODQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528078434", "bodyText": "What is the point of synchronizing this? Also you are changing the instance that synchronized  is using for locking which kinda defeats the intended purpose of synchronized . What are you trying to make threadsafe? Field assignment is already an atomic operation.", "author": "cpmeister", "createdAt": "2020-11-21T06:00:17Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -411,255 +554,812 @@ protected void setMute(String channel, OnOffType mute) {\n         inputs.put(\"Channel\", channel);\n         inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n \n-        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getLoudness(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setLoudness(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredLoudness\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Called from server handler for renderer to be able to send back status to server handler\n+     *\n+     * @param handler\n+     */\n+    protected void setServerHandler(UpnpServerHandler handler) {\n+        logger.debug(\"Set server handler {} on renderer {}\", handler.getThing().getLabel(), thing.getLabel());\n+        serverHandlers.add(handler);\n+    }\n+\n+    /**\n+     * Should be called from server handler when server stops serving this renderer\n+     */\n+    protected void unsetServerHandler() {\n+        logger.debug(\"Unset server handler on renderer {}\", thing.getLabel());\n+        for (UpnpServerHandler handler : serverHandlers) {\n+            Thing serverThing = handler.getThing();\n+            Channel serverChannel;\n+            for (String channel : SERVER_CONTROL_CHANNELS) {\n+                if ((serverChannel = serverThing.getChannel(channel)) != null) {\n+                    handler.updateServerState(serverChannel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+\n+            serverHandlers.remove(handler);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateState(ChannelUID channelUID, State state) {\n+        // override to be able to propagate channel state updates to corresponding channels on the server\n+        if (SERVER_CONTROL_CHANNELS.contains(channelUID.getId())) {\n+            for (UpnpServerHandler handler : serverHandlers) {\n+                Thing serverThing = handler.getThing();\n+                Channel serverChannel = serverThing.getChannel(channelUID.getId());\n+                if (serverChannel != null) {\n+                    logger.debug(\"Update server {} channel {} with state {} from renderer {}\", serverThing.getLabel(),\n+                            state, channelUID, thing.getLabel());\n+                    handler.updateServerState(serverChannel.getUID(), state);\n+                }\n+            }\n+        }\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String id = channelUID.getId();\n+\n+        if (id.endsWith(\"volume\")) {\n+            handleCommandVolume(command, id);\n+        } else if (id.endsWith(\"mute\")) {\n+            handleCommandMute(command, id);\n+        } else if (id.endsWith(\"loudness\")) {\n+            handleCommandLoudness(command, id);\n+        } else {\n+            switch (id) {\n+                case STOP:\n+                    handleCommandStop(command);\n+                    break;\n+                case CONTROL:\n+                    handleCommandControl(channelUID, command);\n+                    break;\n+                case REPEAT:\n+                    handleCommandRepeat(channelUID, command);\n+                    break;\n+                case SHUFFLE:\n+                    handleCommandShuffle(channelUID, command);\n+                case ONLY_PLAY_ONE:\n+                    handleCommandOnlyPlayOne(channelUID, command);\n+                    break;\n+                case URI:\n+                    handleCommandUri(channelUID, command);\n+                    break;\n+                case FAVORITE_SELECT:\n+                    handleCommandFavoriteSelect(command);\n+                    break;\n+                case FAVORITE:\n+                    handleCommandFavorite(channelUID, command);\n+                    break;\n+                case FAVORITE_ACTION:\n+                    handleCommandFavoriteAction(command);\n+                    break;\n+                case PLAYLIST_SELECT:\n+                    handleCommandPlaylistSelect(command);\n+                    break;\n+                case TRACK_POSITION:\n+                    handleCommandTrackPosition(channelUID, command);\n+                    break;\n+                case REL_TRACK_POSITION:\n+                    handleCommandRelTrackPosition(channelUID, command);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"));\n+        } else if (command instanceof PercentType) {\n+            setVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"), (PercentType) command);\n+        }\n+    }\n+\n+    private void handleCommandMute(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandLoudness(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (OnOffType.ON.equals(command)) {\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            stop();\n+            updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void handleCommandControl(ChannelUID channelUID, Command command) {\n+        String state;\n+        if (command instanceof RefreshType) {\n+            state = transportState;\n+            State newState = UnDefType.UNDEF;\n+            if (\"PLAYING\".equals(state)) {\n+                newState = PlayPauseType.PLAY;\n+            } else if (\"STOPPED\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            } else if (\"PAUSED_PLAYBACK\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            }\n+            updateState(channelUID, newState);\n+        } else if (command instanceof PlayPauseType) {\n+            if (PlayPauseType.PLAY.equals(command)) {\n+                if (registeredQueue) {\n+                    registeredQueue = false;\n+                    playingQueue = true;\n+                    oneplayed = false;\n+                    serve();\n+                } else {\n+                    play();\n+                }\n+            } else if (PlayPauseType.PAUSE.equals(command)) {\n+                checkPaused();\n+                pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (NextPreviousType.NEXT.equals(command)) {\n+                serveNext();\n+            } else if (NextPreviousType.PREVIOUS.equals(command)) {\n+                servePrevious();\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            int pos = 0;\n+            if (RewindFastforwardType.FASTFORWARD.equals(command)) {\n+                pos = Integer.min(trackDuration, trackPosition + config.seekstep);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                pos = Integer.max(0, trackPosition - config.seekstep);\n+            }\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    private void handleCommandRepeat(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(repeat));\n+        } else {\n+            repeat = (OnOffType.ON.equals(command));\n+            currentQueue.setRepeat(repeat);\n+            updateState(channelUID, OnOffType.from(repeat));\n+            logger.debug(\"Repeat set to {} for {}\", repeat, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandShuffle(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(shuffle));\n+        } else {\n+            shuffle = (OnOffType.ON.equals(command));\n+            currentQueue.setShuffle(shuffle);\n+            if (!playing) {\n+                resetToStartQueue();\n+            }\n+            updateState(channelUID, OnOffType.from(shuffle));\n+            logger.debug(\"Shuffle set to {} for {}\", shuffle, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandOnlyPlayOne(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+        } else {\n+            onlyplayone = (OnOffType.ON.equals(command));\n+            oneplayed = (onlyplayone && playing) ? true : false;\n+            if (oneplayed) {\n+                setNextURI(\"\", \"\");\n+            } else {\n+                UpnpEntry next = nextEntry;\n+                if (next != null) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                }\n+            }\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+            logger.debug(\"OnlyPlayOne set to {} for {}\", onlyplayone, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandUri(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, StringType.valueOf(nowPlayingUri));\n+        } else if (command instanceof StringType) {\n+            setCurrentURI(command.toString(), \"\");\n+            play();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSelect(Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            updateState(FAVORITE, StringType.valueOf(favoriteName));\n+            playFavorite();\n+        }\n+    }\n+\n+    private void handleCommandFavorite(ChannelUID channelUID, Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            if (favoriteCommandOptionList.contains(new CommandOption(favoriteName, favoriteName))) {\n+                playFavorite();\n+            }\n+        }\n+        updateState(channelUID, StringType.valueOf(favoriteName));\n+    }\n+\n+    private void handleCommandFavoriteAction(Command command) {\n+        if (command instanceof StringType) {\n+            switch (command.toString()) {\n+                case SAVE:\n+                    handleCommandFavoriteSave();\n+                    break;\n+                case DELETE:\n+                    handleCommandFavoriteDelete();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSave() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpFavorite favorite = new UpnpFavorite(favoriteName, nowPlayingUri, currentEntry);\n+            favorite.saveFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteDelete() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpControlUtil.deleteFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+            updateState(FAVORITE, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void handleCommandPlaylistSelect(Command command) {\n+        if (command instanceof StringType) {\n+            String playlistName = command.toString();\n+            UpnpEntryQueue queue = new UpnpEntryQueue();\n+            queue.restoreQueue(playlistName, null, bindingConfig.path);\n+            registerQueue(queue);\n+            resetToStartQueue();\n+            playingQueue = true;\n+            serve();\n+        }\n+    }\n+\n+    private void handleCommandTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+        } else if (command instanceof QuantityType<?>) {\n+            QuantityType<?> position = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+            if (position != null) {\n+                int pos = Integer.min(trackDuration, position.intValue());\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+            }\n+        }\n+    }\n+\n+    private void handleCommandRelTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            int relPosition = (trackDuration != 0) ? (trackPosition * 100) / trackDuration : 0;\n+            updateState(channelUID, new PercentType(relPosition));\n+        } else if (command instanceof PercentType) {\n+            int pos = ((PercentType) command).intValue() * trackDuration / 100;\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    /**\n+     * Set the volume for notifications.\n+     *\n+     * @param volume\n+     */\n+    public void setNotificationVolume(PercentType volume) {\n+        notificationVolume = volume;\n+    }\n+\n+    /**\n+     * Play a notification. Previous state of the renderer will resume at the end of the notification, or after the\n+     * maximum notification duration as defined in the renderer parameters.\n+     *\n+     * @param URI for notification sound\n+     */\n+    public void playNotification(String URI) {\n+        synchronized (notificationLock) {\n+            if (URI.isEmpty()) {\n+                logger.debug(\"UPnP device {} received empty notification URI\", thing.getLabel());\n+                return;\n+            }\n+\n+            notificationUri = URI;\n+\n+            logger.debug(\"UPnP device {} playing notification {}\", thing.getLabel(), URI);\n+\n+            cancelTrackPositionRefresh();\n+            getPositionInfo();\n+\n+            cancelPlayingNotificationFuture();\n+\n+            if (config.maxnotificationduration > 0) {\n+                playingNotificationFuture = upnpScheduler.schedule(this::stop, config.maxnotificationduration,\n+                        TimeUnit.SECONDS);\n+            }\n+            playingNotification = true;\n+\n+            setCurrentURI(URI, \"\");\n+            setNextURI(\"\", \"\");\n+            PercentType volume = notificationVolume;\n+            setVolume(volume == null\n+                    ? new PercentType(Math.min(100,\n+                            Math.max(0, (100 + config.notificationvolumeadjustment) * soundVolume.intValue() / 100)))\n+                    : volume);\n+\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            try {\n+                if (stopping != null) {\n+                    // wait for maximum 2.5s until the renderer stopped before playing\n+                    stopping.get(config.responsetimeout, TimeUnit.MILLISECONDS);\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.debug(\"Timeout exception, renderer {} didn't stop yet, trying to play anyway\", thing.getLabel());\n+            }\n+            play();\n+        }\n+    }\n+\n+    private void cancelPlayingNotificationFuture() {\n+        ScheduledFuture<?> future = playingNotificationFuture;\n+        if (future != null) {\n+            future.cancel(true);\n+            playingNotificationFuture = null;\n+        }\n     }\n \n-    /**\n-     * Invoke getPositionInfo on UPnP Rendering Control.\n-     * Result is received in {@link onValueReceived}.\n-     */\n-    protected void getPositionInfo() {\n-        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+    private void resumeAfterNotification() {\n+        synchronized (notificationLock) {\n+            logger.debug(\"UPnP device {} resume after playing notification\", thing.getLabel());\n \n-        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n-    }\n+            setCurrentURI(nowPlayingUri, \"\");\n+            setVolume(soundVolume);\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+            cancelPlayingNotificationFuture();\n \n-        String transportState;\n-        if (command instanceof RefreshType) {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    getVolume(getCurrentChannel());\n-                    break;\n-                case MUTE:\n-                    getMute(getCurrentChannel());\n-                    break;\n-                case CONTROL:\n-                    transportState = this.transportState;\n-                    State newState = UnDefType.UNDEF;\n-                    if (\"PLAYING\".equals(transportState)) {\n-                        newState = PlayPauseType.PLAY;\n-                    } else if (\"STOPPED\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    }\n-                    updateState(channelUID, newState);\n-                    break;\n+            playingNotification = false;\n+            notificationVolume = null;\n+            notificationUri = \"\";\n+\n+            if (playing) {\n+                int pos = posAtNotificationStart;\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+                play();\n             }\n-            return;\n-        } else {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    setVolume(getCurrentChannel(), (PercentType) command);\n-                    break;\n-                case MUTE:\n-                    setMute(getCurrentChannel(), (OnOffType) command);\n-                    break;\n-                case STOP:\n-                    if (command == OnOffType.ON) {\n-                        updateState(CONTROL, PlayPauseType.PAUSE);\n-                        playerStopped = true;\n-                        stop();\n-                        updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n-                    }\n-                    break;\n-                case CONTROL:\n-                    playerStopped = false;\n-                    if (command instanceof PlayPauseType) {\n-                        if (command == PlayPauseType.PLAY) {\n-                            play();\n-                        } else if (command == PlayPauseType.PAUSE) {\n-                            pause();\n-                        }\n-                    } else if (command instanceof NextPreviousType) {\n-                        if (command == NextPreviousType.NEXT) {\n-                            playerStopped = true;\n-                            serveNext();\n-                        } else if (command == NextPreviousType.PREVIOUS) {\n-                            playerStopped = true;\n-                            servePrevious();\n-                        }\n-                    } else if (command instanceof RewindFastforwardType) {\n-                    }\n-                    break;\n+            posAtNotificationStart = 0;\n+        }\n+    }\n+\n+    private void playFavorite() {\n+        UpnpFavorite favorite = new UpnpFavorite(favoriteName, bindingConfig.path);\n+        String uri = favorite.getUri();\n+        UpnpEntry entry = favorite.getUpnpEntry();\n+        if (!uri.isEmpty()) {\n+            String metadata = \"\";\n+            if (entry != null) {\n+                metadata = UpnpXMLParser.compileMetadataString(entry);\n             }\n+            setCurrentURI(uri, metadata);\n+            play();\n+        }\n+    }\n \n-            return;\n+    void updateFavoritesList() {\n+        synchronized (favoriteCommandOptionList) {\n+            favoriteCommandOptionList = UpnpControlUtil.favorites(bindingConfig.path).stream()\n+                    .map(p -> (new CommandOption(p, p))).collect(Collectors.toList());\n+        }", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3ODQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528078496", "bodyText": "same issue here", "author": "cpmeister", "createdAt": "2020-11-21T06:00:46Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -411,255 +554,812 @@ protected void setMute(String channel, OnOffType mute) {\n         inputs.put(\"Channel\", channel);\n         inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n \n-        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getLoudness(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setLoudness(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredLoudness\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Called from server handler for renderer to be able to send back status to server handler\n+     *\n+     * @param handler\n+     */\n+    protected void setServerHandler(UpnpServerHandler handler) {\n+        logger.debug(\"Set server handler {} on renderer {}\", handler.getThing().getLabel(), thing.getLabel());\n+        serverHandlers.add(handler);\n+    }\n+\n+    /**\n+     * Should be called from server handler when server stops serving this renderer\n+     */\n+    protected void unsetServerHandler() {\n+        logger.debug(\"Unset server handler on renderer {}\", thing.getLabel());\n+        for (UpnpServerHandler handler : serverHandlers) {\n+            Thing serverThing = handler.getThing();\n+            Channel serverChannel;\n+            for (String channel : SERVER_CONTROL_CHANNELS) {\n+                if ((serverChannel = serverThing.getChannel(channel)) != null) {\n+                    handler.updateServerState(serverChannel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+\n+            serverHandlers.remove(handler);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateState(ChannelUID channelUID, State state) {\n+        // override to be able to propagate channel state updates to corresponding channels on the server\n+        if (SERVER_CONTROL_CHANNELS.contains(channelUID.getId())) {\n+            for (UpnpServerHandler handler : serverHandlers) {\n+                Thing serverThing = handler.getThing();\n+                Channel serverChannel = serverThing.getChannel(channelUID.getId());\n+                if (serverChannel != null) {\n+                    logger.debug(\"Update server {} channel {} with state {} from renderer {}\", serverThing.getLabel(),\n+                            state, channelUID, thing.getLabel());\n+                    handler.updateServerState(serverChannel.getUID(), state);\n+                }\n+            }\n+        }\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String id = channelUID.getId();\n+\n+        if (id.endsWith(\"volume\")) {\n+            handleCommandVolume(command, id);\n+        } else if (id.endsWith(\"mute\")) {\n+            handleCommandMute(command, id);\n+        } else if (id.endsWith(\"loudness\")) {\n+            handleCommandLoudness(command, id);\n+        } else {\n+            switch (id) {\n+                case STOP:\n+                    handleCommandStop(command);\n+                    break;\n+                case CONTROL:\n+                    handleCommandControl(channelUID, command);\n+                    break;\n+                case REPEAT:\n+                    handleCommandRepeat(channelUID, command);\n+                    break;\n+                case SHUFFLE:\n+                    handleCommandShuffle(channelUID, command);\n+                case ONLY_PLAY_ONE:\n+                    handleCommandOnlyPlayOne(channelUID, command);\n+                    break;\n+                case URI:\n+                    handleCommandUri(channelUID, command);\n+                    break;\n+                case FAVORITE_SELECT:\n+                    handleCommandFavoriteSelect(command);\n+                    break;\n+                case FAVORITE:\n+                    handleCommandFavorite(channelUID, command);\n+                    break;\n+                case FAVORITE_ACTION:\n+                    handleCommandFavoriteAction(command);\n+                    break;\n+                case PLAYLIST_SELECT:\n+                    handleCommandPlaylistSelect(command);\n+                    break;\n+                case TRACK_POSITION:\n+                    handleCommandTrackPosition(channelUID, command);\n+                    break;\n+                case REL_TRACK_POSITION:\n+                    handleCommandRelTrackPosition(channelUID, command);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"));\n+        } else if (command instanceof PercentType) {\n+            setVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"), (PercentType) command);\n+        }\n+    }\n+\n+    private void handleCommandMute(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandLoudness(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (OnOffType.ON.equals(command)) {\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            stop();\n+            updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void handleCommandControl(ChannelUID channelUID, Command command) {\n+        String state;\n+        if (command instanceof RefreshType) {\n+            state = transportState;\n+            State newState = UnDefType.UNDEF;\n+            if (\"PLAYING\".equals(state)) {\n+                newState = PlayPauseType.PLAY;\n+            } else if (\"STOPPED\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            } else if (\"PAUSED_PLAYBACK\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            }\n+            updateState(channelUID, newState);\n+        } else if (command instanceof PlayPauseType) {\n+            if (PlayPauseType.PLAY.equals(command)) {\n+                if (registeredQueue) {\n+                    registeredQueue = false;\n+                    playingQueue = true;\n+                    oneplayed = false;\n+                    serve();\n+                } else {\n+                    play();\n+                }\n+            } else if (PlayPauseType.PAUSE.equals(command)) {\n+                checkPaused();\n+                pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (NextPreviousType.NEXT.equals(command)) {\n+                serveNext();\n+            } else if (NextPreviousType.PREVIOUS.equals(command)) {\n+                servePrevious();\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            int pos = 0;\n+            if (RewindFastforwardType.FASTFORWARD.equals(command)) {\n+                pos = Integer.min(trackDuration, trackPosition + config.seekstep);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                pos = Integer.max(0, trackPosition - config.seekstep);\n+            }\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    private void handleCommandRepeat(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(repeat));\n+        } else {\n+            repeat = (OnOffType.ON.equals(command));\n+            currentQueue.setRepeat(repeat);\n+            updateState(channelUID, OnOffType.from(repeat));\n+            logger.debug(\"Repeat set to {} for {}\", repeat, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandShuffle(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(shuffle));\n+        } else {\n+            shuffle = (OnOffType.ON.equals(command));\n+            currentQueue.setShuffle(shuffle);\n+            if (!playing) {\n+                resetToStartQueue();\n+            }\n+            updateState(channelUID, OnOffType.from(shuffle));\n+            logger.debug(\"Shuffle set to {} for {}\", shuffle, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandOnlyPlayOne(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+        } else {\n+            onlyplayone = (OnOffType.ON.equals(command));\n+            oneplayed = (onlyplayone && playing) ? true : false;\n+            if (oneplayed) {\n+                setNextURI(\"\", \"\");\n+            } else {\n+                UpnpEntry next = nextEntry;\n+                if (next != null) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                }\n+            }\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+            logger.debug(\"OnlyPlayOne set to {} for {}\", onlyplayone, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandUri(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, StringType.valueOf(nowPlayingUri));\n+        } else if (command instanceof StringType) {\n+            setCurrentURI(command.toString(), \"\");\n+            play();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSelect(Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            updateState(FAVORITE, StringType.valueOf(favoriteName));\n+            playFavorite();\n+        }\n+    }\n+\n+    private void handleCommandFavorite(ChannelUID channelUID, Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            if (favoriteCommandOptionList.contains(new CommandOption(favoriteName, favoriteName))) {\n+                playFavorite();\n+            }\n+        }\n+        updateState(channelUID, StringType.valueOf(favoriteName));\n+    }\n+\n+    private void handleCommandFavoriteAction(Command command) {\n+        if (command instanceof StringType) {\n+            switch (command.toString()) {\n+                case SAVE:\n+                    handleCommandFavoriteSave();\n+                    break;\n+                case DELETE:\n+                    handleCommandFavoriteDelete();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSave() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpFavorite favorite = new UpnpFavorite(favoriteName, nowPlayingUri, currentEntry);\n+            favorite.saveFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteDelete() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpControlUtil.deleteFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+            updateState(FAVORITE, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void handleCommandPlaylistSelect(Command command) {\n+        if (command instanceof StringType) {\n+            String playlistName = command.toString();\n+            UpnpEntryQueue queue = new UpnpEntryQueue();\n+            queue.restoreQueue(playlistName, null, bindingConfig.path);\n+            registerQueue(queue);\n+            resetToStartQueue();\n+            playingQueue = true;\n+            serve();\n+        }\n+    }\n+\n+    private void handleCommandTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+        } else if (command instanceof QuantityType<?>) {\n+            QuantityType<?> position = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+            if (position != null) {\n+                int pos = Integer.min(trackDuration, position.intValue());\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+            }\n+        }\n+    }\n+\n+    private void handleCommandRelTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            int relPosition = (trackDuration != 0) ? (trackPosition * 100) / trackDuration : 0;\n+            updateState(channelUID, new PercentType(relPosition));\n+        } else if (command instanceof PercentType) {\n+            int pos = ((PercentType) command).intValue() * trackDuration / 100;\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    /**\n+     * Set the volume for notifications.\n+     *\n+     * @param volume\n+     */\n+    public void setNotificationVolume(PercentType volume) {\n+        notificationVolume = volume;\n+    }\n+\n+    /**\n+     * Play a notification. Previous state of the renderer will resume at the end of the notification, or after the\n+     * maximum notification duration as defined in the renderer parameters.\n+     *\n+     * @param URI for notification sound\n+     */\n+    public void playNotification(String URI) {\n+        synchronized (notificationLock) {\n+            if (URI.isEmpty()) {\n+                logger.debug(\"UPnP device {} received empty notification URI\", thing.getLabel());\n+                return;\n+            }\n+\n+            notificationUri = URI;\n+\n+            logger.debug(\"UPnP device {} playing notification {}\", thing.getLabel(), URI);\n+\n+            cancelTrackPositionRefresh();\n+            getPositionInfo();\n+\n+            cancelPlayingNotificationFuture();\n+\n+            if (config.maxnotificationduration > 0) {\n+                playingNotificationFuture = upnpScheduler.schedule(this::stop, config.maxnotificationduration,\n+                        TimeUnit.SECONDS);\n+            }\n+            playingNotification = true;\n+\n+            setCurrentURI(URI, \"\");\n+            setNextURI(\"\", \"\");\n+            PercentType volume = notificationVolume;\n+            setVolume(volume == null\n+                    ? new PercentType(Math.min(100,\n+                            Math.max(0, (100 + config.notificationvolumeadjustment) * soundVolume.intValue() / 100)))\n+                    : volume);\n+\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            try {\n+                if (stopping != null) {\n+                    // wait for maximum 2.5s until the renderer stopped before playing\n+                    stopping.get(config.responsetimeout, TimeUnit.MILLISECONDS);\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.debug(\"Timeout exception, renderer {} didn't stop yet, trying to play anyway\", thing.getLabel());\n+            }\n+            play();\n+        }\n+    }\n+\n+    private void cancelPlayingNotificationFuture() {\n+        ScheduledFuture<?> future = playingNotificationFuture;\n+        if (future != null) {\n+            future.cancel(true);\n+            playingNotificationFuture = null;\n+        }\n     }\n \n-    /**\n-     * Invoke getPositionInfo on UPnP Rendering Control.\n-     * Result is received in {@link onValueReceived}.\n-     */\n-    protected void getPositionInfo() {\n-        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+    private void resumeAfterNotification() {\n+        synchronized (notificationLock) {\n+            logger.debug(\"UPnP device {} resume after playing notification\", thing.getLabel());\n \n-        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n-    }\n+            setCurrentURI(nowPlayingUri, \"\");\n+            setVolume(soundVolume);\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+            cancelPlayingNotificationFuture();\n \n-        String transportState;\n-        if (command instanceof RefreshType) {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    getVolume(getCurrentChannel());\n-                    break;\n-                case MUTE:\n-                    getMute(getCurrentChannel());\n-                    break;\n-                case CONTROL:\n-                    transportState = this.transportState;\n-                    State newState = UnDefType.UNDEF;\n-                    if (\"PLAYING\".equals(transportState)) {\n-                        newState = PlayPauseType.PLAY;\n-                    } else if (\"STOPPED\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    }\n-                    updateState(channelUID, newState);\n-                    break;\n+            playingNotification = false;\n+            notificationVolume = null;\n+            notificationUri = \"\";\n+\n+            if (playing) {\n+                int pos = posAtNotificationStart;\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+                play();\n             }\n-            return;\n-        } else {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    setVolume(getCurrentChannel(), (PercentType) command);\n-                    break;\n-                case MUTE:\n-                    setMute(getCurrentChannel(), (OnOffType) command);\n-                    break;\n-                case STOP:\n-                    if (command == OnOffType.ON) {\n-                        updateState(CONTROL, PlayPauseType.PAUSE);\n-                        playerStopped = true;\n-                        stop();\n-                        updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n-                    }\n-                    break;\n-                case CONTROL:\n-                    playerStopped = false;\n-                    if (command instanceof PlayPauseType) {\n-                        if (command == PlayPauseType.PLAY) {\n-                            play();\n-                        } else if (command == PlayPauseType.PAUSE) {\n-                            pause();\n-                        }\n-                    } else if (command instanceof NextPreviousType) {\n-                        if (command == NextPreviousType.NEXT) {\n-                            playerStopped = true;\n-                            serveNext();\n-                        } else if (command == NextPreviousType.PREVIOUS) {\n-                            playerStopped = true;\n-                            servePrevious();\n-                        }\n-                    } else if (command instanceof RewindFastforwardType) {\n-                    }\n-                    break;\n+            posAtNotificationStart = 0;\n+        }\n+    }\n+\n+    private void playFavorite() {\n+        UpnpFavorite favorite = new UpnpFavorite(favoriteName, bindingConfig.path);\n+        String uri = favorite.getUri();\n+        UpnpEntry entry = favorite.getUpnpEntry();\n+        if (!uri.isEmpty()) {\n+            String metadata = \"\";\n+            if (entry != null) {\n+                metadata = UpnpXMLParser.compileMetadataString(entry);\n             }\n+            setCurrentURI(uri, metadata);\n+            play();\n+        }\n+    }\n \n-            return;\n+    void updateFavoritesList() {\n+        synchronized (favoriteCommandOptionList) {\n+            favoriteCommandOptionList = UpnpControlUtil.favorites(bindingConfig.path).stream()\n+                    .map(p -> (new CommandOption(p, p))).collect(Collectors.toList());\n+        }\n+        updateCommandDescription(favoriteSelectChannelUID, favoriteCommandOptionList);\n+    }\n+\n+    @Override\n+    public void playlistsListChanged() {\n+        synchronized (playlistCommandOptionList) {\n+            playlistCommandOptionList = UpnpControlUtil.playlists().stream().map(p -> (new CommandOption(p, p)))\n+                    .collect(Collectors.toList());\n         }", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3ODcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r528078701", "bodyText": "Remove the blank lines here.", "author": "cpmeister", "createdAt": "2020-11-21T06:03:11Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpServerHandler.java", "diffHunk": "@@ -122,34 +134,155 @@ public void initialize() {\n                     \"Channel \" + BROWSE + \" not defined\");\n             return;\n         }\n-        if (config.udn != null) {\n-            if (service.isRegistered(this)) {\n-                initServer();\n-            } else {\n+        Channel playlistSelectChannel = thing.getChannel(PLAYLIST_SELECT);\n+        if (playlistSelectChannel != null) {\n+            playlistSelectChannelUID = playlistSelectChannel.getUID();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Channel \" + PLAYLIST_SELECT + \" not defined\");\n+            return;\n+        }\n+\n+        initDevice();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for media server device {}\", thing.getLabel());\n+\n+        CompletableFuture<Boolean> browsingFuture = isBrowsing;\n+        if (browsingFuture != null) {\n+            browsingFuture.complete(false);\n+            isBrowsing = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    protected void initJob() {\n+        synchronized (jobLock) {\n+            if (!upnpIOService.isRegistered(this)) {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n-                        \"Communication cannot be established with \" + thing.getLabel());\n+                        \"UPnP device with UDN \" + getUDN() + \" not yet registered\");\n+                return;\n+            }\n+\n+            if (!ThingStatus.ONLINE.equals(thing.getStatus())) {\n+                rendererStateOptionList = Collections.synchronizedList(new ArrayList<>());\n+                synchronized (rendererStateOptionList) {\n+                    upnpRenderers.forEach((key, value) -> {\n+                        StateOption stateOption = new StateOption(key, value.getThing().getLabel());\n+                        rendererStateOptionList.add(stateOption);\n+                    });\n+                }\n+                updateStateDescription(rendererChannelUID, rendererStateOptionList);\n+\n+                getProtocolInfo();\n+\n+                browse(currentEntry.getId(), \"BrowseDirectChildren\", \"*\", \"0\", \"0\", config.sortcriteria);\n+\n+                playlistsListChanged();\n+\n+                updateStatus(ThingStatus.ONLINE);", "originalCommit": "ad7fa5603e6fcb602acccd6dd3627c2049681287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5ODQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r529798412", "bodyText": "You should be catching the NumberFormatException that is thrown by the Integer.parseInt.", "author": "cpmeister", "createdAt": "2020-11-24T18:40:55Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -411,255 +554,808 @@ protected void setMute(String channel, OnOffType mute) {\n         inputs.put(\"Channel\", channel);\n         inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n \n-        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getLoudness(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setLoudness(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredLoudness\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Called from server handler for renderer to be able to send back status to server handler\n+     *\n+     * @param handler\n+     */\n+    protected void setServerHandler(UpnpServerHandler handler) {\n+        logger.debug(\"Set server handler {} on renderer {}\", handler.getThing().getLabel(), thing.getLabel());\n+        serverHandlers.add(handler);\n+    }\n+\n+    /**\n+     * Should be called from server handler when server stops serving this renderer\n+     */\n+    protected void unsetServerHandler() {\n+        logger.debug(\"Unset server handler on renderer {}\", thing.getLabel());\n+        for (UpnpServerHandler handler : serverHandlers) {\n+            Thing serverThing = handler.getThing();\n+            Channel serverChannel;\n+            for (String channel : SERVER_CONTROL_CHANNELS) {\n+                if ((serverChannel = serverThing.getChannel(channel)) != null) {\n+                    handler.updateServerState(serverChannel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+\n+            serverHandlers.remove(handler);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateState(ChannelUID channelUID, State state) {\n+        // override to be able to propagate channel state updates to corresponding channels on the server\n+        if (SERVER_CONTROL_CHANNELS.contains(channelUID.getId())) {\n+            for (UpnpServerHandler handler : serverHandlers) {\n+                Thing serverThing = handler.getThing();\n+                Channel serverChannel = serverThing.getChannel(channelUID.getId());\n+                if (serverChannel != null) {\n+                    logger.debug(\"Update server {} channel {} with state {} from renderer {}\", serverThing.getLabel(),\n+                            state, channelUID, thing.getLabel());\n+                    handler.updateServerState(serverChannel.getUID(), state);\n+                }\n+            }\n+        }\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String id = channelUID.getId();\n+\n+        if (id.endsWith(\"volume\")) {\n+            handleCommandVolume(command, id);\n+        } else if (id.endsWith(\"mute\")) {\n+            handleCommandMute(command, id);\n+        } else if (id.endsWith(\"loudness\")) {\n+            handleCommandLoudness(command, id);\n+        } else {\n+            switch (id) {\n+                case STOP:\n+                    handleCommandStop(command);\n+                    break;\n+                case CONTROL:\n+                    handleCommandControl(channelUID, command);\n+                    break;\n+                case REPEAT:\n+                    handleCommandRepeat(channelUID, command);\n+                    break;\n+                case SHUFFLE:\n+                    handleCommandShuffle(channelUID, command);\n+                case ONLY_PLAY_ONE:\n+                    handleCommandOnlyPlayOne(channelUID, command);\n+                    break;\n+                case URI:\n+                    handleCommandUri(channelUID, command);\n+                    break;\n+                case FAVORITE_SELECT:\n+                    handleCommandFavoriteSelect(command);\n+                    break;\n+                case FAVORITE:\n+                    handleCommandFavorite(channelUID, command);\n+                    break;\n+                case FAVORITE_ACTION:\n+                    handleCommandFavoriteAction(command);\n+                    break;\n+                case PLAYLIST_SELECT:\n+                    handleCommandPlaylistSelect(command);\n+                    break;\n+                case TRACK_POSITION:\n+                    handleCommandTrackPosition(channelUID, command);\n+                    break;\n+                case REL_TRACK_POSITION:\n+                    handleCommandRelTrackPosition(channelUID, command);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"));\n+        } else if (command instanceof PercentType) {\n+            setVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"), (PercentType) command);\n+        }\n+    }\n+\n+    private void handleCommandMute(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandLoudness(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (OnOffType.ON.equals(command)) {\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            stop();\n+            updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void handleCommandControl(ChannelUID channelUID, Command command) {\n+        String state;\n+        if (command instanceof RefreshType) {\n+            state = transportState;\n+            State newState = UnDefType.UNDEF;\n+            if (\"PLAYING\".equals(state)) {\n+                newState = PlayPauseType.PLAY;\n+            } else if (\"STOPPED\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            } else if (\"PAUSED_PLAYBACK\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            }\n+            updateState(channelUID, newState);\n+        } else if (command instanceof PlayPauseType) {\n+            if (PlayPauseType.PLAY.equals(command)) {\n+                if (registeredQueue) {\n+                    registeredQueue = false;\n+                    playingQueue = true;\n+                    oneplayed = false;\n+                    serve();\n+                } else {\n+                    play();\n+                }\n+            } else if (PlayPauseType.PAUSE.equals(command)) {\n+                checkPaused();\n+                pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (NextPreviousType.NEXT.equals(command)) {\n+                serveNext();\n+            } else if (NextPreviousType.PREVIOUS.equals(command)) {\n+                servePrevious();\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            int pos = 0;\n+            if (RewindFastforwardType.FASTFORWARD.equals(command)) {\n+                pos = Integer.min(trackDuration, trackPosition + config.seekStep);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                pos = Integer.max(0, trackPosition - config.seekStep);\n+            }\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    private void handleCommandRepeat(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(repeat));\n+        } else {\n+            repeat = (OnOffType.ON.equals(command));\n+            currentQueue.setRepeat(repeat);\n+            updateState(channelUID, OnOffType.from(repeat));\n+            logger.debug(\"Repeat set to {} for {}\", repeat, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandShuffle(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(shuffle));\n+        } else {\n+            shuffle = (OnOffType.ON.equals(command));\n+            currentQueue.setShuffle(shuffle);\n+            if (!playing) {\n+                resetToStartQueue();\n+            }\n+            updateState(channelUID, OnOffType.from(shuffle));\n+            logger.debug(\"Shuffle set to {} for {}\", shuffle, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandOnlyPlayOne(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+        } else {\n+            onlyplayone = (OnOffType.ON.equals(command));\n+            oneplayed = (onlyplayone && playing) ? true : false;\n+            if (oneplayed) {\n+                setNextURI(\"\", \"\");\n+            } else {\n+                UpnpEntry next = nextEntry;\n+                if (next != null) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                }\n+            }\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+            logger.debug(\"OnlyPlayOne set to {} for {}\", onlyplayone, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandUri(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, StringType.valueOf(nowPlayingUri));\n+        } else if (command instanceof StringType) {\n+            setCurrentURI(command.toString(), \"\");\n+            play();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSelect(Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            updateState(FAVORITE, StringType.valueOf(favoriteName));\n+            playFavorite();\n+        }\n+    }\n+\n+    private void handleCommandFavorite(ChannelUID channelUID, Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            if (favoriteCommandOptionList.contains(new CommandOption(favoriteName, favoriteName))) {\n+                playFavorite();\n+            }\n+        }\n+        updateState(channelUID, StringType.valueOf(favoriteName));\n+    }\n+\n+    private void handleCommandFavoriteAction(Command command) {\n+        if (command instanceof StringType) {\n+            switch (command.toString()) {\n+                case SAVE:\n+                    handleCommandFavoriteSave();\n+                    break;\n+                case DELETE:\n+                    handleCommandFavoriteDelete();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSave() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpFavorite favorite = new UpnpFavorite(favoriteName, nowPlayingUri, currentEntry);\n+            favorite.saveFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteDelete() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpControlUtil.deleteFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+            updateState(FAVORITE, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void handleCommandPlaylistSelect(Command command) {\n+        if (command instanceof StringType) {\n+            String playlistName = command.toString();\n+            UpnpEntryQueue queue = new UpnpEntryQueue();\n+            queue.restoreQueue(playlistName, null, bindingConfig.path);\n+            registerQueue(queue);\n+            resetToStartQueue();\n+            playingQueue = true;\n+            serve();\n+        }\n+    }\n+\n+    private void handleCommandTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+        } else if (command instanceof QuantityType<?>) {\n+            QuantityType<?> position = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+            if (position != null) {\n+                int pos = Integer.min(trackDuration, position.intValue());\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+            }\n+        }\n+    }\n+\n+    private void handleCommandRelTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            int relPosition = (trackDuration != 0) ? (trackPosition * 100) / trackDuration : 0;\n+            updateState(channelUID, new PercentType(relPosition));\n+        } else if (command instanceof PercentType) {\n+            int pos = ((PercentType) command).intValue() * trackDuration / 100;\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    /**\n+     * Set the volume for notifications.\n+     *\n+     * @param volume\n+     */\n+    public void setNotificationVolume(PercentType volume) {\n+        notificationVolume = volume;\n+    }\n+\n+    /**\n+     * Play a notification. Previous state of the renderer will resume at the end of the notification, or after the\n+     * maximum notification duration as defined in the renderer parameters.\n+     *\n+     * @param URI for notification sound\n+     */\n+    public void playNotification(String URI) {\n+        synchronized (notificationLock) {\n+            if (URI.isEmpty()) {\n+                logger.debug(\"UPnP device {} received empty notification URI\", thing.getLabel());\n+                return;\n+            }\n+\n+            notificationUri = URI;\n+\n+            logger.debug(\"UPnP device {} playing notification {}\", thing.getLabel(), URI);\n+\n+            cancelTrackPositionRefresh();\n+            getPositionInfo();\n+\n+            cancelPlayingNotificationFuture();\n+\n+            if (config.maxNotificationDuration > 0) {\n+                playingNotificationFuture = upnpScheduler.schedule(this::stop, config.maxNotificationDuration,\n+                        TimeUnit.SECONDS);\n+            }\n+            playingNotification = true;\n+\n+            setCurrentURI(URI, \"\");\n+            setNextURI(\"\", \"\");\n+            PercentType volume = notificationVolume;\n+            setVolume(volume == null\n+                    ? new PercentType(Math.min(100,\n+                            Math.max(0, (100 + config.notificationVolumeAdjustment) * soundVolume.intValue() / 100)))\n+                    : volume);\n+\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            try {\n+                if (stopping != null) {\n+                    // wait for maximum 2.5s until the renderer stopped before playing\n+                    stopping.get(config.responseTimeout, TimeUnit.MILLISECONDS);\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.debug(\"Timeout exception, renderer {} didn't stop yet, trying to play anyway\", thing.getLabel());\n+            }\n+            play();\n+        }\n+    }\n+\n+    private void cancelPlayingNotificationFuture() {\n+        ScheduledFuture<?> future = playingNotificationFuture;\n+        if (future != null) {\n+            future.cancel(true);\n+            playingNotificationFuture = null;\n+        }\n     }\n \n-    /**\n-     * Invoke getPositionInfo on UPnP Rendering Control.\n-     * Result is received in {@link onValueReceived}.\n-     */\n-    protected void getPositionInfo() {\n-        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+    private void resumeAfterNotification() {\n+        synchronized (notificationLock) {\n+            logger.debug(\"UPnP device {} resume after playing notification\", thing.getLabel());\n \n-        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n-    }\n+            setCurrentURI(nowPlayingUri, \"\");\n+            setVolume(soundVolume);\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+            cancelPlayingNotificationFuture();\n \n-        String transportState;\n-        if (command instanceof RefreshType) {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    getVolume(getCurrentChannel());\n-                    break;\n-                case MUTE:\n-                    getMute(getCurrentChannel());\n-                    break;\n-                case CONTROL:\n-                    transportState = this.transportState;\n-                    State newState = UnDefType.UNDEF;\n-                    if (\"PLAYING\".equals(transportState)) {\n-                        newState = PlayPauseType.PLAY;\n-                    } else if (\"STOPPED\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    }\n-                    updateState(channelUID, newState);\n-                    break;\n-            }\n-            return;\n-        } else {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    setVolume(getCurrentChannel(), (PercentType) command);\n-                    break;\n-                case MUTE:\n-                    setMute(getCurrentChannel(), (OnOffType) command);\n-                    break;\n-                case STOP:\n-                    if (command == OnOffType.ON) {\n-                        updateState(CONTROL, PlayPauseType.PAUSE);\n-                        playerStopped = true;\n-                        stop();\n-                        updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n-                    }\n-                    break;\n-                case CONTROL:\n-                    playerStopped = false;\n-                    if (command instanceof PlayPauseType) {\n-                        if (command == PlayPauseType.PLAY) {\n-                            play();\n-                        } else if (command == PlayPauseType.PAUSE) {\n-                            pause();\n-                        }\n-                    } else if (command instanceof NextPreviousType) {\n-                        if (command == NextPreviousType.NEXT) {\n-                            playerStopped = true;\n-                            serveNext();\n-                        } else if (command == NextPreviousType.PREVIOUS) {\n-                            playerStopped = true;\n-                            servePrevious();\n-                        }\n-                    } else if (command instanceof RewindFastforwardType) {\n-                    }\n-                    break;\n+            playingNotification = false;\n+            notificationVolume = null;\n+            notificationUri = \"\";\n+\n+            if (playing) {\n+                int pos = posAtNotificationStart;\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+                play();\n             }\n+            posAtNotificationStart = 0;\n+        }\n+    }\n \n-            return;\n+    private void playFavorite() {\n+        UpnpFavorite favorite = new UpnpFavorite(favoriteName, bindingConfig.path);\n+        String uri = favorite.getUri();\n+        UpnpEntry entry = favorite.getUpnpEntry();\n+        if (!uri.isEmpty()) {\n+            String metadata = \"\";\n+            if (entry != null) {\n+                metadata = UpnpXMLParser.compileMetadataString(entry);\n+            }\n+            setCurrentURI(uri, metadata);\n+            play();\n         }\n     }\n \n+    void updateFavoritesList() {\n+        favoriteCommandOptionList = UpnpControlUtil.favorites(bindingConfig.path).stream()\n+                .map(p -> (new CommandOption(p, p))).collect(Collectors.toList());\n+        updateCommandDescription(favoriteSelectChannelUID, favoriteCommandOptionList);\n+    }\n+\n+    @Override\n+    public void playlistsListChanged() {\n+        playlistCommandOptionList = UpnpControlUtil.playlists().stream().map(p -> (new CommandOption(p, p)))\n+                .collect(Collectors.toList());\n+        updateCommandDescription(playlistSelectChannelUID, playlistCommandOptionList);\n+    }\n+\n     @Override\n     public void onStatusChanged(boolean status) {\n-        logger.debug(\"Renderer status changed to {}\", status);\n-        if (status) {\n-            initRenderer();\n-        } else {\n-            cancelSubscriptionRefreshJob();\n+        if (!status) {\n+            removeSubscriptions();\n \n             updateState(CONTROL, PlayPauseType.PAUSE);\n             cancelTrackPositionRefresh();\n-\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n-                    \"Communication lost with \" + thing.getLabel());\n         }\n         super.onStatusChanged(status);\n     }\n \n+    @Override\n+    protected @Nullable String preProcessValueReceived(Map<String, String> inputs, @Nullable String variable,\n+            @Nullable String value, @Nullable String service, @Nullable String action) {\n+        if (variable == null) {\n+            return null;\n+        } else {\n+            switch (variable) {\n+                case \"CurrentVolume\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Volume\";\n+                case \"CurrentMute\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Mute\";\n+                case \"CurrentLoudness\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Loudness\";\n+                default:\n+                    return variable;\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n         if (logger.isTraceEnabled()) {\n-            logger.trace(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+            logger.trace(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                     variable, value, service);\n         } else {\n             if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n                     || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n                     || \"TrackDuration\".equals(variable))) {\n                 // don't log all variables received when updating the track position every second\n-                logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                logger.debug(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                         variable, value, service);\n             }\n         }\n         if (variable == null) {\n             return;\n         }\n \n-        switch (variable) {\n-            case \"CurrentMute\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundMute = OnOffType.from(Boolean.parseBoolean(value));\n-                    updateState(MUTE, soundMute);\n-                }\n-                break;\n-            case \"CurrentVolume\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundVolume = PercentType.valueOf(value);\n-                    updateState(VOLUME, soundVolume);\n-                }\n-                break;\n-            case \"Sink\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    updateProtocolInfo(value);\n-                }\n-                break;\n-            case \"LastChange\":\n-                // pre-process some variables, eg XML processing\n-                if (!((value == null) || value.isEmpty())) {\n-                    if (\"AVTransport\".equals(service)) {\n-                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n-                        for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n-                            // Update the transport state after the update of the media information\n-                            // to not break the notification mechanism\n-                            if (!\"TransportState\".equals(entrySet.getKey())) {\n-                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n-                            }\n-                            if (\"AVTransportURI\".equals(entrySet.getKey())) {\n+        if (variable.endsWith(\"Volume\")) {\n+            onValueReceivedVolume(variable, value);\n+        } else if (variable.endsWith(\"Mute\")) {\n+            onValueReceivedMute(variable, value);\n+        } else if (variable.endsWith(\"Loudness\")) {\n+            onValueReceivedLoudness(variable, value);\n+        } else {\n+            switch (variable) {\n+                case \"LastChange\":\n+                    onValueReceivedLastChange(value, service);\n+                    break;\n+                case \"CurrentTransportState\":\n+                case \"TransportState\":\n+                    onValueReceivedTransportState(value);\n+                    break;\n+                case \"CurrentTrackURI\":\n+                case \"CurrentURI\":\n+                    onValueReceivedCurrentURI(value);\n+                    break;\n+                case \"CurrentTrackMetaData\":\n+                case \"CurrentURIMetaData\":\n+                    onValueReceivedCurrentMetaData(value);\n+                    break;\n+                case \"NextAVTransportURIMetaData\":\n+                case \"NextURIMetaData\":\n+                    onValueReceivedNextMetaData(value);\n+                    break;\n+                case \"CurrentTrackDuration\":\n+                case \"TrackDuration\":\n+                    onValueReceivedDuration(value);\n+                    break;\n+                case \"RelTime\":\n+                    onValueReceivedRelTime(value);\n+                    break;\n+                default:\n+                    super.onValueReceived(variable, value, service);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedVolume(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            UpnpRenderingControlConfiguration config = renderingControlConfiguration;\n+\n+            long volume = Long.valueOf(value);\n+            volume = volume * 100 / config.maxvolume;\n+\n+            String upnpChannel = variable.replace(\"Volume\", \"volume\").replace(\"Master\", \"\");\n+            updateState(upnpChannel, new PercentType((int) volume));\n+\n+            if (!playingNotification && \"volume\".equals(upnpChannel)) {\n+                soundVolume = new PercentType((int) volume);\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedMute(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            String upnpChannel = variable.replace(\"Mute\", \"mute\").replace(\"Master\", \"\");\n+            updateState(upnpChannel,\n+                    (\"1\".equals(value) || \"true\".equals(value.toLowerCase())) ? OnOffType.ON : OnOffType.OFF);\n+        }\n+    }\n+\n+    private void onValueReceivedLoudness(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            String upnpChannel = variable.replace(\"Mute\", \"mute\").replace(\"Master\", \"\");\n+            updateState(upnpChannel,\n+                    (\"1\".equals(value) || \"true\".equals(value.toLowerCase())) ? OnOffType.ON : OnOffType.OFF);\n+        }\n+    }\n+\n+    private void onValueReceivedLastChange(@Nullable String value, @Nullable String service) {\n+        // This is returned from a GENA subscription. The jupnp library does not allow receiving new GENA subscription\n+        // messages as long as this thread has not finished. As we may trigger long running processes based on this\n+        // result, we run it in a separate thread.\n+        upnpScheduler.submit(() -> {\n+            // pre-process some variables, eg XML processing\n+            if (!((value == null) || value.isEmpty())) {\n+                if (\"AVTransport\".equals(service)) {\n+                    Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n+                    for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n+                        switch (entrySet.getKey()) {\n+                            case \"TransportState\":\n+                                // Update the transport state after the update of the media information\n+                                // to not break the notification mechanism\n+                                break;\n+                            case \"AVTransportURI\":\n                                 onValueReceived(\"CurrentTrackURI\", entrySet.getValue(), service);\n-                            } else if (\"AVTransportURIMetaData\".equals(entrySet.getKey())) {\n+                                break;\n+                            case \"AVTransportURIMetaData\":\n                                 onValueReceived(\"CurrentTrackMetaData\", entrySet.getValue(), service);\n-                            }\n-                        }\n-                        if (parsedValues.containsKey(\"TransportState\")) {\n-                            onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n+                                break;\n+                            default:\n+                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n                         }\n                     }\n-                }\n-                break;\n-            case \"TransportState\":\n-                transportState = (value == null) ? \"\" : value;\n-                if (\"STOPPED\".equals(value)) {\n-                    updateState(CONTROL, PlayPauseType.PAUSE);\n-                    cancelTrackPositionRefresh();\n-                    // playerStopped is true if stop came from openHAB. This allows us to identify if we played to the\n-                    // end of an entry. We should then move to the next entry if the queue is not at the end already.\n-                    if (playing && !playerStopped) {\n-                        // Only go to next for first STOP command, then wait until we received PLAYING before moving\n-                        // to next (avoids issues with renderers sending multiple stop states)\n-                        playing = false;\n-                        serveNext();\n-                    } else {\n-                        currentEntry = nextEntry; // Try to get the metadata for the next entry if controlled by an\n-                                                  // external control point\n-                        playing = false;\n-                    }\n-                } else if (\"PLAYING\".equals(value)) {\n-                    playerStopped = false;\n-                    playing = true;\n-                    updateState(CONTROL, PlayPauseType.PLAY);\n-                    scheduleTrackPositionRefresh();\n-                } else if (\"PAUSED_PLAYBACK\".equals(value)) {\n-                    updateState(CONTROL, PlayPauseType.PAUSE);\n-                }\n-                break;\n-            case \"CurrentTrackURI\":\n-                UpnpEntry current = currentEntry;\n-                if (queueIterator.hasNext() && (current != null) && !current.getRes().equals(value)\n-                        && currentQueue.get(queueIterator.nextIndex()).getRes().equals(value)) {\n-                    // Renderer advanced to next entry independent of openHAB UPnP control point.\n-                    // Advance in the queue to keep proper position status.\n-                    // Make the next entry available to renderers that support it.\n-                    updateMetaDataState(currentQueue.get(queueIterator.nextIndex()));\n-                    logger.trace(\"Renderer moved from '{}' to next entry '{}' in queue\", currentEntry,\n-                            currentQueue.get(queueIterator.nextIndex()));\n-                    currentEntry = queueIterator.next();\n-                    if (queueIterator.hasNext()) {\n-                        UpnpEntry next = currentQueue.get(queueIterator.nextIndex());\n-                        setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                    if (parsedValues.containsKey(\"TransportState\")) {\n+                        onValueReceived(\"TransportState\", parsedValues.get(\"TransportState\"), service);\n                     }\n-                }\n-                if (isSettingURI != null) {\n-                    isSettingURI.complete(true); // We have received current URI, so can allow play to start\n-                }\n-                break;\n-            case \"CurrentTrackMetaData\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n-                    if (!list.isEmpty()) {\n-                        updateMetaDataState(list.get(0));\n+                } else if (\"RenderingControl\".equals(service)) {\n+                    Map<String, @Nullable String> parsedValues = UpnpXMLParser.getRenderingControlFromXML(value);\n+                    for (String parsedValue : parsedValues.keySet()) {\n+                        onValueReceived(parsedValue, parsedValues.get(parsedValue), \"RenderingControl\");\n                     }\n                 }\n-                break;\n-            case \"NextAVTransportURIMetaData\":\n-                if (!((value == null) || (value.isEmpty() || \"NOT_IMPLEMENTED\".equals(value)))) {\n-                    List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n-                    if (!list.isEmpty()) {\n-                        nextEntry = list.get(0);\n+            }\n+        });\n+    }\n+\n+    private void onValueReceivedTransportState(@Nullable String value) {\n+        transportState = (value == null) ? \"\" : value;\n+\n+        if (\"STOPPED\".equals(value)) {\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            if (stopping != null) {\n+                stopping.complete(true); // We have received stop confirmation\n+                isStopping = null;\n+            }\n+\n+            if (playingNotification) {\n+                resumeAfterNotification();\n+                return;\n+            }\n+\n+            cancelCheckPaused();\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            cancelTrackPositionRefresh();\n+            // Only go to next for first STOP command, then wait until we received PLAYING before moving\n+            // to next (avoids issues with renderers sending multiple stop states)\n+            if (playing) {\n+                playing = false;\n+\n+                // playerStopped is true if stop came from openHAB. This allows us to identify if we played to the\n+                // end of an entry, because STOP would come from the player and not from openHAB. We should then\n+                // move to the next entry if the queue is not at the end already.\n+                if (!playerStopped) {\n+                    if (Instant.now().toEpochMilli() >= expectedTrackend) {\n+                        // If we are receiving track duration info, we know when the track is expected to end. If we\n+                        // received STOP before track end, and it is not coming from openHAB, it must have been stopped\n+                        // from the renderer directly, and we do not want to play the next entry.\n+                        if (playingQueue) {\n+                            serveNext();\n+                        }\n                     }\n+                } else if (playingQueue) {\n+                    playingQueue = false;\n                 }\n-                break;\n-            case \"CurrentTrackDuration\":\n-            case \"TrackDuration\":\n-                // track duration and track position have format H+:MM:SS[.F+] or H+:MM:SS[.F0/F1]. We are not\n-                // interested in the fractional seconds, so drop everything after . and calculate in seconds.\n-                if ((value == null) || (\"NOT_IMPLEMENTED\".equals(value))) {\n-                    trackDuration = 0;\n-                    updateState(TRACK_DURATION, UnDefType.UNDEF);\n-                } else {\n-                    trackDuration = Arrays.stream(value.split(\"\\\\.\")[0].split(\":\")).mapToInt(n -> Integer.parseInt(n))\n-                            .reduce(0, (n, m) -> n * 60 + m);\n-                    updateState(TRACK_DURATION, new QuantityType<>(trackDuration, SmartHomeUnits.SECOND));\n-                }\n-                break;\n-            case \"RelTime\":\n-                if ((value == null) || (\"NOT_IMPLEMENTED\".equals(value))) {\n-                    trackPosition = 0;\n-                    updateState(TRACK_POSITION, UnDefType.UNDEF);\n-                } else {\n-                    trackPosition = Arrays.stream(value.split(\"\\\\.\")[0].split(\":\")).mapToInt(n -> Integer.parseInt(n))\n-                            .reduce(0, (n, m) -> n * 60 + m);\n-                    updateState(TRACK_POSITION, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+            }\n+        } else if (\"PLAYING\".equals(value)) {\n+            if (playingNotification) {\n+                return;\n+            }\n+\n+            playerStopped = false;\n+            playing = true;\n+            registeredQueue = false; // reset queue registration flag as we are playing something\n+            updateState(CONTROL, PlayPauseType.PLAY);\n+            scheduleTrackPositionRefresh();\n+        } else if (\"PAUSED_PLAYBACK\".equals(value)) {\n+            cancelCheckPaused();\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+        } else if (\"NO_MEDIA_PRESENT\".equals(value)) {\n+            updateState(CONTROL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void onValueReceivedCurrentURI(@Nullable String value) {\n+        CompletableFuture<Boolean> settingURI = isSettingURI;\n+        if (settingURI != null) {\n+            settingURI.complete(true); // We have received current URI, so can allow play to start\n+        }\n+\n+        UpnpEntry current = currentEntry;\n+        UpnpEntry next = nextEntry;\n+\n+        String uri = \"\";\n+        String currentUri = \"\";\n+        String nextUri = \"\";\n+        try {\n+            if (value != null) {\n+                uri = URLDecoder.decode(value.trim(), StandardCharsets.UTF_8.name());\n+            }\n+            if (current != null) {\n+                currentUri = URLDecoder.decode(current.getRes().trim(), StandardCharsets.UTF_8.name());\n+            }\n+            if (next != null) {\n+                nextUri = URLDecoder.decode(next.getRes(), StandardCharsets.UTF_8.name());\n+            }\n+        } catch (UnsupportedEncodingException ignore) {\n+            // If not valid current URI, we assume there is none\n+        }\n+\n+        if (playingNotification && uri.equals(notificationUri)) {\n+            // No need to update anything more if this is for playing a notification\n+            return;\n+        }\n+\n+        nowPlayingUri = uri;\n+        updateState(URI, StringType.valueOf(uri));\n+\n+        logger.trace(\"Renderer {} received URI: {}\", thing.getLabel(), uri);\n+        logger.trace(\"Renderer {} current URI: {}, equal to received URI {}\", thing.getLabel(), currentUri,\n+                uri.equals(currentUri));\n+        logger.trace(\"Renderer {} next URI: {}\", thing.getLabel(), nextUri);\n+\n+        if (!uri.equals(currentUri)) {\n+            if ((next != null) && uri.equals(nextUri)) {\n+                // Renderer advanced to next entry independent of openHAB UPnP control point.\n+                // Advance in the queue to keep proper position status.\n+                // Make the next entry available to renderers that support it.\n+                logger.trace(\"Renderer {} moved from '{}' to next entry '{}' in queue\", thing.getLabel(), current,\n+                        next);\n+                currentEntry = currentQueue.next();\n+                nextEntry = currentQueue.get(currentQueue.nextIndex());\n+                logger.trace(\"Renderer {} auto move forward, current queue index: {}\", thing.getLabel(),\n+                        currentQueue.index());\n+\n+                updateMetaDataState(next);\n+\n+                // look one further to get next entry for next URI\n+                next = nextEntry;\n+                if ((next != null) && !onlyplayone) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n                 }\n-                break;\n-            default:\n-                super.onValueReceived(variable, value, service);\n-                break;\n+            } else {\n+                // A new entry is being served that does not match the next entry in the queue. This can be because a\n+                // sound or stream is being played through an action, or another control point started a new entry.\n+                // We should clear the metadata in this case and wait for new metadata to arrive.\n+                clearMetaDataState();\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedCurrentMetaData(@Nullable String value) {\n+        if (playingNotification) {\n+            // Don't update metadata when playing notification\n+            return;\n+        }\n+\n+        if (!((value == null) || (value.isEmpty()))) {\n+            List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+            if (!list.isEmpty()) {\n+                updateMetaDataState(list.get(0));\n+                return;\n+            }\n+        }\n+        clearMetaDataState();\n+    }\n+\n+    private void onValueReceivedNextMetaData(@Nullable String value) {\n+        if (!((value == null) || (value.isEmpty() || \"NOT_IMPLEMENTED\".equals(value)))) {\n+            List<UpnpEntry> list = UpnpXMLParser.getEntriesFromXML(value);\n+            if (!list.isEmpty()) {\n+                nextEntry = list.get(0);\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedDuration(@Nullable String value) {\n+        // track duration and track position have format H+:MM:SS[.F+] or H+:MM:SS[.F0/F1]. We are not\n+        // interested in the fractional seconds, so drop everything after . and calculate in seconds.\n+        if ((value == null) || (\"NOT_IMPLEMENTED\".equals(value))) {\n+            trackDuration = 0;\n+            updateState(TRACK_DURATION, UnDefType.UNDEF);\n+            updateState(REL_TRACK_POSITION, UnDefType.UNDEF);\n+        } else {\n+            trackDuration = Arrays.stream(value.split(\"\\\\.\")[0].split(\":\")).mapToInt(n -> Integer.parseInt(n)).reduce(0,\n+                    (n, m) -> n * 60 + m);\n+            updateState(TRACK_DURATION, new QuantityType<>(trackDuration, SmartHomeUnits.SECOND));", "originalCommit": "ed0c4905216eda13d57a406787ed39aba91b036b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5OTI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r529799243", "bodyText": "Writing it like this is a bit easier to read.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!((value == null) || (value.isEmpty()))) {\n          \n          \n            \n                    if (value != null && !value.isEmpty()) {\n          \n      \n    \n    \n  \n\nPlease update elsewhere as well.", "author": "cpmeister", "createdAt": "2020-11-24T18:42:17Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -411,255 +554,808 @@ protected void setMute(String channel, OnOffType mute) {\n         inputs.put(\"Channel\", channel);\n         inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n \n-        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getLoudness(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setLoudness(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredLoudness\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Called from server handler for renderer to be able to send back status to server handler\n+     *\n+     * @param handler\n+     */\n+    protected void setServerHandler(UpnpServerHandler handler) {\n+        logger.debug(\"Set server handler {} on renderer {}\", handler.getThing().getLabel(), thing.getLabel());\n+        serverHandlers.add(handler);\n+    }\n+\n+    /**\n+     * Should be called from server handler when server stops serving this renderer\n+     */\n+    protected void unsetServerHandler() {\n+        logger.debug(\"Unset server handler on renderer {}\", thing.getLabel());\n+        for (UpnpServerHandler handler : serverHandlers) {\n+            Thing serverThing = handler.getThing();\n+            Channel serverChannel;\n+            for (String channel : SERVER_CONTROL_CHANNELS) {\n+                if ((serverChannel = serverThing.getChannel(channel)) != null) {\n+                    handler.updateServerState(serverChannel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+\n+            serverHandlers.remove(handler);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateState(ChannelUID channelUID, State state) {\n+        // override to be able to propagate channel state updates to corresponding channels on the server\n+        if (SERVER_CONTROL_CHANNELS.contains(channelUID.getId())) {\n+            for (UpnpServerHandler handler : serverHandlers) {\n+                Thing serverThing = handler.getThing();\n+                Channel serverChannel = serverThing.getChannel(channelUID.getId());\n+                if (serverChannel != null) {\n+                    logger.debug(\"Update server {} channel {} with state {} from renderer {}\", serverThing.getLabel(),\n+                            state, channelUID, thing.getLabel());\n+                    handler.updateServerState(serverChannel.getUID(), state);\n+                }\n+            }\n+        }\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String id = channelUID.getId();\n+\n+        if (id.endsWith(\"volume\")) {\n+            handleCommandVolume(command, id);\n+        } else if (id.endsWith(\"mute\")) {\n+            handleCommandMute(command, id);\n+        } else if (id.endsWith(\"loudness\")) {\n+            handleCommandLoudness(command, id);\n+        } else {\n+            switch (id) {\n+                case STOP:\n+                    handleCommandStop(command);\n+                    break;\n+                case CONTROL:\n+                    handleCommandControl(channelUID, command);\n+                    break;\n+                case REPEAT:\n+                    handleCommandRepeat(channelUID, command);\n+                    break;\n+                case SHUFFLE:\n+                    handleCommandShuffle(channelUID, command);\n+                case ONLY_PLAY_ONE:\n+                    handleCommandOnlyPlayOne(channelUID, command);\n+                    break;\n+                case URI:\n+                    handleCommandUri(channelUID, command);\n+                    break;\n+                case FAVORITE_SELECT:\n+                    handleCommandFavoriteSelect(command);\n+                    break;\n+                case FAVORITE:\n+                    handleCommandFavorite(channelUID, command);\n+                    break;\n+                case FAVORITE_ACTION:\n+                    handleCommandFavoriteAction(command);\n+                    break;\n+                case PLAYLIST_SELECT:\n+                    handleCommandPlaylistSelect(command);\n+                    break;\n+                case TRACK_POSITION:\n+                    handleCommandTrackPosition(channelUID, command);\n+                    break;\n+                case REL_TRACK_POSITION:\n+                    handleCommandRelTrackPosition(channelUID, command);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"));\n+        } else if (command instanceof PercentType) {\n+            setVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"), (PercentType) command);\n+        }\n+    }\n+\n+    private void handleCommandMute(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandLoudness(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (OnOffType.ON.equals(command)) {\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            stop();\n+            updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void handleCommandControl(ChannelUID channelUID, Command command) {\n+        String state;\n+        if (command instanceof RefreshType) {\n+            state = transportState;\n+            State newState = UnDefType.UNDEF;\n+            if (\"PLAYING\".equals(state)) {\n+                newState = PlayPauseType.PLAY;\n+            } else if (\"STOPPED\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            } else if (\"PAUSED_PLAYBACK\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            }\n+            updateState(channelUID, newState);\n+        } else if (command instanceof PlayPauseType) {\n+            if (PlayPauseType.PLAY.equals(command)) {\n+                if (registeredQueue) {\n+                    registeredQueue = false;\n+                    playingQueue = true;\n+                    oneplayed = false;\n+                    serve();\n+                } else {\n+                    play();\n+                }\n+            } else if (PlayPauseType.PAUSE.equals(command)) {\n+                checkPaused();\n+                pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (NextPreviousType.NEXT.equals(command)) {\n+                serveNext();\n+            } else if (NextPreviousType.PREVIOUS.equals(command)) {\n+                servePrevious();\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            int pos = 0;\n+            if (RewindFastforwardType.FASTFORWARD.equals(command)) {\n+                pos = Integer.min(trackDuration, trackPosition + config.seekStep);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                pos = Integer.max(0, trackPosition - config.seekStep);\n+            }\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    private void handleCommandRepeat(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(repeat));\n+        } else {\n+            repeat = (OnOffType.ON.equals(command));\n+            currentQueue.setRepeat(repeat);\n+            updateState(channelUID, OnOffType.from(repeat));\n+            logger.debug(\"Repeat set to {} for {}\", repeat, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandShuffle(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(shuffle));\n+        } else {\n+            shuffle = (OnOffType.ON.equals(command));\n+            currentQueue.setShuffle(shuffle);\n+            if (!playing) {\n+                resetToStartQueue();\n+            }\n+            updateState(channelUID, OnOffType.from(shuffle));\n+            logger.debug(\"Shuffle set to {} for {}\", shuffle, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandOnlyPlayOne(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+        } else {\n+            onlyplayone = (OnOffType.ON.equals(command));\n+            oneplayed = (onlyplayone && playing) ? true : false;\n+            if (oneplayed) {\n+                setNextURI(\"\", \"\");\n+            } else {\n+                UpnpEntry next = nextEntry;\n+                if (next != null) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                }\n+            }\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+            logger.debug(\"OnlyPlayOne set to {} for {}\", onlyplayone, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandUri(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, StringType.valueOf(nowPlayingUri));\n+        } else if (command instanceof StringType) {\n+            setCurrentURI(command.toString(), \"\");\n+            play();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSelect(Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            updateState(FAVORITE, StringType.valueOf(favoriteName));\n+            playFavorite();\n+        }\n+    }\n+\n+    private void handleCommandFavorite(ChannelUID channelUID, Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            if (favoriteCommandOptionList.contains(new CommandOption(favoriteName, favoriteName))) {\n+                playFavorite();\n+            }\n+        }\n+        updateState(channelUID, StringType.valueOf(favoriteName));\n+    }\n+\n+    private void handleCommandFavoriteAction(Command command) {\n+        if (command instanceof StringType) {\n+            switch (command.toString()) {\n+                case SAVE:\n+                    handleCommandFavoriteSave();\n+                    break;\n+                case DELETE:\n+                    handleCommandFavoriteDelete();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSave() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpFavorite favorite = new UpnpFavorite(favoriteName, nowPlayingUri, currentEntry);\n+            favorite.saveFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteDelete() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpControlUtil.deleteFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+            updateState(FAVORITE, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void handleCommandPlaylistSelect(Command command) {\n+        if (command instanceof StringType) {\n+            String playlistName = command.toString();\n+            UpnpEntryQueue queue = new UpnpEntryQueue();\n+            queue.restoreQueue(playlistName, null, bindingConfig.path);\n+            registerQueue(queue);\n+            resetToStartQueue();\n+            playingQueue = true;\n+            serve();\n+        }\n+    }\n+\n+    private void handleCommandTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+        } else if (command instanceof QuantityType<?>) {\n+            QuantityType<?> position = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+            if (position != null) {\n+                int pos = Integer.min(trackDuration, position.intValue());\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+            }\n+        }\n+    }\n+\n+    private void handleCommandRelTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            int relPosition = (trackDuration != 0) ? (trackPosition * 100) / trackDuration : 0;\n+            updateState(channelUID, new PercentType(relPosition));\n+        } else if (command instanceof PercentType) {\n+            int pos = ((PercentType) command).intValue() * trackDuration / 100;\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    /**\n+     * Set the volume for notifications.\n+     *\n+     * @param volume\n+     */\n+    public void setNotificationVolume(PercentType volume) {\n+        notificationVolume = volume;\n+    }\n+\n+    /**\n+     * Play a notification. Previous state of the renderer will resume at the end of the notification, or after the\n+     * maximum notification duration as defined in the renderer parameters.\n+     *\n+     * @param URI for notification sound\n+     */\n+    public void playNotification(String URI) {\n+        synchronized (notificationLock) {\n+            if (URI.isEmpty()) {\n+                logger.debug(\"UPnP device {} received empty notification URI\", thing.getLabel());\n+                return;\n+            }\n+\n+            notificationUri = URI;\n+\n+            logger.debug(\"UPnP device {} playing notification {}\", thing.getLabel(), URI);\n+\n+            cancelTrackPositionRefresh();\n+            getPositionInfo();\n+\n+            cancelPlayingNotificationFuture();\n+\n+            if (config.maxNotificationDuration > 0) {\n+                playingNotificationFuture = upnpScheduler.schedule(this::stop, config.maxNotificationDuration,\n+                        TimeUnit.SECONDS);\n+            }\n+            playingNotification = true;\n+\n+            setCurrentURI(URI, \"\");\n+            setNextURI(\"\", \"\");\n+            PercentType volume = notificationVolume;\n+            setVolume(volume == null\n+                    ? new PercentType(Math.min(100,\n+                            Math.max(0, (100 + config.notificationVolumeAdjustment) * soundVolume.intValue() / 100)))\n+                    : volume);\n+\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            try {\n+                if (stopping != null) {\n+                    // wait for maximum 2.5s until the renderer stopped before playing\n+                    stopping.get(config.responseTimeout, TimeUnit.MILLISECONDS);\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.debug(\"Timeout exception, renderer {} didn't stop yet, trying to play anyway\", thing.getLabel());\n+            }\n+            play();\n+        }\n+    }\n+\n+    private void cancelPlayingNotificationFuture() {\n+        ScheduledFuture<?> future = playingNotificationFuture;\n+        if (future != null) {\n+            future.cancel(true);\n+            playingNotificationFuture = null;\n+        }\n     }\n \n-    /**\n-     * Invoke getPositionInfo on UPnP Rendering Control.\n-     * Result is received in {@link onValueReceived}.\n-     */\n-    protected void getPositionInfo() {\n-        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+    private void resumeAfterNotification() {\n+        synchronized (notificationLock) {\n+            logger.debug(\"UPnP device {} resume after playing notification\", thing.getLabel());\n \n-        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n-    }\n+            setCurrentURI(nowPlayingUri, \"\");\n+            setVolume(soundVolume);\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+            cancelPlayingNotificationFuture();\n \n-        String transportState;\n-        if (command instanceof RefreshType) {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    getVolume(getCurrentChannel());\n-                    break;\n-                case MUTE:\n-                    getMute(getCurrentChannel());\n-                    break;\n-                case CONTROL:\n-                    transportState = this.transportState;\n-                    State newState = UnDefType.UNDEF;\n-                    if (\"PLAYING\".equals(transportState)) {\n-                        newState = PlayPauseType.PLAY;\n-                    } else if (\"STOPPED\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    }\n-                    updateState(channelUID, newState);\n-                    break;\n-            }\n-            return;\n-        } else {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    setVolume(getCurrentChannel(), (PercentType) command);\n-                    break;\n-                case MUTE:\n-                    setMute(getCurrentChannel(), (OnOffType) command);\n-                    break;\n-                case STOP:\n-                    if (command == OnOffType.ON) {\n-                        updateState(CONTROL, PlayPauseType.PAUSE);\n-                        playerStopped = true;\n-                        stop();\n-                        updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n-                    }\n-                    break;\n-                case CONTROL:\n-                    playerStopped = false;\n-                    if (command instanceof PlayPauseType) {\n-                        if (command == PlayPauseType.PLAY) {\n-                            play();\n-                        } else if (command == PlayPauseType.PAUSE) {\n-                            pause();\n-                        }\n-                    } else if (command instanceof NextPreviousType) {\n-                        if (command == NextPreviousType.NEXT) {\n-                            playerStopped = true;\n-                            serveNext();\n-                        } else if (command == NextPreviousType.PREVIOUS) {\n-                            playerStopped = true;\n-                            servePrevious();\n-                        }\n-                    } else if (command instanceof RewindFastforwardType) {\n-                    }\n-                    break;\n+            playingNotification = false;\n+            notificationVolume = null;\n+            notificationUri = \"\";\n+\n+            if (playing) {\n+                int pos = posAtNotificationStart;\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+                play();\n             }\n+            posAtNotificationStart = 0;\n+        }\n+    }\n \n-            return;\n+    private void playFavorite() {\n+        UpnpFavorite favorite = new UpnpFavorite(favoriteName, bindingConfig.path);\n+        String uri = favorite.getUri();\n+        UpnpEntry entry = favorite.getUpnpEntry();\n+        if (!uri.isEmpty()) {\n+            String metadata = \"\";\n+            if (entry != null) {\n+                metadata = UpnpXMLParser.compileMetadataString(entry);\n+            }\n+            setCurrentURI(uri, metadata);\n+            play();\n         }\n     }\n \n+    void updateFavoritesList() {\n+        favoriteCommandOptionList = UpnpControlUtil.favorites(bindingConfig.path).stream()\n+                .map(p -> (new CommandOption(p, p))).collect(Collectors.toList());\n+        updateCommandDescription(favoriteSelectChannelUID, favoriteCommandOptionList);\n+    }\n+\n+    @Override\n+    public void playlistsListChanged() {\n+        playlistCommandOptionList = UpnpControlUtil.playlists().stream().map(p -> (new CommandOption(p, p)))\n+                .collect(Collectors.toList());\n+        updateCommandDescription(playlistSelectChannelUID, playlistCommandOptionList);\n+    }\n+\n     @Override\n     public void onStatusChanged(boolean status) {\n-        logger.debug(\"Renderer status changed to {}\", status);\n-        if (status) {\n-            initRenderer();\n-        } else {\n-            cancelSubscriptionRefreshJob();\n+        if (!status) {\n+            removeSubscriptions();\n \n             updateState(CONTROL, PlayPauseType.PAUSE);\n             cancelTrackPositionRefresh();\n-\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n-                    \"Communication lost with \" + thing.getLabel());\n         }\n         super.onStatusChanged(status);\n     }\n \n+    @Override\n+    protected @Nullable String preProcessValueReceived(Map<String, String> inputs, @Nullable String variable,\n+            @Nullable String value, @Nullable String service, @Nullable String action) {\n+        if (variable == null) {\n+            return null;\n+        } else {\n+            switch (variable) {\n+                case \"CurrentVolume\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Volume\";\n+                case \"CurrentMute\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Mute\";\n+                case \"CurrentLoudness\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Loudness\";\n+                default:\n+                    return variable;\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n         if (logger.isTraceEnabled()) {\n-            logger.trace(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+            logger.trace(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                     variable, value, service);\n         } else {\n             if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n                     || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n                     || \"TrackDuration\".equals(variable))) {\n                 // don't log all variables received when updating the track position every second\n-                logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                logger.debug(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                         variable, value, service);\n             }\n         }\n         if (variable == null) {\n             return;\n         }\n \n-        switch (variable) {\n-            case \"CurrentMute\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundMute = OnOffType.from(Boolean.parseBoolean(value));\n-                    updateState(MUTE, soundMute);\n-                }\n-                break;\n-            case \"CurrentVolume\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundVolume = PercentType.valueOf(value);\n-                    updateState(VOLUME, soundVolume);\n-                }\n-                break;\n-            case \"Sink\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    updateProtocolInfo(value);\n-                }\n-                break;\n-            case \"LastChange\":\n-                // pre-process some variables, eg XML processing\n-                if (!((value == null) || value.isEmpty())) {\n-                    if (\"AVTransport\".equals(service)) {\n-                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n-                        for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n-                            // Update the transport state after the update of the media information\n-                            // to not break the notification mechanism\n-                            if (!\"TransportState\".equals(entrySet.getKey())) {\n-                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n-                            }\n-                            if (\"AVTransportURI\".equals(entrySet.getKey())) {\n+        if (variable.endsWith(\"Volume\")) {\n+            onValueReceivedVolume(variable, value);\n+        } else if (variable.endsWith(\"Mute\")) {\n+            onValueReceivedMute(variable, value);\n+        } else if (variable.endsWith(\"Loudness\")) {\n+            onValueReceivedLoudness(variable, value);\n+        } else {\n+            switch (variable) {\n+                case \"LastChange\":\n+                    onValueReceivedLastChange(value, service);\n+                    break;\n+                case \"CurrentTransportState\":\n+                case \"TransportState\":\n+                    onValueReceivedTransportState(value);\n+                    break;\n+                case \"CurrentTrackURI\":\n+                case \"CurrentURI\":\n+                    onValueReceivedCurrentURI(value);\n+                    break;\n+                case \"CurrentTrackMetaData\":\n+                case \"CurrentURIMetaData\":\n+                    onValueReceivedCurrentMetaData(value);\n+                    break;\n+                case \"NextAVTransportURIMetaData\":\n+                case \"NextURIMetaData\":\n+                    onValueReceivedNextMetaData(value);\n+                    break;\n+                case \"CurrentTrackDuration\":\n+                case \"TrackDuration\":\n+                    onValueReceivedDuration(value);\n+                    break;\n+                case \"RelTime\":\n+                    onValueReceivedRelTime(value);\n+                    break;\n+                default:\n+                    super.onValueReceived(variable, value, service);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedVolume(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            UpnpRenderingControlConfiguration config = renderingControlConfiguration;\n+\n+            long volume = Long.valueOf(value);\n+            volume = volume * 100 / config.maxvolume;\n+\n+            String upnpChannel = variable.replace(\"Volume\", \"volume\").replace(\"Master\", \"\");\n+            updateState(upnpChannel, new PercentType((int) volume));\n+\n+            if (!playingNotification && \"volume\".equals(upnpChannel)) {\n+                soundVolume = new PercentType((int) volume);\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedMute(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            String upnpChannel = variable.replace(\"Mute\", \"mute\").replace(\"Master\", \"\");\n+            updateState(upnpChannel,\n+                    (\"1\".equals(value) || \"true\".equals(value.toLowerCase())) ? OnOffType.ON : OnOffType.OFF);\n+        }\n+    }\n+\n+    private void onValueReceivedLoudness(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {", "originalCommit": "ed0c4905216eda13d57a406787ed39aba91b036b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNDU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r529804581", "bodyText": "Please store some of the constant strings you use as a static final fields. Like \"AVTransport\" and \"RenderingControl\".", "author": "cpmeister", "createdAt": "2020-11-24T18:51:32Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -324,26 +438,43 @@ public void setCurrentURI(String URI, String URIMetaData) {\n      * @param nextURI\n      * @param nextURIMetaData\n      */\n-    public void setNextURI(String nextURI, String nextURIMetaData) {\n+    protected void setNextURI(String nextURI, String nextURIMetaData) {\n         Map<String, String> inputs = new HashMap<>();\n-        try {\n-            inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n-            inputs.put(\"NextURI\", nextURI);\n-            inputs.put(\"NextURIMetaData\", nextURIMetaData);\n+        inputs.put(\"InstanceID\", Integer.toString(avTransportId));\n+        inputs.put(\"NextURI\", nextURI);\n+        inputs.put(\"NextURIMetaData\", nextURIMetaData);\n \n-            invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n-        } catch (NumberFormatException ex) {\n-            logger.debug(\"Action Invalid Value Format Exception {}\", ex.getMessage());\n-        }\n+        invokeAction(\"AVTransport\", \"SetNextAVTransportURI\", inputs);\n     }\n \n     /**\n-     * Retrieves the current audio channel ('Master' by default).\n-     *\n-     * @return current audio channel\n+     * Invoke GetTransportState on UPnP AV Transport.\n+     * Result is received in {@link onValueReceived}.\n+     */\n+    protected void getTransportState() {\n+        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(avTransportId));\n+\n+        invokeAction(\"AVTransport\", \"GetTransportInfo\", inputs);", "originalCommit": "ed0c4905216eda13d57a406787ed39aba91b036b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNzkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r529807936", "bodyText": "These lists are never mutated, only assigned, so you might as well initially set them to something immutable.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile List<CommandOption> favoriteCommandOptionList = Collections.synchronizedList(new ArrayList<>());\n          \n          \n            \n                private volatile List<CommandOption> playlistCommandOptionList = Collections.synchronizedList(new ArrayList<>());\n          \n          \n            \n                private volatile List<CommandOption> favoriteCommandOptionList = List.of();\n          \n          \n            \n                private volatile List<CommandOption> playlistCommandOptionList = List.of();", "author": "cpmeister", "createdAt": "2020-11-24T18:57:06Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -72,174 +90,225 @@\n \n     private final Logger logger = LoggerFactory.getLogger(UpnpRendererHandler.class);\n \n-    private static final int SUBSCRIPTION_DURATION_SECONDS = 3600;\n-\n-    // UPnP protocol pattern\n-    private static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n-\n     private volatile boolean audioSupport;\n     protected volatile Set<AudioFormat> supportedAudioFormats = new HashSet<>();\n     private volatile boolean audioSinkRegistered;\n \n     private volatile UpnpAudioSinkReg audioSinkReg;\n \n-    private volatile boolean upnpSubscribed;\n+    private volatile Set<UpnpServerHandler> serverHandlers = ConcurrentHashMap.newKeySet();\n+\n+    protected @NonNullByDefault({}) UpnpControlRendererConfiguration config;\n+    private UpnpRenderingControlConfiguration renderingControlConfiguration = new UpnpRenderingControlConfiguration();\n \n-    private static final String UPNP_CHANNEL = \"Master\";\n+    private volatile List<CommandOption> favoriteCommandOptionList = Collections.synchronizedList(new ArrayList<>());\n+    private volatile List<CommandOption> playlistCommandOptionList = Collections.synchronizedList(new ArrayList<>());", "originalCommit": "ed0c4905216eda13d57a406787ed39aba91b036b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwOTMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r529809328", "bodyText": "Is this code supposed to be identical to onValueReceivedMute?", "author": "cpmeister", "createdAt": "2020-11-24T18:59:25Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpRendererHandler.java", "diffHunk": "@@ -411,255 +554,808 @@ protected void setMute(String channel, OnOffType mute) {\n         inputs.put(\"Channel\", channel);\n         inputs.put(\"DesiredMute\", mute == OnOffType.ON ? \"1\" : \"0\");\n \n-        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+        invokeAction(\"RenderingControl\", \"SetMute\", inputs);\n+    }\n+\n+    /**\n+     * Invoke getMute on UPnP Rendering Control.\n+     * Result is received in {@link onValueReceived}.\n+     *\n+     * @param channel\n+     */\n+    protected void getLoudness(String channel) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+\n+        invokeAction(\"RenderingControl\", \"GetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Invoke SetMute on UPnP Rendering Control.\n+     *\n+     * @param channel\n+     * @param mute\n+     */\n+    protected void setLoudness(String channel, OnOffType mute) {\n+        Map<String, String> inputs = new HashMap<>();\n+        inputs.put(\"InstanceID\", Integer.toString(rcsId));\n+        inputs.put(\"Channel\", channel);\n+        inputs.put(\"DesiredLoudness\", mute == OnOffType.ON ? \"1\" : \"0\");\n+\n+        invokeAction(\"RenderingControl\", \"SetLoudness\", inputs);\n+    }\n+\n+    /**\n+     * Called from server handler for renderer to be able to send back status to server handler\n+     *\n+     * @param handler\n+     */\n+    protected void setServerHandler(UpnpServerHandler handler) {\n+        logger.debug(\"Set server handler {} on renderer {}\", handler.getThing().getLabel(), thing.getLabel());\n+        serverHandlers.add(handler);\n+    }\n+\n+    /**\n+     * Should be called from server handler when server stops serving this renderer\n+     */\n+    protected void unsetServerHandler() {\n+        logger.debug(\"Unset server handler on renderer {}\", thing.getLabel());\n+        for (UpnpServerHandler handler : serverHandlers) {\n+            Thing serverThing = handler.getThing();\n+            Channel serverChannel;\n+            for (String channel : SERVER_CONTROL_CHANNELS) {\n+                if ((serverChannel = serverThing.getChannel(channel)) != null) {\n+                    handler.updateServerState(serverChannel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+\n+            serverHandlers.remove(handler);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateState(ChannelUID channelUID, State state) {\n+        // override to be able to propagate channel state updates to corresponding channels on the server\n+        if (SERVER_CONTROL_CHANNELS.contains(channelUID.getId())) {\n+            for (UpnpServerHandler handler : serverHandlers) {\n+                Thing serverThing = handler.getThing();\n+                Channel serverChannel = serverThing.getChannel(channelUID.getId());\n+                if (serverChannel != null) {\n+                    logger.debug(\"Update server {} channel {} with state {} from renderer {}\", serverThing.getLabel(),\n+                            state, channelUID, thing.getLabel());\n+                    handler.updateServerState(serverChannel.getUID(), state);\n+                }\n+            }\n+        }\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+\n+        String id = channelUID.getId();\n+\n+        if (id.endsWith(\"volume\")) {\n+            handleCommandVolume(command, id);\n+        } else if (id.endsWith(\"mute\")) {\n+            handleCommandMute(command, id);\n+        } else if (id.endsWith(\"loudness\")) {\n+            handleCommandLoudness(command, id);\n+        } else {\n+            switch (id) {\n+                case STOP:\n+                    handleCommandStop(command);\n+                    break;\n+                case CONTROL:\n+                    handleCommandControl(channelUID, command);\n+                    break;\n+                case REPEAT:\n+                    handleCommandRepeat(channelUID, command);\n+                    break;\n+                case SHUFFLE:\n+                    handleCommandShuffle(channelUID, command);\n+                case ONLY_PLAY_ONE:\n+                    handleCommandOnlyPlayOne(channelUID, command);\n+                    break;\n+                case URI:\n+                    handleCommandUri(channelUID, command);\n+                    break;\n+                case FAVORITE_SELECT:\n+                    handleCommandFavoriteSelect(command);\n+                    break;\n+                case FAVORITE:\n+                    handleCommandFavorite(channelUID, command);\n+                    break;\n+                case FAVORITE_ACTION:\n+                    handleCommandFavoriteAction(command);\n+                    break;\n+                case PLAYLIST_SELECT:\n+                    handleCommandPlaylistSelect(command);\n+                    break;\n+                case TRACK_POSITION:\n+                    handleCommandTrackPosition(channelUID, command);\n+                    break;\n+                case REL_TRACK_POSITION:\n+                    handleCommandRelTrackPosition(channelUID, command);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"));\n+        } else if (command instanceof PercentType) {\n+            setVolume(\"volume\".equals(id) ? UPNP_MASTER : id.replace(\"volume\", \"\"), (PercentType) command);\n+        }\n+    }\n+\n+    private void handleCommandMute(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setMute(\"mute\".equals(id) ? UPNP_MASTER : id.replace(\"mute\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandLoudness(Command command, String id) {\n+        if (command instanceof RefreshType) {\n+            getLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"));\n+        } else if (command instanceof OnOffType) {\n+            setLoudness(\"loudness\".equals(id) ? UPNP_MASTER : id.replace(\"loudness\", \"\"), (OnOffType) command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (OnOffType.ON.equals(command)) {\n+            updateState(CONTROL, PlayPauseType.PAUSE);\n+            stop();\n+            updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void handleCommandControl(ChannelUID channelUID, Command command) {\n+        String state;\n+        if (command instanceof RefreshType) {\n+            state = transportState;\n+            State newState = UnDefType.UNDEF;\n+            if (\"PLAYING\".equals(state)) {\n+                newState = PlayPauseType.PLAY;\n+            } else if (\"STOPPED\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            } else if (\"PAUSED_PLAYBACK\".equals(state)) {\n+                newState = PlayPauseType.PAUSE;\n+            }\n+            updateState(channelUID, newState);\n+        } else if (command instanceof PlayPauseType) {\n+            if (PlayPauseType.PLAY.equals(command)) {\n+                if (registeredQueue) {\n+                    registeredQueue = false;\n+                    playingQueue = true;\n+                    oneplayed = false;\n+                    serve();\n+                } else {\n+                    play();\n+                }\n+            } else if (PlayPauseType.PAUSE.equals(command)) {\n+                checkPaused();\n+                pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (NextPreviousType.NEXT.equals(command)) {\n+                serveNext();\n+            } else if (NextPreviousType.PREVIOUS.equals(command)) {\n+                servePrevious();\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            int pos = 0;\n+            if (RewindFastforwardType.FASTFORWARD.equals(command)) {\n+                pos = Integer.min(trackDuration, trackPosition + config.seekStep);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                pos = Integer.max(0, trackPosition - config.seekStep);\n+            }\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    private void handleCommandRepeat(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(repeat));\n+        } else {\n+            repeat = (OnOffType.ON.equals(command));\n+            currentQueue.setRepeat(repeat);\n+            updateState(channelUID, OnOffType.from(repeat));\n+            logger.debug(\"Repeat set to {} for {}\", repeat, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandShuffle(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(shuffle));\n+        } else {\n+            shuffle = (OnOffType.ON.equals(command));\n+            currentQueue.setShuffle(shuffle);\n+            if (!playing) {\n+                resetToStartQueue();\n+            }\n+            updateState(channelUID, OnOffType.from(shuffle));\n+            logger.debug(\"Shuffle set to {} for {}\", shuffle, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandOnlyPlayOne(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+        } else {\n+            onlyplayone = (OnOffType.ON.equals(command));\n+            oneplayed = (onlyplayone && playing) ? true : false;\n+            if (oneplayed) {\n+                setNextURI(\"\", \"\");\n+            } else {\n+                UpnpEntry next = nextEntry;\n+                if (next != null) {\n+                    setNextURI(next.getRes(), UpnpXMLParser.compileMetadataString(next));\n+                }\n+            }\n+            updateState(channelUID, OnOffType.from(onlyplayone));\n+            logger.debug(\"OnlyPlayOne set to {} for {}\", onlyplayone, thing.getLabel());\n+        }\n+    }\n+\n+    private void handleCommandUri(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, StringType.valueOf(nowPlayingUri));\n+        } else if (command instanceof StringType) {\n+            setCurrentURI(command.toString(), \"\");\n+            play();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSelect(Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            updateState(FAVORITE, StringType.valueOf(favoriteName));\n+            playFavorite();\n+        }\n+    }\n+\n+    private void handleCommandFavorite(ChannelUID channelUID, Command command) {\n+        if (command instanceof StringType) {\n+            favoriteName = command.toString();\n+            if (favoriteCommandOptionList.contains(new CommandOption(favoriteName, favoriteName))) {\n+                playFavorite();\n+            }\n+        }\n+        updateState(channelUID, StringType.valueOf(favoriteName));\n+    }\n+\n+    private void handleCommandFavoriteAction(Command command) {\n+        if (command instanceof StringType) {\n+            switch (command.toString()) {\n+                case SAVE:\n+                    handleCommandFavoriteSave();\n+                    break;\n+                case DELETE:\n+                    handleCommandFavoriteDelete();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void handleCommandFavoriteSave() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpFavorite favorite = new UpnpFavorite(favoriteName, nowPlayingUri, currentEntry);\n+            favorite.saveFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+        }\n+    }\n+\n+    private void handleCommandFavoriteDelete() {\n+        if (!favoriteName.isEmpty()) {\n+            UpnpControlUtil.deleteFavorite(favoriteName, bindingConfig.path);\n+            updateFavoritesList();\n+            updateState(FAVORITE, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void handleCommandPlaylistSelect(Command command) {\n+        if (command instanceof StringType) {\n+            String playlistName = command.toString();\n+            UpnpEntryQueue queue = new UpnpEntryQueue();\n+            queue.restoreQueue(playlistName, null, bindingConfig.path);\n+            registerQueue(queue);\n+            resetToStartQueue();\n+            playingQueue = true;\n+            serve();\n+        }\n+    }\n+\n+    private void handleCommandTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateState(channelUID, new QuantityType<>(trackPosition, SmartHomeUnits.SECOND));\n+        } else if (command instanceof QuantityType<?>) {\n+            QuantityType<?> position = ((QuantityType<?>) command).toUnit(SmartHomeUnits.SECOND);\n+            if (position != null) {\n+                int pos = Integer.min(trackDuration, position.intValue());\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+            }\n+        }\n+    }\n+\n+    private void handleCommandRelTrackPosition(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            int relPosition = (trackDuration != 0) ? (trackPosition * 100) / trackDuration : 0;\n+            updateState(channelUID, new PercentType(relPosition));\n+        } else if (command instanceof PercentType) {\n+            int pos = ((PercentType) command).intValue() * trackDuration / 100;\n+            seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+        }\n+    }\n+\n+    /**\n+     * Set the volume for notifications.\n+     *\n+     * @param volume\n+     */\n+    public void setNotificationVolume(PercentType volume) {\n+        notificationVolume = volume;\n+    }\n+\n+    /**\n+     * Play a notification. Previous state of the renderer will resume at the end of the notification, or after the\n+     * maximum notification duration as defined in the renderer parameters.\n+     *\n+     * @param URI for notification sound\n+     */\n+    public void playNotification(String URI) {\n+        synchronized (notificationLock) {\n+            if (URI.isEmpty()) {\n+                logger.debug(\"UPnP device {} received empty notification URI\", thing.getLabel());\n+                return;\n+            }\n+\n+            notificationUri = URI;\n+\n+            logger.debug(\"UPnP device {} playing notification {}\", thing.getLabel(), URI);\n+\n+            cancelTrackPositionRefresh();\n+            getPositionInfo();\n+\n+            cancelPlayingNotificationFuture();\n+\n+            if (config.maxNotificationDuration > 0) {\n+                playingNotificationFuture = upnpScheduler.schedule(this::stop, config.maxNotificationDuration,\n+                        TimeUnit.SECONDS);\n+            }\n+            playingNotification = true;\n+\n+            setCurrentURI(URI, \"\");\n+            setNextURI(\"\", \"\");\n+            PercentType volume = notificationVolume;\n+            setVolume(volume == null\n+                    ? new PercentType(Math.min(100,\n+                            Math.max(0, (100 + config.notificationVolumeAdjustment) * soundVolume.intValue() / 100)))\n+                    : volume);\n+\n+            CompletableFuture<Boolean> stopping = isStopping;\n+            try {\n+                if (stopping != null) {\n+                    // wait for maximum 2.5s until the renderer stopped before playing\n+                    stopping.get(config.responseTimeout, TimeUnit.MILLISECONDS);\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                logger.debug(\"Timeout exception, renderer {} didn't stop yet, trying to play anyway\", thing.getLabel());\n+            }\n+            play();\n+        }\n+    }\n+\n+    private void cancelPlayingNotificationFuture() {\n+        ScheduledFuture<?> future = playingNotificationFuture;\n+        if (future != null) {\n+            future.cancel(true);\n+            playingNotificationFuture = null;\n+        }\n     }\n \n-    /**\n-     * Invoke getPositionInfo on UPnP Rendering Control.\n-     * Result is received in {@link onValueReceived}.\n-     */\n-    protected void getPositionInfo() {\n-        Map<String, String> inputs = Collections.singletonMap(\"InstanceID\", Integer.toString(rcsId));\n+    private void resumeAfterNotification() {\n+        synchronized (notificationLock) {\n+            logger.debug(\"UPnP device {} resume after playing notification\", thing.getLabel());\n \n-        invokeAction(\"AVTransport\", \"GetPositionInfo\", inputs);\n-    }\n+            setCurrentURI(nowPlayingUri, \"\");\n+            setVolume(soundVolume);\n \n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        logger.debug(\"Handle command {} for channel {} on renderer {}\", command, channelUID, thing.getLabel());\n+            cancelPlayingNotificationFuture();\n \n-        String transportState;\n-        if (command instanceof RefreshType) {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    getVolume(getCurrentChannel());\n-                    break;\n-                case MUTE:\n-                    getMute(getCurrentChannel());\n-                    break;\n-                case CONTROL:\n-                    transportState = this.transportState;\n-                    State newState = UnDefType.UNDEF;\n-                    if (\"PLAYING\".equals(transportState)) {\n-                        newState = PlayPauseType.PLAY;\n-                    } else if (\"STOPPED\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    } else if (\"PAUSED_PLAYBACK\".equals(transportState)) {\n-                        newState = PlayPauseType.PAUSE;\n-                    }\n-                    updateState(channelUID, newState);\n-                    break;\n-            }\n-            return;\n-        } else {\n-            switch (channelUID.getId()) {\n-                case VOLUME:\n-                    setVolume(getCurrentChannel(), (PercentType) command);\n-                    break;\n-                case MUTE:\n-                    setMute(getCurrentChannel(), (OnOffType) command);\n-                    break;\n-                case STOP:\n-                    if (command == OnOffType.ON) {\n-                        updateState(CONTROL, PlayPauseType.PAUSE);\n-                        playerStopped = true;\n-                        stop();\n-                        updateState(TRACK_POSITION, new QuantityType<>(0, SmartHomeUnits.SECOND));\n-                    }\n-                    break;\n-                case CONTROL:\n-                    playerStopped = false;\n-                    if (command instanceof PlayPauseType) {\n-                        if (command == PlayPauseType.PLAY) {\n-                            play();\n-                        } else if (command == PlayPauseType.PAUSE) {\n-                            pause();\n-                        }\n-                    } else if (command instanceof NextPreviousType) {\n-                        if (command == NextPreviousType.NEXT) {\n-                            playerStopped = true;\n-                            serveNext();\n-                        } else if (command == NextPreviousType.PREVIOUS) {\n-                            playerStopped = true;\n-                            servePrevious();\n-                        }\n-                    } else if (command instanceof RewindFastforwardType) {\n-                    }\n-                    break;\n+            playingNotification = false;\n+            notificationVolume = null;\n+            notificationUri = \"\";\n+\n+            if (playing) {\n+                int pos = posAtNotificationStart;\n+                seek(String.format(\"%02d:%02d:%02d\", pos / 3600, (pos % 3600) / 60, pos % 60));\n+                play();\n             }\n+            posAtNotificationStart = 0;\n+        }\n+    }\n \n-            return;\n+    private void playFavorite() {\n+        UpnpFavorite favorite = new UpnpFavorite(favoriteName, bindingConfig.path);\n+        String uri = favorite.getUri();\n+        UpnpEntry entry = favorite.getUpnpEntry();\n+        if (!uri.isEmpty()) {\n+            String metadata = \"\";\n+            if (entry != null) {\n+                metadata = UpnpXMLParser.compileMetadataString(entry);\n+            }\n+            setCurrentURI(uri, metadata);\n+            play();\n         }\n     }\n \n+    void updateFavoritesList() {\n+        favoriteCommandOptionList = UpnpControlUtil.favorites(bindingConfig.path).stream()\n+                .map(p -> (new CommandOption(p, p))).collect(Collectors.toList());\n+        updateCommandDescription(favoriteSelectChannelUID, favoriteCommandOptionList);\n+    }\n+\n+    @Override\n+    public void playlistsListChanged() {\n+        playlistCommandOptionList = UpnpControlUtil.playlists().stream().map(p -> (new CommandOption(p, p)))\n+                .collect(Collectors.toList());\n+        updateCommandDescription(playlistSelectChannelUID, playlistCommandOptionList);\n+    }\n+\n     @Override\n     public void onStatusChanged(boolean status) {\n-        logger.debug(\"Renderer status changed to {}\", status);\n-        if (status) {\n-            initRenderer();\n-        } else {\n-            cancelSubscriptionRefreshJob();\n+        if (!status) {\n+            removeSubscriptions();\n \n             updateState(CONTROL, PlayPauseType.PAUSE);\n             cancelTrackPositionRefresh();\n-\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n-                    \"Communication lost with \" + thing.getLabel());\n         }\n         super.onStatusChanged(status);\n     }\n \n+    @Override\n+    protected @Nullable String preProcessValueReceived(Map<String, String> inputs, @Nullable String variable,\n+            @Nullable String value, @Nullable String service, @Nullable String action) {\n+        if (variable == null) {\n+            return null;\n+        } else {\n+            switch (variable) {\n+                case \"CurrentVolume\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Volume\";\n+                case \"CurrentMute\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Mute\";\n+                case \"CurrentLoudness\":\n+                    return (inputs.containsKey(\"Channel\") ? inputs.get(\"Channel\") : UPNP_MASTER) + \"Loudness\";\n+                default:\n+                    return variable;\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onValueReceived(@Nullable String variable, @Nullable String value, @Nullable String service) {\n         if (logger.isTraceEnabled()) {\n-            logger.trace(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+            logger.trace(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                     variable, value, service);\n         } else {\n             if (logger.isDebugEnabled() && !(\"AbsTime\".equals(variable) || \"RelCount\".equals(variable)\n                     || \"RelTime\".equals(variable) || \"AbsCount\".equals(variable) || \"Track\".equals(variable)\n                     || \"TrackDuration\".equals(variable))) {\n                 // don't log all variables received when updating the track position every second\n-                logger.debug(\"Upnp device {} received variable {} with value {} from service {}\", thing.getLabel(),\n+                logger.debug(\"UPnP device {} received variable {} with value {} from service {}\", thing.getLabel(),\n                         variable, value, service);\n             }\n         }\n         if (variable == null) {\n             return;\n         }\n \n-        switch (variable) {\n-            case \"CurrentMute\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundMute = OnOffType.from(Boolean.parseBoolean(value));\n-                    updateState(MUTE, soundMute);\n-                }\n-                break;\n-            case \"CurrentVolume\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    soundVolume = PercentType.valueOf(value);\n-                    updateState(VOLUME, soundVolume);\n-                }\n-                break;\n-            case \"Sink\":\n-                if (!((value == null) || (value.isEmpty()))) {\n-                    updateProtocolInfo(value);\n-                }\n-                break;\n-            case \"LastChange\":\n-                // pre-process some variables, eg XML processing\n-                if (!((value == null) || value.isEmpty())) {\n-                    if (\"AVTransport\".equals(service)) {\n-                        Map<String, String> parsedValues = UpnpXMLParser.getAVTransportFromXML(value);\n-                        for (Map.Entry<String, String> entrySet : parsedValues.entrySet()) {\n-                            // Update the transport state after the update of the media information\n-                            // to not break the notification mechanism\n-                            if (!\"TransportState\".equals(entrySet.getKey())) {\n-                                onValueReceived(entrySet.getKey(), entrySet.getValue(), service);\n-                            }\n-                            if (\"AVTransportURI\".equals(entrySet.getKey())) {\n+        if (variable.endsWith(\"Volume\")) {\n+            onValueReceivedVolume(variable, value);\n+        } else if (variable.endsWith(\"Mute\")) {\n+            onValueReceivedMute(variable, value);\n+        } else if (variable.endsWith(\"Loudness\")) {\n+            onValueReceivedLoudness(variable, value);\n+        } else {\n+            switch (variable) {\n+                case \"LastChange\":\n+                    onValueReceivedLastChange(value, service);\n+                    break;\n+                case \"CurrentTransportState\":\n+                case \"TransportState\":\n+                    onValueReceivedTransportState(value);\n+                    break;\n+                case \"CurrentTrackURI\":\n+                case \"CurrentURI\":\n+                    onValueReceivedCurrentURI(value);\n+                    break;\n+                case \"CurrentTrackMetaData\":\n+                case \"CurrentURIMetaData\":\n+                    onValueReceivedCurrentMetaData(value);\n+                    break;\n+                case \"NextAVTransportURIMetaData\":\n+                case \"NextURIMetaData\":\n+                    onValueReceivedNextMetaData(value);\n+                    break;\n+                case \"CurrentTrackDuration\":\n+                case \"TrackDuration\":\n+                    onValueReceivedDuration(value);\n+                    break;\n+                case \"RelTime\":\n+                    onValueReceivedRelTime(value);\n+                    break;\n+                default:\n+                    super.onValueReceived(variable, value, service);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedVolume(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            UpnpRenderingControlConfiguration config = renderingControlConfiguration;\n+\n+            long volume = Long.valueOf(value);\n+            volume = volume * 100 / config.maxvolume;\n+\n+            String upnpChannel = variable.replace(\"Volume\", \"volume\").replace(\"Master\", \"\");\n+            updateState(upnpChannel, new PercentType((int) volume));\n+\n+            if (!playingNotification && \"volume\".equals(upnpChannel)) {\n+                soundVolume = new PercentType((int) volume);\n+            }\n+        }\n+    }\n+\n+    private void onValueReceivedMute(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            String upnpChannel = variable.replace(\"Mute\", \"mute\").replace(\"Master\", \"\");\n+            updateState(upnpChannel,\n+                    (\"1\".equals(value) || \"true\".equals(value.toLowerCase())) ? OnOffType.ON : OnOffType.OFF);\n+        }\n+    }\n+\n+    private void onValueReceivedLoudness(String variable, @Nullable String value) {\n+        if (!((value == null) || (value.isEmpty()))) {\n+            String upnpChannel = variable.replace(\"Mute\", \"mute\").replace(\"Master\", \"\");\n+            updateState(upnpChannel,\n+                    (\"1\".equals(value) || \"true\".equals(value.toLowerCase())) ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "ed0c4905216eda13d57a406787ed39aba91b036b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNTQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r530515461", "bodyText": "No, should of course refer to loudness. Thanks.", "author": "mherwege", "createdAt": "2020-11-25T16:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwOTMyOA=="}], "type": "inlineReview"}, {"oid": "4d0e694d7df8f4615b0e0fc4a6b2b97b33dcf2ef", "url": "https://github.com/openhab/openhab-addons/commit/4d0e694d7df8f4615b0e0fc4a6b2b97b33dcf2ef", "message": "Bring development to OH3.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T07:59:42Z", "type": "commit"}, {"oid": "58d4e53ba5e8bac76cf275ca4a8832d2e4fe34e5", "url": "https://github.com/openhab/openhab-addons/commit/58d4e53ba5e8bac76cf275ca4a8832d2e4fe34e5", "message": "Make browse state channel.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T07:59:47Z", "type": "commit"}, {"oid": "6bb4e74ed8ed8951cdfd1501c3b744c00da7c98f", "url": "https://github.com/openhab/openhab-addons/commit/6bb4e74ed8ed8951cdfd1501c3b744c00da7c98f", "message": "Added current title channel, removed current id channel.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T07:59:52Z", "type": "commit"}, {"oid": "8ae3ec582364f3e709b75d87e5f14b542a0cffe5", "url": "https://github.com/openhab/openhab-addons/commit/8ae3ec582364f3e709b75d87e5f14b542a0cffe5", "message": "Rebase.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T07:59:57Z", "type": "commit"}, {"oid": "8227df086796c19261a6363ad0475db51fe5da89", "url": "https://github.com/openhab/openhab-addons/commit/8227df086796c19261a6363ad0475db51fe5da89", "message": "Spotless corrections.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T08:00:02Z", "type": "commit"}, {"oid": "7902944eaae9b106196c8966c19a4c42b9e4cba6", "url": "https://github.com/openhab/openhab-addons/commit/7902944eaae9b106196c8966c19a4c42b9e4cba6", "message": "Some cleanup.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T08:00:08Z", "type": "commit"}, {"oid": "abf97be873b988d6d6928dda7923a76716a286b0", "url": "https://github.com/openhab/openhab-addons/commit/abf97be873b988d6d6928dda7923a76716a286b0", "message": "Review feedback.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T08:00:13Z", "type": "commit"}, {"oid": "f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "url": "https://github.com/openhab/openhab-addons/commit/f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "message": "Review comments.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T16:47:51Z", "type": "commit"}, {"oid": "f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "url": "https://github.com/openhab/openhab-addons/commit/f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "message": "Review comments.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-25T16:47:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2OTQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531069478", "bodyText": "The number of tasks is not that important, but the duration of those tasks. Do you schedule any long running tasks?", "author": "fwolter", "createdAt": "2020-11-26T14:34:51Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/java/org/openhab/binding/upnpcontrol/internal/handler/UpnpHandler.java", "diffHunk": "@@ -12,55 +12,281 @@\n  */\n package org.openhab.binding.upnpcontrol.internal.handler;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.jupnp.registry.RegistryListener;\n+import org.openhab.binding.upnpcontrol.internal.UpnpChannelName;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicCommandDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.UpnpDynamicStateDescriptionProvider;\n+import org.openhab.binding.upnpcontrol.internal.config.UpnpControlBindingConfiguration;\n import org.openhab.binding.upnpcontrol.internal.config.UpnpControlConfiguration;\n+import org.openhab.binding.upnpcontrol.internal.queue.UpnpPlaylistsListener;\n+import org.openhab.binding.upnpcontrol.internal.util.UpnpControlUtil;\n+import org.openhab.core.common.ThreadPoolManager;\n import org.openhab.core.io.transport.upnp.UpnpIOParticipant;\n import org.openhab.core.io.transport.upnp.UpnpIOService;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingStatus;\n import org.openhab.core.thing.ThingStatusDetail;\n import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.CommandDescription;\n+import org.openhab.core.types.CommandDescriptionBuilder;\n+import org.openhab.core.types.CommandOption;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link UpnpHandler} is the base class for {@link UpnpRendererHandler} and {@link UpnpServerHandler}.\n+ * The {@link UpnpHandler} is the base class for {@link UpnpRendererHandler} and {@link UpnpServerHandler}. The base\n+ * class implements UPnPConnectionManager service actions.\n  *\n  * @author Mark Herwege - Initial contribution\n  * @author Karel Goderis - Based on UPnP logic in Sonos binding\n  */\n @NonNullByDefault\n-public abstract class UpnpHandler extends BaseThingHandler implements UpnpIOParticipant {\n+public abstract class UpnpHandler extends BaseThingHandler implements UpnpIOParticipant, UpnpPlaylistsListener {\n \n     private final Logger logger = LoggerFactory.getLogger(UpnpHandler.class);\n \n-    protected UpnpIOService service;\n-    protected volatile String transportState = \"\";\n-    protected volatile int connectionId;\n-    protected volatile int avTransportId;\n-    protected volatile int rcsId;\n-    protected @NonNullByDefault({}) UpnpControlConfiguration config;\n+    // UPnP constants\n+    static final String CONNECTION_MANAGER = \"ConnectionManager\";\n+    static final String CONNECTION_ID = \"ConnectionID\";\n+    static final String AV_TRANSPORT_ID = \"AVTransportID\";\n+    static final String RCS_ID = \"RcsID\";\n+    static final Pattern PROTOCOL_PATTERN = Pattern.compile(\"(?:.*):(?:.*):(.*):(?:.*)\");\n \n-    public UpnpHandler(Thing thing, UpnpIOService upnpIOService) {\n+    protected UpnpIOService upnpIOService;\n+\n+    protected volatile @Nullable RemoteDevice device;\n+\n+    // The handlers can potentially create an important number of tasks, therefore put them in a separate thread pool\n+    protected ScheduledExecutorService upnpScheduler = ThreadPoolManager.getScheduledPool(\"binding-upnpcontrol\");", "originalCommit": "f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NTAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531155028", "bodyText": "Many of them wait for a response from the device, so these could take some time. Also, it made it a lot easier to debug, as it is possible to more easily identify the threads started by the handlers.", "author": "mherwege", "createdAt": "2020-11-26T17:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2OTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1Njk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531156986", "bodyText": "These are acutally no valid arguments to create an own thread pool. @cpmeister WDYT?", "author": "fwolter", "createdAt": "2020-11-26T17:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2OTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2NTI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531165262", "bodyText": "He uses invokeActionLock to run one of the tasks essentially single threaded, which although would be more efficient to use a single-threaded executor for that section I think a separate threadpool should be used regardless because you don't want to eat up threads on the shared threadpool for such a task.", "author": "cpmeister", "createdAt": "2020-11-26T17:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2OTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2OTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531169012", "bodyText": "OK", "author": "fwolter", "createdAt": "2020-11-26T17:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2OTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4MTc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531081753", "bodyText": "Is this breaking backward compatibility?", "author": "fwolter", "createdAt": "2020-11-26T14:54:22Z", "path": "bundles/org.openhab.binding.upnpcontrol/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -23,52 +36,163 @@\n \t\t\t<channel id=\"tracknumber\" typeId=\"tracknumber\"/>\n \t\t\t<channel id=\"trackduration\" typeId=\"trackduration\"/>\n \t\t\t<channel id=\"trackposition\" typeId=\"trackposition\"/>\n+\t\t\t<channel id=\"reltrackposition\" typeId=\"reltrackposition\"/>\n \t\t</channels>\n+\t\t<representation-property>udn</representation-property>\n \t\t<config-description>\n \t\t\t<parameter name=\"udn\" type=\"text\" required=\"true\">\n \t\t\t\t<label>Unique Device Name</label>\n \t\t\t\t<description>The UDN identifies the UPnP Renderer</description>\n \t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the refresh interval in seconds</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"notificationVolumeAdjustment\" type=\"integer\" min=\"-100\" max=\"100\" step=\"1\" unit=\"%\">\n+\t\t\t\t<label>Notification Sound Volume Adjustment</label>\n+\t\t\t\t<description>Specifies the percentage adjustment to the current sound volume when playing notifications</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"maxNotificationDuration\" type=\"integer\" unit=\"s\">\n+\t\t\t\t<label>Maximum Notification Duration</label>\n+\t\t\t\t<description>Specifies the maximum duration for notifications, longer notification sounds will be interrupted. O\n+\t\t\t\t\trepresents no maximum duration</description>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"seekStep\" type=\"integer\" min=\"1\">\n+\t\t\t\t<label>Fast Forward/Rewind Step</label>\n+\t\t\t\t<description>Step in seconds for fast forward rewind</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"responseTimeout\" type=\"integer\" unit=\"ms\">\n+\t\t\t\t<label>UPnP Response Timeout</label>\n+\t\t\t\t<description>Specifies the timeout in milliseconds when waiting for responses on UPnP actions</description>\n+\t\t\t\t<default>2500</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n \t\t</config-description>\n-\n \t</thing-type>\n+\n \t<thing-type id=\"upnpserver\">\n \t\t<label>UPnPServer</label>\n \t\t<description>UPnP AV Server</description>\n \t\t<channels>\n \t\t\t<channel id=\"upnprenderer\" typeId=\"upnprenderer\"/>\n-\t\t\t<channel id=\"currentid\" typeId=\"currentid\"/>\n+\t\t\t<channel id=\"currenttitle\" typeId=\"system.media-title\"/>", "originalCommit": "f6e01470ce8f6294a87b102066a4309b5fb9cd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1MDI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531150257", "bodyText": "@fwolter Yes, it is. The browse channel now is a state channel and contains the info. The browse channel used to be a command channel. I could keep the channel, but I am not sure it is worth it. Will the change from command to state channel for browse not be breaking as well? And having it on the browse channel is important, I noticed, when setting up a UI in OH3.", "author": "mherwege", "createdAt": "2020-11-26T17:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4MTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NDQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531154415", "bodyText": "Just asking. The current users need to remove and re-add the Thing to make it work again after an update. If you confirm, I'll add the \"(potentially) not backward compatible\" label.", "author": "fwolter", "createdAt": "2020-11-26T17:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4MTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5OTY1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9081#discussion_r531199653", "bodyText": "Yes, I believe it is best to remove the channel. So, it will not be backward compatible.", "author": "mherwege", "createdAt": "2020-11-26T19:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4MTc1Mw=="}], "type": "inlineReview"}, {"oid": "f9181bd878290e01a522af827ea52d4b03e902c9", "url": "https://github.com/openhab/openhab-addons/commit/f9181bd878290e01a522af827ea52d4b03e902c9", "message": "Resolve type annotation null type mismatch.\n\nSigned-off-by: Mark Herwege <mark.herwege@telenet.be>", "committedDate": "2020-11-27T20:27:07Z", "type": "commit"}]}