{"pr_number": 7056, "pr_title": "[bluetooth] Added support for connection based discovery", "pr_createdAt": "2020-02-22T21:52:16Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7056", "timeline": [{"oid": "84d4ac1b4eb650005ada1d58e428789cbf2cd1dd", "url": "https://github.com/openhab/openhab-addons/commit/84d4ac1b4eb650005ada1d58e428789cbf2cd1dd", "message": "Simplify code\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-10T21:44:26Z", "type": "commit"}, {"oid": "d30dca8f1ed0ad2b1858693d4625f84cb48d8860", "url": "https://github.com/openhab/openhab-addons/commit/d30dca8f1ed0ad2b1858693d4625f84cb48d8860", "message": "Added support for connection based discovery\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-22T01:14:00Z", "type": "commit"}, {"oid": "91a807a0f758063188c788e17cef93bbe978338a", "url": "https://github.com/openhab/openhab-addons/commit/91a807a0f758063188c788e17cef93bbe978338a", "message": "code cleanup\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-22T01:25:54Z", "type": "commit"}, {"oid": "6f7259ba92e345dbcf912c021e6cd649cd074945", "url": "https://github.com/openhab/openhab-addons/commit/6f7259ba92e345dbcf912c021e6cd649cd074945", "message": "minor fix\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-22T21:31:32Z", "type": "commit"}, {"oid": "66deb284571d910c7e4e314b1468c82d225dc3e4", "url": "https://github.com/openhab/openhab-addons/commit/66deb284571d910c7e4e314b1468c82d225dc3e4", "message": "Added multiDiscoverySingleConnectionTest\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-22T21:51:16Z", "type": "commit"}, {"oid": "fc3a38d7d1503d47607e706ccd83eb0e3ddf050d", "url": "https://github.com/openhab/openhab-addons/commit/fc3a38d7d1503d47607e706ccd83eb0e3ddf050d", "message": "code cleanup\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-22T21:55:55Z", "type": "commit"}, {"oid": "e9c79cfd77eeaa1c851e960af8dfb35e81a33264", "url": "https://github.com/openhab/openhab-addons/commit/e9c79cfd77eeaa1c851e960af8dfb35e81a33264", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into\n6919\n\n# Conflicts:\n#\tbundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/handler/BlueZBridgeHandler.java\n\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-27T21:00:47Z", "type": "commit"}, {"oid": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "url": "https://github.com/openhab/openhab-addons/commit/3fb34b9de42209ce997614a9c4c6aa0898d0befe", "message": "Code cleanup and more unit tests\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-02-28T01:32:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5ODIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r386098227", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    notifyRemovalListeners(device);\n          \n          \n            \n                                    discoveryListeners.forEach(listener -> listener.deviceRemoved(device));", "author": "J-N-K", "createdAt": "2020-03-01T11:03:21Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/handler/BlueZBridgeHandler.java", "diffHunk": "@@ -182,6 +182,7 @@ private void refreshDevices() {\n                         logger.debug(\"Removing device '{}' due to inactivity\", device.getAddress());\n                         device.dispose();\n                         devices.remove(device.getAddress());\n+                        notifyRemovalListeners(device);", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0Mjg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387242864", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-03-03T19:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5ODIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MjYyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387162620", "bodyText": "Is this only for keeping track of the number of locks? Wouldn't .getHoldCount() also work? And why are there several  locks for the same object?", "author": "J-N-K", "createdAt": "2020-03-03T17:02:04Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/discovery/internal/BluetoothAddressLocker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.discovery.internal;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+\n+/**\n+ * The {@link BluetoothAddressLocker} handles global locking of BluetoothAddress.\n+ * This is used to make sure that devices with handlers are not connected to during discovery.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ */\n+public class BluetoothAddressLocker {\n+\n+    private static Map<BluetoothAddress, LockReference> locks = new ConcurrentHashMap<>();\n+\n+    public static void lock(BluetoothAddress address) {\n+        locks.compute(address, (addr, oldRef) -> {\n+            LockReference ref = oldRef;\n+            if (ref == null) {\n+                ref = new LockReference();\n+            }\n+            ref.count++;", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI3OTE4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387279189", "bodyText": "The counters are meant to keep track of outside references to the lock, so that once there are no references, the lock can be removed from the map and then garbage collected. Since bluetooth address are dynamic and constantly changing, it is necessary to design it like this for long term stability of the runtime.\nThe entire reason I created this was to prevent connection discovery from connecting to a device that has a handler. Since a handler should have de facto control over the device, discovery shouldn't change its state.\nThis locking works in conjunction with BluetoothDevice.hasListeners() to determine whether or not a device is in use.\nAlthough, after taking the time to write this all out has made me realize that there is a flaw in using \"hasListeners\" for this purpose, so I'll have to rewrite my logic.", "author": "cpmeister", "createdAt": "2020-03-03T20:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1ODgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387858806", "bodyText": "Is this blocking the merge or can it be added alter without breaking something until then", "author": "J-N-K", "createdAt": "2020-03-04T18:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyOTI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r388529290", "bodyText": "Not blocking at all, just finished adding it. Would have done so yesterday but was sick \ud83e\udd37\u200d\u2642", "author": "cpmeister", "createdAt": "2020-03-05T19:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NzM1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387167357", "bodyText": "What can throw an exception here? I did look at BlukiiDiscoveryParticipant? and RuviiTagDiscoveryParticipantand both requiredeviceto be non-null, but NPE seem to be the only exception possible. This should IMO be solved by proper null-checks (and annotations, which seem to be wrong) and not by catchingRuntimeException`.", "author": "J-N-K", "createdAt": "2020-03-03T17:09:45Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/discovery/internal/BluetoothDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.discovery.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothBindingConstants;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic.GattCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompanyIdentifiers;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.BluetoothDeviceListener;\n+import org.openhab.binding.bluetooth.discovery.BluetoothDiscoveryParticipant;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BluetoothDiscoveryProcess} does the work of creating a DiscoveryResult from a set of\n+ * {@link BluetoothDisocveryParticipant}s\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class BluetoothDiscoveryProcess implements Supplier<DiscoveryResult>, BluetoothDeviceListener {\n+\n+    private static final int DISCOVERY_TTL = 300;\n+\n+    private final Logger logger = LoggerFactory.getLogger(BluetoothDiscoveryProcess.class);\n+\n+    private final Lock serviceDiscoveryLock = new ReentrantLock();\n+    private final Condition connectionCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition serviceDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition nameDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+\n+    private final Collection<BluetoothDiscoveryParticipant> participants;\n+    private final BluetoothDevice device;\n+\n+    private volatile boolean servicesDiscovered = false;\n+\n+    public BluetoothDiscoveryProcess(BluetoothDevice device, Collection<BluetoothDiscoveryParticipant> participants) {\n+        this.participants = participants;\n+        this.device = device;\n+    }\n+\n+    @Override\n+    public DiscoveryResult get() {\n+        // first see if any of the participants that don't require a connection recognize this device\n+        List<BluetoothDiscoveryParticipant> connectionParticipants = new ArrayList<>();\n+        for (BluetoothDiscoveryParticipant participant : participants) {\n+            if (participant.requiresConnection(device)) {\n+                connectionParticipants.add(participant);\n+                continue;\n+            }\n+            try {\n+                DiscoveryResult result = participant.createResult(device);\n+                if (result != null) {\n+                    return result;\n+                }\n+            } catch (RuntimeException e) {", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMzIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387313234", "bodyText": "This is more or less legacy code that was copied from DiscoveryService.\nBut my understanding of its purpose is to prevent an error in any one DiscoveryParticipant from prevent discovery from another DiscoveryParticipant or the creation of a default discovery. You are correct that there is no reasonable exception that would be thrown by the current codebase. I think catching runtime exceptions here is useful for future-proofing the eventual creation of potentially complex DiscoveryParticipants which may interact with more than just the bluetooth device and thus may end up causing unintended errors during discovery.\nWhether or not you agree with that sentiment is entirely up to you.", "author": "cpmeister", "createdAt": "2020-03-03T21:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NzkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387167907", "bodyText": "see above", "author": "J-N-K", "createdAt": "2020-03-03T17:10:43Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/discovery/internal/BluetoothDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.discovery.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothBindingConstants;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic.GattCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompanyIdentifiers;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.BluetoothDeviceListener;\n+import org.openhab.binding.bluetooth.discovery.BluetoothDiscoveryParticipant;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BluetoothDiscoveryProcess} does the work of creating a DiscoveryResult from a set of\n+ * {@link BluetoothDisocveryParticipant}s\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class BluetoothDiscoveryProcess implements Supplier<DiscoveryResult>, BluetoothDeviceListener {\n+\n+    private static final int DISCOVERY_TTL = 300;\n+\n+    private final Logger logger = LoggerFactory.getLogger(BluetoothDiscoveryProcess.class);\n+\n+    private final Lock serviceDiscoveryLock = new ReentrantLock();\n+    private final Condition connectionCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition serviceDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition nameDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+\n+    private final Collection<BluetoothDiscoveryParticipant> participants;\n+    private final BluetoothDevice device;\n+\n+    private volatile boolean servicesDiscovered = false;\n+\n+    public BluetoothDiscoveryProcess(BluetoothDevice device, Collection<BluetoothDiscoveryParticipant> participants) {\n+        this.participants = participants;\n+        this.device = device;\n+    }\n+\n+    @Override\n+    public DiscoveryResult get() {\n+        // first see if any of the participants that don't require a connection recognize this device\n+        List<BluetoothDiscoveryParticipant> connectionParticipants = new ArrayList<>();\n+        for (BluetoothDiscoveryParticipant participant : participants) {\n+            if (participant.requiresConnection(device)) {\n+                connectionParticipants.add(participant);\n+                continue;\n+            }\n+            try {\n+                DiscoveryResult result = participant.createResult(device);\n+                if (result != null) {\n+                    return result;\n+                }\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Participant '{}' threw an exception\", participant.getClass().getName(), e);\n+            }\n+        }\n+\n+        // Since we couldn't find a result, lets try the connection based participants\n+        DiscoveryResult result = null;\n+        if (!connectionParticipants.isEmpty()) {\n+            BluetoothAddress address = device.getAddress();\n+            try {\n+                BluetoothAddressLocker.lock(address);\n+                if (!device.hasListeners()) {\n+                    result = findConnectionResult(connectionParticipants);\n+                    // make sure to disconnect before letting go of the device\n+                    if (device.getConnectionState() == ConnectionState.CONNECTED) {\n+                        try {\n+                            if (!device.disconnect()) {\n+                                logger.debug(\"Failed to disconnect from device {}\", address);\n+                            }\n+                        } catch (RuntimeException ex) {\n+                            logger.warn(\"Error occurred during bluetooth discovery for device {} on adapter {}\",\n+                                    address, device.getAdapter().getAddress(), ex);\n+                        }\n+                    }\n+                }\n+            } finally {\n+                BluetoothAddressLocker.unlock(address);\n+            }\n+        }\n+        if (result == null) {\n+            result = createDefaultResult(device);\n+        }\n+        return result;\n+    }\n+\n+    private DiscoveryResult createDefaultResult(BluetoothDevice device) {\n+        // We did not find a thing type for this device, so let's treat it as a generic one\n+        String label = device.getName();\n+        if (label == null || label.length() == 0 || label.equals(device.getAddress().toString().replace(':', '-'))) {\n+            label = \"Bluetooth Device\";\n+        }\n+\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(BluetoothBindingConstants.CONFIGURATION_ADDRESS, device.getAddress().toString());\n+        Integer txPower = device.getTxPower();\n+        if (txPower != null && txPower > 0) {\n+            properties.put(BluetoothBindingConstants.PROPERTY_TXPOWER, Integer.toString(txPower));\n+        }\n+        String manufacturer = BluetoothCompanyIdentifiers.get(device.getManufacturerId());\n+        if (manufacturer == null) {\n+            logger.debug(\"Unknown manufacturer Id ({}) found on bluetooth device.\", device.getManufacturerId());\n+        } else {\n+            properties.put(Thing.PROPERTY_VENDOR, manufacturer);\n+            label += \" (\" + manufacturer + \")\";\n+        }\n+\n+        ThingUID thingUID = new ThingUID(BluetoothBindingConstants.THING_TYPE_BEACON, device.getAdapter().getUID(),\n+                device.getAddress().toString().toLowerCase().replace(\":\", \"\"));\n+\n+        // Create the discovery result and add to the inbox\n+        return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withRepresentationProperty(BluetoothBindingConstants.CONFIGURATION_ADDRESS).withTTL(DISCOVERY_TTL)\n+                .withBridge(device.getAdapter().getUID()).withLabel(label).build();\n+    }\n+\n+    private @Nullable DiscoveryResult findConnectionResult(List<BluetoothDiscoveryParticipant> connectionParticipants) {\n+        try {\n+            device.addListener(this);\n+            for (BluetoothDiscoveryParticipant participant : connectionParticipants) {\n+                // we call this every time just in case a participant somehow closes the connection\n+                if (device.getConnectionState() != ConnectionState.CONNECTED) {\n+                    if (device.getConnectionState() != ConnectionState.CONNECTING && !device.connect()) {\n+                        logger.debug(\"Connection attempt failed to start for device {}\", device.getAddress());\n+                        // something failed, so we abandon connection discovery\n+                        return null;\n+                    }\n+                    if (!awaitConnection(1, TimeUnit.SECONDS)) {\n+                        logger.debug(\"Connection to device {} timed out\", device.getAddress());\n+                        return null;\n+                    }\n+                    if (!servicesDiscovered) {\n+                        device.discoverServices();\n+                        if (!awaitServiceDiscovery(1, TimeUnit.SECONDS)) {\n+                            logger.debug(\"Service discovery for device {} timed out\", device.getAddress());\n+                            // something failed, so we abandon connection discovery\n+                            return null;\n+                        }\n+                    }\n+                    tryToDiscoverNameIfMissing();\n+                }\n+\n+                try {\n+                    DiscoveryResult result = participant.createResult(device);\n+                    if (result != null) {\n+                        return result;\n+                    }\n+                } catch (RuntimeException e) {", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMzM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387313383", "bodyText": "see above", "author": "cpmeister", "createdAt": "2020-03-03T21:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NzkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2ODA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387168075", "bodyText": "see above", "author": "J-N-K", "createdAt": "2020-03-03T17:10:56Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/discovery/internal/BluetoothDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.discovery.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothBindingConstants;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic.GattCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompanyIdentifiers;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.BluetoothDeviceListener;\n+import org.openhab.binding.bluetooth.discovery.BluetoothDiscoveryParticipant;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BluetoothDiscoveryProcess} does the work of creating a DiscoveryResult from a set of\n+ * {@link BluetoothDisocveryParticipant}s\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class BluetoothDiscoveryProcess implements Supplier<DiscoveryResult>, BluetoothDeviceListener {\n+\n+    private static final int DISCOVERY_TTL = 300;\n+\n+    private final Logger logger = LoggerFactory.getLogger(BluetoothDiscoveryProcess.class);\n+\n+    private final Lock serviceDiscoveryLock = new ReentrantLock();\n+    private final Condition connectionCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition serviceDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+    private final Condition nameDiscoveryCondition = serviceDiscoveryLock.newCondition();\n+\n+    private final Collection<BluetoothDiscoveryParticipant> participants;\n+    private final BluetoothDevice device;\n+\n+    private volatile boolean servicesDiscovered = false;\n+\n+    public BluetoothDiscoveryProcess(BluetoothDevice device, Collection<BluetoothDiscoveryParticipant> participants) {\n+        this.participants = participants;\n+        this.device = device;\n+    }\n+\n+    @Override\n+    public DiscoveryResult get() {\n+        // first see if any of the participants that don't require a connection recognize this device\n+        List<BluetoothDiscoveryParticipant> connectionParticipants = new ArrayList<>();\n+        for (BluetoothDiscoveryParticipant participant : participants) {\n+            if (participant.requiresConnection(device)) {\n+                connectionParticipants.add(participant);\n+                continue;\n+            }\n+            try {\n+                DiscoveryResult result = participant.createResult(device);\n+                if (result != null) {\n+                    return result;\n+                }\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Participant '{}' threw an exception\", participant.getClass().getName(), e);\n+            }\n+        }\n+\n+        // Since we couldn't find a result, lets try the connection based participants\n+        DiscoveryResult result = null;\n+        if (!connectionParticipants.isEmpty()) {\n+            BluetoothAddress address = device.getAddress();\n+            try {\n+                BluetoothAddressLocker.lock(address);\n+                if (!device.hasListeners()) {\n+                    result = findConnectionResult(connectionParticipants);\n+                    // make sure to disconnect before letting go of the device\n+                    if (device.getConnectionState() == ConnectionState.CONNECTED) {\n+                        try {\n+                            if (!device.disconnect()) {\n+                                logger.debug(\"Failed to disconnect from device {}\", address);\n+                            }\n+                        } catch (RuntimeException ex) {", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNjc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387316765", "bodyText": "The underlying BluetoothDevice implementations are not flawless (especially the BluezBluetoothDevice), and it is very possible an unintended RuntimeException could occur here. But I don't think a failure to disconnect should prevent a device discovery hence we catch any RuntimeExceptions.", "author": "cpmeister", "createdAt": "2020-03-03T21:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2ODA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387170720", "bodyText": "EOL missing. Please run the spotless-formatter before we merge.", "author": "J-N-K", "createdAt": "2020-03-03T17:15:17Z", "path": "bundles/org.openhab.binding.bluetooth/src/test/java/org/openhab/binding/bluetooth/MockBluetoothAdapter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+\n+/**\n+ * Mock implementation of a {@link BluetoothAdapter}.\n+ *\n+ * @author Connor Petty - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MockBluetoothAdapter implements BluetoothAdapter {\n+\n+    private Map<BluetoothAddress, MockBluetoothDevice> devices = new ConcurrentHashMap<>();\n+    private BluetoothAddress address = TestUtils.randomAddress();\n+    private ThingUID uid = TestUtils.randomThingUID();\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return uid;\n+    }\n+\n+    @Override\n+    public void addDiscoveryListener(BluetoothDiscoveryListener listener) {\n+    }\n+\n+    @Override\n+    public void removeDiscoveryListener(@Nullable BluetoothDiscoveryListener listener) {\n+    }\n+\n+    @Override\n+    public void scanStart() {\n+    }\n+\n+    @Override\n+    public void scanStop() {\n+    }\n+\n+    @Override\n+    public BluetoothAddress getAddress() {\n+        return address;\n+    }\n+\n+    @Override\n+    public MockBluetoothDevice getDevice(BluetoothAddress address) {\n+        return devices.computeIfAbsent(address, addr -> new MockBluetoothDevice(this, addr));\n+    }\n+\n+}", "originalCommit": "3fb34b9de42209ce997614a9c4c6aa0898d0befe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r387318512", "bodyText": "will do", "author": "cpmeister", "createdAt": "2020-03-03T21:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MDcyMA=="}], "type": "inlineReview"}, {"oid": "a643c31e87a87d5c2ad6bdffb9784d5149c5a9bb", "url": "https://github.com/openhab/openhab-addons/commit/a643c31e87a87d5c2ad6bdffb9784d5149c5a9bb", "message": "Fixed exclusive connection logic\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-03-05T19:40:52Z", "type": "commit"}, {"oid": "0fd3f2b70578ce6021dbcff8da6c46d489f83b43", "url": "https://github.com/openhab/openhab-addons/commit/0fd3f2b70578ce6021dbcff8da6c46d489f83b43", "message": "applied spotless check\n\nSigned-off-by: Connor Petty <cpmeister@users.noreply.github.com>", "committedDate": "2020-03-05T20:05:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAxMzExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7056#discussion_r389013115", "bodyText": "for the next iteration :-)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .noneMatch(d -> d.hasListeners());\n          \n          \n            \n                            .noneMatch(BluetoothDevice::hasListeners);", "author": "J-N-K", "createdAt": "2020-03-06T16:41:56Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/discovery/internal/BluetoothDiscoveryProcess.java", "diffHunk": "@@ -122,6 +127,15 @@ public DiscoveryResult get() {\n         return result;\n     }\n \n+    private boolean isAddressAvailable(BluetoothAddress address) {\n+        // if a device with this address has a handler on any of the adapters, we abandon discovery\n+        return adapters.stream().filter(adapter -> adapter.hasDevice(address))\n+                // get adapter's corresponding device\n+                .map(adapter -> adapter.getDevice(address))\n+                // make sure nothing is listening to any of them\n+                .noneMatch(d -> d.hasListeners());", "originalCommit": "a643c31e87a87d5c2ad6bdffb9784d5149c5a9bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}