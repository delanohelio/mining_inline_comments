{"pr_number": 1304, "pr_title": "Create OP_RETURN parser", "pr_createdAt": "2020-09-09T16:59:38Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1304", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc5OTE4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485799183", "bodyText": "I suggest making this class extend PeginInstructionsException", "author": "josedahlquist", "createdAt": "2020-09-09T17:36:42Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsParseException.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package co.rsk.peg.pegininstructions;\n+\n+public class PeginInstructionsParseException extends Exception {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMDAwNg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485800006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"[getOpReturnOutput] {}\", message);\n          \n          \n            \n                        logger.debug(\"[buildPeginInstructions] {}\", message);", "author": "josedahlquist", "createdAt": "2020-09-09T17:38:13Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMTMzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485801331", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n          \n          \n            \n                public PeginInstructions buildPeginInstructions(BtcTransaction btcTx) throws PeginInstructionsException {\n          \n      \n    \n    \n  \n\nYou should return the interface, not the base class, and the method should throw a specific Exception, not a generic one", "author": "josedahlquist", "createdAt": "2020-09-09T17:40:30Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMjE5OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485802199", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"[getOpReturnOutput] {}\", message);\n          \n          \n            \n                        logger.debug(\"[extractOpReturnData] {}\", message);\n          \n      \n    \n    \n  \n\nAnd there is another logger with the same typo", "author": "josedahlquist", "createdAt": "2020-09-09T17:42:00Z", "path": "rskj-core/src/main/java/co/rsk/peg/utils/BtcTransactionFormatUtils.java", "diffHunk": "@@ -57,4 +68,38 @@ public static boolean isBlockHeaderSize(int size, ActivationConfig.ForBlock acti\n         return (activations.isActive(ConsensusRule.RSKIP124) && size == MIN_BLOCK_HEADER_SIZE) ||\n                 (!activations.isActive(ConsensusRule.RSKIP124) && size >= MIN_BLOCK_HEADER_SIZE && size <= MAX_BLOCK_HEADER_SIZE);\n     }\n+\n+    public static byte[] extractOpReturnData(BtcTransaction btcTx) throws NoOpReturnException, InvalidOpReturnOutputException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[getOpReturnOutput] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMjQ5OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485802498", "bodyText": "Why should it fail if it doesn't find an op_return op code?", "author": "josedahlquist", "createdAt": "2020-09-09T17:42:35Z", "path": "rskj-core/src/main/java/co/rsk/peg/utils/BtcTransactionFormatUtils.java", "diffHunk": "@@ -57,4 +68,38 @@ public static boolean isBlockHeaderSize(int size, ActivationConfig.ForBlock acti\n         return (activations.isActive(ConsensusRule.RSKIP124) && size == MIN_BLOCK_HEADER_SIZE) ||\n                 (!activations.isActive(ConsensusRule.RSKIP124) && size >= MIN_BLOCK_HEADER_SIZE && size <= MAX_BLOCK_HEADER_SIZE);\n     }\n+\n+    public static byte[] extractOpReturnData(BtcTransaction btcTx) throws NoOpReturnException, InvalidOpReturnOutputException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[getOpReturnOutput] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new NoOpReturnException(message);", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MzUxMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487043512", "bodyText": "This no longer makes sense", "author": "josedahlquist", "createdAt": "2020-09-11T13:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485803104", "bodyText": "Add a couple more tests, null and empty data at least.", "author": "josedahlquist", "createdAt": "2020-09-09T17:43:42Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsBaseTest.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PeginInstructionsBaseTest {\n+\n+    @Test\n+    public void extractProtocolVersion() {\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(\n+                Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a\"));\n+\n+        Assert.assertEquals(1, protocolVersion);\n+    }", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NjY5Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485856692", "bodyText": "Add the case when a single byte is sent in the payload", "author": "marcos-iov", "createdAt": "2020-09-09T19:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NzMxOA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485857318", "bodyText": "Maybe also a test when protocol version > 9 to check that it's parsing hex values to int correctly", "author": "marcos-iov", "createdAt": "2020-09-09T19:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODExMjE3OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488112178", "bodyText": "Add the case when a single byte is sent in the payload\n\nIt is not possible that this method receive only one byte of data.", "author": "guidohernan93", "createdAt": "2020-09-14T17:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3Njk3MQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488176971", "bodyText": "what about:\n\nAdd a couple more tests, null and empty data at least.", "author": "josedahlquist", "createdAt": "2020-09-14T19:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIwMDA2Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488200062", "bodyText": "extractOpReturnData will never return null or empty data.", "author": "guidohernan93", "createdAt": "2020-09-14T20:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNTgzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485805831", "bodyText": "This and the following test should be a single test.", "author": "josedahlquist", "createdAt": "2020-09-09T17:48:56Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsProviderTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.core.Coin;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.bitcoinj.script.Script;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.config.BridgeRegTestConstants;\n+import co.rsk.core.RskAddress;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PeginInstructionsProviderTest {\n+    private final NetworkParameters params = BridgeRegTestConstants.getInstance().getBtcParams();\n+\n+    @Test(expected = PeginInstructionsException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_null_op_return_data() throws Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params);\n+\n+        // Add OP_RETURN output with empty data\n+        btcTransaction.addOutput(Coin.ZERO, new Script(new byte[] { ScriptOpCodes.OP_RETURN }));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_invalid_protocol_version() throws Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.INVALID_PROTOCOL_VERSION_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_try_parse_data_length_smaller_than_expected_v1() throws\n+            Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.SMALLER_THAN_EXPECTED_DATA_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_try_parse_data_length_different_than_supported_v1() throws\n+            Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.UNSUPPORTED_DATA_LENGTH_FOR_V1_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test\n+    public void peginInstructionsProvider_buildPeginInstructions_and_check_protocol_version_v1() throws Exception {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNzA1Nw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485807057", "bodyText": "This method should be at most protected", "author": "josedahlquist", "createdAt": "2020-09-09T17:51:07Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        this.btcRefundAddress = getBtcRefundAddressFromData(data);\n+    }\n+\n+    public Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODY1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485828651", "bodyText": "Add @Override annotation", "author": "marcos-iov", "createdAt": "2020-09-09T18:30:13Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+\n+    protected RskAddress rskDestinationAddress;\n+    private final int protocolVersion;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    public int getProtocolVersion() {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMjg3MA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485832870", "bodyText": "Add @OverRide annotation", "author": "marcos-iov", "createdAt": "2020-09-09T18:38:07Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+\n+    protected RskAddress rskDestinationAddress;\n+    private final int protocolVersion;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMzQ4Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485833482", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new PeginInstructionsParseException(\"Invalid data length\");\n          \n          \n            \n                        throw new PeginInstructionsParseException(\"Invalid data length. Expected at least 22 bytes, received {}\", data.length);", "author": "marcos-iov", "createdAt": "2020-09-09T18:39:21Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+\n+    protected RskAddress rskDestinationAddress;\n+    private final int protocolVersion;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public static int extractProtocolVersion(byte[] data) {\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"Invalid data length\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNTAxNg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485835016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PeginInstructionsBase peginInstructions;\n          \n          \n            \n                    PeginInstructions peginInstructions;", "author": "marcos-iov", "createdAt": "2020-09-09T18:42:09Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNTI5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485835296", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n          \n          \n            \n                    byte[] opReturnOutputData = BtcTransactionFormatUtils.extractOpReturnData(btcTx);", "author": "marcos-iov", "createdAt": "2020-09-09T18:42:39Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzODE1Nw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485838157", "bodyText": "If opReturnOutput has only 1 byte this will throw OutOfBoundsException. Maybe when checking if the data is null we could also check if data length is at least 22 bytes", "author": "marcos-iov", "createdAt": "2020-09-09T18:48:20Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MjIzMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485842232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n          \n          \n            \n                            peginInstructionsVersion1.parse(opReturnOutput);\n          \n          \n            \n                            peginInstructions = peginInstructionsVersion1;\n          \n          \n            \n                            peginInstructions = new PeginInstructionsVersion1(btcTx.getParams());\n          \n          \n            \n                            ((PeginInstructionsVersion1) peginInstructions).parse(opReturnOutput);", "author": "marcos-iov", "createdAt": "2020-09-09T18:55:57Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutput);\n+                peginInstructions = peginInstructionsVersion1;", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMTY4OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487131688", "bodyText": "I don't see why would this be better. In fact, intellij warns about it.", "author": "guidohernan93", "createdAt": "2020-09-11T15:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MjY2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485842669", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n          \n          \n            \n                            logger.debug(\"[buildPeginInstructions] Invalid protocol version given: {}\", protocolVersion);", "author": "marcos-iov", "createdAt": "2020-09-09T18:56:42Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutput);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NDgzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485844831", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            logger.trace(\"[buildPeginInstructions] PeginInstructions: {}\", peginInstructions.getClass());", "author": "marcos-iov", "createdAt": "2020-09-09T19:00:36Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.peg.utils.BtcTransactionFormatUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructionsBase buildPeginInstructions(BtcTransaction btcTx) throws Exception {\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = BtcTransactionFormatUtils.extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutput);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0Nzc5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485847796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"[validateDataLength] Invalid data length\");\n          \n          \n            \n                        logger.debug(\"[validateDataLength] Invalid data length. Expected 22 or 43 bytes, received {}\", data.length);", "author": "marcos-iov", "createdAt": "2020-09-09T19:06:24Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODM2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485848369", "bodyText": "Same message as above, put in a variable", "author": "marcos-iov", "createdAt": "2020-09-09T19:07:20Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0OTk0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485849942", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"[getBtcRefundAddressFromData] Invalid btc address type\");\n          \n          \n            \n                            logger.debug(\"[getBtcRefundAddressFromData] Invalid btc address type: {}\", btcRefundAddressType);", "author": "marcos-iov", "createdAt": "2020-09-09T19:10:06Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        this.btcRefundAddress = getBtcRefundAddressFromData(data);\n+    }\n+\n+    public Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                break;\n+            case P2SH_ADDRESS_TYPE:\n+                // Uses scriptPubKeyHash\n+                btcRefundAddress = new Address(this.params, this.params.getP2SHHeader(), hash);\n+                break;\n+            default:\n+                logger.debug(\"[getBtcRefundAddressFromData] Invalid btc address type\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MDE4Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485850182", "bodyText": "Same message as above, put it in a variable", "author": "marcos-iov", "createdAt": "2020-09-09T19:10:32Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        this.btcRefundAddress = getBtcRefundAddressFromData(data);\n+    }\n+\n+    public Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                break;\n+            case P2SH_ADDRESS_TYPE:\n+                // Uses scriptPubKeyHash\n+                btcRefundAddress = new Address(this.params, this.params.getP2SHHeader(), hash);\n+                break;\n+            default:\n+                logger.debug(\"[getBtcRefundAddressFromData] Invalid btc address type\");\n+                throw new PeginInstructionsParseException(\"Invalid btc address type\");", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MDY0MA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485850640", "bodyText": "Log obtained address", "author": "marcos-iov", "createdAt": "2020-09-09T19:11:12Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        this.btcRefundAddress = getBtcRefundAddressFromData(data);\n+    }\n+\n+    public Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                break;\n+            case P2SH_ADDRESS_TYPE:\n+                // Uses scriptPubKeyHash\n+                btcRefundAddress = new Address(this.params, this.params.getP2SHHeader(), hash);\n+                break;\n+            default:\n+                logger.debug(\"[getBtcRefundAddressFromData] Invalid btc address type\");\n+                throw new PeginInstructionsParseException(\"Invalid btc address type\");\n+        }\n+", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTIzMw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485851233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n          \n          \n            \n                protected abstract void validateAdditionalDataLength(byte[] data) throws PeginInstructionsParseException;", "author": "marcos-iov", "createdAt": "2020-09-09T19:12:23Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+\n+    protected RskAddress rskDestinationAddress;\n+    private final int protocolVersion;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public static int extractProtocolVersion(byte[] data) {\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"Invalid data length\");\n+        }\n+\n+        this.rskDestinationAddress = getRskDestinationAddressFromData(data);\n+        validateDataLength(data);\n+        parseAdditionalData(data);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;", "originalCommit": "68d653e4b88970592cebaff89ae37dcf80f00075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNjE1NA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487136154", "bodyText": "Name is clear I think, not validating only additional data length.", "author": "guidohernan93", "createdAt": "2020-09-11T15:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTc2Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485851762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n          \n          \n            \n                protected abstract void validateAdditionalDataLength(byte[] data) throws PeginInstructionsParseException;", "author": "marcos-iov", "createdAt": "2020-09-09T19:13:20Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddress = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddress);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMjUxNg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487022516", "bodyText": "I think the original name makes more sense. As indeed it should validate the whole data length and not just the additional.", "author": "josedahlquist", "createdAt": "2020-09-11T12:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjYyMQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485852621", "bodyText": "I would add some trace level logging, btc tx hash, protocol version, maybe op return data also", "author": "marcos-iov", "createdAt": "2020-09-09T19:14:55Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.InvalidOpReturnOutputException;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructions buildPeginInstructions(BtcTransaction btcTx) throws", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTY3OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485855678", "bodyText": "This can go inside peginstructions package since it's only thrown from PeginInstructionsProvider. And also inherit from PeginInstructionsException", "author": "marcos-iov", "createdAt": "2020-09-09T19:20:53Z", "path": "rskj-core/src/main/java/co/rsk/peg/InvalidOpReturnOutputException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTc4MQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485855781", "bodyText": "This can go inside peginstructions package since it's only thrown from PeginInstructionsProvider. And also inherit from PeginInstructionsException", "author": "marcos-iov", "createdAt": "2020-09-09T19:21:05Z", "path": "rskj-core/src/main/java/co/rsk/peg/NoOpReturnException.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package co.rsk.peg;", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTg5OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487021899", "bodyText": "@guidohernan93 please move this Exception to the pegininstructions package", "author": "josedahlquist", "createdAt": "2020-09-11T12:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1OTk4Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485859982", "bodyText": "thrown InvalidOpReturnOutputException", "author": "marcos-iov", "createdAt": "2020-09-09T19:27:41Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.InvalidOpReturnOutputException;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructions buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException, NoOpReturnException, InvalidOpReturnOutputException {\n+\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutput);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return peginInstructions;\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx) throws NoOpReturnException, InvalidOpReturnOutputException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNzAzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487137031", "bodyText": "It is throwing PeginInstructionsException", "author": "guidohernan93", "createdAt": "2020-09-11T15:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1OTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzOTYyNw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487139627", "bodyText": "I think it's simpler to throw the exception here instead of continuing the execution and then have an if asking if data == null. When this happens you already know the data received is invalid", "author": "marcos-iov", "createdAt": "2020-09-11T15:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1OTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MDgxMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485860812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String message = \"Only one output with OP_RETURN is allowed\";\n          \n          \n            \n                        String message = String.format(\"Only one output with OP_RETURN is allowed. Found %d\", opReturnOccurrences);", "author": "marcos-iov", "createdAt": "2020-09-09T19:28:46Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.InvalidOpReturnOutputException;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public PeginInstructions buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException, NoOpReturnException, InvalidOpReturnOutputException {\n+\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutput = extractOpReturnData(btcTx);\n+\n+        if (opReturnOutput == null || opReturnOutput.length == 0) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutput);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutput);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return peginInstructions;\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx) throws NoOpReturnException, InvalidOpReturnOutputException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);\n+            throw new NoOpReturnException(message);\n+        }\n+\n+        if (opReturnOccurrences > 1) {\n+            String message = \"Only one output with OP_RETURN is allowed\";", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NDkwMw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485864903", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PeginInstructionsVersion1 peginInstructionsVersion1 =\n          \n          \n            \n                            (PeginInstructionsVersion1) peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n          \n          \n            \n                    PeginInstructions peginInstructions =\n          \n          \n            \n            peginInstructionsProvider.buildPeginInstructions(btcTransaction);", "author": "marcos-iov", "createdAt": "2020-09-09T19:34:21Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsProviderTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.core.Coin;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.bitcoinj.script.Script;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.config.BridgeRegTestConstants;\n+import co.rsk.core.RskAddress;\n+import co.rsk.peg.InvalidOpReturnOutputException;\n+import co.rsk.peg.NoOpReturnException;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PeginInstructionsProviderTest {\n+    private final NetworkParameters params = BridgeRegTestConstants.getInstance().getBtcParams();\n+\n+    @Test(expected = PeginInstructionsException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_null_op_return_data() throws Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params);\n+\n+        // Add OP_RETURN output with empty data\n+        btcTransaction.addOutput(Coin.ZERO, new Script(new byte[] { ScriptOpCodes.OP_RETURN }));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_invalid_protocol_version() throws Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.INVALID_PROTOCOL_VERSION_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_try_parse_data_length_smaller_than_expected_v1() throws\n+            Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.SMALLER_THAN_EXPECTED_DATA_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsProvider_buildPeginInstructions_try_parse_data_length_different_than_supported_v1() throws\n+            Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.UNSUPPORTED_DATA_LENGTH_FOR_V1_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        peginInstructionsProvider.buildPeginInstructions(btcTransaction);\n+    }\n+\n+    @Test\n+    public void peginInstructionsProvider_buildPeginInstructions_and_check_protocol_version_v1() throws Exception {\n+        BtcTransaction btcTransaction = new BtcTransaction(params,\n+                Hex.decode(RawTransactions.VALID_DATA_WITHOUT_REFUND_ADDRESS_V1_TX));\n+\n+        PeginInstructionsProvider peginInstructionsProvider = new PeginInstructionsProvider();\n+        PeginInstructionsVersion1 peginInstructionsVersion1 =\n+                (PeginInstructionsVersion1) peginInstructionsProvider.buildPeginInstructions(btcTransaction);", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MzcwMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485873702", "bodyText": "Assert.assertFalse(obtainedBtcAddress.isP2SHAddress());", "author": "marcos-iov", "createdAt": "2020-09-09T19:44:51Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1Test.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.config.BridgeRegTestConstants;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1Test {\n+    private final NetworkParameters params = BridgeRegTestConstants.getInstance().getBtcParams();\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_validateDataLength_invalid_length_too_large() throws Exception {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.validateDataLength(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a98\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getProtocolVersion() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertEquals(1, peginInstructionsVersion1.getProtocolVersion());\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getRskDestinationAddress_no_data() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertNull(peginInstructionsVersion1.getRskDestinationAddress());\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_parse_data_invalid_length() throws PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.parse(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_no_refund_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Assert.assertEquals(Optional.empty(),\n+                peginInstructionsVersion1.getBtcRefundAddressFromData(\n+                        Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a\")));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2pkh_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params, Hex.decode(\"4f4c767a2d308eebb3f0f1247f9163c896e0b7d2\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a014f4c767a2d308eebb3f0f1247f9163c896e0b7d2\";\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NDAzOA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485874038", "bodyText": "Assert.assertTrue(obtainedBtcAddress.isP2SHAddress());", "author": "marcos-iov", "createdAt": "2020-09-09T19:45:12Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1Test.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.config.BridgeRegTestConstants;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1Test {\n+    private final NetworkParameters params = BridgeRegTestConstants.getInstance().getBtcParams();\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_validateDataLength_invalid_length_too_large() throws Exception {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.validateDataLength(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a98\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getProtocolVersion() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertEquals(1, peginInstructionsVersion1.getProtocolVersion());\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getRskDestinationAddress_no_data() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertNull(peginInstructionsVersion1.getRskDestinationAddress());\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_parse_data_invalid_length() throws PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.parse(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_no_refund_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Assert.assertEquals(Optional.empty(),\n+                peginInstructionsVersion1.getBtcRefundAddressFromData(\n+                        Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a\")));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2pkh_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params, Hex.decode(\"4f4c767a2d308eebb3f0f1247f9163c896e0b7d2\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a014f4c767a2d308eebb3f0f1247f9163c896e0b7d2\";\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2sh_p2wpkh_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params,\n+                params.getP2SHHeader(),\n+                Hex.decode(\"19d7e0ee9bf6bd70d1d046b066d1c2726e1accc1\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a0219d7e0ee9bf6bd70d1d046b066d1c2726e1accc1\";\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0Mjk4Ng==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485942986", "bodyText": "Check that the obtainedBtcAddress is P2SH not the one you created", "author": "marcos-iov", "createdAt": "2020-09-09T21:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NDAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NDc4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485944783", "bodyText": "That's true!", "author": "guidohernan93", "createdAt": "2020-09-09T21:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NDk5MA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485874990", "bodyText": "Assert.assertTrue(obtainedBtcAddress.isP2SHAddress());", "author": "marcos-iov", "createdAt": "2020-09-09T19:46:18Z", "path": "rskj-core/src/test/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1Test.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.config.BridgeRegTestConstants;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1Test {\n+    private final NetworkParameters params = BridgeRegTestConstants.getInstance().getBtcParams();\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_validateDataLength_invalid_length_too_large() throws Exception {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.validateDataLength(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a98\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getProtocolVersion() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertEquals(1, peginInstructionsVersion1.getProtocolVersion());\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getRskDestinationAddress_no_data() {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        Assert.assertNull(peginInstructionsVersion1.getRskDestinationAddress());\n+    }\n+\n+    @Test(expected = PeginInstructionsParseException.class)\n+    public void peginInstructionsV1_parse_data_invalid_length() throws PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+        peginInstructionsVersion1.parse(Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b\"));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_no_refund_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Assert.assertEquals(Optional.empty(),\n+                peginInstructionsVersion1.getBtcRefundAddressFromData(\n+                        Hex.decode(\"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a\")));\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2pkh_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params, Hex.decode(\"4f4c767a2d308eebb3f0f1247f9163c896e0b7d2\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a014f4c767a2d308eebb3f0f1247f9163c896e0b7d2\";\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2sh_p2wpkh_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params,\n+                params.getP2SHHeader(),\n+                Hex.decode(\"19d7e0ee9bf6bd70d1d046b066d1c2726e1accc1\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a0219d7e0ee9bf6bd70d1d046b066d1c2726e1accc1\";\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);\n+    }\n+\n+    @Test\n+    public void peginInstructionsV1_getBtcRefundAddressFromData_p2sh_multisig_address() throws\n+            PeginInstructionsParseException {\n+        PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(params);\n+\n+        Address btcAddress = new Address(params,\n+                params.getP2SHHeader(),\n+                Hex.decode(\"6c230519d0957afca4a7ffbeda9ab29c3ca233d9\"));\n+\n+        String rawData = \"00010e537aad84447a2c2a7590d5f2665ef5cf9b667a026c230519d0957afca4a7ffbeda9ab29c3ca233d9\";\n+\n+        Optional<Address> obtainedBtcAddress = peginInstructionsVersion1.getBtcRefundAddressFromData(Hex.decode(rawData));\n+        Assert.assertEquals(Optional.of(btcAddress), obtainedBtcAddress);", "originalCommit": "99c0bbf50155caf7f5e97d59cdef6831123975a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b575bbbd11cbe8848014162b77973cb185ce759", "url": "https://github.com/rsksmart/rskj/commit/4b575bbbd11cbe8848014162b77973cb185ce759", "message": "Reorder PeginInstructionsBase class methods\nMove extractOpReturnData to PeginInstructionsProvider class\nMake getBtcRefundAddressFromData method protected", "committedDate": "2020-09-09T19:48:51Z", "type": "forcePushed"}, {"oid": "43a640736b76964124ac737921ad88ef0473119c", "url": "https://github.com/rsksmart/rskj/commit/43a640736b76964124ac737921ad88ef0473119c", "message": "Reorder PeginInstructionsBase class methods\nMove extractOpReturnData to PeginInstructionsProvider class\nMake getBtcRefundAddressFromData method protected", "committedDate": "2020-09-09T20:30:21Z", "type": "forcePushed"}, {"oid": "da429da76fc0bc1cc4b07e9013cdc0f4cf6cc9b7", "url": "https://github.com/rsksmart/rskj/commit/da429da76fc0bc1cc4b07e9013cdc0f4cf6cc9b7", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations", "committedDate": "2020-09-09T20:39:47Z", "type": "forcePushed"}, {"oid": "7935fa04834559d8eef2af17e5a0e930c7d48b83", "url": "https://github.com/rsksmart/rskj/commit/7935fa04834559d8eef2af17e5a0e930c7d48b83", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional", "committedDate": "2020-09-09T21:02:07Z", "type": "forcePushed"}, {"oid": "79b2e23b18abd0a75fca2745198f2206c3e47afc", "url": "https://github.com/rsksmart/rskj/commit/79b2e23b18abd0a75fca2745198f2206c3e47afc", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional", "committedDate": "2020-09-09T21:27:54Z", "type": "forcePushed"}, {"oid": "ff67af16ebf89fae1d9cf0ca399c8d6a9c1e20e5", "url": "https://github.com/rsksmart/rskj/commit/ff67af16ebf89fae1d9cf0ca399c8d6a9c1e20e5", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional", "committedDate": "2020-09-09T21:55:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MzU0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r485963542", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {\n          \n          \n            \n                protected void getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {\n          \n      \n    \n    \n  \n\nJust set the value to btcRefundAddress inside this method instead of returning. It will save you a code smell", "author": "marcos-iov", "createdAt": "2020-09-09T22:48:37Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        this.btcRefundAddress = getBtcRefundAddressFromData(data);\n+    }\n+\n+    protected Optional<Address> getBtcRefundAddressFromData(byte[] data) throws PeginInstructionsParseException {", "originalCommit": "ff67af16ebf89fae1d9cf0ca399c8d6a9c1e20e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f8191fcd751e47d69e56d23729922af287838c2", "url": "https://github.com/rsksmart/rskj/commit/4f8191fcd751e47d69e56d23729922af287838c2", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void", "committedDate": "2020-09-10T15:28:12Z", "type": "forcePushed"}, {"oid": "1f11bbf405afc836d29dd02b7e49305b60332120", "url": "https://github.com/rsksmart/rskj/commit/1f11bbf405afc836d29dd02b7e49305b60332120", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void", "committedDate": "2020-09-10T16:52:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMjg2OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487022868", "bodyText": "I would make this validation as the first step in this method. We want to validate the length before trying to parse any of the data.", "author": "josedahlquist", "createdAt": "2020-09-11T12:50:45Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddressBytes = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddressBytes);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n+\n+    protected abstract void parseAdditionalData(byte[] data) throws PeginInstructionsParseException;\n+\n+    public static int extractProtocolVersion(byte[] data) {\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    @Override\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    @Override\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            String message = String.format(\"Invalid data length. Expected at least 22 bytes, \"\n+                + \"received %s\", data.length);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+\n+        this.rskDestinationAddress = getRskDestinationAddressFromData(data);\n+        validateDataLength(data);", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMzY1OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487023658", "bodyText": "How could the data be null? and the data length validation is responsibility of PeginInstructions itself and not the provider", "author": "josedahlquist", "createdAt": "2020-09-11T12:52:06Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1Njg0Ng==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487056846", "bodyText": "Could be null if an empty data OP_RETURN is provided. And, when you extract that data, for some reason could be less than the expected data (user error).", "author": "guidohernan93", "createdAt": "2020-09-11T13:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDE1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487024159", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n          \n          \n            \n                    logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());", "author": "josedahlquist", "createdAt": "2020-09-11T12:52:59Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {\n+            String message = \"Invalid OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTMyOQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487025329", "bodyText": "Catch any Exception here as well, because if there is any unhandled exception that would make the caller fail too.\nIf a generic Exception is thrown, log it so we can understand what happened", "author": "josedahlquist", "createdAt": "2020-09-11T12:55:00Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTk4NQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487025985", "bodyText": "I wonder if this could trigger an NPE", "author": "josedahlquist", "createdAt": "2020-09-11T12:56:06Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {\n+            String message = \"Invalid OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MTU0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487051542", "bodyText": "No, because it is not possible for a BTC tx not tu have any outputs. At least one output will exist, if it is not OP_RETURN doesn't matter.", "author": "guidohernan93", "createdAt": "2020-09-11T13:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjc3NA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487026774", "bodyText": "I suggest moving the logic of this method directly to parseAdditionalData", "author": "josedahlquist", "createdAt": "2020-09-11T12:57:34Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            logger.debug(\"[validateDataLength] Invalid data length\");\n+            throw new PeginInstructionsParseException(\"[validateDataLength] Invalid data length\");\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        parseBtcRefundAddress(data);\n+    }\n+\n+    protected void parseBtcRefundAddress(byte[] data) throws PeginInstructionsParseException {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MTM5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487051393", "bodyText": "But what if we have move validations on the future for additional data? The idea would be that parseAdditionalData call all the validation methods that could exist.", "author": "guidohernan93", "createdAt": "2020-09-11T13:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMjUyOA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487032528", "bodyText": "You could move this validation to be the first instruction to avoid parsing anything", "author": "josedahlquist", "createdAt": "2020-09-11T13:08:05Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddressBytes = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddressBytes);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n+\n+    protected abstract void parseAdditionalData(byte[] data) throws PeginInstructionsParseException;\n+\n+    public static int extractProtocolVersion(byte[] data) {\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    @Override\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    @Override\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            String message = String.format(\"Invalid data length. Expected at least 22 bytes, \"\n+                + \"received %s\", data.length);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+\n+        this.rskDestinationAddress = getRskDestinationAddressFromData(data);\n+        validateDataLength(data);", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMjc5MA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487032790", "bodyText": "These validations don't seem appropriate for this class", "author": "josedahlquist", "createdAt": "2020-09-11T13:08:32Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0OTEwNg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487049106", "bodyText": "It could be on method extractOpReturnData, but it is still on this class. Where should it be so?", "author": "guidohernan93", "createdAt": "2020-09-11T13:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMjc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3OTQxMw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488179413", "bodyText": "just left another comment about this. You already check the length in the base class of PeginInstructions. You shouldn't duplicate that logic.\nClosing this comment as it's repeated :)", "author": "josedahlquist", "createdAt": "2020-09-14T19:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMjc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzNDUwMA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487034500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n          \n          \n            \n                    logger.debug(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());", "author": "josedahlquist", "createdAt": "2020-09-11T13:11:19Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {\n+            String message = \"Invalid OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzNTE4OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487035188", "bodyText": "I wonder if this could trigger an NPE", "author": "josedahlquist", "createdAt": "2020-09-11T13:12:25Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import co.rsk.peg.NoOpReturnException;\n+import java.util.List;\n+import java.util.Optional;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {\n+            String message = \"Invalid OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.info(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {", "originalCommit": "1f11bbf405afc836d29dd02b7e49305b60332120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NzkyMA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487047920", "bodyText": "No, because it is not possible for a BTC tx not tu have any outputs. At least one output will exist, if it is not OP_RETURN doesn't matter.", "author": "guidohernan93", "createdAt": "2020-09-11T13:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzNTE4OA=="}], "type": "inlineReview"}, {"oid": "41adaf4b6c73fc6a9665506ef02bb6611556e7d8", "url": "https://github.com/rsksmart/rskj/commit/41adaf4b6c73fc6a9665506ef02bb6611556e7d8", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info", "committedDate": "2020-09-11T13:54:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2ODkzMw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487068933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"[getOpReturnOutput] {}\", message);\n          \n          \n            \n                        logger.trace(\"[getOpReturnOutput] {}\", message);", "author": "josedahlquist", "createdAt": "2020-09-11T14:06:51Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (Exception e) {\n+            logger.debug(\"Error extracting OP_RETURN data: {}\", e.getMessage());\n+            return Optional.empty();\n+        }\n+\n+        if (opReturnOutputData == null || opReturnOutputData.length < 22) {\n+            String message = \"Invalid OP_RETURN data found\";\n+            logger.debug(\"[buildPeginInstructions] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        logger.trace(\"[buildPeginInstructions] OP_RETURN data: {}\", Hex.toHexString(opReturnOutputData));\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                logger.trace(\"[buildPeginInstructions] Going to build peginInstructions version 1..\");\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                logger.trace(\"Successfully created peginInstructions version 1\");\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";\n+            logger.debug(\"[getOpReturnOutput] {}\", message);", "originalCommit": "41adaf4b6c73fc6a9665506ef02bb6611556e7d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "edbd1655677b7bc3e6cfdf89d0c048ad141d4a2b", "url": "https://github.com/rsksmart/rskj/commit/edbd1655677b7bc3e6cfdf89d0c048ad141d4a2b", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider", "committedDate": "2020-09-11T14:12:57Z", "type": "forcePushed"}, {"oid": "100a8aacd63644d80168ed240ae851b2ea13a5d5", "url": "https://github.com/rsksmart/rskj/commit/100a8aacd63644d80168ed240ae851b2ea13a5d5", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider", "committedDate": "2020-09-11T14:16:23Z", "type": "forcePushed"}, {"oid": "87f7d18cb3b8c9ffb61aebc593ee2c9452a103b1", "url": "https://github.com/rsksmart/rskj/commit/87f7d18cb3b8c9ffb61aebc593ee2c9452a103b1", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T14:18:46Z", "type": "forcePushed"}, {"oid": "b01755e58a869de0d93b0a61488f94d6e1c87a30", "url": "https://github.com/rsksmart/rskj/commit/b01755e58a869de0d93b0a61488f94d6e1c87a30", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T14:19:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NDk0OA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487084948", "bodyText": "Careful here. We must not treat every exception equally.\nIf there is no OP_RETURN we should return Optional.empty.\nBut if there is any other situation (more than one op_return, null data after op_return, or any unhandled exception) we should raise a new exception for the funds to be returned.", "author": "josedahlquist", "createdAt": "2020-09-11T14:31:51Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (Exception e) {", "originalCommit": "b01755e58a869de0d93b0a61488f94d6e1c87a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4756a232cd05ace791ed354e1456cbc4148b4559", "url": "https://github.com/rsksmart/rskj/commit/4756a232cd05ace791ed354e1456cbc4148b4559", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T15:09:20Z", "type": "forcePushed"}, {"oid": "d779ac024d7a69d11084b9fea26112defcdc30c3", "url": "https://github.com/rsksmart/rskj/commit/d779ac024d7a69d11084b9fea26112defcdc30c3", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T15:54:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDA5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487134093", "bodyText": "When logging and throwing an exception with the same message it's good to put in a variable. So it is easy to change in both places in case it's necessary", "author": "marcos-iov", "createdAt": "2020-09-11T15:48:48Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        } catch (Exception e) {\n+            logger.debug(\"Btc tx: {} has an invalid OP_RETURN structure\", btcTx.getHash());\n+            throw new PeginInstructionsException(\"Transaction has an invalid OP_RETURN structure\", e);", "originalCommit": "4756a232cd05ace791ed354e1456cbc4148b4559", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDQ1Mg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487134452", "bodyText": "Also, remember to put the method name in brackets as a prefix in the log message", "author": "marcos-iov", "createdAt": "2020-09-11T15:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNTQ3MQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487135471", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String message = \"No OP_RETURN output found for tx\";\n          \n          \n            \n                        String message = \"No OP_RETURN output found for tx {}\", tx.getHash;", "author": "marcos-iov", "createdAt": "2020-09-11T15:51:13Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        } catch (Exception e) {\n+            logger.debug(\"Btc tx: {} has an invalid OP_RETURN structure\", btcTx.getHash());\n+            throw new PeginInstructionsException(\"Transaction has an invalid OP_RETURN structure\", e);\n+        }\n+\n+        logger.trace(\"[buildPeginInstructions] OP_RETURN data: {}\", Hex.toHexString(opReturnOutputData));\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                logger.trace(\"[buildPeginInstructions] Going to build peginInstructions version 1..\");\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                logger.trace(\"Successfully created peginInstructions version 1\");\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";", "originalCommit": "4756a232cd05ace791ed354e1456cbc4148b4559", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNjIyMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487136222", "bodyText": "This is no longer necessary if InvalidOpReturnOutputException is thrown in line 67", "author": "marcos-iov", "createdAt": "2020-09-11T15:52:31Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructions peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            return Optional.empty();\n+        } catch (Exception e) {\n+            logger.debug(\"Btc tx: {} has an invalid OP_RETURN structure\", btcTx.getHash());\n+            throw new PeginInstructionsException(\"Transaction has an invalid OP_RETURN structure\", e);\n+        }\n+\n+        logger.trace(\"[buildPeginInstructions] OP_RETURN data: {}\", Hex.toHexString(opReturnOutputData));\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                logger.trace(\"[buildPeginInstructions] Going to build peginInstructions version 1..\");\n+                PeginInstructionsVersion1 peginInstructionsVersion1 = new PeginInstructionsVersion1(btcTx.getParams());\n+                peginInstructionsVersion1.parse(opReturnOutputData);\n+                peginInstructions = peginInstructionsVersion1;\n+                logger.trace(\"Successfully created peginInstructions version 1\");\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given\");\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = \"No OP_RETURN output found for tx\";\n+            logger.trace(\"[extractOpReturnData] {}\", message);\n+            throw new NoOpReturnException(message);\n+        }\n+\n+        if (opReturnOccurrences > 1) {\n+            String message = String.format(\"Only one output with OP_RETURN is allowed. Found %d\",\n+                opReturnOccurrences);\n+            logger.debug(\"[extractOpReturnData] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        if (data == null) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[extractOpReturnData] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }", "originalCommit": "4756a232cd05ace791ed354e1456cbc4148b4559", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjgwNw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487142807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String message = String.format(\"[getBtcRefundAddressFromData] Invalid btc address type: %d\", btcRefundAddressType);\n          \n          \n            \n                            String message = String.format(\"[parseAdditionalData] Invalid btc address type: %d\", btcRefundAddressType);", "author": "marcos-iov", "createdAt": "2020-09-11T16:04:06Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            String message = String.format(\"[validateDataLength] Invalid data length. Expected 22 or 43 bytes, received %d\", data.length);\n+            logger.debug(message);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            this.btcRefundAddress = Optional.empty();\n+            return;\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                logger.debug(\"Obtained P2PKH BTC address: {}\",btcRefundAddress);\n+                break;\n+            case P2SH_ADDRESS_TYPE:\n+                // Uses scriptPubKeyHash\n+                btcRefundAddress = new Address(this.params, this.params.getP2SHHeader(), hash);\n+                logger.debug(\"Obtained P2SH BTC address: {}\",btcRefundAddress);\n+                break;\n+            default:\n+                String message = String.format(\"[getBtcRefundAddressFromData] Invalid btc address type: %d\", btcRefundAddressType);", "originalCommit": "d779ac024d7a69d11084b9fea26112defcdc30c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31d5636c13844de89c8ca04ca556e6ddcb22e872", "url": "https://github.com/rsksmart/rskj/commit/31d5636c13844de89c8ca04ca556e6ddcb22e872", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T18:03:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzMDk1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487230959", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            + \"received %s\", data.length);\n          \n          \n            \n                            + \"received %d\", data.length);", "author": "marcos-iov", "createdAt": "2020-09-11T18:57:09Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddressBytes = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddressBytes);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n+\n+    protected abstract void parseAdditionalData(byte[] data) throws PeginInstructionsParseException;\n+\n+    public static int extractProtocolVersion(byte[] data) {\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    @Override\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    @Override\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            String message = String.format(\"Invalid data length. Expected at least 22 bytes, \"\n+                + \"received %s\", data.length);", "originalCommit": "31d5636c13844de89c8ca04ca556e6ddcb22e872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzNDA5Nw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487234097", "bodyText": "Put method name as prefix", "author": "marcos-iov", "createdAt": "2020-09-11T19:03:46Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            String message = String.format(\"[validateDataLength] Invalid data length. Expected 22 or 43 bytes, received %d\", data.length);\n+            logger.debug(message);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            this.btcRefundAddress = Optional.empty();\n+            return;\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                logger.debug(\"Obtained P2PKH BTC address: {}\",btcRefundAddress);", "originalCommit": "31d5636c13844de89c8ca04ca556e6ddcb22e872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzNDE3NQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r487234175", "bodyText": "Put method name as prefix", "author": "marcos-iov", "createdAt": "2020-09-11T19:03:55Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            String message = String.format(\"[validateDataLength] Invalid data length. Expected 22 or 43 bytes, received %d\", data.length);\n+            logger.debug(message);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            this.btcRefundAddress = Optional.empty();\n+            return;\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;\n+\n+        switch (btcRefundAddressType) {\n+            case P2PKH_ADDRESS_TYPE:\n+                // Uses pubKeyHash\n+                btcRefundAddress = new Address(this.params, hash);\n+                logger.debug(\"Obtained P2PKH BTC address: {}\",btcRefundAddress);\n+                break;\n+            case P2SH_ADDRESS_TYPE:\n+                // Uses scriptPubKeyHash\n+                btcRefundAddress = new Address(this.params, this.params.getP2SHHeader(), hash);\n+                logger.debug(\"Obtained P2SH BTC address: {}\",btcRefundAddress);", "originalCommit": "31d5636c13844de89c8ca04ca556e6ddcb22e872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4cdb27070598b97697997491a8676a2e1d51bd26", "url": "https://github.com/rsksmart/rskj/commit/4cdb27070598b97697997491a8676a2e1d51bd26", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T19:24:50Z", "type": "forcePushed"}, {"oid": "ff6e3fe4e7907889f5e2f9ba13548fb8a2a0efd9", "url": "https://github.com/rsksmart/rskj/commit/ff6e3fe4e7907889f5e2f9ba13548fb8a2a0efd9", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-11T19:54:17Z", "type": "forcePushed"}, {"oid": "a3918d522dbcea4809d2c7d06cfee825674efb02", "url": "https://github.com/rsksmart/rskj/commit/a3918d522dbcea4809d2c7d06cfee825674efb02", "message": "Create OP_RETURN parser\n\nCreate interface and implement it on PegInstructionBaseClase from where all the versions will extend.\nCreate multiple exceptions to manage errors.", "committedDate": "2020-09-14T14:40:45Z", "type": "commit"}, {"oid": "66901af5dbc45c855849d7c53fdb34bb9e9b973d", "url": "https://github.com/rsksmart/rskj/commit/66901af5dbc45c855849d7c53fdb34bb9e9b973d", "message": "Add unit test for PeginInstructions classes and update BtcTransactionFormatUtilsTest as it now contains the method extractOpReturnData", "committedDate": "2020-09-14T14:40:55Z", "type": "commit"}, {"oid": "985e7f8e1b94fbf6035adc065456b25cb10ef19e", "url": "https://github.com/rsksmart/rskj/commit/985e7f8e1b94fbf6035adc065456b25cb10ef19e", "message": "Create class to contain all the raw transactions and rename some tests", "committedDate": "2020-09-14T14:41:03Z", "type": "commit"}, {"oid": "02c14eb742c29ef02bec1db906f7f4589bb0142c", "url": "https://github.com/rsksmart/rskj/commit/02c14eb742c29ef02bec1db906f7f4589bb0142c", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-14T14:41:11Z", "type": "commit"}, {"oid": "02c14eb742c29ef02bec1db906f7f4589bb0142c", "url": "https://github.com/rsksmart/rskj/commit/02c14eb742c29ef02bec1db906f7f4589bb0142c", "message": "Applying improvements in PeginInstructions code\n- Reorder PeginInstructionsBase class methods\n- Move extractOpReturnData to PeginInstructionsProvider class\n- Make getBtcRefundAddressFromData method protected\n- Add override annotation to getRskDestinationAddress and getProtocolVersion methods on base class\n- Add op_return data validation on PegInstructionsProvider\n- Fix some test and add validations\n- Make buildPeginInstructions Optional\n- Rename getBtcRefundAddress to parseBtcRefundAddress and make it void\n- Move NoOpReturnException class to pegininstructions package\n- Add some debug info\n- Remove unnecessary data validation length from provider\n- Move getBtcRefundAddress logic to parseAdditionalData on PeginInstructionsV1", "committedDate": "2020-09-14T14:41:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NTk1OQ==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488175959", "bodyText": "This validation shouldn't be here, is already performed by PeginInstructionsBase", "author": "josedahlquist", "createdAt": "2020-09-14T19:40:28Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsProvider.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.script.ScriptChunk;\n+import co.rsk.bitcoinj.script.ScriptOpCodes;\n+import java.util.List;\n+import java.util.Optional;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PeginInstructionsProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsProvider.class);\n+\n+    public Optional<PeginInstructions> buildPeginInstructions(BtcTransaction btcTx) throws\n+        PeginInstructionsException {\n+\n+        logger.trace(\"[buildPeginInstructions] Using btc tx {}\", btcTx.getHash());\n+\n+        PeginInstructionsBase peginInstructions;\n+        byte[] opReturnOutputData;\n+\n+        try {\n+            opReturnOutputData = extractOpReturnData(btcTx);\n+        } catch (NoOpReturnException e) {\n+            logger.trace(\"[buildPeginInstructions] {}\", e.getMessage());\n+            return Optional.empty();\n+        } catch (Exception e) {\n+            String message = String.format(\"Btc tx: %s has an invalid OP_RETURN structure\", btcTx.getHash());\n+            logger.debug(message);\n+            throw new PeginInstructionsException(message, e);\n+        }\n+\n+        logger.trace(\"[buildPeginInstructions] OP_RETURN data: {}\", Hex.toHexString(opReturnOutputData));\n+\n+        int protocolVersion = PeginInstructionsBase.extractProtocolVersion(opReturnOutputData);\n+\n+        switch (protocolVersion) {\n+            case 1:\n+                logger.trace(\"[buildPeginInstructions] Going to build peginInstructions version 1..\");\n+                peginInstructions = new PeginInstructionsVersion1(btcTx.getParams());\n+                break;\n+            default:\n+                logger.debug(\"[buildPeginInstructions] Invalid protocol version given: {}\", protocolVersion);\n+                throw new PeginInstructionsException(\"Invalid protocol version\");\n+        }\n+\n+        peginInstructions.parse(opReturnOutputData);\n+        logger.trace(\"[buildPeginInstructions] Successfully created peginInstructions: {}\",\n+            peginInstructions.getClass());\n+\n+        return Optional.of(peginInstructions);\n+    }\n+\n+    protected static byte[] extractOpReturnData(BtcTransaction btcTx)\n+        throws PeginInstructionsException {\n+        byte[] data = new byte[]{};\n+        int opReturnOccurrences = 0;\n+\n+        logger.trace(\"[extractOpReturnData] Getting OP_RETURN data for btc tx: {}\", btcTx.getHash());\n+\n+        for (int i=0; i<btcTx.getOutputs().size(); i++) {\n+            List<ScriptChunk> chunksByOutput = btcTx.getOutput(i).getScriptPubKey().getChunks();\n+            if (chunksByOutput.get(0).opcode == ScriptOpCodes.OP_RETURN) {\n+                if (chunksByOutput.size() > 1) {\n+                    data = btcTx.getOutput(i).getScriptPubKey().getChunks().get(1).data;\n+                    opReturnOccurrences++;\n+                } else {\n+                    // OP_RETURN exist but data is empty\n+                    opReturnOccurrences++;\n+                    data = null;\n+                }\n+            }\n+        }\n+\n+        if (opReturnOccurrences == 0) {\n+            String message = String.format(\"No OP_RETURN output found for tx %s\", btcTx.getHash());\n+            throw new NoOpReturnException(message);\n+        }\n+\n+        if (opReturnOccurrences > 1) {\n+            String message = String.format(\"Only one output with OP_RETURN is allowed. Found %d\",\n+                opReturnOccurrences);\n+            logger.debug(\"[extractOpReturnData] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        if (data == null) {\n+            String message = \"Empty OP_RETURN data found\";\n+            logger.debug(\"[extractOpReturnData] {}\", message);\n+            throw new PeginInstructionsException(message);\n+        }\n+\n+        if (data.length < 22) {", "originalCommit": "02c14eb742c29ef02bec1db906f7f4589bb0142c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5OTAwNw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488199007", "bodyText": "You first call extractOpReturnData and then parse method is called (that's when parse method is called).", "author": "guidohernan93", "createdAt": "2020-09-14T20:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMDQ4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488830487", "bodyText": "Not sure if it makes sense to have this here, isn't the data length checked in validateDataLength?", "author": "marcos-iov", "createdAt": "2020-09-15T17:16:22Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddressBytes = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddressBytes);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n+\n+    protected abstract void parseAdditionalData(byte[] data) throws PeginInstructionsParseException;\n+\n+    public static int extractProtocolVersion(byte[] data) throws PeginInstructionsParseException {\n+        if (data == null || data.length < 2) {\n+            String message;\n+\n+            if (data == null) {\n+                message = \"Provided data is null\";\n+            }\n+            else {\n+                message = String.format(\"Invalid data given. Expected at least 2 bytes, \" +\n+                    \"received %d\", data.length);\n+            }\n+\n+            logger.debug(\"[extractProtocolVersion] {}\", message);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+\n+        byte[] protocolVersionBytes = Arrays.copyOfRange(data, 0, 2);\n+        return ByteUtil.byteArrayToInt(protocolVersionBytes);\n+    }\n+\n+    @Override\n+    public RskAddress getRskDestinationAddress() {\n+        return this.rskDestinationAddress;\n+    }\n+\n+    @Override\n+    public int getProtocolVersion() {\n+        return this.protocolVersion;\n+    }\n+\n+    public void parse(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length < 22) {\n+            logger.debug(\"[parse] Invalid data length\");\n+            String message = String.format(\"Invalid data length. Expected at least 22 bytes, \"\n+                + \"received %d\", data.length);\n+            throw new PeginInstructionsParseException(message);\n+        }", "originalCommit": "657ec599cee7850044645b5b44c57c677db7039a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzk4NA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488833984", "bodyText": "Length must be at least 22 bytes. Then, for v1, you check that length is 22 or 43 bytes, otherwise will fail. Maybe, for later versions, that validation will be different, but we always need at least those 22 bytes.", "author": "guidohernan93", "createdAt": "2020-09-15T17:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NzM5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488857396", "bodyText": "Remove validation finally, each version will take care of validating the data length.", "author": "guidohernan93", "createdAt": "2020-09-15T17:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMDQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMDgxMg==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488830812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "author": "marcos-iov", "createdAt": "2020-09-15T17:16:56Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsBase.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.core.RskAddress;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+public abstract class PeginInstructionsBase implements PeginInstructions {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsBase.class);\n+    private final int protocolVersion;\n+    protected RskAddress rskDestinationAddress;\n+\n+    protected PeginInstructionsBase(int protocolVersion) {\n+        this.protocolVersion = protocolVersion;\n+    }\n+\n+    private RskAddress getRskDestinationAddressFromData(byte[] data) {\n+        byte[] rskDestinationAddressBytes = Arrays.copyOfRange(data, 2, 22);\n+        return new RskAddress(rskDestinationAddressBytes);\n+    }\n+\n+    protected abstract void validateDataLength(byte[] data) throws PeginInstructionsParseException;\n+\n+    protected abstract void parseAdditionalData(byte[] data) throws PeginInstructionsParseException;\n+\n+    public static int extractProtocolVersion(byte[] data) throws PeginInstructionsParseException {\n+        if (data == null || data.length < 2) {\n+            String message;\n+\n+            if (data == null) {\n+                message = \"Provided data is null\";\n+            }\n+            else {", "originalCommit": "657ec599cee7850044645b5b44c57c677db7039a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzODYxMA==", "url": "https://github.com/rsksmart/rskj/pull/1304#discussion_r488838610", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Address btcRefundAddress;\n          \n          \n            \n                    Address parsedBtcRefundAddress;\n          \n      \n    \n    \n  \n\nThis will save you a code smell", "author": "marcos-iov", "createdAt": "2020-09-15T17:26:22Z", "path": "rskj-core/src/main/java/co/rsk/peg/pegininstructions/PeginInstructionsVersion1.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package co.rsk.peg.pegininstructions;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import org.ethereum.util.ByteUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class PeginInstructionsVersion1 extends PeginInstructionsBase {\n+    private static final Logger logger = LoggerFactory.getLogger(PeginInstructionsVersion1.class);\n+    private static final int P2PKH_ADDRESS_TYPE = 1;\n+    private static final int P2SH_ADDRESS_TYPE = 2;\n+\n+    private final NetworkParameters params;\n+    private Optional<Address> btcRefundAddress;\n+\n+    public PeginInstructionsVersion1(NetworkParameters params) {\n+        super(1);\n+        this.params = params;\n+    }\n+\n+    @Override\n+    protected void validateDataLength(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length != 22 && data.length != 43) {\n+            String message = String.format(\"[validateDataLength] Invalid data length. Expected 22 or 43 bytes, received %d\", data.length);\n+            logger.debug(message);\n+            throw new PeginInstructionsParseException(message);\n+        }\n+    }\n+\n+    @Override\n+    protected void parseAdditionalData(byte[] data) throws PeginInstructionsParseException {\n+        if (data.length == 22) {\n+            this.btcRefundAddress = Optional.empty();\n+            return;\n+        }\n+\n+        byte[] btcRefundAddressTypeBytes = Arrays.copyOfRange(data, 22, 23);\n+        int btcRefundAddressType = ByteUtil.byteArrayToInt(btcRefundAddressTypeBytes);\n+        byte[] hash = Arrays.copyOfRange(data, 23, data.length);\n+\n+        Address btcRefundAddress;", "originalCommit": "657ec599cee7850044645b5b44c57c677db7039a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0578996bc5b4f7ba89f271425a649e96c9d5b45c", "url": "https://github.com/rsksmart/rskj/commit/0578996bc5b4f7ba89f271425a649e96c9d5b45c", "message": "Remove data length validation from provider\nValidate data on extractProtocolVersion", "committedDate": "2020-09-15T17:49:57Z", "type": "commit"}, {"oid": "0578996bc5b4f7ba89f271425a649e96c9d5b45c", "url": "https://github.com/rsksmart/rskj/commit/0578996bc5b4f7ba89f271425a649e96c9d5b45c", "message": "Remove data length validation from provider\nValidate data on extractProtocolVersion", "committedDate": "2020-09-15T17:49:57Z", "type": "forcePushed"}]}