{"pr_number": 1231, "pr_title": "Refactor registerBtcTransaction", "pr_createdAt": "2020-05-05T20:43:30Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1231", "timeline": [{"oid": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "url": "https://github.com/rsksmart/rskj/commit/22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "message": "Refactor registerBtcTransaction\n\nCreate method validationsForRegisterBtcTransaction\n\nAdd validation methods on BridgeUtils\n\nAdd unit tests on BridgeSupportTest and BridgeUtilTest", "committedDate": "2020-05-05T20:58:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r421633642", "bodyText": "Maybe it would be better to throw a custom exception", "author": "marcos-iov", "createdAt": "2020-05-07T16:25:25Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTAyNQ==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r421649025", "bodyText": "It could be a VerificationException maybe", "author": "guidohernan93", "createdAt": "2020-05-07T16:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438457587", "bodyText": "Yes, we should throw meaningful exceptions. Typed and/or with a message to help the log reader grasp what happened.\nAlthough in this case you could just log and return false. No need to throw an exception I think.", "author": "josedahlquist", "createdAt": "2020-06-10T23:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3OTE3NA==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r441579174", "bodyText": "Throws exception with message now, as it was throwing exception originally. In case we prefer to log and return false, we should remove the try/catch block on the call.", "author": "guidohernan93", "createdAt": "2020-06-17T14:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYzMzY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NjU5OQ==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438456599", "bodyText": "Funny name\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean isAlreadyBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException {\n          \n          \n            \n                public boolean isAlreadyBtcTxHashProcessed(Sha256Hash btcTxHash) throws IOException {", "author": "josedahlquist", "createdAt": "2020-06-10T23:12:28Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java", "diffHunk": "@@ -1219,6 +1157,21 @@ public Long getBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException\n         return provider.getHeightIfBtcTxhashIsAlreadyProcessed(btcTxHash).orElse(-1L);\n     }\n \n+    /**\n+     * Returns if tx was already processed by the bridge\n+     * @param btcTxHash the btc tx hash for which to retrieve the height.\n+     * @return true or false according\n+     * @throws  IOException\n+     * */\n+    public boolean isAlreadyBtcTxHashProcessedHeight(Sha256Hash btcTxHash) throws IOException {", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDAwNQ==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460005", "bodyText": "the argument for the block height doesn't match the height you are setting in the stored block", "author": "josedahlquist", "createdAt": "2020-06-10T23:23:51Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDQ2NQ==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460465", "bodyText": "I'm a bit confused. Regardles of the rskip, we would never accept tx without inputs.", "author": "josedahlquist", "createdAt": "2020-06-10T23:25:21Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDUyMg==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460522", "bodyText": "and please specify the rskip in the test name", "author": "josedahlquist", "createdAt": "2020-06-10T23:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDY1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438460651", "bodyText": "Same comment", "author": "josedahlquist", "createdAt": "2020-06-10T23:25:57Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MTc3MA==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438461770", "bodyText": "A comment here could help understand the test.\nI understand we are creating a tx and a PMT on one hand, and a block which has no relation with said tx and PMT on the other hand; therefore the transaction will be rejected because the merkle block won't match.\nIs that right?", "author": "josedahlquist", "createdAt": "2020-06-10T23:29:53Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(true);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), Hex.decode(\"00000000000100\"));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_invalid_block_merkle_root() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjMyOA==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438462328", "bodyText": "A comment in the test would help reviewers.\nIn this test, the block includes a valid merkleRoot that you calculate from the PMT you craft.\nGood test!", "author": "josedahlquist", "createdAt": "2020-06-10T23:31:39Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java", "diffHunk": "@@ -4147,6 +4143,303 @@ public void hasBtcCoinbaseTransaction_fails_with_null_coinbase_information_after\n         Assert.assertFalse(bridgeSupport.hasBtcBlockCoinbaseTransactionInformation(Sha256Hash.ZERO_HASH));\n     }\n \n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_true() throws IOException {\n+        Repository repository = createRepository();\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+\n+        provider.setHeightBtcTxhashAlreadyProcessed(btcTransaction.getHash(), 1L);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        Assert.assertTrue(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void isAlreadyBtcTxHashProcessedHeight_false() throws IOException {\n+        BtcTransaction btcTransaction = new BtcTransaction(btcParams);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n+        Assert.assertFalse(bridgeSupport.isAlreadyBtcTxHashProcessedHeight(btcTransaction.getHash()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_negative_height() throws BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), -1, data, data));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_insufficient_confirmations() throws IOException, BlockStoreException {\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = new RepositoryBtcBlockStoreWithCache.Factory(bridgeConstants.getBtcParams());\n+        Repository repository = createRepository();\n+        BridgeStorageProvider provider = new BridgeStorageProvider(repository, PrecompiledContracts.BRIDGE_ADDR, bridgeConstants, activationsBeforeForks);\n+        BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, provider, repository, mock(BtcLockSenderProvider.class), mock(Block.class), btcBlockStoreFactory);\n+\n+        byte[] data = Hex.decode(\"ab\");\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), 100, data, data));\n+    }\n+\n+    @Test(expected = BridgeIllegalArgumentException.class)\n+    public void validationsForRegisterBtcTransaction_invalid_pmt() throws IOException, BlockStoreException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        String pmtSerializedEncoded = \"030000000279e7c0da739df8a00f12c0bff55e5438f530aa5859ff9874258cd7bad3fe709746aff89\" +\n+                \"7e6a851faa80120d6ae99db30883699ac0428fc7192d6c3fec0ca64010d\";\n+        byte[] pmtSerialized = Hex.decode(pmtSerializedEncoded);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), btcTxHeight, pmtSerialized, btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_hash_not_in_pmt() throws BlockStoreException, AddressFormatException, IOException {\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(PegTestUtils.createHash(0));\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_before_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(false);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), btcTx.bitcoinSerialize());\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void validationsForRegisterBtcTransaction_tx_without_inputs_after_rskip() throws IOException, BlockStoreException {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP143)).thenReturn(true);\n+\n+        BtcTransaction btcTx = new BtcTransaction(btcParams);\n+        BridgeConstants bridgeConstants = mock(BridgeConstants.class);\n+\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x01;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(btcTx.getHash());\n+\n+        PartialMerkleTree pmt = new PartialMerkleTree(btcParams, bits, hashes, 1);\n+\n+        int btcTxHeight = 2;\n+\n+        doReturn(btcParams).when(bridgeConstants).getBtcParams();\n+        doReturn(0).when(bridgeConstants).getBtc2RskMinimumAcceptableConfirmations();\n+        StoredBlock storedBlock = mock(StoredBlock.class);\n+        doReturn(btcTxHeight - 1).when(storedBlock).getHeight();\n+        BtcBlock btcBlock = mock(BtcBlock.class);\n+        doReturn(Sha256Hash.of(Hex.decode(\"aa\"))).when(btcBlock).getHash();\n+        doReturn(btcBlock).when(storedBlock).getHeader();\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        doReturn(storedBlock).when(btcBlockStore).getChainHead();\n+        BtcBlockStoreWithCache.Factory mockFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+        when(mockFactory.newInstance(any())).thenReturn(btcBlockStore);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+                bridgeConstants,\n+                mock(BridgeStorageProvider.class),\n+                mock(Repository.class),\n+                mock(BridgeEventLogger.class),\n+                null,\n+                mockFactory,\n+                activations\n+        );\n+\n+        bridgeSupport.validationsForRegisterBtcTransaction(btcTx.getHash(), 0, pmt.bitcoinSerialize(), Hex.decode(\"00000000000100\"));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_invalid_block_merkle_root() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =\n+                new co.rsk.bitcoinj.core.BtcBlock(bridgeConstants.getBtcParams(), 1, PegTestUtils.createHash(), Sha256Hash.ZERO_HASH,\n+                        1, 1, 1, new ArrayList<>());\n+\n+        int height = 1;\n+\n+        mockChainOfStoredBlocks(btcBlockStore, btcBlock, height + bridgeConstants.getBtc2RskMinimumAcceptableConfirmations(), height);\n+\n+        BridgeSupport bridgeSupport = new BridgeSupport(\n+                bridgeConstants,\n+                mockBridgeStorageProvider,\n+                mock(BridgeEventLogger.class),\n+                new BtcLockSenderProvider(),\n+                mock(Repository.class),\n+                mock(Block.class),\n+                mock(Context.class),\n+                mock(FederationSupport.class),\n+                btcBlockStoreFactory,\n+                mock(ActivationConfig.ForBlock.class)\n+        );\n+\n+        Assert.assertFalse(bridgeSupport.validationsForRegisterBtcTransaction(tx.getHash(), height, pmt.bitcoinSerialize(), tx.bitcoinSerialize()));\n+    }\n+\n+    @Test\n+    public void validationsForRegisterBtcTransaction_successful() throws IOException, BlockStoreException {\n+        BridgeStorageProvider mockBridgeStorageProvider = mock(BridgeStorageProvider.class);\n+        when(mockBridgeStorageProvider.getHeightIfBtcTxhashIsAlreadyProcessed(any(Sha256Hash.class))).thenReturn(Optional.empty());\n+\n+        when(mockBridgeStorageProvider.getNewFederation()).thenReturn(bridgeConstants.getGenesisFederation());\n+\n+        BtcBlockStoreWithCache.Factory btcBlockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n+\n+        BtcBlockStoreWithCache btcBlockStore = mock(BtcBlockStoreWithCache.class);\n+        when(btcBlockStoreFactory.newInstance(any(Repository.class))).thenReturn(btcBlockStore);\n+\n+        // Create transaction\n+        Coin lockValue = Coin.COIN;\n+        BtcTransaction tx = new BtcTransaction(bridgeConstants.getBtcParams());\n+        tx.addOutput(lockValue, mockBridgeStorageProvider.getNewFederation().getAddress());\n+        BtcECKey srcKey = new BtcECKey();\n+        tx.addInput(PegTestUtils.createHash(1), 0, ScriptBuilder.createInputScript(null, srcKey));\n+\n+        // Create header and PMT\n+        byte[] bits = new byte[1];\n+        bits[0] = 0x3f;\n+        List<Sha256Hash> hashes = new ArrayList<>();\n+        hashes.add(tx.getHash());\n+        PartialMerkleTree pmt = new PartialMerkleTree(bridgeConstants.getBtcParams(), bits, hashes, 1);\n+        Sha256Hash merkleRoot = pmt.getTxnHashAndMerkleRoot(new ArrayList<>());\n+        co.rsk.bitcoinj.core.BtcBlock btcBlock =", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjQzNw==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438462437", "bodyText": "This dependency is truly used?!", "author": "josedahlquist", "createdAt": "2020-06-10T23:32:04Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "diffHunk": "@@ -48,8 +50,10 @@\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n+import sun.nio.ch.Net;", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MzA4NA==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438463084", "bodyText": "Be careful sending a mock in this way, plus expecting Exception. The method could be failing with an NPE if internally depends on any value from the mocked NetworkParameters.", "author": "josedahlquist", "createdAt": "2020-06-10T23:34:16Z", "path": "rskj-core/src/test/java/co/rsk/peg/BridgeUtilsTest.java", "diffHunk": "@@ -511,6 +515,79 @@ public void getCoinFromBigInteger() {\n         Assert.assertEquals(Coin.COIN, BridgeUtils.getCoinFromBigInteger(BigInteger.valueOf(Coin.COIN.getValue())));\n     }\n \n+    @Test(expected = Exception.class)\n+    public void validateHeightAndConfirmations_invalid_height() throws Exception {\n+        BridgeUtils.validateHeightAndConfirmations(-1, 0, 0, null);\n+    }\n+\n+    @Test\n+    public void validateHeightAndConfirmation_insufficient_confirmations() throws Exception {\n+        Assert.assertFalse(BridgeUtils.validateHeightAndConfirmations(2, 5, 10, Sha256Hash.of(Hex.decode(\"ab\"))));\n+    }\n+\n+    @Test\n+    public void validateHeightAndConfirmation_enough_confirmations() throws Exception {\n+        Assert.assertTrue(BridgeUtils.validateHeightAndConfirmations(2, 5, 3, Sha256Hash.of(Hex.decode(\"ab\"))));\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void calculateMerkleRoot_invalid_pmt() {\n+        BridgeUtils.calculateMerkleRoot(mock(NetworkParameters.class), Hex.decode(\"ab\"), null);", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2Mzk0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1231#discussion_r438463942", "bodyText": "You could probably remove hash parameter as it doesn't have an actual usage internally, and instead, logging in the callers directly.", "author": "josedahlquist", "createdAt": "2020-06-10T23:37:26Z", "path": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java", "diffHunk": "@@ -243,4 +241,49 @@ private static boolean isFromFeePerKbChangeAuthorizedSender(org.ethereum.core.Tr\n         AddressBasedAuthorizer authorizer = bridgeConfiguration.getFeePerKbChangeAuthorizer();\n         return authorizer.isAuthorized(rskTx);\n     }\n+\n+    public static boolean validateHeightAndConfirmations(int height, int btcBestChainHeight, int acceptableConfirmationsAmount, Sha256Hash btcTxHash) throws Exception {\n+        // Check there are at least N blocks on top of the supplied height\n+        if (height < 0) {\n+            throw new Exception();\n+        }\n+        int confirmations = btcBestChainHeight - height + 1;\n+        if (confirmations < acceptableConfirmationsAmount) {\n+            logger.warn(\n+                    \"Btc Tx {} at least {} confirmations are required, but there are only {} confirmations\",\n+                    btcTxHash,\n+                    acceptableConfirmationsAmount,\n+                    confirmations\n+            );\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static Sha256Hash calculateMerkleRoot(NetworkParameters networkParameters, byte[] pmtSerialized, Sha256Hash btcTxHash) throws VerificationException{\n+        PartialMerkleTree pmt = new PartialMerkleTree(networkParameters, pmtSerialized, 0);\n+        List<Sha256Hash> hashesInPmt = new ArrayList<>();\n+        Sha256Hash merkleRoot = pmt.getTxnHashAndMerkleRoot(hashesInPmt);\n+        if (!hashesInPmt.contains(btcTxHash)) {\n+            logger.warn(\"Supplied Btc Tx {} is not in the supplied partial merkle tree\", btcTxHash);\n+            return null;\n+        }\n+        return merkleRoot;\n+    }\n+\n+    public static void validateInputsCount(byte[] btcTxSerialized, boolean isActiveRskip, Sha256Hash btcTxHash) throws VerificationException.EmptyInputsOrOutputs {", "originalCommit": "22bb3c6e513ae9c023aedc0abf6f8e97ada51414", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d135916897f1a643497c1a973e02a9092b83cf5f", "url": "https://github.com/rsksmart/rskj/commit/d135916897f1a643497c1a973e02a9092b83cf5f", "message": "Minor fixes on classes and tests", "committedDate": "2020-06-17T14:09:02Z", "type": "forcePushed"}, {"oid": "e0a89c99ca2ef041e13644d2a0e6c59751cbbf75", "url": "https://github.com/rsksmart/rskj/commit/e0a89c99ca2ef041e13644d2a0e6c59751cbbf75", "message": "Refactor registerBtcTransaction\n\nCreate method validationsForRegisterBtcTransaction\n\nAdd validation methods on BridgeUtils\n\nAdd unit tests on BridgeSupportTest and BridgeUtilTest", "committedDate": "2020-06-18T14:25:10Z", "type": "commit"}, {"oid": "914a71985ce093ffc0667b99dd941651eb5790ef", "url": "https://github.com/rsksmart/rskj/commit/914a71985ce093ffc0667b99dd941651eb5790ef", "message": "Minor fixes on classes and tests", "committedDate": "2020-06-18T14:25:10Z", "type": "commit"}, {"oid": "914a71985ce093ffc0667b99dd941651eb5790ef", "url": "https://github.com/rsksmart/rskj/commit/914a71985ce093ffc0667b99dd941651eb5790ef", "message": "Minor fixes on classes and tests", "committedDate": "2020-06-18T14:25:10Z", "type": "forcePushed"}]}