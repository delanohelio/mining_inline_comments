{"pr_number": 1201, "pr_title": "Added verification of node consolidated config property names", "pr_createdAt": "2020-03-30T12:51:24Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1201", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1ODMzOQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400358339", "bodyText": "reference.conf is used by convention :\nhttps://github.com/lightbend/config#standard-behavior", "author": "patogalla", "createdAt": "2020-03-30T17:15:19Z", "path": "rskj-core/src/main/resources/reference.conf", "diffHunk": "@@ -3,6 +3,20 @@ blockchain.config.hardforkActivationHeights.papyrus200 = -1\n ", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0OTA5MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401449090", "bodyText": "Thanks @patogalla", "author": "Vovchyk", "createdAt": "2020-04-01T08:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1ODMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MTQzMQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400361431", "bodyText": "I would suggest doing like : \"Enum.VALUE.equals(value)\",\ngood practice", "author": "patogalla", "createdAt": "2020-03-30T17:19:56Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTA4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059087", "bodyText": "well.. there're pros and cons.. people from sonarsource suggest using == - https://rules.sonarsource.com/java/RSPEC-4551.", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2Mjk2NA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400362964", "bodyText": "Isnt a way to compare types before going to the switch, it seems redundant to me, asking in each switch statement for the equal type. Whats the logic there?", "author": "patogalla", "createdAt": "2020-03-30T17:22:27Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODg0Ng==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401448846", "bodyText": "I've updated the code a bit.", "author": "Vovchyk", "createdAt": "2020-04-01T08:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2Mjk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTAzNQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400369035", "bodyText": "\"(key.isEmpty() ? \"\" : key + \".\")\" logic should be outside \"for\", no need to ask in each iteration.", "author": "patogalla", "createdAt": "2020-03-30T17:31:44Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n+                    throw typeMismatchException(key, expectedValue, actualValue);\n+                }\n+                for (Map.Entry<String, ConfigValue> actualEntry : ((ConfigObject) actualValue).entrySet()) {\n+                    ConfigValue expectedEntryValue = ((ConfigObject) expectedValue).get(actualEntry.getKey());\n+                    verify((key.isEmpty() ? \"\" : key + \".\") + actualEntry.getKey(), expectedEntryValue, actualEntry.getValue());", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTE1NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059155", "bodyText": "done", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDMyNw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r400370327", "bodyText": "instead of throwing, it would be nice to collect them, and throw/log them all at once.", "author": "patogalla", "createdAt": "2020-03-30T17:33:37Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +150,52 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String key, @Nullable ConfigValue expectedValue, ConfigValue actualValue) {\n+        if (expectedValue == null) {\n+            throw unexpectedKeyException(key, actualValue);\n+        }\n+\n+        switch (actualValue.valueType()) {\n+            case OBJECT:\n+                if (!expectedValue.valueType().equals(ConfigValueType.OBJECT)) {\n+                    throw typeMismatchException(key, expectedValue, actualValue);", "originalCommit": "537c435f42504606be9060cc8309bdde0a349596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTI1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406059251", "bodyText": "done", "author": "Vovchyk", "createdAt": "2020-04-09T08:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDMyNw=="}], "type": "inlineReview"}, {"oid": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "url": "https://github.com/rsksmart/rskj/commit/6a1da5be6f455f3323d6b829cb3764a504f48cd2", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-01T08:35:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTEyMA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401451120", "bodyText": "Config without systemPropsConfig and systemEnvConfig which are out of our interest", "author": "Vovchyk", "createdAt": "2020-04-01T08:44:46Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -56,13 +59,38 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n     }\n \n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {\n+            Config expectedConfig = ConfigFactory.load(EXPECTED_RESOURCE_PATH);\n+            Config actualConfig = ConfigFactory.empty()", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMzQ3OA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401623478", "bodyText": "can you add this as a comment on the code directly?", "author": "nicops", "createdAt": "2020-04-01T13:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MjI0OA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401452248", "bodyText": "The idea is that the expected.conf file should contain all possible config settings which are expected by the node", "author": "Vovchyk", "createdAt": "2020-04-01T08:46:40Z", "path": "rskj-core/src/main/resources/expected.conf", "diffHunk": "@@ -0,0 +1,458 @@\n+# disable wasabi+1 consensus rules by default for every network", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNTcwNQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401625705", "bodyText": "same as before, can you add this as a header comment on the expected.conf file, to explain what the file is about?", "author": "nicops", "createdAt": "2020-04-01T13:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MjI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjYyNg==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401626626", "bodyText": "maybe we can flesh out these entries so it gets validated?", "author": "nicops", "createdAt": "2020-04-01T13:45:13Z", "path": "rskj-core/src/main/resources/expected.conf", "diffHunk": "@@ -0,0 +1,458 @@\n+# disable wasabi+1 consensus rules by default for every network\n+blockchain.config.hardforkActivationHeights.papyrus200 = -1\n+\n+blockchain = {\n+    config = {\n+        name = main\n+\n+        # Flag that forces to verify whether a node is started with unknown configuration property names.\n+        # Whole list of possible property names is defined in the reference.conf file.\n+        verify = false\n+\n+        hardforkActivationHeights = {\n+            bahamas = 3397,\n+            afterBridgeSync = 370000,\n+            orchid = 729000,\n+            orchid060 = 1052700,\n+            wasabi100 = 1591000,\n+            twoToThree = 2018000\n+        }\n+        consensusRules = {\n+            areBridgeTxsPaid = afterBridgeSync,\n+            rskip85 = orchid,\n+            rskip87 = orchid,\n+            rskip88 = orchid,\n+            rskip89 = orchid,\n+            rskip90 = orchid,\n+            rskip91 = orchid,\n+            rskip92 = orchid,\n+            rskip97 = orchid,\n+            rskip98 = orchid,\n+            rskip103 = orchid060,\n+            rskip106 = wasabi100,\n+            rskip110 = wasabi100,\n+            rskip119 = wasabi100,\n+            rskip120 = wasabi100,\n+            rskip122 = wasabi100,\n+            rskip123 = wasabi100,\n+            rskip124 = wasabi100,\n+            rskip125 = wasabi100,\n+            rskip126 = wasabi100,\n+            rskip132 = wasabi100,\n+            rskip134 = papyrus200,\n+            rskip136 = bahamas,\n+            rskip137 = papyrus200,\n+            rskip140 = papyrus200,\n+            rskip143 = papyrus200,\n+            rskip146 = papyrus200,\n+            rskip150 = twoToThree,\n+            rskip151 = papyrus200,\n+            rskip152 = papyrus200\n+            rskip156 = papyrus200\n+            rskipUMM = papyrus200\n+        }\n+    }\n+    gc = {\n+        enabled = false\n+        epochs = 3\n+        blocksPerEpoch = 20000\n+    }\n+}\n+\n+peer {\n+    # Boot node list\n+    # Use to connect to specific nodes\n+    active = [ ]\n+\n+    # list of trusted peers the incoming connections is always accepted from. Even if the max amount of connections is reached\n+    # This is used to create a filter of Trusted peers\n+    trusted = [\n+        # Sample entries:", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401626980", "bodyText": "This is the original case? When a misspelled property will be warned... am i right?", "author": "patogalla", "createdAt": "2020-04-01T13:45:39Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -128,4 +156,66 @@ private Config getNetworkDefaultConfig(Config userConfig) {\n         logger.info(\"Network not set, using mainnet by default\");\n         return ConfigFactory.load(MAINNET_RESOURCE_PATH);\n     }\n+\n+    private static void verify(String keyPath, @Nullable ConfigValue expectedValue, ConfigValue actualValue, List<String> problems) {\n+        Objects.requireNonNull(keyPath);\n+        Objects.requireNonNull(actualValue);\n+        ConfigValueType actualValueType = Objects.requireNonNull(actualValue.valueType());\n+\n+        if (expectedValue == null) {", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NjU1MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405486550", "bodyText": "This seems to be my original case presented in #1192. Maybe a comment explaining how we got here can help.", "author": "lucasvuotto", "createdAt": "2020-04-08T12:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjkzMA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405522930", "bodyText": "agree, I would add a comment here.", "author": "nicops", "createdAt": "2020-04-08T13:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzE5NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406053195", "bodyText": "Yes, the verify method is recursive one and expectedValue could be null during recursive iterations when an appropriate matching key path is to found.", "author": "Vovchyk", "createdAt": "2020-04-09T08:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNjk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNzc3Ng==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401637776", "bodyText": "for clarity I would replace this with dummy data", "author": "nicops", "createdAt": "2020-04-01T13:59:52Z", "path": "rskj-core/src/main/resources/expected.conf", "diffHunk": "@@ -0,0 +1,458 @@\n+# disable wasabi+1 consensus rules by default for every network\n+blockchain.config.hardforkActivationHeights.papyrus200 = -1\n+\n+blockchain = {\n+    config = {\n+        name = main\n+\n+        # Flag that forces to verify whether a node is started with unknown configuration property names.\n+        # Whole list of possible property names is defined in the reference.conf file.\n+        verify = false\n+\n+        hardforkActivationHeights = {\n+            bahamas = 3397,\n+            afterBridgeSync = 370000,\n+            orchid = 729000,\n+            orchid060 = 1052700,\n+            wasabi100 = 1591000,\n+            twoToThree = 2018000\n+        }\n+        consensusRules = {\n+            areBridgeTxsPaid = afterBridgeSync,\n+            rskip85 = orchid,\n+            rskip87 = orchid,\n+            rskip88 = orchid,\n+            rskip89 = orchid,\n+            rskip90 = orchid,\n+            rskip91 = orchid,\n+            rskip92 = orchid,\n+            rskip97 = orchid,\n+            rskip98 = orchid,\n+            rskip103 = orchid060,\n+            rskip106 = wasabi100,\n+            rskip110 = wasabi100,\n+            rskip119 = wasabi100,\n+            rskip120 = wasabi100,\n+            rskip122 = wasabi100,\n+            rskip123 = wasabi100,\n+            rskip124 = wasabi100,\n+            rskip125 = wasabi100,\n+            rskip126 = wasabi100,\n+            rskip132 = wasabi100,\n+            rskip134 = papyrus200,\n+            rskip136 = bahamas,\n+            rskip137 = papyrus200,\n+            rskip140 = papyrus200,\n+            rskip143 = papyrus200,\n+            rskip146 = papyrus200,\n+            rskip150 = twoToThree,\n+            rskip151 = papyrus200,\n+            rskip152 = papyrus200\n+            rskip156 = papyrus200\n+            rskipUMM = papyrus200\n+        }\n+    }\n+    gc = {\n+        enabled = false\n+        epochs = 3\n+        blocksPerEpoch = 20000\n+    }\n+}\n+\n+peer {\n+    # Boot node list\n+    # Use to connect to specific nodes\n+    active = [ ]\n+\n+    # list of trusted peers the incoming connections is always accepted from. Even if the max amount of connections is reached\n+    # This is used to create a filter of Trusted peers\n+    trusted = [\n+        # Sample entries:\n+        # {nodeId = \"e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c\"},\n+        # {ip = \"11.22.33.44\"},\n+        # {ip = \"11.22.33.*\"},\n+        # {\n+        #   nodeId = \"e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c\"\n+        #   ip = \"11.22.33.44\"\n+        # }\n+    ]\n+\n+    # connection timeout for trying to connect to a peer [seconds]\n+    connection.timeout = 2\n+\n+    # the parameter specifies how much time we will wait for a message to come before closing the channel\n+    channel.read.timeout = 300\n+\n+    # Private key of the peer\n+    # nodeId = <NODE_ID>\n+    # privateKey = <PRIVATE_KEY>\n+\n+    p2p {\n+        # max frame size in bytes when framing is enabled\n+        framing.maxSize = 32768\n+\n+        # forces peer to send Handshake message in format defined by EIP-8,\n+        # see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md\n+        eip8 = true\n+\n+        # the time in seconds to ping other peers on the network\n+        pingInterval = 5\n+    }\n+\n+    # max number of active peers our node will maintain\n+    # extra peers trying to connect us will be dropped with TOO_MANY_PEERS message\n+    # the incoming connection from the peer matching 'peer.trusted' entry is always accepted\n+    maxActivePeers = 30\n+\n+    # address blocks are defined to allow or restrict access from ip ranges\n+    filter {\n+        # max number of connections allowed on a single address block\n+        maxConnections = 16\n+        # the cidr bits used to define a subnet in IPV4 - i.e. 32 bits is a full address\n+        networkCidr = 24\n+    }\n+\n+    discovery = {\n+        # if peer discovery is off\n+        # the peer window will show\n+        # only what retrieved by active\n+        # peer [true/false]\n+        enabled = true\n+\n+        # List of the peers to start\n+        # the search of the online peers\n+        # values: [ip:port]\n+        ip.list = [\n+            \"bootstrap01.rsk.co:5050\",", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzODA2NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401638065", "bodyText": "same here, and everything else related to mainnet, I would put dummy data.", "author": "nicops", "createdAt": "2020-04-01T14:00:16Z", "path": "rskj-core/src/main/resources/expected.conf", "diffHunk": "@@ -0,0 +1,458 @@\n+# disable wasabi+1 consensus rules by default for every network\n+blockchain.config.hardforkActivationHeights.papyrus200 = -1\n+\n+blockchain = {\n+    config = {\n+        name = main\n+\n+        # Flag that forces to verify whether a node is started with unknown configuration property names.\n+        # Whole list of possible property names is defined in the reference.conf file.\n+        verify = false\n+\n+        hardforkActivationHeights = {\n+            bahamas = 3397,\n+            afterBridgeSync = 370000,\n+            orchid = 729000,\n+            orchid060 = 1052700,\n+            wasabi100 = 1591000,\n+            twoToThree = 2018000\n+        }\n+        consensusRules = {\n+            areBridgeTxsPaid = afterBridgeSync,\n+            rskip85 = orchid,\n+            rskip87 = orchid,\n+            rskip88 = orchid,\n+            rskip89 = orchid,\n+            rskip90 = orchid,\n+            rskip91 = orchid,\n+            rskip92 = orchid,\n+            rskip97 = orchid,\n+            rskip98 = orchid,\n+            rskip103 = orchid060,\n+            rskip106 = wasabi100,\n+            rskip110 = wasabi100,\n+            rskip119 = wasabi100,\n+            rskip120 = wasabi100,\n+            rskip122 = wasabi100,\n+            rskip123 = wasabi100,\n+            rskip124 = wasabi100,\n+            rskip125 = wasabi100,\n+            rskip126 = wasabi100,\n+            rskip132 = wasabi100,\n+            rskip134 = papyrus200,\n+            rskip136 = bahamas,\n+            rskip137 = papyrus200,\n+            rskip140 = papyrus200,\n+            rskip143 = papyrus200,\n+            rskip146 = papyrus200,\n+            rskip150 = twoToThree,\n+            rskip151 = papyrus200,\n+            rskip152 = papyrus200\n+            rskip156 = papyrus200\n+            rskipUMM = papyrus200\n+        }\n+    }\n+    gc = {\n+        enabled = false\n+        epochs = 3\n+        blocksPerEpoch = 20000\n+    }\n+}\n+\n+peer {\n+    # Boot node list\n+    # Use to connect to specific nodes\n+    active = [ ]\n+\n+    # list of trusted peers the incoming connections is always accepted from. Even if the max amount of connections is reached\n+    # This is used to create a filter of Trusted peers\n+    trusted = [\n+        # Sample entries:\n+        # {nodeId = \"e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c\"},\n+        # {ip = \"11.22.33.44\"},\n+        # {ip = \"11.22.33.*\"},\n+        # {\n+        #   nodeId = \"e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c\"\n+        #   ip = \"11.22.33.44\"\n+        # }\n+    ]\n+\n+    # connection timeout for trying to connect to a peer [seconds]\n+    connection.timeout = 2\n+\n+    # the parameter specifies how much time we will wait for a message to come before closing the channel\n+    channel.read.timeout = 300\n+\n+    # Private key of the peer\n+    # nodeId = <NODE_ID>\n+    # privateKey = <PRIVATE_KEY>\n+\n+    p2p {\n+        # max frame size in bytes when framing is enabled\n+        framing.maxSize = 32768\n+\n+        # forces peer to send Handshake message in format defined by EIP-8,\n+        # see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md\n+        eip8 = true\n+\n+        # the time in seconds to ping other peers on the network\n+        pingInterval = 5\n+    }\n+\n+    # max number of active peers our node will maintain\n+    # extra peers trying to connect us will be dropped with TOO_MANY_PEERS message\n+    # the incoming connection from the peer matching 'peer.trusted' entry is always accepted\n+    maxActivePeers = 30\n+\n+    # address blocks are defined to allow or restrict access from ip ranges\n+    filter {\n+        # max number of connections allowed on a single address block\n+        maxConnections = 16\n+        # the cidr bits used to define a subnet in IPV4 - i.e. 32 bits is a full address\n+        networkCidr = 24\n+    }\n+\n+    discovery = {\n+        # if peer discovery is off\n+        # the peer window will show\n+        # only what retrieved by active\n+        # peer [true/false]\n+        enabled = true\n+\n+        # List of the peers to start\n+        # the search of the online peers\n+        # values: [ip:port]\n+        ip.list = [\n+            \"bootstrap01.rsk.co:5050\",\n+            \"bootstrap02.rsk.co:5050\",\n+            \"bootstrap03.rsk.co:5050\",\n+            \"bootstrap04.rsk.co:5050\",\n+            \"bootstrap05.rsk.co:5050\",\n+            \"bootstrap06.rsk.co:5050\",\n+            \"bootstrap07.rsk.co:5050\",\n+            \"bootstrap08.rsk.co:5050\",\n+            \"bootstrap09.rsk.co:5050\",\n+            \"bootstrap10.rsk.co:5050\",\n+            \"bootstrap11.rsk.co:5050\",\n+            \"bootstrap12.rsk.co:5050\",\n+            \"bootstrap13.rsk.co:5050\",\n+            \"bootstrap14.rsk.co:5050\",\n+            \"bootstrap15.rsk.co:5050\",\n+            \"bootstrap16.rsk.co:5050\"\n+        ]\n+    }\n+\n+    # Port for server to listen for incoming connections\n+    port = 5050\n+\n+    # Network id\n+    networkId = 775\n+}\n+\n+# the folder resources/genesis contains several versions of genesis configuration according to the network the peer will run on\n+genesis = rsk-mainnet.json", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzOTg0MA==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r401639840", "bodyText": "replace reference.conf in comment with expected.conf", "author": "nicops", "createdAt": "2020-04-01T14:02:44Z", "path": "rskj-core/src/main/resources/reference.conf", "diffHunk": "@@ -3,6 +3,10 @@ blockchain.config.hardforkActivationHeights.papyrus200 = -1\n \n blockchain = {\n     config = {\n+        # Flag that forces to verify whether a node is started with unknown configuration property names.\n+        # Whole list of possible property names is defined in the reference.conf file.", "originalCommit": "6a1da5be6f455f3323d6b829cb3764a504f48cd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a3429f938f36f89216300c8563644aa9dacb412e", "url": "https://github.com/rsksmart/rskj/commit/a3429f938f36f89216300c8563644aa9dacb412e", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-06T08:21:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405484475", "bodyText": "I can see this getting overly verbose and quite difficult to read and search for problems, should multiple configuration problems be present. I suggest making verify return a boolean instead, signaling if the verification was successful, and logging each of the misconfigurations instead of pushing them into problems.", "author": "lucasvuotto", "createdAt": "2020-04-08T12:26:03Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -55,14 +51,59 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n         this.cliArgs = Objects.requireNonNull(cliArgs);\n     }\n \n+    /**\n+     * Loads configurations from different sources with the following precedence:\n+     * 1. Command line arguments\n+     * 2. Environment variables\n+     * 3. System properties\n+     * 4. User configuration file\n+     * 5. Installer configuration file\n+     * 6. Default settings per network in resources/[network].conf\n+     * 7. Default settings for all networks in resources/reference.conf\n+     *\n+     * <p>\n+     * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n+     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     *\n+     * Note:\n+     *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n+     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n+     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *\n+     * @throws RskConfigurationException on configuration errors\n+     *\n+     * @see ConfigProblems\n+     */\n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {\n+            Config expectedConfig = ConfigFactory.parseResourcesAnySyntax(EXPECTED_RESOURCE_PATH)\n+                    .withFallback(systemPropsConfig)\n+                    .withFallback(systemEnvConfig);\n+\n+            ArrayList<String> problems = new ArrayList<>();\n+            verify(\"\", expectedConfig.root(), unifiedConfig.root(), problems);\n+            if (!problems.isEmpty()) {\n+                throw new RskConfigurationException(\"Verification of node configs has failed. The following problems were found: \"\n+                        + String.join(\"; \", problems));", "originalCommit": "a3429f938f36f89216300c8563644aa9dacb412e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNTI5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405605293", "bodyText": "I agree and disagree.\nAgree: I would iterate over problems and log each of them as a separate line.\nDisagree: I think the method works fine as it is, right now we don't unit test it directly, but it could be directly unit tested, and it's a richer interface to have it return a problems array instead of a boolean. What I would add is an overload:\n private static List<String> verify(ConfigValue expectedRoot, ConfigValue actualRoot) {\n    ArrayList<String> problems = new ArrayList<>();\n    verify(\"\", expectedConfig.root(), unifiedConfig.root(), problems);\n    return problems;\n}\n\nIMHO it's nice to add an overload in such cases to make the calling code more oblivious to the internal details of the recursive method.", "author": "nicops", "createdAt": "2020-04-08T15:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MDg3Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406050873", "bodyText": "I just don't want to overarchitect this solution. Good point about doing verification all the time and only throwing an exception if the flag is present.", "author": "Vovchyk", "createdAt": "2020-04-09T08:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405485123", "bodyText": "Can't we run the config verification always and just abort execution only when this flag is set?", "author": "lucasvuotto", "createdAt": "2020-04-08T12:27:11Z", "path": "rskj-core/src/main/java/co/rsk/config/ConfigLoader.java", "diffHunk": "@@ -55,14 +51,59 @@ public ConfigLoader(CliArgs<NodeCliOptions, NodeCliFlags> cliArgs) {\n         this.cliArgs = Objects.requireNonNull(cliArgs);\n     }\n \n+    /**\n+     * Loads configurations from different sources with the following precedence:\n+     * 1. Command line arguments\n+     * 2. Environment variables\n+     * 3. System properties\n+     * 4. User configuration file\n+     * 5. Installer configuration file\n+     * 6. Default settings per network in resources/[network].conf\n+     * 7. Default settings for all networks in resources/reference.conf\n+     *\n+     * <p>\n+     * If the <b><blockchain.config.verify/b> setting is {@code true} (either set in a .conf file or via <b>--verify-config</b> command line flag),\n+     * then the loaded config wll be tested against the setting names defined in the expected.conf config file.\n+     *\n+     * Note:\n+     *  1. The <b><blockchain.config.verify/b> setting is {@code false} by default.\n+     *  2. Config verification process of matching actual and expected configs is recursive and takes into account appropriate setting names\n+     *      and values which are collections of other settings (LIST's and OBJECT's).\n+     *\n+     * @throws RskConfigurationException on configuration errors\n+     *\n+     * @see ConfigProblems\n+     */\n     public Config getConfig() {\n-        Config userConfig = getConfigFromCliArgs()\n-                .withFallback(ConfigFactory.systemProperties())\n-                .withFallback(ConfigFactory.systemEnvironment())\n-                .withFallback(getUserCustomConfig())\n-                .withFallback(getInstallerConfig());\n+        Config cliConfig = getConfigFromCliArgs();\n+        Config systemPropsConfig = ConfigFactory.systemProperties();\n+        Config systemEnvConfig = ConfigFactory.systemEnvironment();\n+        Config userCustomConfig = getUserCustomConfig();\n+        Config installerConfig = getInstallerConfig();\n+\n+        Config userConfig = ConfigFactory.empty()\n+                .withFallback(cliConfig)\n+                .withFallback(systemPropsConfig)\n+                .withFallback(systemEnvConfig)\n+                .withFallback(userCustomConfig)\n+                .withFallback(installerConfig);\n         Config networkBaseConfig = getNetworkDefaultConfig(userConfig);\n-        return userConfig.withFallback(networkBaseConfig);\n+        Config unifiedConfig = userConfig.withFallback(networkBaseConfig);\n+\n+        if (unifiedConfig.getBoolean(SystemProperties.PROPERTY_BC_VERIFY)) {", "originalCommit": "a3429f938f36f89216300c8563644aa9dacb412e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjE4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405522183", "bodyText": "that would be interesting. In which case we catch the exception and only log it?", "author": "nicops", "createdAt": "2020-04-08T13:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyOTY1Ng==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405529656", "bodyText": "About what exception are we talking? I only see verify throwing an exception if there is a malformed entry in expected.conf.", "author": "lucasvuotto", "createdAt": "2020-04-08T13:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMDAwNg==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405600006", "bodyText": "sorry, I did not read the code carefully between all the changes. Right now this method throws the exception, it could skip throwing the exception if the flag is not set.", "author": "nicops", "createdAt": "2020-04-08T15:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDQ0NQ==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r405494445", "bodyText": "You're missing a key in here:\n            methods = {\n                enabled = []\n                disabled = []\n            }\n\n(cf \n  \n    \n      rskj/rskj-core/src/main/java/co/rsk/config/RskSystemProperties.java\n    \n    \n         Line 238\n      in\n      1e842d8\n    \n    \n    \n    \n\n        \n          \n           if (configElement.hasPath(\"methods.enabled\")) { \n        \n    \n  \n\n)", "author": "lucasvuotto", "createdAt": "2020-04-08T12:43:20Z", "path": "rskj-core/src/main/resources/expected.conf", "diffHunk": "@@ -0,0 +1,160 @@\n+blockchain = {\n+    config = {\n+        name = <name>\n+        verify = <verify>\n+        hardforkActivationHeights = { }\n+        consensusRules = { }\n+    }\n+    gc = {\n+        enabled = <enabled>\n+        epochs = <epochs>\n+        blocksPerEpoch = <blocksPerEpoch>\n+    }\n+}\n+peer = {\n+    active = [ ]\n+    trusted = [ ]\n+    connection.timeout = <timeout>\n+    channel.read.timeout = <timeout>\n+    p2p = {\n+        framing.maxSize = <maxSize>\n+        eip8 = <eip8>\n+        pingInterval = <pingInterval>\n+    }\n+    maxActivePeers = <maxActivePeers>\n+    filter = {\n+        maxConnections = <maxConnections>\n+        networkCidr = <networkCidr>\n+    }\n+    discovery = {\n+        enabled = <enabled>\n+        ip.list = [<ip>]\n+    }\n+    port = <port>\n+    networkId = <networkId>\n+}\n+genesis = <genesis>\n+database = {\n+    dir = <dir>\n+    import = {\n+        url = <url>\n+        trusted-keys = [<trusted-key>]\n+    }\n+}\n+hello.phrase = <phrase>\n+wallet = {\n+    enabled = <enabled>\n+    accounts = [<accounts>]\n+}\n+miner = {\n+    minGasPrice = <minGasPrice>\n+    server = {\n+        enabled = <enabled>\n+        isFixedClock = <isFixedClock>\n+    }\n+    client = {\n+        enabled = <enabled>\n+        autoMine = <autoMine>\n+        delayBetweenBlocks = <delayBetweenBlocks>\n+        delayBetweenRefreshes = <delayBetweenRefreshes>\n+    }\n+    coinbase.secret = <secret>\n+}\n+database = {\n+    reset = <reset>\n+    import = {\n+        enabled = <enabled>\n+        trusted-keys = [<trusted-key>]\n+    }\n+}\n+bind_address = <bind_address>\n+public = {\n+    ipCheckService = <ipCheckService>\n+}\n+transaction = {\n+    outdated = {\n+        threshold = <threshold>\n+        timeout = <timeout>\n+    }\n+    gasPriceBump = <gasPriceBump>\n+}\n+dump = {\n+    full = <full>\n+    dir = <dir>\n+    block = <block>\n+    style = <style>\n+    clean.on.restart = <restart>\n+}\n+vm = {\n+    executionStackSize = <executionStackSize>\n+    structured = {\n+        trace = <trace>\n+        traceOptions = <traceOptions>\n+        dir = <dir>\n+        compressed = <compressed>\n+        initStorageLimit = <initStorageLimit>\n+    }\n+}\n+play.vm = <vm>\n+keyvalue.datasource = <datasource>\n+sync = {\n+    enabled = <enabled>\n+    max.hashes.ask = <ask>\n+    peer.count = <count>\n+    expectedPeers = <expectedPeers>\n+    timeoutWaitingPeers = <timeoutWaitingPeers>\n+    timeoutWaitingRequest = <timeoutWaitingRequest>\n+    expirationTimePeerStatus = <expirationTimePeerStatus>\n+    maxSkeletonChunks = <maxSkeletonChunks>\n+    maxRequestedBodies = <maxRequestedBodies>\n+    longSyncLimit = <longSyncLimit>\n+    chunkSize = <chunkSize>\n+}\n+rpc = {\n+    providers = {\n+        web = {\n+            cors = <cors>\n+            http = {\n+                enabled = <enabled>\n+                bind_address = <bind_address>\n+                hosts = []\n+                port = <port>\n+                linger_time = <linger_time>\n+            }\n+            ws = {\n+                enabled = <enabled>\n+                bind_address = <bind_address>\n+                port = <port>\n+            }\n+        }\n+    }\n+    modules = [\n+        {\n+            name = <name>\n+            version = <version>\n+            enabled = <enabled>", "originalCommit": "a3429f938f36f89216300c8563644aa9dacb412e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzU3Mw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r406053573", "bodyText": "thanks", "author": "Vovchyk", "createdAt": "2020-04-09T08:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDQ0NQ=="}], "type": "inlineReview"}, {"oid": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "url": "https://github.com/rsksmart/rskj/commit/0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-11T12:53:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU0NzcwMw==", "url": "https://github.com/rsksmart/rskj/pull/1201#discussion_r407547703", "bodyText": "with the latest change, this test and the one above it is not making any assertion", "author": "nicops", "createdAt": "2020-04-13T15:45:47Z", "path": "rskj-core/src/test/java/co/rsk/config/ConfigLoaderTest.java", "diffHunk": "@@ -181,13 +168,7 @@ public void detectExpectedScalarValueProblemInList() {\n \n         mockConfigFactory(defaultConfig, expectedConfig);\n \n-        try {\n-            loader.getConfig();\n-        } catch (RskConfigurationException e) {\n-            assertThat(e.getMessage(), containsString(ConfigProblems.expectedScalarValueProblem(\"expectedKey[0]\", EMPTY_LIST_VALUE)));\n-\n-            throw e;\n-        }\n+        loader.getConfig();", "originalCommit": "0b0e4a2cd7a608df26a52f6dacb745d816fd0b78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63a829a8d92f966575d8c81475ff4cb04efc2dfd", "url": "https://github.com/rsksmart/rskj/commit/63a829a8d92f966575d8c81475ff4cb04efc2dfd", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-25T09:32:47Z", "type": "forcePushed"}, {"oid": "653879c305926c0596a0511ad2421bdaaad3bba7", "url": "https://github.com/rsksmart/rskj/commit/653879c305926c0596a0511ad2421bdaaad3bba7", "message": "Added verification of node consolidated config property names", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "c973bf23ce80e83208d5c3e192920c261bce526d", "url": "https://github.com/rsksmart/rskj/commit/c973bf23ce80e83208d5c3e192920c261bce526d", "message": "Added extra keys to expected.conf", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "url": "https://github.com/rsksmart/rskj/commit/1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-28T13:48:14Z", "type": "commit"}, {"oid": "1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "url": "https://github.com/rsksmart/rskj/commit/1fd9fabd0de5a5d0557e5d1fb24cdad29f30513a", "message": "Check config settings all the time. Throw an exception if the flag is set", "committedDate": "2020-04-28T13:48:14Z", "type": "forcePushed"}]}