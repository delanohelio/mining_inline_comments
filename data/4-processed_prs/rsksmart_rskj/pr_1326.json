{"pr_number": 1326, "pr_title": "Implemented block propagation enhancements", "pr_createdAt": "2020-10-05T16:21:34Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1326", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxODcwNQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r501718705", "bodyText": "AFAIK, this method is only used for testing. Maybe we could move this implementation to test packages", "author": "ajlopezrsk", "createdAt": "2020-10-08T13:26:12Z", "path": "rskj-core/src/test/java/co/rsk/net/utils/AsyncNodeBlockProcessorListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package co.rsk.net.utils;\n+\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.AsyncNodeBlockProcessor;\n+import co.rsk.net.BlockProcessResult;\n+import co.rsk.net.Peer;\n+import org.ethereum.core.Block;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * Utility class that allows to wait for some particular block to be processed.\n+ */\n+public class AsyncNodeBlockProcessorListener implements AsyncNodeBlockProcessor.Listener {\n+\n+    private final BlockingQueue<Block> processedBlocks = new LinkedBlockingQueue<>();\n+\n+    @Override\n+    public void onBlockProcessed(@Nonnull AsyncNodeBlockProcessor blockProcessor,\n+                                 @Nullable Peer sender, @Nonnull Block block,\n+                                 @Nonnull BlockProcessResult blockProcessResult) {\n+        processedBlocks.add(block);\n+    }\n+\n+    public void waitForBlock(@Nonnull Keccak256 hash) throws InterruptedException {", "originalCommit": "786ddc7e597a6a7e02bdc857d24e855b5e17f314", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMyNTQ0Nw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r505325447", "bodyText": "this AsyncNodeBlockProcessorListener class is already part of the test package. This is an utility class for testing purposes.", "author": "Vovchyk", "createdAt": "2020-10-15T08:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDI4Nw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r501720287", "bodyText": "Processing the block, connecting to a chain, OK. Any second relay of this block? AFAIR geth implementation sends a second relay after the full process of the block", "author": "ajlopezrsk", "createdAt": "2020-10-08T13:28:25Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.net.sync.SyncConfiguration;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        // TODO: add block validation\n+\n+        BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false, false);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            blocksToProcess.offer(new PeerBlockPair(sender, block));\n+        }\n+\n+        return blockProcessResult;\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stop(0L);\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stop(long waitMillis) {\n+        stopped = true;\n+\n+        try {\n+            thread.interrupt();\n+            if (waitMillis > 0L) {\n+                thread.join(waitMillis);\n+            }\n+        } catch (InterruptedException e) {\n+            logger.error(\"Failed to join the thread\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Get peer/block pair\");\n+\n+                PeerBlockPair pair = blocksToProcess.take();\n+\n+                sender = pair.peer;\n+                block = pair.block;\n+\n+                logger.trace(\"Start block processing\");\n+                BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false, true);", "originalCommit": "786ddc7e597a6a7e02bdc857d24e855b5e17f314", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMyNjE5MA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r505326190", "bodyText": "yes, as agreed this could be part of the next phase.", "author": "Vovchyk", "createdAt": "2020-10-15T08:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDI4Nw=="}], "type": "inlineReview"}, {"oid": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "url": "https://github.com/rsksmart/rskj/commit/b7e58e7f26656e906d64078c59fba3d778cb75c2", "message": "Added block validation logic", "committedDate": "2020-10-15T07:53:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MTYzOA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509541638", "bodyText": "Why not to check if the block is ALREADY in the \"net store\"? Maybe it could avoid the process of duplicated blocks that arrives from different peers to this node, but are not yet added to any chain because they are still in the to process queue", "author": "ajlopezrsk", "createdAt": "2020-10-21T18:14:05Z", "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -69,21 +70,19 @@ public BlockSyncService(\n         this.config = config;\n     }\n \n-    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n-        Instant start = Instant.now();\n-        long bestBlockNumber = this.getBestBlockNumber();\n-        long blockNumber = block.getNumber();\n+    protected boolean preprocessBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4MDQwOQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510380409", "bodyText": "I'm also worried about this.\nReceiving the same block multiple times doesn't seem correctly handled.", "author": "donequis", "createdAt": "2020-10-22T18:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0ODg5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511948896", "bodyText": "Done", "author": "Vovchyk", "createdAt": "2020-10-26T13:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzMxNw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509697317", "bodyText": "Can we add here a summary of the Validator classes applied in this validator?", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:07:17Z", "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockRelayValidatorImpl.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.core.bc;\n+\n+import co.rsk.validators.*;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.ethereum.db.BlockStore;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Validates a block if it is good enough to be propagated.\n+ */", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0OTAyNA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511949024", "bodyText": "Done", "author": "Vovchyk", "createdAt": "2020-10-26T13:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5OTU5Mw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509699593", "bodyText": "listener is only for testing?\nif thats the case, I would spec a diff constructor adding the listener, and a comment that its only for testing.\nthis allow us to avoid a \"null\" in RskContext construction and a clear knowledge that its not used in real scenario.", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:10:04Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MDE0Mw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511950143", "bodyText": "Done. Basically that listener is just an interface, so potentially can be used anywhere", "author": "Vovchyk", "createdAt": "2020-10-26T13:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5OTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509729328", "bodyText": "Shouldn't we validate header and block, before preprocessing?\nThis is a more open/complex question.\nThe issue that i see, is that if block header (e.g.) is invalid, we'll be trying to get parents when not necessary.", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:48:42Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MzMyMA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511953320", "bodyText": "preprocessing basically does simple checks before block processing like distance to the best block. More importantly it checks if a parent block has already been gotten. Without parent we cannot validate block or start its processing.", "author": "Vovchyk", "createdAt": "2020-10-26T13:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjA3MQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r512172071", "bodyText": "I've just inverted the order, as @patogallaiovlabs  mentions, and I didn't get any error, that's because of DummyValidator. We should take care of that and cover that case properly\nif (isValid(block)) {\n            boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n            if (looksGood) {", "author": "fedejinich", "createdAt": "2020-10-26T18:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3OTM0Ng==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r512179346", "bodyText": "I think we should decouple that logic (maybe have a BlockBasicValidator which validates genesis, header and block), then preprocess and finally run parents validation. For me it doesn't make sense to preprocess a block with invalid header", "author": "fedejinich", "createdAt": "2020-10-26T18:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzU1Mw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r526017553", "bodyText": "I didn't follow all the discussion, but I think we should do all the validations that NOT involves access to disk or memory caches, FIRST.", "author": "ajlopezrsk", "createdAt": "2020-11-18T11:34:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMTcyMw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509731723", "bodyText": "No limit queue could bring issues?", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:52:05Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTU5Ng==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511955596", "bodyText": "I'd prefer not to have any upper limit. This queue is a temporary storage for blocks to be processed in a separate thread, so this shouldn't be huge in terms of size. Most of the time its size should be close to zero.", "author": "Vovchyk", "createdAt": "2020-10-26T13:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMzM2NA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509733364", "bodyText": "you could extract this to a method, to make it more readable.", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:54:23Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");\n+            Map<Keccak256, ImportResult> result = Collections.singletonMap(block.getHash(), ImportResult.INVALID_BLOCK);\n+            return new BlockProcessResult(false, result, block.getPrintableHash(),\n+                    Duration.between(start, Instant.now()));\n+        }\n+\n+        return new BlockProcessResult(false, null, block.getPrintableHash(),", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTY4MA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511955680", "bodyText": "Done", "author": "Vovchyk", "createdAt": "2020-10-26T13:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczMzM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNDIyNg==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r509734226", "bodyText": "this could be extracted outside the log line, to make it more readable.", "author": "patogallaiovlabs", "createdAt": "2020-10-21T21:55:23Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTc2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511955769", "bodyText": "Done", "author": "Vovchyk", "createdAt": "2020-10-26T13:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNDIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NTQxMA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510145410", "bodyText": "make sense to add block hash/number?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T13:06:37Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<PeerBlockPair> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = blockSyncService.preprocessBlock(block, sender, false);\n+        if (looksGood) {\n+            if (isValid(block)) {\n+                boolean offer = blocksToProcess.offer(new PeerBlockPair(sender, block));\n+                if (!offer) {\n+                    logger.warn(\"Cannot add a block for processing into the queue\");\n+                }\n+\n+                return new BlockProcessResult(true, null, block.getPrintableHash(),\n+                        Duration.between(start, Instant.now()));\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", block.getNumber(), block.getPrintableHash(),\n+                    sender != null ? sender.getPeerNodeID().toString() : \"N/A\");\n+            Map<Keccak256, ImportResult> result = Collections.singletonMap(block.getHash(), ImportResult.INVALID_BLOCK);\n+            return new BlockProcessResult(false, result, block.getPrintableHash(),\n+                    Duration.between(start, Instant.now()));\n+        }\n+\n+        return new BlockProcessResult(false, null, block.getPrintableHash(),\n+                Duration.between(start, Instant.now()));\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stopThread();\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stopAndWait(long waitMillis) throws InterruptedException {\n+        stopThread();\n+\n+        if (waitMillis > 0L) {\n+            thread.join(waitMillis);\n+        }\n+    }\n+\n+    private void stopThread() {\n+        stopped = true;\n+        thread.interrupt();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Get peer/block pair\");\n+\n+                PeerBlockPair pair = blocksToProcess.take();\n+\n+                sender = pair.peer;\n+                block = pair.block;\n+\n+                logger.trace(\"Start block processing\");", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTg5NA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511955894", "bodyText": "Done", "author": "Vovchyk", "createdAt": "2020-10-26T13:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0NjcxMQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510246711", "bodyText": "\ud83d\udc4d", "author": "patogallaiovlabs", "createdAt": "2020-10-22T15:17:42Z", "path": "rskj-core/src/main/java/co/rsk/net/messages/MessageVisitor.java", "diffHunk": "@@ -112,11 +112,7 @@ public void apply(BlockMessage message) {\n \n         tryRelayBlock(block, result);\n \n-        if (result.isBest()) {\n-            sender.imported(true);\n-        } else {\n-            sender.imported(false);\n-        }\n+        sender.imported(result.isBest());", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2ODY0OQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510268649", "bodyText": "\"preprocess\" is executed twice? first time when you put in the queue and this is the second time when you actually process it?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T15:46:39Z", "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -105,6 +103,17 @@ public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolea\n                 logger.trace(\"Missing hashes for block in process {} {}\", blockNumber, block.getPrintableHash());\n                 requestMissingHashes(sender, unknownHashes);\n             }\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n+        final Instant start = Instant.now();\n+\n+        boolean looksGood = preprocessBlock(block, sender, ignoreMissingHashes);", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NjkyMg==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511956922", "bodyText": "Yes", "author": "Vovchyk", "createdAt": "2020-10-26T13:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2ODY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgwMDExMA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r512800110", "bodyText": "We could leave this until the next step. It's too soon to take care of this case.", "author": "patogallaiovlabs", "createdAt": "2020-10-27T15:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2ODY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjQzOQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510362439", "bodyText": "be careful here... if it happens to fail, it won't stop. Is there anyway to put a timeout here?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T18:12:56Z", "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzM5MA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511957390", "bodyText": "This is a test. But any way added a timeout for tests", "author": "Vovchyk", "createdAt": "2020-10-26T13:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjY3MQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510362671", "bodyText": "why wait time so high?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T18:13:20Z", "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());\n+        }\n+\n+        Assert.assertFalse(store.hasBlock(block));\n+        Assert.assertEquals(11, blockchain.getBestBlock().getNumber());\n+        Assert.assertArrayEquals(block.getHash().getBytes(), blockchain.getBestBlockHash());\n+        Assert.assertEquals(1, store.size());\n+\n+        processor.stopAndWait(WAIT_TIME);", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzU2Nw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511957567", "bodyText": "set to to 60 secs", "author": "Vovchyk", "createdAt": "2020-10-26T13:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2MjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3NjQwNg==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510376406", "bodyText": "why dont you save the last result and ask only for the last one outside the loop?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T18:37:21Z", "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorTest.java", "diffHunk": "@@ -0,0 +1,1030 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.blockchain.utils.BlockGenerator;\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.messages.*;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockIdentifier;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class AsyncNodeBlockProcessorTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+    \n+    @Test\n+    public void processBlockSavingInStore() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final BlockGenerator blockGenerator = new BlockGenerator();\n+        final Block parent = blockGenerator.createChildBlock(blockGenerator.getGenesisBlock());\n+        final Block orphan = blockGenerator.createChildBlock(parent);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+\n+        Assert.assertTrue(store.hasBlock(orphan));\n+        Assert.assertEquals(1, store.size());\n+    }\n+\n+    @Test\n+    public void processBlockWithTooMuchHeight() {\n+        final NetBlockStore store = new NetBlockStore();\n+        final Peer sender = new SimplePeer();\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final Block orphan = new BlockGenerator().createBlock(1000, 0);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        processor.processBlock(sender, orphan);\n+\n+        Assert.assertNotEquals(1, processor.getNodeInformation().getNodesByBlock(orphan.getHash().getBytes()).size());\n+        Assert.assertFalse(store.hasBlock(orphan));\n+        Assert.assertEquals(0, store.size());\n+    }\n+\n+    @Test\n+    public void advancedBlock() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final long advancedBlockNumber = syncConfiguration.getChunkSize() * syncConfiguration.getMaxSkeletonChunks() + blockchain.getBestBlock().getNumber() + 1;\n+\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.isAdvancedBlock(advancedBlockNumber));\n+        Assert.assertFalse(processor.isAdvancedBlock(advancedBlockNumber - 1));\n+    }\n+\n+    @Test\n+    public void canBeIgnoredForUncles() {\n+        final NetBlockStore store = new NetBlockStore();\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(15);\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final int uncleGenerationLimit = config.getNetworkConstants().getUncleGenerationLimit();\n+        final long blockNumberThatCanBeIgnored = blockchain.getBestBlock().getNumber() - 1 - uncleGenerationLimit;\n+\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), null);\n+\n+        Assert.assertTrue(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored));\n+        Assert.assertFalse(processor.canBeIgnoredForUnclesRewards(blockNumberThatCanBeIgnored + 1));\n+    }\n+\n+    @Test\n+    public void processBlockAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(10);\n+\n+        Assert.assertEquals(10, blockchain.getBestBlock().getNumber());\n+\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBlockByNumber(0);\n+        store.saveBlock(genesis);\n+\n+        final Block block = new BlockGenerator().createChildBlock(blockchain.getBlockByNumber(10));\n+\n+        Assert.assertEquals(11, block.getNumber());\n+        Assert.assertArrayEquals(blockchain.getBestBlockHash(), block.getParentHash().getBytes());\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, block);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(block.getHash());\n+        }\n+\n+        Assert.assertFalse(store.hasBlock(block));\n+        Assert.assertEquals(11, blockchain.getBestBlock().getNumber());\n+        Assert.assertArrayEquals(block.getHash().getBytes(), blockchain.getBestBlockHash());\n+        Assert.assertEquals(1, store.size());\n+\n+        processor.stopAndWait(WAIT_TIME);\n+    }\n+\n+    @Test\n+    public void processTenBlocksAddingToBlockchain() throws InterruptedException {\n+        final Blockchain blockchain = new BlockChainBuilder().ofSize(0);\n+        final NetBlockStore store = new NetBlockStore();\n+        final Block genesis = blockchain.getBestBlock();\n+\n+        final List<Block> blocks = new BlockGenerator().getBlockChain(genesis, 10);\n+\n+        final BlockNodeInformation nodeInformation = new BlockNodeInformation();\n+        final SyncConfiguration syncConfiguration = SyncConfiguration.IMMEDIATE_FOR_TESTING;\n+        final TestSystemProperties config = new TestSystemProperties();\n+        final BlockSyncService blockSyncService = new BlockSyncService(config, store, blockchain, nodeInformation, syncConfiguration);\n+        final AsyncNodeBlockProcessorListener listener = new AsyncNodeBlockProcessorListener();\n+        final AsyncNodeBlockProcessor processor = new AsyncNodeBlockProcessor(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, makeBlockValidator(), listener);\n+        processor.start();\n+\n+        BlockProcessResult blockProcessResult = processor.processBlock(null, genesis);\n+        if (blockProcessResult.isScheduledForProcessing()) {\n+            listener.waitForBlock(genesis.getHash());\n+        }\n+\n+        Assert.assertEquals(0, store.size());\n+\n+        Block blockToWait = null;\n+        for (Block b : blocks) {\n+            BlockProcessResult result = processor.processBlock(null, b);\n+            if (result.isScheduledForProcessing()) {\n+                blockToWait = b;", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1ODQ3NA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511958474", "bodyText": "it's actually being saved in blockToWait and processed outside the loop. Or did I get you wrong?", "author": "Vovchyk", "createdAt": "2020-10-26T13:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3NjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NjA1Mg==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r510396052", "bodyText": "I liked these before/after, cant we do sthg similar with the other test class?", "author": "patogallaiovlabs", "createdAt": "2020-10-22T19:11:49Z", "path": "rskj-core/src/test/java/co/rsk/net/AsyncNodeBlockProcessorUnclesTest.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.TestSystemProperties;\n+import co.rsk.core.bc.BlockChainImpl;\n+import co.rsk.net.simples.SimplePeer;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.net.utils.AsyncNodeBlockProcessorListener;\n+import co.rsk.test.builders.BlockBuilder;\n+import co.rsk.test.builders.BlockChainBuilder;\n+import co.rsk.validators.BlockValidator;\n+import co.rsk.validators.DummyBlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AsyncNodeBlockProcessorUnclesTest {\n+\n+    private static final long WAIT_TIME = Long.MAX_VALUE;\n+\n+    private BlockChainBuilder blockChainBuilder;\n+    private BlockChainImpl blockChain;\n+    private AsyncNodeBlockProcessor processor;\n+    private AsyncNodeBlockProcessorListener listener;\n+\n+    @Before\n+    public void setUp() {\n+        blockChainBuilder = new BlockChainBuilder();\n+        blockChain = blockChainBuilder.build();\n+        listener = new AsyncNodeBlockProcessorListener();\n+        processor = createAsyncNodeBlockProcessor(blockChain, listener);\n+        processor.start();\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        processor.stopAndWait(WAIT_TIME);\n+    }", "originalCommit": "b7e58e7f26656e906d64078c59fba3d778cb75c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MDAxNA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r511960014", "bodyText": "Do you mean AsyncNodeBlockProcessorTest class? In this class AsyncNodeBlockProcessor is constructed differently for every test. Or did you mean something else?", "author": "Vovchyk", "createdAt": "2020-10-26T13:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NjA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwOTA3Ng==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r514509076", "bodyText": "The PoW rule should be validated before this.\nIt would be easy to DoS the nodes in the current state: RSKIP92 allows the creation of a block with the same hash but with invalid PoW, and the current code would allow it to reach the store actually forcing the valid block to be rejected.", "author": "donequis", "createdAt": "2020-10-29T19:22:37Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockRelayValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator, @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.listener = listener;\n+        this.blockRelayValidator = blockRelayValidator;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockRelayValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockRelayValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        if (store.hasBlock(block)) {", "originalCommit": "36c31e5c5556c51905012be2d6d3a5ecef129204", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxNzY0OQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r516817649", "bodyText": "@donequis, I've separated block validation onto two stages. Block header validation now happens before store.hasBlock(block), and it includes PoW and block timestamp validation rules. Validation of the block itself and its parent happens later on (as it was before). Let me know about your thoughts.", "author": "Vovchyk", "createdAt": "2020-11-03T16:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwOTA3Ng=="}], "type": "inlineReview"}, {"oid": "d335ae977381f662e78049c4d9dbf23cc964c498", "url": "https://github.com/rsksmart/rskj/commit/d335ae977381f662e78049c4d9dbf23cc964c498", "message": "Added prior block header validation", "committedDate": "2020-11-03T12:47:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNDc1Ng==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r526014756", "bodyText": "Why not to delegate this logic to a block processor getter? Or is there a situation when even having fast block propagation enable, we should need the direct block processor instead of async one?", "author": "ajlopezrsk", "createdAt": "2020-11-18T11:29:26Z", "path": "rskj-core/src/main/java/co/rsk/RskContext.java", "diffHunk": "@@ -1558,9 +1626,14 @@ private TransactionGateway getTransactionGateway() {\n \n     private NodeMessageHandler getNodeMessageHandler() {\n         if (nodeMessageHandler == null) {\n+            RskSystemProperties rskSystemProperties = getRskSystemProperties();\n+            BlockProcessor blockProcessor = rskSystemProperties.fastBlockPropagation()", "originalCommit": "d335ae977381f662e78049c4d9dbf23cc964c498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyOTQ5NA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r526829494", "bodyText": "done", "author": "Vovchyk", "createdAt": "2020-11-19T12:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNDc1Ng=="}], "type": "inlineReview"}, {"oid": "aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "url": "https://github.com/rsksmart/rskj/commit/aa364423c02c53f40b5cb4ed6f306d30e5c25cbc", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor", "committedDate": "2020-11-19T12:15:02Z", "type": "forcePushed"}, {"oid": "5af06a3308a55ea137dfee148f12842afd3a88b8", "url": "https://github.com/rsksmart/rskj/commit/5af06a3308a55ea137dfee148f12842afd3a88b8", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor", "committedDate": "2020-11-19T14:20:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0MzA3MQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531043071", "bodyText": "Can we default to false for this validators? There's no need to relay a genesis block", "author": "donequis", "createdAt": "2020-11-26T13:52:08Z", "path": "rskj-core/src/main/java/co/rsk/core/bc/BlockHeaderRelayValidatorImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.core.bc;\n+\n+import co.rsk.validators.BlockHeaderValidationRule;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.BlockHeader;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Validates a block header if it is good enough to be propagated.\n+ *\n+ * The validation includes:\n+ * - validation of the header data of the block\n+ */\n+public class BlockHeaderRelayValidatorImpl implements BlockValidator {\n+\n+    private final BlockHeaderValidationRule blockHeaderValidator;\n+\n+    public BlockHeaderRelayValidatorImpl(@Nonnull BlockHeaderValidationRule blockHeaderValidator) {\n+        this.blockHeaderValidator = blockHeaderValidator;\n+    }\n+\n+    /**\n+     * Checks if a block header is valid.\n+     *\n+     * @param block Block to validate\n+     * @return true if the block is valid, otherwise - false.\n+     */\n+    @Override\n+    public boolean isValid(@Nonnull Block block) {\n+        if (block.isGenesis()) {", "originalCommit": "5af06a3308a55ea137dfee148f12842afd3a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MTEzOQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531171139", "bodyText": "Done in 834dbc8", "author": "Vovchyk", "createdAt": "2020-11-26T17:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0MzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0OTY1OA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531049658", "bodyText": "We could add the relay headers validations here, so we prevent accessing the disk before PoW check", "author": "donequis", "createdAt": "2020-11-26T14:03:15Z", "path": "rskj-core/src/main/java/co/rsk/net/BlockSyncService.java", "diffHunk": "@@ -102,18 +102,28 @@ public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolea\n                 logger.trace(\"Missing hashes for block in process {} {}\", blockNumber, block.getPrintableHash());\n                 requestMissingHashes(sender, unknownHashes);\n             }\n-            return BlockProcessResult.invalidBlock(block, start);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public BlockProcessResult processBlock(@Nonnull Block block, Peer sender, boolean ignoreMissingHashes) {\n+        final Instant start = Instant.now();\n+\n+        boolean readyForProcessing = preprocessBlock(block, sender, ignoreMissingHashes);", "originalCommit": "5af06a3308a55ea137dfee148f12842afd3a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MTI3Mw==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r531171273", "bodyText": "Done in 2db0d6e", "author": "Vovchyk", "createdAt": "2020-11-26T17:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0OTY1OA=="}], "type": "inlineReview"}, {"oid": "2db0d6e6f1d60a415b0456338f54c34e673879f8", "url": "https://github.com/rsksmart/rskj/commit/2db0d6e6f1d60a415b0456338f54c34e673879f8", "message": "Added validation of block header in BlockSyncService", "committedDate": "2020-11-26T17:28:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NDU5OA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r545384598", "bodyText": "stopped = true? Could be an undesired stop, right?", "author": "patogallaiovlabs", "createdAt": "2020-12-17T20:30:59Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockHeaderValidator;\n+\n+    private final BlockValidator blockValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.blockHeaderValidator = blockHeaderValidator;\n+        this.blockValidator = blockValidator;\n+        this.listener = listener;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockHeaderValidator, blockValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        // Validate block header first to see if its PoW is valid at all\n+        if (!isBlockHeaderValid(block)) {\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        // Check if block is already in the queue\n+        if (store.hasBlock(block)) {\n+            logger.trace(\"Ignored block with number {} and hash {} from {} as it's already in the queue\", blockNumber, blockHash, peer);\n+            return ignoreBlockResult(block, start);\n+        }\n+\n+        // Check if block is ready for processing - if the block is not too advanced, its parent block is in place etc.\n+        boolean readyForProcessing = blockSyncService.preprocessBlock(block, sender, false);\n+        if (readyForProcessing) {\n+            // Validate block if it can be added to the queue for processing\n+            if (isBlockValid(block)) {\n+                boolean offer = blocksToProcess.offer(new BlockInfo(sender, block));\n+                if (offer) {\n+                    logger.trace(\"Added block with number {} and hash {} from {} to the queue\", blockNumber, blockHash, peer);\n+                } else {\n+                    // This should not happen as the queue is unbounded\n+                    logger.warn(\"Cannot add block for processing into the queue with number {} {} from {}\", blockNumber, blockHash, peer);\n+                }\n+\n+                return scheduledForProcessingResult(block, start);\n+            }\n+\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        logger.trace(\"Ignored block with number {} and hash {} from {} as it's not ready for processing yet\", blockNumber, blockHash, peer);\n+        return ignoreBlockResult(block, start);\n+    }\n+\n+    @Override\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    @Override\n+    public void stop() {\n+        stopThread();\n+    }\n+\n+    /**\n+     * Stop the service and wait until a working thread is stopped for {@code waitMillis} milliseconds,\n+     * if {@code waitMillis} greater than zero. If {@code waitMillis} is zero, then immediately returns.\n+     */\n+    public void stopAndWait(long waitMillis) throws InterruptedException {\n+        stopThread();\n+\n+        if (waitMillis > 0L) {\n+            thread.join(waitMillis);\n+        }\n+    }\n+\n+    private void stopThread() {\n+        stopped = true;\n+        thread.interrupt();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            Peer sender = null;\n+            Block block = null;\n+\n+            try {\n+                logger.trace(\"Awaiting block for processing from the queue...\");\n+\n+                BlockInfo blockInfo = blocksToProcess.take();\n+\n+                sender = blockInfo.peer;\n+                block = blockInfo.block;\n+\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Start block processing with number {} and hash {} from {}\", block.getNumber(), block.getPrintableHash(), sender);\n+                }\n+\n+                BlockProcessResult blockProcessResult = blockSyncService.processBlock(block, sender, false);\n+                logger.trace(\"Finished block processing\");\n+\n+                if (listener != null) {\n+                    listener.onBlockProcessed(this, sender, block, blockProcessResult);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.trace(\"Thread has been interrupted\");\n+\n+                Thread.currentThread().interrupt();", "originalCommit": "2db0d6e6f1d60a415b0456338f54c34e673879f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyOTcwMA==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r545829700", "bodyText": "well, this flag stopped is being set by other threads. This particular thread with the loop only reads it.", "author": "Vovchyk", "createdAt": "2020-12-18T13:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NDU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NjAzNQ==", "url": "https://github.com/rsksmart/rskj/pull/1326#discussion_r545386035", "bodyText": "I would separate the logic of \"adding to the queue\" in another method, and check for \"stopped\" flag.\nThen you could decide to log(that it is stopped) or log/stop the node(?)", "author": "patogallaiovlabs", "createdAt": "2020-12-17T20:33:33Z", "path": "rskj-core/src/main/java/co/rsk/net/AsyncNodeBlockProcessor.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.net;\n+\n+import co.rsk.config.InternalService;\n+import co.rsk.crypto.Keccak256;\n+import co.rsk.net.sync.SyncConfiguration;\n+import co.rsk.validators.BlockValidator;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.Blockchain;\n+import org.ethereum.core.ImportResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * AsyncNodeBlockProcessor processes blockchain blocks that are received from other nodes.\n+ * If a block passes validation, it will immediately be propagated to other nodes and its execution will be scheduled on a separate thread.\n+ * Blocks are being executed and connected to the blockchain sequentially one after another.\n+ * <p>\n+ * If a block is not ready to be added to the blockchain, it will be on hold in a BlockStore.\n+ * <p>\n+ */\n+public class AsyncNodeBlockProcessor extends NodeBlockProcessor implements InternalService, Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"asyncblockprocessor\");\n+\n+    private final BlockingQueue<BlockInfo> blocksToProcess = new LinkedBlockingQueue<>();\n+\n+    private final BlockValidator blockHeaderValidator;\n+\n+    private final BlockValidator blockValidator;\n+\n+    private final Thread thread = new Thread(this,\"async block processor\");\n+\n+    private final Listener listener;\n+\n+    private volatile boolean stopped;\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator,\n+                                   @Nullable Listener listener) {\n+        super(store, blockchain, nodeInformation, blockSyncService, syncConfiguration);\n+        this.blockHeaderValidator = blockHeaderValidator;\n+        this.blockValidator = blockValidator;\n+        this.listener = listener;\n+    }\n+\n+    public AsyncNodeBlockProcessor(@Nonnull NetBlockStore store, @Nonnull Blockchain blockchain, @Nonnull BlockNodeInformation nodeInformation,\n+                                   @Nonnull BlockSyncService blockSyncService, @Nonnull SyncConfiguration syncConfiguration,\n+                                   @Nonnull BlockValidator blockHeaderValidator, @Nonnull BlockValidator blockValidator) {\n+        this(store, blockchain, nodeInformation, blockSyncService, syncConfiguration, blockHeaderValidator, blockValidator, null);\n+    }\n+\n+    @Override\n+    public BlockProcessResult processBlock(@Nullable Peer sender, @Nonnull Block block) {\n+        final Instant start = Instant.now();\n+\n+        final long blockNumber = block.getNumber();\n+        final String blockHash = block.getPrintableHash();\n+        final String peer = sender != null ? sender.getPeerNodeID().toString() : \"N/A\";\n+\n+        // Validate block header first to see if its PoW is valid at all\n+        if (!isBlockHeaderValid(block)) {\n+            logger.warn(\"Invalid block with number {} {} from {} \", blockNumber, blockHash, peer);\n+            return invalidBlockResult(block, start);\n+        }\n+\n+        // Check if block is already in the queue\n+        if (store.hasBlock(block)) {\n+            logger.trace(\"Ignored block with number {} and hash {} from {} as it's already in the queue\", blockNumber, blockHash, peer);\n+            return ignoreBlockResult(block, start);\n+        }\n+\n+        // Check if block is ready for processing - if the block is not too advanced, its parent block is in place etc.\n+        boolean readyForProcessing = blockSyncService.preprocessBlock(block, sender, false);\n+        if (readyForProcessing) {\n+            // Validate block if it can be added to the queue for processing\n+            if (isBlockValid(block)) {\n+                boolean offer = blocksToProcess.offer(new BlockInfo(sender, block));", "originalCommit": "2db0d6e6f1d60a415b0456338f54c34e673879f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36f76228f35dad42be9496b2a28c8bee850ade5f", "url": "https://github.com/rsksmart/rskj/commit/36f76228f35dad42be9496b2a28c8bee850ade5f", "message": "Extracted adding block to queue into separate method", "committedDate": "2020-12-21T13:28:01Z", "type": "forcePushed"}, {"oid": "20740f831fd5b0b1f6b70068f409360ea7e20642", "url": "https://github.com/rsksmart/rskj/commit/20740f831fd5b0b1f6b70068f409360ea7e20642", "message": "Extracted adding block to queue into separate method", "committedDate": "2021-01-18T13:20:19Z", "type": "forcePushed"}, {"oid": "c6dfaacb30a4cfef5098686fb9c4e866f86b5657", "url": "https://github.com/rsksmart/rskj/commit/c6dfaacb30a4cfef5098686fb9c4e866f86b5657", "message": "Implemented block propagation enhancements", "committedDate": "2021-01-19T17:05:47Z", "type": "commit"}, {"oid": "14d34abd39f6cf4ffc64856f8adff8be2b7f37b8", "url": "https://github.com/rsksmart/rskj/commit/14d34abd39f6cf4ffc64856f8adff8be2b7f37b8", "message": "Added block validation logic", "committedDate": "2021-01-19T17:05:47Z", "type": "commit"}, {"oid": "9740378bf8ab7c3a078ee51f25a82694ed08d1af", "url": "https://github.com/rsksmart/rskj/commit/9740378bf8ab7c3a078ee51f25a82694ed08d1af", "message": "Added check if block is already in net store; Minor refactoring", "committedDate": "2021-01-19T17:05:47Z", "type": "commit"}, {"oid": "ef3684c87d8f7f3ee55aa5a3cf4438c8ce6cbcdd", "url": "https://github.com/rsksmart/rskj/commit/ef3684c87d8f7f3ee55aa5a3cf4438c8ce6cbcdd", "message": "Added test for a case when block is invalid", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "4f78cd7e6e73a7cdc5f6b1c550201236ac990f63", "url": "https://github.com/rsksmart/rskj/commit/4f78cd7e6e73a7cdc5f6b1c550201236ac990f63", "message": "Added prior block header validation", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "2f0dca3cc67866455b317383b84ff521062021f9", "url": "https://github.com/rsksmart/rskj/commit/2f0dca3cc67866455b317383b84ff521062021f9", "message": "Used BlockProcessResult's factory methods", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "3a4184a3699928c243b65a1b30c27062b3ed70bf", "url": "https://github.com/rsksmart/rskj/commit/3a4184a3699928c243b65a1b30c27062b3ed70bf", "message": "Moved AsyncNodeBlockProcessor creation to getNodeBlockProcessor", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "6afe2097287088d0d4142bf4bd2645e42911147e", "url": "https://github.com/rsksmart/rskj/commit/6afe2097287088d0d4142bf4bd2645e42911147e", "message": "Return false for genesis block in relay validators", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "7e4d0fb770dd63448c62dd05843daed90baca553", "url": "https://github.com/rsksmart/rskj/commit/7e4d0fb770dd63448c62dd05843daed90baca553", "message": "Added validation of block header in BlockSyncService", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "url": "https://github.com/rsksmart/rskj/commit/f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "message": "Extracted adding block to queue into separate method", "committedDate": "2021-01-19T17:05:48Z", "type": "commit"}, {"oid": "f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "url": "https://github.com/rsksmart/rskj/commit/f3ff9f1d5199aafb98bca2b2e68515248d843ac8", "message": "Extracted adding block to queue into separate method", "committedDate": "2021-01-19T17:05:48Z", "type": "forcePushed"}]}