{"pr_number": 1351, "pr_title": "Peer scoring logs", "pr_createdAt": "2020-10-30T16:12:39Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1351", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NTg0Mw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r515295843", "bodyText": "pass an address as parameter too", "author": "fedejinich", "createdAt": "2020-10-30T18:19:49Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringManager.java", "diffHunk": "@@ -71,16 +71,19 @@ protected boolean removeEldestEntry(Map.Entry<NodeID, PeerScoring> eldest) {\n      * @param event     event type (@see EventType)\r\n      */\r\n     public void recordEvent(NodeID id, InetAddress address, EventType event) {\r\n+        //todo(techdebt) this method encourages null params, this is not desirable\r\n         synchronized (accessLock) {\r\n-            if (id != null) {\r\n+            if (id != null) { //todo(techdebt) it seems this is always true\r\n                 PeerScoring scoring = peersByNodeID.computeIfAbsent(id, k -> peerScoringFactory.newInstance());\r\n-                recordEvent(scoring, event, this.nodePunishmentCalculator);\r\n+                recordEventAndStartPunishment(scoring, event, this.nodePunishmentCalculator, id);\r\n             }\r\n \r\n             if (address != null) {\r\n                 PeerScoring scoring = peersByAddress.computeIfAbsent(address, k -> peerScoringFactory.newInstance());\r\n-                recordEvent(scoring, event, this.ipPunishmentCalculator);\r\n+                recordEventAndStartPunishment(scoring, event, this.ipPunishmentCalculator, id);\r\n             }\r\n+\r\n+            PeerScoringLogger.recordEvent(id, event);\r", "originalCommit": "502c3cc016ce03f74b1df474608e8608fb230463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9bb5bff157f3c5e902b485d80a4becd4ebe1982", "url": "https://github.com/rsksmart/rskj/commit/c9bb5bff157f3c5e902b485d80a4becd4ebe1982", "message": "removed logger class & added address to recordEvent log", "committedDate": "2020-11-03T01:03:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMDY5OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519000698", "bodyText": "make sense to use just 1 property? if it is -1 is disabled?\ndont know what is our standard for this.", "author": "patogallaiovlabs", "createdAt": "2020-11-06T20:55:51Z", "path": "rskj-core/src/main/java/co/rsk/config/RskSystemProperties.java", "diffHunk": "@@ -343,4 +343,12 @@ public long getVmExecutionStackSize() {\n     }\n \n     public String cryptoLibrary() { return configFromFiles.getString(\"crypto.library\");}\n+\n+    public boolean isPeerScoringStatsReportEnabled() {\n+        return configFromFiles.getBoolean(\"scoring.statsReport.enabled\");", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg0MTQ1NQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519841455", "bodyText": "mmm I think it's much more clear to have separate properties like this and avoid supposing properties. On your approach we will have less code (with more intentions).  Lets define that standard :)", "author": "fedejinich", "createdAt": "2020-11-09T14:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMTQzNw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519001437", "bodyText": "Did you try it? I think it could be both.", "author": "patogallaiovlabs", "createdAt": "2020-11-06T20:57:32Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringManager.java", "diffHunk": "@@ -64,23 +68,28 @@ protected boolean removeEldestEntry(Map.Entry<NodeID, PeerScoring> eldest) {\n     }\r\n \r\n     /**\r\n-     * Record the event, givent the node id and/or the network address\r\n+     * Record the event, given the node id and/or the network address\r\n      *\r\n      * @param id        node id or null\r\n      * @param address   address or null\r\n      * @param event     event type (@see EventType)\r\n      */\r\n     public void recordEvent(NodeID id, InetAddress address, EventType event) {\r\n+        //todo(techdebt) this method encourages null params, this is not desirable\r\n         synchronized (accessLock) {\r\n-            if (id != null) {\r\n+            if (id != null) { //todo(techdebt) it seems this is always true\r\n                 PeerScoring scoring = peersByNodeID.computeIfAbsent(id, k -> peerScoringFactory.newInstance());\r\n-                recordEvent(scoring, event, this.nodePunishmentCalculator);\r\n+                recordEventAndStartPunishment(scoring, event, this.nodePunishmentCalculator, id);\r\n             }\r\n \r\n             if (address != null) {\r\n                 PeerScoring scoring = peersByAddress.computeIfAbsent(address, k -> peerScoringFactory.newInstance());\r\n-                recordEvent(scoring, event, this.ipPunishmentCalculator);\r\n+                recordEventAndStartPunishment(scoring, event, this.ipPunishmentCalculator, id);\r\n             }\r\n+\r\n+            String peersBy = id != null ? \"NodeID\" : \"Address\";\r", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMzI4MA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r524523280", "bodyText": "Usually we collected the events TWICE, if possible: by node id and by address. In some events we don't have the node id, yet. The rationale to have both, is to collect events for the same node_id, but maybe with different address along the time. Or same address with different node id.", "author": "ajlopezrsk", "createdAt": "2020-11-16T19:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MzY3OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527083678", "bodyText": "adding this as method comment", "author": "fedejinich", "createdAt": "2020-11-19T17:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEwMTgwMQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527101801", "bodyText": "92cc672", "author": "fedejinich", "createdAt": "2020-11-19T18:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjUwMw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519002503", "bodyText": "I would change \"Reason\" to \"Last event\".", "author": "patogallaiovlabs", "createdAt": "2020-11-06T20:59:56Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringManager.java", "diffHunk": "@@ -241,18 +258,37 @@ public PeerScoring getPeerScoring(InetAddress address) {\n     }\r\n \r\n     /**\r\n-     * Calculates the reputation for a peer\r\n-     * Starts punishment if needed\r\n-     *\r\n-     * @param scoring       the peer scoring\r\n-     * @param calculator    the calculator to use\r\n+     * Records an event and starts punishment if needed\r\n+     * @param peerScoring the peer scoring\r\n+     * @param event an event type\r\n+     * @param punishmentCalculator calculator to use\r\n+     * @param nodeID a node id\r\n      */\r\n-    private void recordEvent(PeerScoring scoring, EventType event, PunishmentCalculator calculator) {\r\n-        scoring.recordEvent(event);\r\n-        boolean reputation = scoringCalculator.hasGoodReputation(scoring);\r\n+    private void recordEventAndStartPunishment(PeerScoring peerScoring, EventType event, PunishmentCalculator punishmentCalculator, NodeID nodeID) {\r\n+        peerScoring.recordEvent(event);\r\n+\r\n+        boolean shouldStartPunishment = !scoringCalculator.hasGoodReputation(peerScoring) && peerScoring.hasGoodReputation();\r\n+        if (shouldStartPunishment) {\r\n+            long punishmentTime = punishmentCalculator.calculate(peerScoring.getPunishmentCounter(), peerScoring.getScore());\r\n+            peerScoring.startPunishment(punishmentTime);\r\n+\r\n+            String nodeIDFormated = nodeIdForLog(nodeID);\r\n+            logger.debug(\"NodeID {} has been punished for {} milliseconds. Reason {}\", nodeIDFormated, punishmentTime, event);\r", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzODA0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519838042", "bodyText": "modified :)", "author": "fedejinich", "createdAt": "2020-11-09T14:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzA1Ng==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519007056", "bodyText": "Calculate \"toString\" only once.", "author": "patogallaiovlabs", "createdAt": "2020-11-06T21:11:19Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringManager.java", "diffHunk": "@@ -241,18 +258,37 @@ public PeerScoring getPeerScoring(InetAddress address) {\n     }\r\n \r\n     /**\r\n-     * Calculates the reputation for a peer\r\n-     * Starts punishment if needed\r\n-     *\r\n-     * @param scoring       the peer scoring\r\n-     * @param calculator    the calculator to use\r\n+     * Records an event and starts punishment if needed\r\n+     * @param peerScoring the peer scoring\r\n+     * @param event an event type\r\n+     * @param punishmentCalculator calculator to use\r\n+     * @param nodeID a node id\r\n      */\r\n-    private void recordEvent(PeerScoring scoring, EventType event, PunishmentCalculator calculator) {\r\n-        scoring.recordEvent(event);\r\n-        boolean reputation = scoringCalculator.hasGoodReputation(scoring);\r\n+    private void recordEventAndStartPunishment(PeerScoring peerScoring, EventType event, PunishmentCalculator punishmentCalculator, NodeID nodeID) {\r\n+        peerScoring.recordEvent(event);\r\n+\r\n+        boolean shouldStartPunishment = !scoringCalculator.hasGoodReputation(peerScoring) && peerScoring.hasGoodReputation();\r\n+        if (shouldStartPunishment) {\r\n+            long punishmentTime = punishmentCalculator.calculate(peerScoring.getPunishmentCounter(), peerScoring.getScore());\r\n+            peerScoring.startPunishment(punishmentTime);\r\n+\r\n+            String nodeIDFormated = nodeIdForLog(nodeID);\r\n+            logger.debug(\"NodeID {} has been punished for {} milliseconds. Reason {}\", nodeIDFormated, punishmentTime, event);\r\n+            logger.debug(\"{}\", new PeerScoringInformation(peerScoring, nodeIDFormated, \"\"));\r\n+        }\r\n+    }\r\n+\r\n+    private String nodeIdForLog(NodeID id) {\r\n+        if(id == null) {\r\n+            return \"NO_NODE_ID\";\r\n+        }\r\n+        return id.toString().substring(id.toString().length() - 7, id.toString().length() - 1);\r", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzk2Mg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519007962", "bodyText": "Be careful with format, we already unified the way nodeID are printed, i think.", "author": "patogallaiovlabs", "createdAt": "2020-11-06T21:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzNzkxNw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519837917", "bodyText": "changed :)", "author": "fedejinich", "createdAt": "2020-11-09T14:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODEwNQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519008105", "bodyText": "why upper?", "author": "patogallaiovlabs", "createdAt": "2020-11-06T21:14:07Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringSummaryService.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package co.rsk.scoring;\n+\n+import co.rsk.config.InternalService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PeerScoringSummaryService implements InternalService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"peerScoring\");\n+\n+    private final long REPORT_TIME;", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg0MDAzMg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519840032", "bodyText": "because it's a constant :)", "author": "fedejinich", "createdAt": "2020-11-09T14:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODM2OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519008368", "bodyText": "logger.error(...)", "author": "patogallaiovlabs", "createdAt": "2020-11-06T21:14:44Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringSummaryService.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package co.rsk.scoring;\n+\n+import co.rsk.config.InternalService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PeerScoringSummaryService implements InternalService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"peerScoring\");\n+\n+    private final long REPORT_TIME;\n+    private final PeerScoringManager peerScoringManager;\n+\n+    public PeerScoringSummaryService(long peerScoringStatsReportTime, PeerScoringManager peerScoringManager) {\n+        this.REPORT_TIME = peerScoringStatsReportTime;\n+        this.peerScoringManager = peerScoringManager;\n+    }\n+\n+    @Override\n+    public void start() {\n+        logger.debug(\"starting peer scoring summary service\");\n+        try {\n+            ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+            executorService.scheduleAtFixedRate(() -> this.report(peerScoringManager.getPeersInformation()),\n+                    0,\n+                    REPORT_TIME,\n+                    TimeUnit.MILLISECONDS\n+            );\n+        } catch (Exception e) {\n+            e.printStackTrace();", "originalCommit": "db104a0ae34463ba6ffb79e7665ec6298aac6b53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzOTU5Mg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r519839592", "bodyText": "i think this one it's too light to be considered as an error, what do you expect from an error?", "author": "fedejinich", "createdAt": "2020-11-09T14:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODM2OA=="}], "type": "inlineReview"}, {"oid": "12d72bd4001b3eb68260f62483174c7d23600a30", "url": "https://github.com/rsksmart/rskj/commit/12d72bd4001b3eb68260f62483174c7d23600a30", "message": "expose json rpc method sco_badReputationSummary", "committedDate": "2020-11-09T05:39:56Z", "type": "forcePushed"}, {"oid": "a71f7b3d21a316d31b26eecdff9fb9b5b1ec49ee", "url": "https://github.com/rsksmart/rskj/commit/a71f7b3d21a316d31b26eecdff9fb9b5b1ec49ee", "message": "sonarcloud fixies and more test cases", "committedDate": "2020-11-09T15:44:48Z", "type": "forcePushed"}, {"oid": "fbe8cfddfacbadb547292b7d256adb98f0840a91", "url": "https://github.com/rsksmart/rskj/commit/fbe8cfddfacbadb547292b7d256adb98f0840a91", "message": "sonarcloud fixies and more test cases", "committedDate": "2020-11-09T16:18:29Z", "type": "forcePushed"}, {"oid": "813ae849ffdd693215642bd36be3799e304682fa", "url": "https://github.com/rsksmart/rskj/commit/813ae849ffdd693215642bd36be3799e304682fa", "message": "sonarcloud fixies and more test cases", "committedDate": "2020-11-09T16:35:20Z", "type": "forcePushed"}, {"oid": "f33cb1f800f7d3ac5937a26ee710b31002d63ad6", "url": "https://github.com/rsksmart/rskj/commit/f33cb1f800f7d3ac5937a26ee710b31002d63ad6", "message": "sonarcloud fixies and more test cases", "committedDate": "2020-11-09T16:41:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI1MjE2OQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r524252169", "bodyText": "scheduledExecutorService cannot be null here, can it? Also shouldn't we check validity of peerScoringManager and time values in the constructor where they are initially provided?", "author": "Vovchyk", "createdAt": "2020-11-16T13:04:16Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringReporterService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package co.rsk.scoring;\n+\n+import co.rsk.config.InternalService;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This service prints a summary of nodes with bad reputation, every 5 minutes (configurable)\n+ * */\n+public class PeerScoringReporterService implements InternalService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"peerScoring\");\n+\n+    private final PeerScoringManager peerScoringManager;\n+    private final long time;\n+    private ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+    private boolean running = false;\n+\n+    public PeerScoringReporterService(long time, PeerScoringManager peerScoringManager) {\n+        this.time = time;\n+        this.peerScoringManager = peerScoringManager;\n+    }\n+\n+    @Override\n+    public void start() {\n+        logger.debug(\"starting peer scoring reporter service\");\n+        try {\n+            List<PeerScoringInformation> peerScoringInformationList = peerScoringManager.getPeersInformation();\n+            scheduledExecutorService.scheduleAtFixedRate(() -> printReport(peerScoringInformationList),\n+                    0,\n+                    time,\n+                    TimeUnit.MILLISECONDS\n+            );\n+            running = true;\n+        } catch (Exception e) {\n+            logger.warn(\"peer scoring reporter failed\", e);\n+            stop();\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        scheduledExecutorService.shutdown();\n+        logger.warn(\"peer scoring reporter service has been stopped\");\n+        running = false;\n+    }\n+\n+    public boolean printReport(List<PeerScoringInformation> peerScoringInformationList) {\n+        try {\n+            String badReputationSummary = PeerScoringReporterUtil.badReputationSummaryString(peerScoringInformationList);\n+            logger.debug(\"bad reputation summary {}\", badReputationSummary);\n+\n+            String peersInformationDetailed = PeerScoringReporterUtil.detailedBadReputationStatusString(peerScoringInformationList);\n+            logger.debug(\"detailed bad reputation status {}\", peersInformationDetailed);\n+        } catch (Exception e) {\n+            logger.warn(\"failed to print report\", e);\n+\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    public boolean initialized() {\n+        return scheduledExecutorService != null && peerScoringManager != null && time > 0;", "originalCommit": "a6ff65e68892aea71302bb814bfee258d9d84d8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI1NTE5NA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r524255194", "bodyText": "As for me this error-handling is a bit over-complicated. Result of this method is not being used by the scheduledExecutorService, is it? It's only for testing purposes? Can we alternatively check if this method throws an exception in the tests, and return nothing here? The PeerScoringReporterUtil's utility methods can only produce unchecked/runtime exceptions I suppose.", "author": "Vovchyk", "createdAt": "2020-11-16T13:09:26Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringReporterService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package co.rsk.scoring;\n+\n+import co.rsk.config.InternalService;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This service prints a summary of nodes with bad reputation, every 5 minutes (configurable)\n+ * */\n+public class PeerScoringReporterService implements InternalService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(\"peerScoring\");\n+\n+    private final PeerScoringManager peerScoringManager;\n+    private final long time;\n+    private ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+    private boolean running = false;\n+\n+    public PeerScoringReporterService(long time, PeerScoringManager peerScoringManager) {\n+        this.time = time;\n+        this.peerScoringManager = peerScoringManager;\n+    }\n+\n+    @Override\n+    public void start() {\n+        logger.debug(\"starting peer scoring reporter service\");\n+        try {\n+            List<PeerScoringInformation> peerScoringInformationList = peerScoringManager.getPeersInformation();\n+            scheduledExecutorService.scheduleAtFixedRate(() -> printReport(peerScoringInformationList),\n+                    0,\n+                    time,\n+                    TimeUnit.MILLISECONDS\n+            );\n+            running = true;\n+        } catch (Exception e) {\n+            logger.warn(\"peer scoring reporter failed\", e);\n+            stop();\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        scheduledExecutorService.shutdown();\n+        logger.warn(\"peer scoring reporter service has been stopped\");\n+        running = false;\n+    }\n+\n+    public boolean printReport(List<PeerScoringInformation> peerScoringInformationList) {", "originalCommit": "a6ff65e68892aea71302bb814bfee258d9d84d8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzOTgxOQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527839819", "bodyText": "yep you're right, I confused Exceptions with RuntimeExceptions. I'll move testing logic to a TestPeerScoringReporterService as @ajlopez suggested yesterday.\nAlso I'll simplify that error handling", "author": "fedejinich", "createdAt": "2020-11-20T17:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI1NTE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg0NjU3NA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527846574", "bodyText": "9b301af", "author": "fedejinich", "createdAt": "2020-11-20T17:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI1NTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUxODQzMg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r524518432", "bodyText": "Why \"BadReputation\"? We could use this information for any peer, not only the ones with bad reputation. ie, the number of valid blocks", "author": "ajlopezrsk", "createdAt": "2020-11-16T19:27:28Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringBadReputationSummary.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package co.rsk.scoring;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * This is a presentational object of peers with bad reputation\n+ * It's used to expose a json rpc message (sco_badReputationSummary())\n+ */\n+public class PeerScoringBadReputationSummary {\n+    private int count;\n+    private int successfulHandshakes;\n+    private int failedHandshakes;\n+    private int invalidNetworks;\n+    private int repeatedMessages;\n+    private int validBlocks;\n+    private int validTransactions;\n+    private int invalidBlocks;\n+    private int invalidTransactions;\n+    private int invalidMessages;\n+    private int timeoutMessages;\n+    private int unexpectedMessages;\n+    private int invalidHeader;\n+    private int peersTotalScore;\n+    private int punishments;\n+\n+    public PeerScoringBadReputationSummary(int count,", "originalCommit": "a6ff65e68892aea71302bb814bfee258d9d84d8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NDQzOQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527044439", "bodyText": "changed", "author": "fedejinich", "createdAt": "2020-11-19T16:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUxODQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMTg2Mg==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r524521862", "bodyText": "Could we consider the alternative of having an ScoringForTest class (defined in test code that extends Scoring and override the getter methods), to inject a Scoring with some injected values? In this way, we could diminish the production code related with testing", "author": "ajlopezrsk", "createdAt": "2020-11-16T19:33:33Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringInformation.java", "diffHunk": "@@ -45,10 +47,38 @@ public PeerScoringInformation(PeerScoring scoring, String id, String type) {\n         this.id = id;\r\n     }\r\n \r\n+    @VisibleForTesting\r\n+    public PeerScoringInformation(String type, boolean goodReputation,\r", "originalCommit": "a6ff65e68892aea71302bb814bfee258d9d84d8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMTM5OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527001398", "bodyText": "well, the fact is that I think a class should only have one simple constructor and any other complex construction should be a static method. It's more transparent and it's unified.\nI don't think extending and overriding it's a good practice, I'd rather contruct them in auxiliary methods on test classes", "author": "fedejinich", "createdAt": "2020-11-19T15:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1MzM2OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527053368", "bodyText": "Well, you can do that, for static factory methods, that ARE INVOLVED in production use case. It is not the case with this one, AFAIK. It could be better to move all this to test code; the way I suggested in my previous comment removes any test-oriented-and-only-used-to-test code from production code", "author": "ajlopezrsk", "createdAt": "2020-11-19T17:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5MjkwNQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527092905", "bodyText": "there is a factory method: construct a PeerScoringInformation given a Scoring object. I agree we should remove test oriented stuff from prod, and we also need to use constructors in a more transparent way", "author": "fedejinich", "createdAt": "2020-11-19T18:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEwMjQyOQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527102429", "bodyText": "fc09e75", "author": "fedejinich", "createdAt": "2020-11-19T18:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyMTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMTA3NQ==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527921075", "bodyText": "id.toString() doesn't do this?", "author": "patogallaiovlabs", "createdAt": "2020-11-20T19:19:32Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringManager.java", "diffHunk": "@@ -241,18 +260,37 @@ public PeerScoring getPeerScoring(InetAddress address) {\n     }\r\n \r\n     /**\r\n-     * Calculates the reputation for a peer\r\n-     * Starts punishment if needed\r\n-     *\r\n-     * @param scoring       the peer scoring\r\n-     * @param calculator    the calculator to use\r\n+     * Records an event and starts punishment if needed\r\n+     * @param peerScoring the peer scoring\r\n+     * @param event an event type\r\n+     * @param punishmentCalculator calculator to use\r\n+     * @param nodeID a node id\r\n      */\r\n-    private void recordEvent(PeerScoring scoring, EventType event, PunishmentCalculator calculator) {\r\n-        scoring.recordEvent(event);\r\n-        boolean reputation = scoringCalculator.hasGoodReputation(scoring);\r\n+    private void recordEventAndStartPunishment(PeerScoring peerScoring, EventType event, PunishmentCalculator punishmentCalculator, NodeID nodeID) {\r\n+        peerScoring.recordEvent(event);\r\n+\r\n+        boolean shouldStartPunishment = !scoringCalculator.hasGoodReputation(peerScoring) && peerScoring.hasGoodReputation();\r\n+        if (shouldStartPunishment) {\r\n+            long punishmentTime = punishmentCalculator.calculate(peerScoring.getPunishmentCounter(), peerScoring.getScore());\r\n+            peerScoring.startPunishment(punishmentTime);\r\n+\r\n+            String nodeIDFormated = nodeIdForLog(nodeID);\r\n+            logger.debug(\"NodeID {} has been punished for {} milliseconds. Last event {}\", nodeIDFormated, punishmentTime, event);\r\n+            logger.debug(\"{}\", PeerScoringInformation.buildByScoring(peerScoring, nodeIDFormated, \"\"));\r\n+        }\r\n+    }\r\n+\r\n+    private String nodeIdForLog(NodeID id) {\r\n+        if(id == null) {\r\n+            return \"NO_NODE_ID\";\r\n+        }\r\n+        return ByteUtil.toHexString(id.getID());\r", "originalCommit": "6bb971acf84f9fc41a6289965b70202b6da4a833", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyNzM3Nw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527927377", "bodyText": "5dd4f96", "author": "fedejinich", "createdAt": "2020-11-20T19:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjAxMw==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527922013", "bodyText": "why do you need equals and hash?", "author": "patogallaiovlabs", "createdAt": "2020-11-20T19:21:17Z", "path": "rskj-core/src/main/java/co/rsk/scoring/PeerScoringReputationSummary.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package co.rsk.scoring;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * This is a presentational object\n+ * It's used to expose a json rpc message (sco_badReputationSummary())\n+ */\n+public class PeerScoringReputationSummary {\n+    private int count;\n+    private int successfulHandshakes;\n+    private int failedHandshakes;\n+    private int invalidHeader;\n+    private int validBlocks;\n+    private int invalidBlocks;\n+    private int validTransactions;\n+    private int invalidTransactions;\n+    private int invalidNetworks;\n+    private int invalidMessages;\n+    private int repeatedMessages;\n+    private int timeoutMessages;\n+    private int unexpectedMessages;\n+    private int peersTotalScore;\n+    private int punishments;\n+    private int goodReputationCount;\n+    private int badReputationCount;\n+\n+    public PeerScoringReputationSummary(int count,\n+                                        int successfulHandshakes,\n+                                        int failedHandshakes,\n+                                        int invalidNetworks,\n+                                        int repeatedMessages,\n+                                        int validBlocks,\n+                                        int validTransactions,\n+                                        int invalidBlocks,\n+                                        int invalidTransactions,\n+                                        int invalidMessages,\n+                                        int timeoutMessages,\n+                                        int unexpectedMessages,\n+                                        int invalidHeader,\n+                                        int peersTotalScore,\n+                                        int punishments,\n+                                        int goodReputationCount,\n+                                        int badReputationCount) {\n+        this.count = count;\n+        this.successfulHandshakes = successfulHandshakes;\n+        this.failedHandshakes = failedHandshakes;\n+        this.invalidHeader = invalidHeader;\n+        this.validBlocks = validBlocks;\n+        this.invalidBlocks = invalidBlocks;\n+        this.validTransactions = validTransactions;\n+        this.invalidTransactions = invalidTransactions;\n+        this.invalidNetworks = invalidNetworks;\n+        this.invalidMessages = invalidMessages;\n+        this.repeatedMessages = repeatedMessages;\n+        this.timeoutMessages = timeoutMessages;\n+        this.unexpectedMessages = unexpectedMessages;\n+        this.peersTotalScore = peersTotalScore;\n+        this.punishments = punishments;\n+        this.goodReputationCount = goodReputationCount;\n+        this.badReputationCount = badReputationCount;\n+    }\n+\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    public int getSuccessfulHandshakes() {\n+        return successfulHandshakes;\n+    }\n+\n+    public int getFailedHandshakes() {\n+        return failedHandshakes;\n+    }\n+\n+    public int getInvalidNetworks() {\n+        return invalidNetworks;\n+    }\n+\n+    public int getRepeatedMessages() {\n+        return repeatedMessages;\n+    }\n+\n+    public int getValidBlocks() {\n+        return validBlocks;\n+    }\n+\n+    public int getValidTransactions() {\n+        return validTransactions;\n+    }\n+\n+    public int getInvalidBlocks() {\n+        return invalidBlocks;\n+    }\n+\n+    public int getInvalidTransactions() {\n+        return invalidTransactions;\n+    }\n+\n+    public int getInvalidMessages() {\n+        return invalidMessages;\n+    }\n+\n+    public int getTimeoutMessages() {\n+        return timeoutMessages;\n+    }\n+\n+    public int getUnexpectedMessages() {\n+        return unexpectedMessages;\n+    }\n+\n+    public int getInvalidHeader() {\n+        return invalidHeader;\n+    }\n+\n+    public int getPeersTotalScore() {\n+        return peersTotalScore;\n+    }\n+\n+    public int getPunishments() {\n+        return punishments;\n+    }\n+\n+    public int getGoodReputationCount() {\n+        return goodReputationCount;\n+    }\n+\n+    public int getBadReputationCount() {\n+        return badReputationCount;\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+        if(!(object instanceof PeerScoringReputationSummary)) {\n+            return false;\n+        }\n+        PeerScoringReputationSummary p = (PeerScoringReputationSummary) object;\n+\n+        return getCount() == p.getCount() &&\n+                getFailedHandshakes() == p.getFailedHandshakes() &&\n+                getInvalidMessages() == p.getInvalidMessages() &&\n+                getInvalidNetworks() == p.getInvalidNetworks() &&\n+                getInvalidHeader() == p.getInvalidHeader() &&\n+                getInvalidBlocks() == p.getInvalidBlocks() &&\n+                getInvalidTransactions() == p.getInvalidTransactions() &&\n+                getSuccessfulHandshakes() == p.getSuccessfulHandshakes() &&\n+                getValidTransactions() == p.getValidTransactions() &&\n+                getPunishments() == p.getPunishments() &&\n+                getPeersTotalScore() == p.getPeersTotalScore() &&\n+                getUnexpectedMessages() == p.getUnexpectedMessages() &&\n+                getTimeoutMessages() == p.getTimeoutMessages() &&\n+                getRepeatedMessages() == p.getRepeatedMessages() &&\n+                getValidBlocks() == p.getValidBlocks();", "originalCommit": "6bb971acf84f9fc41a6289965b70202b6da4a833", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyNjk4OA==", "url": "https://github.com/rsksmart/rskj/pull/1351#discussion_r527926988", "bodyText": "sonarcloud :(", "author": "fedejinich", "createdAt": "2020-11-20T19:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMjAxMw=="}], "type": "inlineReview"}, {"oid": "edcefede36d2c617b42d0f4bf29bebaecec52016", "url": "https://github.com/rsksmart/rskj/commit/edcefede36d2c617b42d0f4bf29bebaecec52016", "message": "used nodeId.toString()", "committedDate": "2020-11-20T20:54:22Z", "type": "forcePushed"}, {"oid": "b128686f1c3c2e9481ce7c9d8b2c207c9114413f", "url": "https://github.com/rsksmart/rskj/commit/b128686f1c3c2e9481ce7c9d8b2c207c9114413f", "message": "used nodeId.toString()", "committedDate": "2020-11-25T19:57:13Z", "type": "forcePushed"}, {"oid": "493b8f59a804aec1792663b479d4d78e19ece49c", "url": "https://github.com/rsksmart/rskj/commit/493b8f59a804aec1792663b479d4d78e19ece49c", "message": "logs for peer scoring", "committedDate": "2020-12-01T18:37:44Z", "type": "commit"}, {"oid": "a34e0537a7cc715797407112c2a7f2e56db6641f", "url": "https://github.com/rsksmart/rskj/commit/a34e0537a7cc715797407112c2a7f2e56db6641f", "message": "maintainability", "committedDate": "2020-12-01T18:37:45Z", "type": "commit"}, {"oid": "5eb543d0c94adc754b73cc6155169b9afa3c271f", "url": "https://github.com/rsksmart/rskj/commit/5eb543d0c94adc754b73cc6155169b9afa3c271f", "message": "removed unnecesary log", "committedDate": "2020-12-01T18:37:46Z", "type": "commit"}, {"oid": "32caa389053f2eed3d27e3412a58709628cbdc09", "url": "https://github.com/rsksmart/rskj/commit/32caa389053f2eed3d27e3412a58709628cbdc09", "message": "fix sonar codesmells", "committedDate": "2020-12-01T18:37:47Z", "type": "commit"}, {"oid": "b541cbf942626a2734ae0ff2bd2b8f41e7d6e0f2", "url": "https://github.com/rsksmart/rskj/commit/b541cbf942626a2734ae0ff2bd2b8f41e7d6e0f2", "message": "removed logger class & added address to recordEvent log", "committedDate": "2020-12-01T18:37:48Z", "type": "commit"}, {"oid": "a26499d758af1e6193946a24b20f17e5d80d7d52", "url": "https://github.com/rsksmart/rskj/commit/a26499d758af1e6193946a24b20f17e5d80d7d52", "message": "added peer scoring summary service", "committedDate": "2020-12-01T18:37:49Z", "type": "commit"}, {"oid": "a9ab4b90efd7003d9b16d0d14145cbdcad98ea70", "url": "https://github.com/rsksmart/rskj/commit/a9ab4b90efd7003d9b16d0d14145cbdcad98ea70", "message": "expose json rpc method sco_badReputationSummary", "committedDate": "2020-12-01T18:37:50Z", "type": "commit"}, {"oid": "63f86de1aac1558a8a4f0f69437b84118b016329", "url": "https://github.com/rsksmart/rskj/commit/63f86de1aac1558a8a4f0f69437b84118b016329", "message": "sonarcloud fixies and more test cases", "committedDate": "2020-12-01T18:37:51Z", "type": "commit"}, {"oid": "8d06a0f8f14d9a90797e5989c3f477dd26b00f09", "url": "https://github.com/rsksmart/rskj/commit/8d06a0f8f14d9a90797e5989c3f477dd26b00f09", "message": "logging missing exceptions", "committedDate": "2020-12-01T18:37:52Z", "type": "commit"}, {"oid": "c8abbaa2702fcdb48b965ec5c4b1ab4665eb3c92", "url": "https://github.com/rsksmart/rskj/commit/c8abbaa2702fcdb48b965ec5c4b1ab4665eb3c92", "message": "now with reputation summary instead of bad reputation summary", "committedDate": "2020-12-01T18:37:53Z", "type": "commit"}, {"oid": "11ee5f8b5ab70c6c52ea61d5cfd0443ecdb44db0", "url": "https://github.com/rsksmart/rskj/commit/11ee5f8b5ab70c6c52ea61d5cfd0443ecdb44db0", "message": "removed testing constructor on PeerScoringInformation", "committedDate": "2020-12-01T18:37:54Z", "type": "commit"}, {"oid": "7d2a039f4b4f2866655851fda3493aa9083040be", "url": "https://github.com/rsksmart/rskj/commit/7d2a039f4b4f2866655851fda3493aa9083040be", "message": "logg address and nodeId on PeerScoringManager", "committedDate": "2020-12-01T18:37:54Z", "type": "commit"}, {"oid": "36e7038fda5891df5ee3ad49084cc17f7279b84f", "url": "https://github.com/rsksmart/rskj/commit/36e7038fda5891df5ee3ad49084cc17f7279b84f", "message": "removed testing logic from prod", "committedDate": "2020-12-01T18:37:55Z", "type": "commit"}, {"oid": "8614a4d32bc1c332762083beeb053f839ddbb4f2", "url": "https://github.com/rsksmart/rskj/commit/8614a4d32bc1c332762083beeb053f839ddbb4f2", "message": "remove unused import", "committedDate": "2020-12-01T18:37:56Z", "type": "commit"}, {"oid": "8f2eae6714cc66597d9c1a7ee9a83ab655d52b84", "url": "https://github.com/rsksmart/rskj/commit/8f2eae6714cc66597d9c1a7ee9a83ab655d52b84", "message": "used nodeId.toString()", "committedDate": "2020-12-01T18:37:57Z", "type": "commit"}, {"oid": "fb2faae359d42e271810981165d3dba637391b67", "url": "https://github.com/rsksmart/rskj/commit/fb2faae359d42e271810981165d3dba637391b67", "message": "summary every 5 minutes", "committedDate": "2020-12-01T18:37:58Z", "type": "commit"}, {"oid": "fb2faae359d42e271810981165d3dba637391b67", "url": "https://github.com/rsksmart/rskj/commit/fb2faae359d42e271810981165d3dba637391b67", "message": "summary every 5 minutes", "committedDate": "2020-12-01T18:37:58Z", "type": "forcePushed"}]}