{"pr_number": 2663, "pr_title": "Initial implementation of the authorizations endpoints", "pr_createdAt": "2020-02-09T15:14:41Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2663", "timeline": [{"oid": "0201ef1055fcdb9562939888dace1d8c650b6662", "url": "https://github.com/DSpace/DSpace/commit/0201ef1055fcdb9562939888dace1d8c650b6662", "message": "Initial implementation of the authorizations endpoints", "committedDate": "2020-02-09T14:56:42Z", "type": "commit"}, {"oid": "214d7dfc9b88e1cff51da6218a2559b216401a11", "url": "https://github.com/DSpace/DSpace/commit/214d7dfc9b88e1cff51da6218a2559b216401a11", "message": "DS-4413 complete implementation of the authz infrastructure and ITs", "committedDate": "2020-02-15T23:38:58Z", "type": "commit"}, {"oid": "4f20954e9d38401ebd50f70cf65d1d196ad1a7e4", "url": "https://github.com/DSpace/DSpace/commit/4f20954e9d38401ebd50f70cf65d1d196ad1a7e4", "message": "DS-4413 fix checkstyle and add ITs for the withdraw, reinstate and cclicense feature", "committedDate": "2020-02-16T15:59:29Z", "type": "commit"}, {"oid": "9a7f9e7ada1556525744f820bc7a50618ff914e0", "url": "https://github.com/DSpace/DSpace/commit/9a7f9e7ada1556525744f820bc7a50618ff914e0", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz", "committedDate": "2020-02-16T23:53:52Z", "type": "commit"}, {"oid": "3524f10cccd0672ae3343dd884b6bf97720b624b", "url": "https://github.com/DSpace/DSpace/commit/3524f10cccd0672ae3343dd884b6bf97720b624b", "message": "DS-4413 fix checkstyle and ITs after projection and IndexableObject refactoring", "committedDate": "2020-02-17T22:10:38Z", "type": "commit"}, {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "url": "https://github.com/DSpace/DSpace/commit/1d64d8932b15922f4baea4f81d77961d5471d7b9", "message": "DS-4413 exclude uniqueType from the json output", "committedDate": "2020-02-18T07:17:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382710649", "bodyText": "Please don't cache the ConfigurationService in a static variable reference. This will cause auto-reloading of the configuration to no longer work properly (i.e. this is a step backwards as the AuthorizationConfiguration would require restarting Tomcat to reload its configurations).  Additionally, keeping the configuration in a static variable means that no tests (unit or integration) can override the settings in AuthorizeConfiguration.\nInstead of doing this, just use DSpaceServicesFactory.getInstance().getConfigurationService() everywhere in this class where you require a static reference.  That will ensure reloading still works and you are always using the latest ConfigurationService instead of a local cache of it.", "author": "tdonohue", "createdAt": "2020-02-21T17:30:09Z", "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDc5Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382784793", "bodyText": "A local variable would work too, since a method invocation shouldn't last long enough to worry about someone changing the configuration.  This could help readability, and avoid exhausting the reader (or the author!) with repeated long expressions if the method uses more than one configuration property.", "author": "mwoodiupui", "createdAt": "2020-02-21T20:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwODY4Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382808686", "bodyText": "@mwoodiupui : yes, agreed for most classes/scenarios.  A local variable or @Autowired would normally be the best approach to getting the ConfigurationService & working with it.\nHowever this AuthorizeConfiguration class seems to be a Util style class...it's a ton of static methods that are one-line requests for a specific config value.  So, in this class, the above DSpaceServiceFactory one-liner is probably the best we can do.", "author": "tdonohue", "createdAt": "2020-02-21T21:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzAwMg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923002", "bodyText": "Hi @tdonohue I agree with you that this class is not ideal and it could nice to get ride of it in future I have avoided to do that to avoid to broad the scope of this PR and make it bigger than needed. The only change that I have had to introduce is the switch from the ConfigurationManager to the ConfigurationService to be able to easily change the configuration in the test. That said, the static reference to the ConfigurationService is not a problem for the reloading as this happen internally to the ConfigurationService itself. The issue would be to cache an actual value otherwise, it would mean that when a config file is changed the whole spring context is refreshed and this doesn't look to be the case. Anyway, I have introduced an IntegrationTest in the dspace-api to specifically test that see\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-021a0801128069441947b7de3acc859d\nBTW I haven't found test related to the reloadable configuration if you are aware of such test please give me direction maybe the extra methods added in the AbstractIntegrationTest\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-1be4c4783e30c75d0db54c3b3b049bfd\nalready exists elsewhere, otherwise it will be good have now a first test in place that touch also that aspect", "author": "abollini", "createdAt": "2020-02-22T16:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM2Mjc0MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r383362740", "bodyText": "@abollini : Tests for reloading configs exist in the dspace-services layer.  Here's the one that tests for an automatic reload. There's others in this same Test class that test other areas of configuration reload/population, etc. https://github.com/DSpace/DSpace/blob/master/dspace-services/src/test/java/org/dspace/servicemanager/config/DSpaceConfigurationServiceTest.java#L529\nI still have a strong preference for avoiding any static references to beans/classes.  It's really unnecessary here, since you can get a reference via the DSpaceServicesFactory rather than re-caching it locally.\nThat said, I'll let it slide here since you've added tests to prove that it works as expected, regardless of the static reference.", "author": "tdonohue", "createdAt": "2020-02-24T16:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTUxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382711515", "bodyText": "This init() can be removed. As noted above, we don't need/want a static reference to configurations.", "author": "tdonohue", "createdAt": "2020-02-21T17:32:00Z", "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;\n \n     /**\n      * Default constructor\n      */\n     private AuthorizeConfiguration() { }\n \n+    /**\n+     * Complete the initialization of the class retrieving a reference to the {@link ConfigurationService}. MUST be\n+     * called at the start of each method\n+     */\n+    private synchronized static void init() {", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzAyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923029", "bodyText": "as by above comment #2663 (comment), the current code is working. I prefer the current implementation that is a bit more efficient (avoiding to lookup in the spring context each time) and less verbose. Anyway, I'm open to switch to what you propose if needed", "author": "abollini", "createdAt": "2020-02-22T16:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMjAzMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382712031", "bodyText": "Here's where you could just replace this line with:\nreturn DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"core.authorization.community-admin.group\", true);\nThis same replacement will work for all the static methods in this class.", "author": "tdonohue", "createdAt": "2020-02-21T17:33:12Z", "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;\n \n     /**\n      * Default constructor\n      */\n     private AuthorizeConfiguration() { }\n \n+    /**\n+     * Complete the initialization of the class retrieving a reference to the {@link ConfigurationService}. MUST be\n+     * called at the start of each method\n+     */\n+    private synchronized static void init() {\n+        if (configurationService != null) {\n+            return;\n+        }\n+        configurationService = new DSpace().getConfigurationService();\n+    }\n     /**\n      * Are community admins allowed to create new, not strictly community\n      * related, group?\n      *\n      * @return true/false\n      */\n     public static boolean canCommunityAdminPerformGroupCreation() {\n-        return can_communityAdmin_group;\n+        init();\n+        return configurationService.getBooleanProperty(\"core.authorization.community-admin.group\", true);", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzA0Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923042", "bodyText": "see #2663 (comment)", "author": "abollini", "createdAt": "2020-02-22T16:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMjAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMzY2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382713669", "bodyText": "It'd be useful to provide an example ID in this JavaDocs, just to clarify the exact structure of this ID.  Documenting the exact format here is very important as later JavaDocs (in other methods) reference this method's Javadocs.", "author": "tdonohue", "createdAt": "2020-02-21T17:36:49Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to\n+ * use a specific {@link AuthorizationFeature} on a defined object. The target object must implement the\n+ * {@link IndexableObject} interface so to have an unique ID and type\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public class Authorization {\n+    /**\n+     * the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    private EPerson eperson;\n+\n+    /**\n+     * the feature that is authorized to be used\n+     */\n+    private AuthorizationFeature feature;\n+\n+    /**\n+     * the object where the feature can be used. Not null, for repository wide feature use the {@link Site} object\n+     */\n+    private BaseObjectRest object;\n+\n+    public Authorization() {\n+    }\n+\n+    public Authorization(EPerson eperson, AuthorizationFeature feature, BaseObjectRest object) {\n+        super();\n+        this.eperson = eperson;\n+        this.feature = feature;\n+        this.object = object;\n+    }\n+\n+\n+    /**\n+     * \n+     * @return the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    public EPerson getEperson() {\n+        return eperson;\n+    }\n+\n+    /**\n+     * \n+     * @param eperson\n+     *            the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    public void setEperson(EPerson eperson) {\n+        this.eperson = eperson;\n+    }\n+\n+    /**\n+     * \n+     * @return the feature that is authorized to be used\n+     */\n+    public AuthorizationFeature getFeature() {\n+        return feature;\n+    }\n+\n+    /**\n+     * \n+     * @param feature\n+     *            the feature that is authorized to be used\n+     */\n+    public void setFeature(AuthorizationFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * \n+     * @return the object where the feature can be used. Not null, for repository wide feature use the {@link Site}\n+     *         object\n+     */\n+    public BaseObjectRest getObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * \n+     * @param object\n+     *            the object where the feature can be used. Not null, for repository wide feature use the {@link Site}\n+     *            object\n+     */\n+    public void setObject(BaseObjectRest object) {\n+        this.object = object;\n+    }\n+\n+\n+    /**\n+     * \n+     * @return an unique business identifier generated by concatenation of eperson uuid (if any), feature name and\n+     *         object unique identifier", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzExMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923111", "bodyText": "done https://github.com/DSpace/DSpace/pull/2663/files#diff-209e8c68a7591c1623680a31cb45f289R105", "author": "abollini", "createdAt": "2020-02-22T16:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDg3OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382714878", "bodyText": "I think you mean the SiteRest object in this comment.  The Site object is not a valid BaseObjectRest object, but the SiteRest object is.", "author": "tdonohue", "createdAt": "2020-02-21T17:39:29Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.content.Site;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link Site} object for repository wide", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzE2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923166", "bodyText": "good catch! done https://github.com/DSpace/DSpace/pull/2663/files#diff-45b57d6b8d2a54bb77e65f0c311f6b23R32", "author": "abollini", "createdAt": "2020-02-22T16:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTA5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382715091", "bodyText": "Again, should reference SiteRest object, not Site", "author": "tdonohue", "createdAt": "2020-02-21T17:39:59Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeatureService.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.core.Context;\n+\n+/**\n+ * This service provides access to the Authorization Features and check if the feature is allowed or not in a specific\n+ * context and object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeatureService {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the requested\n+     * feature for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param feature\n+     *            the Authorization Feature to check\n+     * @param object\n+     *            the object target by the feature. Passing a null object always return false. To check repository wide\n+     *            feature pass the {@link Site} object", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzE5NQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923195", "bodyText": "https://github.com/DSpace/DSpace/pull/2663/files#diff-c00af5d5224a3d8f49b54340b8e563d9R34", "author": "abollini", "createdAt": "2020-02-22T16:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzc0NQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382717745", "bodyText": "It's unclear to me why this commented out block of code exists here?  It seems like you could remove it, and just add a inline comment (above the return statement) saying something like :\n// Loops through all features, returning any that match the given typeID", "author": "tdonohue", "createdAt": "2020-02-21T17:45:36Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/AuthorizationFeatureServiceImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+/**\n+ * This is the default implementation of the {@link AuthorizationFeatureService}. It is based on the spring autowiring\n+ * feature to discover all the features available in the system\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+@Service\n+public class AuthorizationFeatureServiceImpl implements AuthorizationFeatureService {\n+    @Autowired\n+    private List<AuthorizationFeature> features;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, AuthorizationFeature feature, BaseObjectRest object)\n+            throws SQLException {\n+        if (object == null) {\n+            // the authorization interface require that the object is not null\n+            return false;\n+        }\n+\n+        if (feature == null\n+                || !ArrayUtils.contains(feature.getSupportedTypes(), object.getUniqueType())) {\n+            return false;\n+        }\n+\n+        return feature.isAuthorized(context, object);\n+    }\n+\n+    @Override\n+    public List<AuthorizationFeature> findAll() {\n+        return features;\n+    }\n+\n+    @Override\n+    public AuthorizationFeature find(String name) {\n+        for (AuthorizationFeature feature : features) {\n+            if (StringUtils.equals(name, feature.getName())) {\n+                return feature;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<AuthorizationFeature> findByResourceType(String typeID) {\n+        return features\n+                .stream()\n+                .filter(f -> ArrayUtils.contains(f.getSupportedTypes(), typeID))\n+                .collect(Collectors.toList());\n+//        List<AuthorizationFeature> foundFeatures = new ArrayList<AuthorizationFeature>();\n+//        for (AuthorizationFeature f : features) {\n+//            if (ArrayUtils.contains(f.getSupportedTypes(), typeID)) {\n+//                foundFeatures.add(f);\n+//            }\n+//        }\n+//        return foundFeatures;", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzI3NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923274", "bodyText": "yes, it is just the old style syntax as during development I was fighting with a bug and become unsure about the \"more elegant\" code. I removed it and put the comment that you suggest also aligning the parameter name to the one used by the interface (with improved javadoc)\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-c00af5d5224a3d8f49b54340b8e563d9R62\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-1acc1abfa758f7912a88470a71f817d5R72", "author": "abollini", "createdAt": "2020-02-22T16:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMTgxMw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382721813", "bodyText": "This bit of code looks very odd at a glance. Could you add an inline comment to describe it?\nIt looks like you are setting the user to the current user by default, but then changing it to the epersonUuid user when that is not null.", "author": "tdonohue", "createdAt": "2020-02-21T17:55:01Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzM3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923373", "bodyText": "I have added comment and take the chance to refactor the code removing duplication across the two search methods see\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-f9a2e78906cc332239e9cf5062428f3aR279", "author": "abollini", "createdAt": "2020-02-22T16:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMTgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMjc3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382722777", "bodyText": "This line also looks odd at a glance. It needs an inline comment to describe the logic here.  Something like\n// Temporarily change the Context's current user in order to retrieve authorizations based on that user", "author": "tdonohue", "createdAt": "2020-02-21T17:57:01Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMzM5MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382923390", "bodyText": "done, see also #2663 (comment)", "author": "abollini", "createdAt": "2020-02-22T16:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMzU2NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382723564", "bodyText": "Please add Javadocs or inline comments to this method. It's quite complex and has no inline comments, making it difficult to follow the logic here.", "author": "tdonohue", "createdAt": "2020-02-21T17:58:51Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            @Parameter(value = \"feature\", required = true) String featureName,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);\n+        AuthorizationFeature feature = authorizationFeatureService.find(featureName);\n+        AuthorizationRest authorizationRest = null;\n+        if (authorizationFeatureService.isAuthorized(context, feature, obj)) {\n+            Authorization authz = new Authorization();\n+            authz.setEperson(user);\n+            authz.setFeature(feature);\n+            authz.setObject(obj);\n+            authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+        }\n+        context.setCurrentUser(currUser);\n+        return authorizationRest;\n+    }\n+\n+    private BaseObjectRest getObject(Context context, String uri) throws SQLException {", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDQyNw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924427", "bodyText": "This is indeed an useful method that could be easily needed in other endpoint, I have made it public, moved to the org.dspace.app.rest.utils.Utils class and added javadoc. See https://github.com/DSpace/DSpace/pull/2663/files#diff-6fdce65db891f81afe28b714fe8ddddaR740", "author": "abollini", "createdAt": "2020-02-22T16:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzM2OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382727368", "bodyText": "This JavaDocs needs updating, as FindableObject was removed.", "author": "tdonohue", "createdAt": "2020-02-21T18:07:34Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that deal with resources that can be make\n+ * {@link FindableObject}", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDQ2NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924464", "bodyText": "done, https://github.com/DSpace/DSpace/pull/2663/files#diff-431cf6863613e58075585b11aa41cb2eR17", "author": "abollini", "createdAt": "2020-02-22T16:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzQ5Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382727492", "bodyText": "Please add JavaDocs to the two methods in this interface.", "author": "tdonohue", "createdAt": "2020-02-21T18:07:52Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that deal with resources that can be make\n+ * {@link FindableObject}\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F>\n+ *            the FindableObject type\n+ * @param <PK>\n+ *            the primary key type\n+ */\n+public interface FindableObjectRepository<T extends ReloadableEntity<PK>,\n+    PK extends Serializable> {\n+\n+    T findDomainObjectByPk(Context context, PK id) throws SQLException;\n+\n+    Class<PK> getPKClass();", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyODY2MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382728661", "bodyText": "Since this is only checking for READ permission, shouldn't this be named something like ReadAuthorizationPermissionEvaluatorPlugin?  Or maybe just ReadPermissionEvaluatorPlugin?", "author": "tdonohue", "createdAt": "2020-02-21T18:10:32Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/AuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class AuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyOTQxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382729415", "bodyText": "I don't quite understand this change.  Should we update the Javadocs description of this Regex to describe the format it expects?  Or maybe give an example or two.", "author": "tdonohue", "createdAt": "2020-02-21T18:12:06Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java", "diffHunk": "@@ -22,7 +22,7 @@ private RegexUtils(){}\n      * identifier (digits or uuid)\n      */\n     public static final String REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG = \"/{id:^(?!^\\\\d+$)\" +\n-        \"(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)[\\\\w+\\\\-]+$+}\";\n+        \"(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)[\\\\w+\\\\-\\\\.]+$+}\";", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyMDc1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382920757", "bodyText": "well I don't know really how to improve the javadoc here. It should be everything that is not an UUID or a digit. My fix is to be sure that identifier containing a dot (\".\") are allowed as for instance\n8c7b9132-eadc-4199-af6d-3260a678e96f_withdrawItem_core.item_c8924526-67ef-479a-8e37-dd8d19e625e9 that by accident can be the identifier of an authorization", "author": "abollini", "createdAt": "2020-02-22T15:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyOTQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwNTgzNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r383405836", "bodyText": "Ok, this makes sense to me & seems reasonable. Prior to enhanced JavaDocs, I wasn't aware that these identifiers could have dots/periods.", "author": "tdonohue", "createdAt": "2020-02-24T17:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyOTQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMDU2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382730566", "bodyText": "These tests in this IT all look good, but they all assume you already have admin permissions. Shouldn't we have at least a few tests here to verify the proper errors are thrown if you are unauthenticated or logged in as a non-admin?", "author": "tdonohue", "createdAt": "2020-02-21T18:14:36Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationFeatureRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization Feature endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationFeatureRestRepositoryIT extends AbstractControllerIntegrationTest {\n+    @Autowired\n+    private AuthorizationFeatureService authzFeatureService;\n+\n+    @Test\n+    /**\n+     * All the features should be returned\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+        int expReturn = featuresNum > 20 ? 20 : featuresNum;\n+        String adminToken = getAuthToken(admin.getEmail(), password);", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDkwNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924905", "bodyText": "As these use cases where very quick to test (1 line of code) they are tested at the end of the method (also for the findOne and the search methods) to avoid to slow the test phase without adding to much value. If you thing that is better to have them in a dedicated method I will do. The current test are here\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R57\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R59\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R117\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R120\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R129\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R131\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R160\nhttps://github.com/DSpace/DSpace/pull/2663/files#diff-96e7d07bd9f65de53e27a7847cecc571R164", "author": "abollini", "createdAt": "2020-02-22T16:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMDU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM2NTYzMg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r383365632", "bodyText": "@abollini : could you please just add a comment at the end of findAll() to say something like \"Non-admin tests are performed below in ____  (reference the methods where they are done)\".  It makes it easier for others to realize that you purposefully chose not to repeat the same tests -- otherwise, I tend to assume you may have accidentally forgotten them.", "author": "tdonohue", "createdAt": "2020-02-24T16:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMDU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNDIxNA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393504214", "bodyText": "I have added comments to note which scenario is tested from time to time (admin, normal user, anonymous). As it is the line below your comment it is not shown as outdated", "author": "abollini", "createdAt": "2020-03-17T08:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMjg5OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382732899", "bodyText": "The PR #2668 is now merged, so these commented out tests should be reenabled.", "author": "tdonohue", "createdAt": "2020-02-21T18:19:38Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDYyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924629", "bodyText": "81b9a18", "author": "abollini", "createdAt": "2020-02-22T16:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzMyNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733326", "bodyText": "We should remove System.out statements", "author": "tdonohue", "createdAt": "2020-02-21T18:20:31Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NzQ5OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382787498", "bodyText": "I would use logging at DEBUG level, if there is any possibility of wanting to debug this again, and just leave it in.", "author": "mwoodiupui", "createdAt": "2020-02-21T20:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDYwMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924601", "bodyText": "switched to log.debug", "author": "abollini", "createdAt": "2020-02-22T16:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzQ1MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733450", "bodyText": "Another System.out to remove", "author": "tdonohue", "createdAt": "2020-02-21T18:20:47Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", admin.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\"))\n+            .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A test community\").build();\n+        CommunityRest comRest = converterService.toRest(com, converterService.getProjection(DefaultProjection.NAME));\n+        String comUri = utils.linkToSingleResource(comRest, \"self\").getHref();\n+        context.restoreAuthSystemState();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(admin.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works return 204 No Content when a feature is not granted\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureNotGrantedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", alwaysFalse.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 204 No Content code when the requested object doesn't exist but the uri\n+     * is potentially valid (i.e. deleted object) or the feature doesn't exist\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectAndFeatureTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI or feature (required\n+     * parameters)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDU5MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924590", "bodyText": "switched to log.debug", "author": "abollini", "createdAt": "2020-02-22T16:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzU3MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733571", "bodyText": "Again, these tests can be reenabled", "author": "tdonohue", "createdAt": "2020-02-21T18:21:03Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", admin.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\"))\n+            .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A test community\").build();\n+        CommunityRest comRest = converterService.toRest(com, converterService.getProjection(DefaultProjection.NAME));\n+        String comUri = utils.linkToSingleResource(comRest, \"self\").getHref();\n+        context.restoreAuthSystemState();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(admin.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works return 204 No Content when a feature is not granted\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureNotGrantedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", alwaysFalse.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 204 No Content code when the requested object doesn't exist but the uri\n+     * is potentially valid (i.e. deleted object) or the feature doesn't exist\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectAndFeatureTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI or feature (required\n+     * parameters)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName()))\n+                .andExpect(status().isBadRequest());\n+        }\n+\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDU2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924563", "bodyText": "81b9a18", "author": "abollini", "createdAt": "2020-02-22T16:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNTE3Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382735172", "bodyText": "All these private AuthorizationFeature variables were initially confusing to me, as it wasn't clear these were real test data classes.  Since this alwaysFalse feature is actually represented by the AlwaysFalseFeature class, I wonder if we should reference it here by that class.  Otherwise, this IT looks a little confusing, as it's unclear what test classes it's using.", "author": "tdonohue", "createdAt": "2020-02-21T18:24:32Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNDQ5OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382924499", "bodyText": "I have added javadoc on top of these attributes to clarify, I would prefer to don't use the concrete class here to avoid a cast in the setUp method but feel free to re-ask for that if you feel more comfortable in this other way", "author": "abollini", "createdAt": "2020-02-22T16:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwNjE2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r383406166", "bodyText": "Javadocs are a good solution here. Thanks!", "author": "tdonohue", "createdAt": "2020-02-24T17:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNzAwOQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382737009", "bodyText": "I'm unclear why this change is needed.  It's not obvious to me where this is being used in this PR.", "author": "tdonohue", "createdAt": "2020-02-21T18:28:18Z", "path": "dspace-api/src/main/java/org/dspace/discovery/IndexableObject.java", "diffHunk": "@@ -21,7 +21,7 @@\n  * @param <PK>\n  *            the Class of the primary key\n  */\n-public interface IndexableObject<T extends ReloadableEntity, PK extends Serializable> {\n+public interface IndexableObject<T extends ReloadableEntity<PK>, PK extends Serializable> {", "originalCommit": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMjE4OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382902188", "bodyText": "it is not a real change, I have only noted that the reference to the generic ReloadableEntity was not parameterized so I have added it to remove the warning", "author": "abollini", "createdAt": "2020-02-22T10:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNzAwOQ=="}], "type": "inlineReview"}, {"oid": "de8e3ec93bee615195cc219f4b99b9679675beff", "url": "https://github.com/DSpace/DSpace/commit/de8e3ec93bee615195cc219f4b99b9679675beff", "message": "Add IT to proof that the AuthorizeConfiguration support the config reload", "committedDate": "2020-02-22T14:39:20Z", "type": "commit"}, {"oid": "6acfd30d1509902f0063fa96001edfba0d7474a7", "url": "https://github.com/DSpace/DSpace/commit/6acfd30d1509902f0063fa96001edfba0d7474a7", "message": "Code cleanup and improved documentation", "committedDate": "2020-02-22T15:40:08Z", "type": "commit"}, {"oid": "d797ab0407df2d0003285bc9dd488cbb9343ba36", "url": "https://github.com/DSpace/DSpace/commit/d797ab0407df2d0003285bc9dd488cbb9343ba36", "message": "track the reset of the local.cfg file", "committedDate": "2020-02-22T15:40:47Z", "type": "commit"}, {"oid": "2726bc627776de8e55444958d2177695906954fc", "url": "https://github.com/DSpace/DSpace/commit/2726bc627776de8e55444958d2177695906954fc", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz", "committedDate": "2020-02-22T15:52:13Z", "type": "commit"}, {"oid": "81b9a18e81d517db887273eba09b6ca97483b248", "url": "https://github.com/DSpace/DSpace/commit/81b9a18e81d517db887273eba09b6ca97483b248", "message": "Enable additional test for bad request", "committedDate": "2020-02-22T16:02:53Z", "type": "commit"}, {"oid": "61cd47107975ed1d49283252d4f60b8604424ac5", "url": "https://github.com/DSpace/DSpace/commit/61cd47107975ed1d49283252d4f60b8604424ac5", "message": "remove unused field", "committedDate": "2020-02-22T16:04:29Z", "type": "commit"}, {"oid": "adfe2b6959a89763d573652939ad0f28846a561f", "url": "https://github.com/DSpace/DSpace/commit/adfe2b6959a89763d573652939ad0f28846a561f", "message": "Move the getBaseObjectRestFromUri method to the Utils class and add javadoc", "committedDate": "2020-02-22T16:26:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxMTc1OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384511758", "bodyText": "Where did the 5.5 seconds originate from?\nIs this because the configuration will auto-verify every 5 seconds, or will this be dependent on the responsiveness of the environment?\nSince each call to appendToLocalConfiguration increases test duration and each destroy after the appendToLocalConfiguration was call will also increase test duration, I would prefer to add a warning to minimize use of this method", "author": "benbosman", "createdAt": "2020-02-26T14:05:46Z", "path": "dspace-api/src/test/java/org/dspace/AbstractIntegrationTest.java", "diffHunk": "@@ -21,5 +32,96 @@\n  */\n @Ignore\n public class AbstractIntegrationTest extends AbstractUnitTest {\n-    // This class intentionally left blank.\n+\n+    /**\n+     * holds the size of the local.cfg file, see {@link #cleanExtraConfigurations()}\n+     **/\n+    private long initialLocalCfgSize;\n+\n+    /**\n+     * set to true if the local cfg has been manipulated\n+     */\n+    private boolean localCfgChanged = false;\n+\n+    @Override\n+    @Before\n+    /**\n+     * Extend the {@link AbstractUnitTest#init} method to deal with extra\n+     * configuration that can be manipulated at runtime during the Integration Test\n+     */\n+    public void init() {\n+        super.init();\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        FileChannel fileOpen;\n+        try {\n+            fileOpen = FileChannel.open(Paths.get(extraConfPath), StandardOpenOption.READ);\n+            initialLocalCfgSize = fileOpen.size();\n+            fileOpen.close();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    @After\n+    /**\n+     * Extend the {@link AbstractUnitTest#destroy} method to deal with extra\n+     * configurations that can be manipulated at runtime during the Integration Test\n+     */\n+    public void destroy() {\n+        super.destroy();\n+        cleanExtraConfigurations();\n+    }\n+\n+    /**\n+     * Restore the local.cfg file to its initial size\n+     */\n+    protected void cleanExtraConfigurations() {\n+        if (!localCfgChanged) {\n+            // return immediately as no changes have been applied so we can avoid to wait\n+            // for configuration reload\n+            return;\n+        }\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        try {\n+            FileChannel.open(Paths.get(extraConfPath), StandardOpenOption.WRITE)\n+                .truncate(initialLocalCfgSize).close();\n+            localCfgChanged = false;\n+            // sleep for 5.5 seconds to give the time to the configuration to note the change\n+            Thread.sleep(5500);\n+        } catch (IOException | InterruptedException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @return the full path to the in use local.cfg file\n+     */\n+    private String getLocalConfigurationFilePath() {\n+        return new DSpace().getConfigurationService()\n+                .getProperty(\"dspace.dir\") + \"/config/local.cfg\";\n+    }\n+\n+    /**\n+     * Append the input text to the current local.cfg file assuring\n+     * that the new text goes in a new line and sleep enough time to allow the\n+     * configuration reload\n+     * \n+     * @param textToAppend\n+     */\n+    protected void appendToLocalConfiguration(String textToAppend) {\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        try (Writer output = new BufferedWriter(new FileWriter(extraConfPath, true))) {\n+            output.append(\"\\n\");\n+            output.append(textToAppend);\n+            output.flush();\n+            output.close();\n+            localCfgChanged = true;\n+            // sleep for 5.5 seconds to give the time to the configuration to note the change\n+            Thread.sleep(5500);", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTI3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384599276", "bodyText": "DSpace's default configuration for Apache Commons Configuration auto-reloads every 5 seconds.  See our config-definition.xml here:    https://github.com/DSpace/DSpace/blob/master/dspace/config/config-definition.xml#L47-L48\nSo, I suspect that's why 5.5 was chosen here.  However, a comment could be added here to note that this number is based on the configured reload delay in our config-definition.xml", "author": "tdonohue", "createdAt": "2020-02-26T16:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxMTc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjQxMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392411", "bodyText": "done", "author": "abollini", "createdAt": "2020-03-08T18:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxMTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNjE0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384516146", "bodyText": "Since this is bound to an EPerson, how will this impact special groups?\nPerhaps this can be sorted out with an IT verifying for a user who's permissions are granted via a special group (e.g. using IPAuthentication or password authentication)", "author": "benbosman", "createdAt": "2020-02-26T14:12:57Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjYzNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392635", "bodyText": "special groups can only be seen for the current loggedin user as they are more related to the current session (from which ip, with which auth method I'm loggedin etc). I have added IT and fixes to deal with such use case see this build failure https://travis-ci.org/4Science/DSpace/builds/659848212?utm_medium=notification&utm_source=github_status and subsequent success https://travis-ci.org/4Science/DSpace/builds/659864966?utm_medium=notification&utm_source=github_status", "author": "abollini", "createdAt": "2020-03-08T18:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkyMDE4OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390920188", "bodyText": "Thanks, that looks like a test solution to verify the special groups", "author": "benbosman", "createdAt": "2020-03-11T11:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNjE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDQyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384520421", "bodyText": "Could you also add a description for at least some of the features, this is currently not used", "author": "benbosman", "createdAt": "2020-02-26T14:19:38Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link SiteRest} object for repository\n+     *            wide feature\n+     * @return true if the user associated with the context has access to the feature for the specified object\n+     */\n+    boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException;\n+\n+    /**\n+     * Return the name of the feature\n+     * \n+     * @return the name of the feature\n+     */\n+    default String getName() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.name();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the description of the feature\n+     *\n+     * @return the description of the feature\n+     */\n+    default String getDescription() {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjY0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392646", "bodyText": "done", "author": "abollini", "createdAt": "2020-03-08T18:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNzgyMw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384527823", "bodyText": "Can you add a description here, this feature is not clear based on the name alone. The JavaDocs are quite clear and would be a good start except for the fact that I wasn't sure whether this is limited to archived items", "author": "benbosman", "createdAt": "2020-02-26T14:31:15Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CCLicenseFeature.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The cclicense feature. It can be used by administrators (or community/collection delegate) to manage the Creative\n+ * Commons license for an item\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CCLicenseFeature.NAME)", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjY1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392651", "bodyText": "I reused here the javadoc, I'm myself not sure about the fact that this feature should be limited to archived items. In this PR I'm not going to change any existing behavior and the current java api doesn't put any protection in place to limit this feature to archived items. I agree with you that it could be appropriate to clarify that aspect but it is better to do that in the scope of the CCLicense feature implementation, I haven't found an angular task for that so I created DSpace/dspace-angular#612", "author": "abollini", "createdAt": "2020-03-08T18:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNzgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzOTM1MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384539350", "bodyText": "Can you add a comment clearly stating this user can be null", "author": "benbosman", "createdAt": "2020-02-26T14:48:29Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjY2OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392668", "bodyText": "done", "author": "abollini", "createdAt": "2020-03-08T18:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzOTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTcxMA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384541710", "bodyText": "If the current context contains special groups, but they're not applicable for the included user (admins requesting permissions of other users), those special groups seem to be used to verify the user is authorized\nCan you add an IT for this use case, and resolve this if it's indeed a problem (e.g. temporarily removing the special groups for the test and making sure they're not permanently removed)", "author": "benbosman", "createdAt": "2020-02-26T14:51:44Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjczNw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392737", "bodyText": "good catch, added the test method verifySpecialGroupMembershipTest\nsee this build failure https://travis-ci.org/4Science/DSpace/builds/659848212?utm_medium=notification&utm_source=github_status and subsequent success https://travis-ci.org/4Science/DSpace/builds/659864966?utm_medium=notification&utm_source=github_status", "author": "abollini", "createdAt": "2020-03-08T18:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkyMjM5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390922391", "bodyText": "Thanks, this looks like a good solution to catch the special groups, and the IT proves it as well", "author": "benbosman", "createdAt": "2020-03-11T11:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDk3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384544973", "bodyText": "The Javadocs don't match the method parameters here", "author": "benbosman", "createdAt": "2020-02-26T14:56:22Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjc0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392746", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzAwOA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547008", "bodyText": "Similar to above, can you check the impact of special groups", "author": "benbosman", "createdAt": "2020-02-26T14:59:17Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjc3NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392774", "bodyText": "yes, done #2663 (comment)", "author": "abollini", "createdAt": "2020-03-08T18:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzE5Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547197", "bodyText": "Similar to above, can you check the impact of special groups", "author": "benbosman", "createdAt": "2020-02-26T14:59:34Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            @Parameter(value = \"feature\", required = true) String featureName,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        AuthorizationFeature feature = authorizationFeatureService.find(featureName);\n+        AuthorizationRest authorizationRest = null;\n+        if (authorizationFeatureService.isAuthorized(context, feature, obj)) {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjc5Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392793", "bodyText": "yes, done see #2663 (comment)", "author": "abollini", "createdAt": "2020-03-08T18:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzMyNw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547327", "bodyText": "The Javadocs don't match the method parameters here", "author": "benbosman", "createdAt": "2020-02-26T14:59:47Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjc1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392759", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0ODY2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384548663", "bodyText": "Isn't this a ReloadableEntityObjectRepository? Findable sounds like it's search related", "author": "benbosman", "createdAt": "2020-02-26T15:01:39Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that need to\n+ * provide access to the DSpace API model objects corresponding to the REST\n+ * resources that it manages\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F> the ReloadableEntity type\n+ * @param <PK> the primary key type\n+ */\n+public interface FindableObjectRepository<T extends ReloadableEntity<PK>,", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjc5OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392798", "bodyText": "yes, I have applied the suggested rename", "author": "abollini", "createdAt": "2020-03-08T18:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0ODY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MjY5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384552691", "bodyText": "Why is this not based on context.getCurrentUser()?", "author": "benbosman", "createdAt": "2020-02-26T15:07:53Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/ReadAuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class ReadAuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ReadAuthorizationPermissionEvaluatorPlugin.class);\n+\n+    @Autowired\n+    AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Override\n+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,\n+            DSpaceRestPermission permission) {\n+\n+        DSpaceRestPermission restPermission = DSpaceRestPermission.convert(permission);\n+\n+        if (!DSpaceRestPermission.READ.equals(restPermission)\n+                || !StringUtils.equalsIgnoreCase(targetType, AuthorizationRest.NAME)) {\n+            return false;\n+        }\n+\n+        Request request = requestService.getCurrentRequest();\n+        Context context = ContextUtil.obtainContext(request.getServletRequest());\n+        try {\n+            // admin can always access\n+            if (authorizeService.isAdmin(context)) {\n+                return true;\n+            }\n+            EPerson ePerson = authorizationRestUtil.getEperson(context, targetId.toString());\n+            EPerson currUser = null;\n+\n+            currUser = ePersonService.findByEmail(context, (String) authentication.getPrincipal());", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjgwMg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392802", "bodyText": "no reason indeed, fixed", "author": "abollini", "createdAt": "2020-03-08T18:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDE5NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384570194", "bodyText": "why is this a separate endpoint? According to the contract this should be part of the /object endpoint, and the feature is an optional parameter", "author": "benbosman", "createdAt": "2020-02-26T15:32:22Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjgwNw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392807", "bodyText": "in the contract update PR I have included this change. It makes much easier and clean the implementation and the testing", "author": "abollini", "createdAt": "2020-03-08T18:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzNTMwMw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390935303", "bodyText": "The impact for Angular is most likely limited, so this should work as well", "author": "benbosman", "createdAt": "2020-03-11T12:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDExOA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384584118", "bodyText": "Does this imply you can only request the \"features\" of resources you have read rights for?\nI was under the assumption this could be used to identify whether the current user has permissions to download a bitstream on the item which are displayed in DSpace 6 with a lock icon", "author": "benbosman", "createdAt": "2020-02-26T15:52:03Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg0OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392849", "bodyText": "Yes. We don't have enough information at this point to make a different decision. Limit access to the authorization object that indeed include the scope object to people that can READ the scope object make sense and is safe. For bitstream that you cannot completely READ (you can know that they exists but you cannot download them) we should find a suitable solution.\nEssentially we will need a way to differentiate between READ only metadata and READ content, the easier would probably be use READ for just metadata relaxing the permission evaluator for bitstreams to always trust user that have READ on the Item for \"normal bundle\" and introduce a DOWNLOAD permission that will really use the READ resourcepolicy on the bitstream. Again I recommend to put this discussion and the consequent implementation in a separate task", "author": "abollini", "createdAt": "2020-03-08T18:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzNDU5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390934591", "bodyText": "Could you in that case provide feedback in https://jira.lyrasis.org/browse/DS-4454 on how you'd expect it to be possible to identify whether the current user can download the bitstream?", "author": "benbosman", "createdAt": "2020-03-11T12:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NzE2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393497169", "bodyText": "https://jira.lyrasis.org/browse/DS-4454?focusedCommentId=64231&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-64231", "author": "abollini", "createdAt": "2020-03-17T07:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjM1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384636357", "bodyText": "Why is this being tested? Should this have been a test on epersonAuthToken to verify it's forbidden?", "author": "benbosman", "createdAt": "2020-02-26T17:08:55Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationFeatureRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization Feature endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationFeatureRestRepositoryIT extends AbstractControllerIntegrationTest {\n+    @Autowired\n+    private AuthorizationFeatureService authzFeatureService;\n+\n+    @Test\n+    /**\n+     * All the features should be returned\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+        int expReturn = featuresNum > 20 ? 20 : featuresNum;\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features\")).andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.features\", Matchers.hasSize(is(expReturn))))\n+                .andExpect(jsonPath(\"$._links.self.href\", Matchers.containsString(\"/api/authz/features\")))\n+                .andExpect(jsonPath(\"$.page.size\", is(20)))\n+                .andExpect(jsonPath(\"$.page.totalElements\", is(featuresNum)));\n+\n+        getClient().perform(get(\"/api/authz/features\")).andExpect(status().isUnauthorized());\n+\n+        String epersonAuthToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonAuthToken).perform(get(\"/api/authz/features\")).andExpect(status().isForbidden());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * The feature endpoint must provide proper pagination\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllWithPaginationTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        List<String> featureIDs = new ArrayList<String>();\n+        for (int page = 0; page < featuresNum; page++) {\n+            AtomicReference<String> idRef = new AtomicReference<String>();\n+\n+            getClient(adminToken)\n+                    .perform(get(\"/api/authz/features\").param(\"page\", String.valueOf(page)).param(\"size\", \"1\"))\n+                    .andExpect(status().isOk()).andExpect(jsonPath(\"$._embedded.features\", Matchers.hasSize(is(1))))\n+                    .andExpect(jsonPath(\"$._links.self.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(\n+                            (page == 0) ? jsonPath(\"$._links.prev.href\").doesNotExist()\n+                                    : jsonPath(\"$._links.prev.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect((page == featuresNum - 1)\n+                            ? jsonPath(\"$._links.next.href\").doesNotExist()\n+                            : jsonPath(\"$._links.next.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$._links.first.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$._links.last.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$.page.size\", is(1)))\n+                    .andExpect(jsonPath(\"$.page.totalElements\", is(Integer.valueOf(featuresNum))))\n+                    .andDo(result -> idRef\n+                            .set(read(result.getResponse().getContentAsString(), \"$._embedded.features[0].id\")));\n+\n+            if (idRef.get() == null || featureIDs.contains(idRef.get())) {\n+                fail(\"Duplicate feature \" + idRef.get() + \" returned at page \" + page);\n+            }\n+            featureIDs.add(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    /**\n+     * The feature resource endpoint must expose the proper structure and be reserved to administrators\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$.id\", is(\"withdrawItem\")))\n+                .andExpect(jsonPath(\"$.description\", Matchers.any(String.class)))\n+                .andExpect(jsonPath(\"$.resourcetypes\", Matchers.contains(\"core.item\")))\n+                .andExpect(jsonPath(\"$.type\", is(\"feature\")));\n+\n+        getClient().perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isUnauthorized());\n+\n+        String epersonAuthToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonAuthToken).perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    public void findOneNotFoundTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/not-existing-feature\")).andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/features/not-existing-feature\")).andExpect(status().isUnauthorized());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/1\")).andExpect(status().isNotFound());", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392868", "bodyText": "these test are to verify that the endpoint works properly when a not existing feature is requested. The /1 test is included to check an identifier of a different type than what we expect (an integer instead than a string)", "author": "abollini", "createdAt": "2020-03-08T18:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384998833", "bodyText": "This tests which features are not embedded, but doesn't verify which features are embedded. The same applies for tests below\nAlso, I don't expect anything to be embedded since no projection is requested", "author": "benbosman", "createdAt": "2020-02-27T09:18:31Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1170 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+            .getLogger(AuthorizationRestRepositoryIT.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysTrueFeature}\n+     */\n+    private AuthorizationFeature alwaysTrue;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysFalseFeature}\n+     */\n+    private AuthorizationFeature alwaysFalse;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysThrowExceptionFeature}\n+     */\n+    private AuthorizationFeature alwaysException;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForAdminsFeature}\n+     */\n+    private AuthorizationFeature trueForAdmins;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForLoggedUsersFeature}\n+     */\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForTestFeature}\n+     */\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjk1MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392950", "bodyText": "the reason why projection was not requested is because it was introduced after than these test were written. I have updated them now.\nI cannot test that the expected features are included because we don't know all of them in advance. We will add more and more features soon and I prefer to avoid the need to update such test for each new feature. Instead, it would be sufficient to verify that what is returned match the request.", "author": "abollini", "createdAt": "2020-03-08T18:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkyODEzNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390928136", "bodyText": "I noticed the $._embedded.feature is currently still not verifying which data is present (only which data is not present). The test would be more reliable if it can verify the expected features are present", "author": "benbosman", "createdAt": "2020-03-11T12:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NzI2Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393497262", "bodyText": "fixed", "author": "abollini", "createdAt": "2020-03-17T07:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0MDAwNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393640006", "bodyText": "@abollini where has this been fixed?", "author": "benbosman", "createdAt": "2020-03-17T12:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwODM5MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r395808390", "bodyText": "sorry, you are right the check were still missing. Added here 59b7716", "author": "abollini", "createdAt": "2020-03-20T18:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNDIwNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r396304206", "bodyText": "Thanks for the updates, that's really helpful.\nI think you missed one though: \n  \n    \n      DSpace/dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java\n    \n    \n         Line 536\n      in\n      59b7716\n    \n    \n    \n    \n\n        \n          \n           JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",", "author": "benbosman", "createdAt": "2020-03-23T09:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzgxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r385007815", "bodyText": "Wouldn't it be better to replace 100 with authzFeatureService.findAll().size() (same for the similar tests below)", "author": "benbosman", "createdAt": "2020-02-27T09:34:46Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1170 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+            .getLogger(AuthorizationRestRepositoryIT.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysTrueFeature}\n+     */\n+    private AuthorizationFeature alwaysTrue;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysFalseFeature}\n+     */\n+    private AuthorizationFeature alwaysFalse;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysThrowExceptionFeature}\n+     */\n+    private AuthorizationFeature alwaysException;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForAdminsFeature}\n+     */\n+    private AuthorizationFeature trueForAdmins;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForLoggedUsersFeature}\n+     */\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForTestFeature}\n+     */\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        for (String invalidUri : invalidUris) {\n+            log.debug(\"findByObjectBadRequestTest - Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+            .andExpect(status().isBadRequest());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjk1Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392952", "bodyText": "it doesn't really make a difference because we have an upper limit set by our pagination. I have preferred to avoid an extra call and also decided to set an explicit (reasonable limit) here with a commit so that if we hit it in future it should be easier to understand the issue. Using a larger value could stop to work when we will put in place a protection for our pagination to say \"refuse request with page larger than 100, 500 or...\".\nWhen (if) we will hit this limit we will need to run across all the pages to be sure to hit the exception", "author": "abollini", "createdAt": "2020-03-08T18:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkyODkxMg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390928912", "bodyText": "Do you expect the total amount of features to be > 100? If this is to be expected, it would be best to create a JIRA issue since we'd expect it to be a required modification", "author": "benbosman", "createdAt": "2020-03-11T12:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5OTcyNw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393499727", "bodyText": "https://jira.lyrasis.org/browse/DS-4463", "author": "abollini", "createdAt": "2020-03-17T08:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzcwMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r385013701", "bodyText": "I assume this should not be disabled here?", "author": "benbosman", "createdAt": "2020-02-27T09:44:31Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/CCLicenseFeatureRestIT.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.CCLicenseFeature;\n+import org.dspace.app.rest.builder.CollectionBuilder;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.ItemBuilder;\n+import org.dspace.app.rest.builder.ResourcePolicyBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.ResourcePolicy;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.core.Constants;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the ccLicense feature\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class CCLicenseFeatureRestIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature ccLicenseFeature;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ccLicenseFeature = authorizationFeatureService.find(CCLicenseFeature.NAME);\n+    }\n+\n+    @Test\n+    public void authorizedAsAdminTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A community\").build();\n+        Collection col = CollectionBuilder.createCollection(context, com).withName(\"A collection\").build();\n+        Item item = ItemBuilder.createItem(context, col).withTitle(\"Item to withdraw\").build();\n+        context.restoreAuthSystemState();\n+\n+        ItemRest itemRest = converterService.toRest(item, converterService.getProjection(DefaultProjection.NAME));\n+        String itemUri = utils.linkToSingleResource(itemRest, \"self\").getHref();\n+        Authorization authAdminCCLicense = new Authorization(admin, ccLicenseFeature, itemRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminCCLicense.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", itemUri)\n+                .param(\"eperson\", admin.getID().toString())\n+                .param(\"feature\", ccLicenseFeature.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\",\n+                    Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+    }\n+\n+    @Test\n+    public void checkAuthorizationAsCommunityAdminTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A community\").withAdminGroup(eperson)\n+                .build();\n+        Collection col = CollectionBuilder.createCollection(context, com).withName(\"A collection\").build();\n+        Item item = ItemBuilder.createItem(context, col).withTitle(\"Item to withdraw\").build();\n+        context.restoreAuthSystemState();\n+\n+        ItemRest itemRest = converterService.toRest(item, converterService.getProjection(DefaultProjection.NAME));\n+        String itemUri = utils.linkToSingleResource(itemRest, \"self\").getHref();\n+        Authorization authAdminCCLicense = new Authorization(eperson, ccLicenseFeature, itemRest);\n+\n+        // access the authorization for the community admin user\n+        String comAdminToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(comAdminToken).perform(get(\"/api/authz/authorizations/\" + authAdminCCLicense.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        getClient(comAdminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", itemUri)\n+                .param(\"eperson\", eperson.getID().toString())\n+                .param(\"feature\", ccLicenseFeature.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\",\n+                    Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        // verify that the property core.authorization.collection-admin.item-admin.cc-license = false is respected\n+        // the community admins should be still authorized\n+        configurationService.setProperty(\"core.authorization.item-admin.cc-license\", false);", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjk2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392966", "bodyText": "No it is intentional as stated in the comment. I'm testing that in the case the feature is reserved to the community administrator he can still access the feature, so I \"restrict\" the feature disabling access for item and collection admins", "author": "abollini", "createdAt": "2020-03-08T18:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzMDExNQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390930115", "bodyText": "But as far as I can see in the test, you're only testing for a collection admin and not an item admin. I would have only expected the change to core.authorization.collection-admin.item-admin.cc-license", "author": "benbosman", "createdAt": "2020-03-11T12:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwMTg5MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393501890", "bodyText": "the delegation of authorization require that you disable all the lower level to work. No changes on this, it works in this way also in the current version. If we turnoff \"only for collection admin\" without turnoff for item admins the collections admin will be still able to do as they are ALSO item admins.\nTest specific for collection admins and item admins are in the dedicated test methods\ncheckAuthorizationAsCollectionAdminTest\ncheckAuthorizationAsItemAdminTest", "author": "abollini", "createdAt": "2020-03-17T08:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzcwMQ=="}], "type": "inlineReview"}, {"oid": "be410e2cb885009cde9de287c09f1ed9c4629fcf", "url": "https://github.com/DSpace/DSpace/commit/be410e2cb885009cde9de287c09f1ed9c4629fcf", "message": "improve comments about all the managed scenarios", "committedDate": "2020-02-27T14:19:34Z", "type": "commit"}, {"oid": "cb83c4c1618a49c6b07d27be15e24270c318f82a", "url": "https://github.com/DSpace/DSpace/commit/cb83c4c1618a49c6b07d27be15e24270c318f82a", "message": "Clarify the reason of the sleep time", "committedDate": "2020-02-27T14:31:10Z", "type": "commit"}, {"oid": "9e08df614a0a71c223b05ccd3ebba9ae01e11276", "url": "https://github.com/DSpace/DSpace/commit/9e08df614a0a71c223b05ccd3ebba9ae01e11276", "message": "add description to the features", "committedDate": "2020-02-27T14:39:50Z", "type": "commit"}, {"oid": "0403f45dc1af7a21b3c7073f91c7c0ecf130b298", "url": "https://github.com/DSpace/DSpace/commit/0403f45dc1af7a21b3c7073f91c7c0ecf130b298", "message": "improve the comments clarifying the null scenario", "committedDate": "2020-02-27T14:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMjUxMA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387922510", "bodyText": "Why isn't this method using ItemRest.getUniqueType() instead of hardcoding the same value here?  I notice all the Feature classes in this PR are hardcoding their own getSupportedTypes(), instead of using the value(s) returned via getUniqueType()", "author": "tdonohue", "createdAt": "2020-03-04T20:42:42Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CCLicenseFeature.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The cclicense feature. It can be used by administrators (or community/collection delegate) to manage the Creative\n+ * Commons license for an item\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CCLicenseFeature.NAME)\n+public class CCLicenseFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"cclicense\";\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!(object instanceof ItemRest)) {\n+            return false;\n+        }\n+        Item item = (Item) utils.getDSpaceAPIObjectFromRest(context, object);\n+        try {\n+            AuthorizeUtil.authorizeManageCCLicense(context, item);\n+        } catch (AuthorizeException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String[] getSupportedTypes() {\n+        return new String[] { ItemRest.CATEGORY + \".\" + ItemRest.NAME };", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjk5NA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389392994", "bodyText": "Unfortunately it's an instance method not a static one so I cannot do that", "author": "abollini", "createdAt": "2020-03-08T18:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMjUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMzkxNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387923916", "bodyText": "I want to talk more about this method in tomorrow's meeting. But, this method should have JavaDocs to describe it, and especially how it differs from the existing RestModel.getType() method (and when to use one over the other).", "author": "tdonohue", "createdAt": "2020-03-04T20:45:34Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestAddressableModel.java", "diffHunk": "@@ -44,4 +44,9 @@ public Projection getProjection() {\n     public void setProjection(Projection projection) {\n         this.projection = projection;\n     }\n+\n+    @JsonIgnore\n+    public String getUniqueType() {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwMjIyNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393502226", "bodyText": "as agreed in the dev meeting I have created a ticket to cleanup that later\nhttps://jira.lyrasis.org/browse/DS-4460", "author": "abollini", "createdAt": "2020-03-17T08:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMzkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyNTE2Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387925162", "bodyText": "This JavaDocs is currently incorrect, as it's not using RestModel.getType(). Instead it's using RestAddressableModel.getUniqueType().  However, I'd like to discuss this more in tomorrow's meeting to decide on a final direction here... it currently seems odd to me to have both a getType() and a getUniqueType().", "author": "tdonohue", "createdAt": "2020-03-04T20:48:04Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link SiteRest} object for repository\n+     *            wide feature\n+     * @return true if the user associated with the context has access to the feature for the specified object\n+     */\n+    boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException;\n+\n+    /**\n+     * Return the name of the feature\n+     * \n+     * @return the name of the feature\n+     */\n+    default String getName() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.name();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the description of the feature\n+     *\n+     * @return the description of the feature\n+     */\n+    default String getDescription() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.description();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the supported object type according to the {@link RestModel#getType()}", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwMjI5Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393502297", "bodyText": "done", "author": "abollini", "createdAt": "2020-03-17T08:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyNTE2Mg=="}], "type": "inlineReview"}, {"oid": "8e975bc2289ca02dd04187647c2402c66e788074", "url": "https://github.com/DSpace/DSpace/commit/8e975bc2289ca02dd04187647c2402c66e788074", "message": "Rename FindableObjectRepository in ReloadableEntityObjectRepository", "committedDate": "2020-03-05T16:31:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDE3MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904171", "bodyText": "The IndexableObject is mentioned here, but it isn't used in this class, I assume it should be the \"BaseObjectRest\" ?", "author": "KevinVdV", "createdAt": "2020-03-06T13:33:42Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to\n+ * use a specific {@link AuthorizationFeature} on a defined object. The target object must implement the\n+ * {@link IndexableObject} interface so to have an unique ID and type", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzAxMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393011", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDM0OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904349", "bodyText": "What if the item is Null ?", "author": "KevinVdV", "createdAt": "2020-03-06T13:34:06Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/ReinstateFeature.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The reinstate feature. It can be used by administrators (or community/collection delegate) to reinstate an item that\n+ * was previously withdrawn\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = ReinstateFeature.NAME)\n+public class ReinstateFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"reinstateItem\";\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!(object instanceof ItemRest)) {\n+            return false;\n+        }\n+        Item item = (Item) utils.getDSpaceAPIObjectFromRest(context, object);\n+        if (!item.isWithdrawn()) {", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzMzOQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393339", "bodyText": "the AuthorizeFeatureService protects against NPE, it is stated in the interface contract (javadoc). I have added a test in the service test to demonstrate that as well see commit 4192b09", "author": "abollini", "createdAt": "2020-03-08T18:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDQ4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904489", "bodyText": "Perhaps add a small message here for the log ?", "author": "KevinVdV", "createdAt": "2020-03-06T13:34:26Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzAxNg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393016", "bodyText": "it is provided by the getFeatureName inside the IllegalArgumentException. For such reason the exception is stated in the method javadoc despite to be a runtime exception", "author": "abollini", "createdAt": "2020-03-08T18:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDkyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904921", "bodyText": "This param isn't used in this method.", "author": "KevinVdV", "createdAt": "2020-03-06T13:35:18Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0MQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393341", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDk3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904973", "bodyText": "This param isn't used in this method.", "author": "KevinVdV", "createdAt": "2020-03-06T13:35:25Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0Mg==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393342", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTEwNA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905104", "bodyText": "This param isn't used in this method.", "author": "KevinVdV", "createdAt": "2020-03-06T13:35:42Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393347", "bodyText": "fixed thanks", "author": "abollini", "createdAt": "2020-03-08T18:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTQxMA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905410", "bodyText": "This , should be", "author": "KevinVdV", "createdAt": "2020-03-06T13:36:18Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that need to\n+ * provide access to the DSpace API model objects corresponding to the REST\n+ * resources that it manages\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F> the ReloadableEntity type", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM1MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393350", "bodyText": "This is now the ReloadableEntityObjectRepository, I guess you noted that F was used instead than T, now fixed", "author": "abollini", "createdAt": "2020-03-08T18:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTY5MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905690", "bodyText": "Perhaps add a small message here for the log ?", "author": "KevinVdV", "createdAt": "2020-03-06T13:36:50Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/ReadAuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class ReadAuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ReadAuthorizationPermissionEvaluatorPlugin.class);\n+\n+    @Autowired\n+    AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Override\n+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,\n+            DSpaceRestPermission permission) {\n+\n+        DSpaceRestPermission restPermission = DSpaceRestPermission.convert(permission);\n+\n+        if (!DSpaceRestPermission.READ.equals(restPermission)\n+                || !StringUtils.equalsIgnoreCase(targetType, AuthorizationRest.NAME)) {\n+            return false;\n+        }\n+\n+        Request request = requestService.getCurrentRequest();\n+        Context context = ContextUtil.obtainContext(request.getServletRequest());\n+        try {\n+            // admin can always access\n+            if (authorizeService.isAdmin(context)) {\n+                return true;\n+            }\n+            EPerson ePerson = authorizationRestUtil.getEperson(context, targetId.toString());\n+            EPerson currUser = null;\n+\n+            currUser = ePersonService.findByEmail(context, (String) authentication.getPrincipal());\n+\n+            if (ePerson == null) {\n+                // everyone can check authorization for the anonymous user\n+                return true;\n+            } else {\n+                // anonymous user\n+                if (currUser != null && currUser.getID().equals(ePerson.getID())) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            log.error(e.getMessage(), e);", "originalCommit": "adfe2b6959a89763d573652939ad0f28846a561f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM2MA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r389393360", "bodyText": "I don't know exactly what useful information can be added, all the other PermissionEvalutorPlugin do the same. This don't mean that we cannot improve the logging here but I really like to get suggestion :)", "author": "abollini", "createdAt": "2020-03-08T18:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTY5MA=="}], "type": "inlineReview"}, {"oid": "d63493905bba7f33237e7de961050c5b662c6adf", "url": "https://github.com/DSpace/DSpace/commit/d63493905bba7f33237e7de961050c5b662c6adf", "message": "Javadoc cleanup, force projection in test that need it", "committedDate": "2020-03-08T15:42:01Z", "type": "commit"}, {"oid": "db2257e6bf8c5270ad4a41b9647e810fd60120d7", "url": "https://github.com/DSpace/DSpace/commit/db2257e6bf8c5270ad4a41b9647e810fd60120d7", "message": "Add test related to the specialGroups", "committedDate": "2020-03-08T16:41:52Z", "type": "commit"}, {"oid": "ace118a722e22abd75282313e276560efd8c02f2", "url": "https://github.com/DSpace/DSpace/commit/ace118a722e22abd75282313e276560efd8c02f2", "message": "Fix special groups scenario", "committedDate": "2020-03-08T16:43:28Z", "type": "commit"}, {"oid": "616323a887a32136e1a00ad7db0964ee76278bcf", "url": "https://github.com/DSpace/DSpace/commit/616323a887a32136e1a00ad7db0964ee76278bcf", "message": "Add test for the AuthorizationFeatureService", "committedDate": "2020-03-08T18:11:43Z", "type": "commit"}, {"oid": "4192b09d105d10408ec131783263866349ce0c4d", "url": "https://github.com/DSpace/DSpace/commit/4192b09d105d10408ec131783263866349ce0c4d", "message": "Add test for null object in isAuthorized", "committedDate": "2020-03-08T18:21:27Z", "type": "commit"}, {"oid": "82d4908d62a00326e590b53a96e6ddac1615f382", "url": "https://github.com/DSpace/DSpace/commit/82d4908d62a00326e590b53a96e6ddac1615f382", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz", "committedDate": "2020-03-10T08:58:20Z", "type": "commit"}, {"oid": "2e7a12e16638a965f12e354df226afed4e2e257e", "url": "https://github.com/DSpace/DSpace/commit/2e7a12e16638a965f12e354df226afed4e2e257e", "message": "Fix unnoted merge conflict by git", "committedDate": "2020-03-10T17:00:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390624173", "bodyText": "If I correctly understand the purpose of this new method, I'd  like to suggest we instead change the behavior of setCurrentUser() to automatically clear the (cached) specialGroups List whenever it is called.\nIt seems fragile to me to expect code to know when to empty out the specialGroups listing by calling this new method.  Instead, it's more logical to remove the cached specialGroups whenever the current user changes....a new current user should not inherit the groups of the last current user.", "author": "tdonohue", "createdAt": "2020-03-10T21:33:04Z", "path": "dspace-api/src/main/java/org/dspace/core/Context.java", "diffHunk": "@@ -628,6 +628,17 @@ public boolean inSpecialGroup(UUID groupID) {\n         return myGroups;\n     }\n \n+    /**\n+     * This method will remove any special group that was assigned to the context.\n+     * This should be used in very specific scenario such as login-as feature where\n+     * we don't want to pass special group related to the current request /\n+     * authentication method. Normally an authentication method only need to add it\n+     * own additional group without touching what is already set in the context\n+     */\n+    public void emptySpecialGroups() {\n+        specialGroups.clear();\n+    }", "originalCommit": "2e7a12e16638a965f12e354df226afed4e2e257e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MzU3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390953577", "bodyText": "@tdonohue  your understanding is correct and I agree that the method must be used with caution (this is what I try to tell in the javadoc). Your idea is interesting, we cannot do that directly in the setCurrentUser because it is used elsewhere also as part of the authentication process so I think it would be risky to change, what about introducing a specific method loginAs (and a terminateLoginAs)? this would be easier to understand, reusable and we can encapsulate here the logic to store the current specialGroup, empty and restore later.\nBTW: restoring is not really needed as on the REST side each request will be just limited to a single functionality but for the sake of clarity it is just good to \"restore\" the context before that the request complete", "author": "abollini", "createdAt": "2020-03-11T13:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk3NDk1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390974959", "bodyText": "If we'd modify that, we have to be careful to verify setCurrentUser() is never used where the specialGroups need to be retained (e.g. as part of an authentication method), especially since there were no tests for specialGroups (Andrea has created the first test for it in this PR)", "author": "benbosman", "createdAt": "2020-03-11T13:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzg2OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390983868", "bodyText": "If we are concerned about changing setCurrentUser() at this time, I'm OK with @abollini's idea to have a separate loginAs (and terminateLoginAs) methods alongside setCurrentUser().  I just don't like this new emptySpecialGroups() method, as it implies that other code needs to understand the inner workings of the Context class, and know exactly when specialGroups are cached and when they need emptying.  I'd rather the Context class make those decisions itself, and a loginAs and terminateLoginAs would align better with that idea.", "author": "tdonohue", "createdAt": "2020-03-11T13:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwNjg0Mw==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r391506843", "bodyText": "This does sound like a good alternative to me as well, but I would prefer a different name because DSpace offers a login as feature, and that can't work with this method (since it has to be permanent)", "author": "benbosman", "createdAt": "2020-03-12T09:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwMjY5OA==", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r393502698", "bodyText": "done, see f0210c5", "author": "abollini", "createdAt": "2020-03-17T08:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw=="}], "type": "inlineReview"}, {"oid": "f0210c5a46bbb5f9123ec1e4cb5187e9c441e590", "url": "https://github.com/DSpace/DSpace/commit/f0210c5a46bbb5f9123ec1e4cb5187e9c441e590", "message": "encapsulate the logic to switch current user in the context class", "committedDate": "2020-03-16T17:36:38Z", "type": "commit"}, {"oid": "59b7716725588fafc44c988a8517aab022b6fc4e", "url": "https://github.com/DSpace/DSpace/commit/59b7716725588fafc44c988a8517aab022b6fc4e", "message": "Add expected embedded in the search test", "committedDate": "2020-03-20T17:28:30Z", "type": "commit"}, {"oid": "8cced80df3393ff2cddbe68c35b40e91d0fcbc68", "url": "https://github.com/DSpace/DSpace/commit/8cced80df3393ff2cddbe68c35b40e91d0fcbc68", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz", "committedDate": "2020-03-20T17:35:42Z", "type": "commit"}, {"oid": "5e2fc68fbd09308bad55b0bda334e631c413ced6", "url": "https://github.com/DSpace/DSpace/commit/5e2fc68fbd09308bad55b0bda334e631c413ced6", "message": "Code cleanup - removed unused special group lists", "committedDate": "2020-03-20T18:04:09Z", "type": "commit"}, {"oid": "95504b41219132a79bd1a96e6707bd039fceb6e8", "url": "https://github.com/DSpace/DSpace/commit/95504b41219132a79bd1a96e6707bd039fceb6e8", "message": "Fix checkstyle issues", "committedDate": "2020-03-20T20:46:48Z", "type": "commit"}, {"oid": "c9bca71bbf68a3a804142b08c5a1d22a02ec1963", "url": "https://github.com/DSpace/DSpace/commit/c9bca71bbf68a3a804142b08c5a1d22a02ec1963", "message": "Add extra check to verify that the returned feature is the expected one", "committedDate": "2020-03-23T10:30:58Z", "type": "commit"}]}