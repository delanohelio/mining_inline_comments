{"pr_number": 2824, "pr_title": "DS-4515 - Start new submission via Search or ID Lookup (using Live Import)", "pr_createdAt": "2020-07-02T23:54:48Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2824", "timeline": [{"oid": "5c8ff2c74312c5c97a14c01e2efa4d8521c1c1cb", "url": "https://github.com/DSpace/DSpace/commit/5c8ff2c74312c5c97a14c01e2efa4d8521c1c1cb", "message": "DS-4530 enforce the use of the latest override of the findOne when checking permission for embedding", "committedDate": "2020-06-20T16:49:56Z", "type": "commit"}, {"oid": "f50d0d664832142525d68ed22ae4e5ec935d9770", "url": "https://github.com/DSpace/DSpace/commit/f50d0d664832142525d68ed22ae4e5ec935d9770", "message": "Add dependency needed by the pubmed live import provider", "committedDate": "2020-06-20T16:50:36Z", "type": "commit"}, {"oid": "38c566723384729f1e97ab0b7687d6696bb79180", "url": "https://github.com/DSpace/DSpace/commit/38c566723384729f1e97ab0b7687d6696bb79180", "message": "DS-4515 enable live import provider as external authority", "committedDate": "2020-06-20T16:52:23Z", "type": "commit"}, {"oid": "bd2cf94376e5560559d838c04d74cd0817c654a4", "url": "https://github.com/DSpace/DSpace/commit/bd2cf94376e5560559d838c04d74cd0817c654a4", "message": "DS-4529 External authorities endpoint doesn't support the pagination", "committedDate": "2020-06-20T16:52:45Z", "type": "commit"}, {"oid": "f3844e63a4dfff1eae7c8e6901741fa49e88b09d", "url": "https://github.com/DSpace/DSpace/commit/f3844e63a4dfff1eae7c8e6901741fa49e88b09d", "message": "Merge branch 'master' into DS-4515_submit-external-source", "committedDate": "2020-06-24T15:01:03Z", "type": "commit"}, {"oid": "808c4633f159246543b79c723f3617e06c70c0db", "url": "https://github.com/DSpace/DSpace/commit/808c4633f159246543b79c723f3617e06c70c0db", "message": "submit external suorce partial implementation", "committedDate": "2020-07-01T08:36:43Z", "type": "commit"}, {"oid": "238317bc8df250130af162de845623702b43cd81", "url": "https://github.com/DSpace/DSpace/commit/238317bc8df250130af162de845623702b43cd81", "message": "Arxiv Live import integration", "committedDate": "2020-07-01T14:50:45Z", "type": "commit"}, {"oid": "b15fa7c5b0c381dd05d6493d0b5dd3e08a402c02", "url": "https://github.com/DSpace/DSpace/commit/b15fa7c5b0c381dd05d6493d0b5dd3e08a402c02", "message": "show ids and links in response", "committedDate": "2020-07-02T00:32:11Z", "type": "commit"}, {"oid": "f71866b5e300453aec669e24ea087204d93ff90c", "url": "https://github.com/DSpace/DSpace/commit/f71866b5e300453aec669e24ea087204d93ff90c", "message": "Add comment", "committedDate": "2020-07-02T08:30:49Z", "type": "commit"}, {"oid": "03ac31dc109d733917c94f1bf1cb8d26a6f14bcf", "url": "https://github.com/DSpace/DSpace/commit/03ac31dc109d733917c94f1bf1cb8d26a6f14bcf", "message": "Exception handling", "committedDate": "2020-07-02T10:05:50Z", "type": "commit"}, {"oid": "02953eb087c931dba77fd84d3e6ba788464b4458", "url": "https://github.com/DSpace/DSpace/commit/02953eb087c931dba77fd84d3e6ba788464b4458", "message": "Update comment and minor fix", "committedDate": "2020-07-02T12:45:04Z", "type": "commit"}, {"oid": "dbde82478b052371bfc1b3780a622797b3ebf333", "url": "https://github.com/DSpace/DSpace/commit/dbde82478b052371bfc1b3780a622797b3ebf333", "message": "remove unused code", "committedDate": "2020-07-02T14:22:36Z", "type": "commit"}, {"oid": "af38c36bdb094d91f934565d79bab66e29679363", "url": "https://github.com/DSpace/DSpace/commit/af38c36bdb094d91f934565d79bab66e29679363", "message": "add JavaDoc to LiveImportDataProvider public method", "committedDate": "2020-07-06T09:33:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0NTcwMA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455645700", "bodyText": "Since this is a new method compared to the SimpleXpathMetadatumContributor, can add some docs explaining what it does?", "author": "benbosman", "createdAt": "2020-07-16T09:18:37Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+\n+import org.apache.axiom.om.OMAttribute;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMText;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldMapping;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.jaxen.JaxenException;\n+import org.springframework.beans.factory.annotation.Required;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor implements MetadataContributor<OMElement> {\n+    private MetadataFieldConfig field;\n+\n+    /**\n+     * Return prefixToNamespaceMapping\n+     *\n+     * @return a prefixToNamespaceMapping map\n+     */\n+    public Map<String, String> getPrefixToNamespaceMapping() {\n+        return prefixToNamespaceMapping;\n+    }\n+\n+    private MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping;\n+\n+    /**\n+     * Return metadataFieldMapping\n+     *\n+     * @return MetadataFieldMapping\n+     */\n+    public MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> getMetadataFieldMapping() {\n+        return metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the metadataFieldMapping of this ArXivIdMetadataContributor\n+     *\n+     * @param metadataFieldMapping the new mapping.\n+     */\n+    public void setMetadataFieldMapping(\n+        MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping) {\n+        this.metadataFieldMapping = metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the prefixToNamespaceMapping for this object,\n+     *\n+     * @param prefixToNamespaceMapping the new mapping.\n+     */\n+    @Resource(name = \"isiFullprefixMapping\")\n+    public void setPrefixToNamespaceMapping(Map<String, String> prefixToNamespaceMapping) {\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+    }\n+\n+    private Map<String, String> prefixToNamespaceMapping;\n+\n+    /**\n+     * Initialize ArXivIdMetadataContributor with a query, prefixToNamespaceMapping and MetadataFieldConfig\n+     *\n+     * @param query                    query string\n+     * @param prefixToNamespaceMapping metadata prefix to namespace mapping\n+     * @param field\n+     * <a href=\"https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/importer/external#metadata-mapping-\">MetadataFieldConfig</a>\n+     */\n+    public ArXivIdMetadataContributor(String query, Map<String, String> prefixToNamespaceMapping,\n+                                           MetadataFieldConfig field) {\n+        this.query = query;\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Empty constructor for ArXivIdMetadataContributor\n+     */\n+    public ArXivIdMetadataContributor() {\n+\n+    }\n+\n+    private String query;\n+\n+    /**\n+     * Return the MetadataFieldConfig used while retrieving MetadatumDTO\n+     *\n+     * @return MetadataFieldConfig\n+     */\n+    public MetadataFieldConfig getField() {\n+        return field;\n+    }\n+\n+    /**\n+     * Setting the MetadataFieldConfig\n+     *\n+     * @param field MetadataFieldConfig used while retrieving MetadatumDTO\n+     */\n+    @Required\n+    public void setField(MetadataFieldConfig field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Return query used to create an xpathExpression on, this query is used to\n+     *\n+     * @return the query this instance is based on\n+     */\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    @Required\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        List<MetadatumDTO> values = new LinkedList<>();\n+        try {\n+            AXIOMXPath xpath = new AXIOMXPath(query);\n+            for (String ns : prefixToNamespaceMapping.keySet()) {\n+                xpath.addNamespace(prefixToNamespaceMapping.get(ns), ns);\n+            }\n+            List<Object> nodes = xpath.selectNodes(t);\n+            for (Object el : nodes) {\n+                if (el instanceof OMElement) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMElement) el).getText()));\n+                } else if (el instanceof OMAttribute) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMAttribute) el).getAttributeValue()));\n+                } else if (el instanceof String) {\n+                    values.add(metadataFieldMapping.toDCValue(field, (String) el));\n+                } else if (el instanceof OMText) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n+                } else {\n+                    System.err.println(\"node of type: \" + el.getClass());\n+                }\n+            }\n+            parseValue(values);\n+            return values;\n+        } catch (JaxenException e) {\n+            System.err.println(query);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void parseValue(List<MetadatumDTO> dtos) {", "originalCommit": "af38c36bdb094d91f934565d79bab66e29679363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNTg4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460235889", "bodyText": "I agree this new method should have JavaDocs. It's not clear the purpose of this method...it seems to be changing the current value of all MetadatumDTO objects?", "author": "tdonohue", "createdAt": "2020-07-24T19:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0NTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxNzg5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r466317891", "bodyText": "Thanks for adding the JavaDocs, I do wonder how the item id is used here, I thought this was about the ArXiv ID", "author": "benbosman", "createdAt": "2020-08-06T10:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0NTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0ODI3NA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455648274", "bodyText": "why is this customization necessary?", "author": "benbosman", "createdAt": "2020-07-16T09:22:40Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/ConverterService.java", "diffHunk": "@@ -149,14 +149,29 @@ private Annotation getAnnotationForRestObject(BaseObjectRest restObject) {\n         DSpaceRestRepository repositoryToUse = utils\n             .getResourceRepositoryByCategoryAndModel(baseObjectRest.getCategory(), baseObjectRest.getType());\n         Annotation preAuthorize = null;\n+        int maxDepth = 0;\n         for (Method m : repositoryToUse.getClass().getMethods()) {\n             if (StringUtils.equalsIgnoreCase(m.getName(), \"findOne\")) {\n-                preAuthorize = AnnotationUtils.findAnnotation(m, PreAuthorize.class);\n+                int depth = howManySuperclass(m.getDeclaringClass());", "originalCommit": "af38c36bdb094d91f934565d79bab66e29679363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQxOTkwOA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r456419908", "bodyText": "this is a fix for https://jira.lyrasis.org/browse/DS-4530 that was initially discovery working on this PR", "author": "abollini", "createdAt": "2020-07-17T12:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0ODI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxNzE2MQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r466317161", "bodyText": "Isn't the repositoryToUse supposed to make sure the correct method is found?\nI also wouldn't see how this would solve a problem with retrieving the annotation since DSpaceRestRepository also has a superclass", "author": "benbosman", "createdAt": "2020-08-06T10:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0ODI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1MDA5MA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455650090", "bodyText": "why is the total dropped?", "author": "benbosman", "createdAt": "2020-07-16T09:25:15Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ExternalSourceRestRepository.java", "diffHunk": "@@ -89,10 +89,10 @@ public ExternalSourceRest findOne(Context context, String externalSourceName) {\n     }\n \n     @Override\n+    @PreAuthorize(\"permitAll()\")\n     public Page<ExternalSourceRest> findAll(Context context, Pageable pageable) {\n         List<ExternalDataProvider> externalSources = externalDataService.getExternalDataProviders();\n-        return converter.toRestPage(externalSources, pageable, externalSources.size(),", "originalCommit": "af38c36bdb094d91f934565d79bab66e29679363", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNjEyNw==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r459136127", "bodyText": "the original code was buggy as the method toRestPage with 4 parameters expect that the list contains only the requested page. When the pagination is not directly supported by the service it is needed to use the 3 parameters form that will automatically extract the right subset from the whole list. There were no test failure as the endpoint was only tested with a single mock external source provider. Please note that this bug and in general the implementation of this endpoint is not part of our PR that was scoped to add support for live import provider", "author": "abollini", "createdAt": "2020-07-22T23:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1MDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1NzY4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455657689", "bodyText": "Also just noticed this uses System.err.println, while log.error is preferred. This is also happening at https://github.com/DSpace/DSpace/blob/main/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathMetadatumContributor.java#L160 which is why I didn't see it immediately. This should be a small change to improve\nThis also happens a few lines below", "author": "benbosman", "createdAt": "2020-07-16T09:38:03Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+\n+import org.apache.axiom.om.OMAttribute;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMText;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldMapping;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.jaxen.JaxenException;\n+import org.springframework.beans.factory.annotation.Required;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor implements MetadataContributor<OMElement> {\n+    private MetadataFieldConfig field;\n+\n+    /**\n+     * Return prefixToNamespaceMapping\n+     *\n+     * @return a prefixToNamespaceMapping map\n+     */\n+    public Map<String, String> getPrefixToNamespaceMapping() {\n+        return prefixToNamespaceMapping;\n+    }\n+\n+    private MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping;\n+\n+    /**\n+     * Return metadataFieldMapping\n+     *\n+     * @return MetadataFieldMapping\n+     */\n+    public MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> getMetadataFieldMapping() {\n+        return metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the metadataFieldMapping of this ArXivIdMetadataContributor\n+     *\n+     * @param metadataFieldMapping the new mapping.\n+     */\n+    public void setMetadataFieldMapping(\n+        MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping) {\n+        this.metadataFieldMapping = metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the prefixToNamespaceMapping for this object,\n+     *\n+     * @param prefixToNamespaceMapping the new mapping.\n+     */\n+    @Resource(name = \"isiFullprefixMapping\")\n+    public void setPrefixToNamespaceMapping(Map<String, String> prefixToNamespaceMapping) {\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+    }\n+\n+    private Map<String, String> prefixToNamespaceMapping;\n+\n+    /**\n+     * Initialize ArXivIdMetadataContributor with a query, prefixToNamespaceMapping and MetadataFieldConfig\n+     *\n+     * @param query                    query string\n+     * @param prefixToNamespaceMapping metadata prefix to namespace mapping\n+     * @param field\n+     * <a href=\"https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/importer/external#metadata-mapping-\">MetadataFieldConfig</a>\n+     */\n+    public ArXivIdMetadataContributor(String query, Map<String, String> prefixToNamespaceMapping,\n+                                           MetadataFieldConfig field) {\n+        this.query = query;\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Empty constructor for ArXivIdMetadataContributor\n+     */\n+    public ArXivIdMetadataContributor() {\n+\n+    }\n+\n+    private String query;\n+\n+    /**\n+     * Return the MetadataFieldConfig used while retrieving MetadatumDTO\n+     *\n+     * @return MetadataFieldConfig\n+     */\n+    public MetadataFieldConfig getField() {\n+        return field;\n+    }\n+\n+    /**\n+     * Setting the MetadataFieldConfig\n+     *\n+     * @param field MetadataFieldConfig used while retrieving MetadatumDTO\n+     */\n+    @Required\n+    public void setField(MetadataFieldConfig field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Return query used to create an xpathExpression on, this query is used to\n+     *\n+     * @return the query this instance is based on\n+     */\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    @Required\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        List<MetadatumDTO> values = new LinkedList<>();\n+        try {\n+            AXIOMXPath xpath = new AXIOMXPath(query);\n+            for (String ns : prefixToNamespaceMapping.keySet()) {\n+                xpath.addNamespace(prefixToNamespaceMapping.get(ns), ns);\n+            }\n+            List<Object> nodes = xpath.selectNodes(t);\n+            for (Object el : nodes) {\n+                if (el instanceof OMElement) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMElement) el).getText()));\n+                } else if (el instanceof OMAttribute) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMAttribute) el).getAttributeValue()));\n+                } else if (el instanceof String) {\n+                    values.add(metadataFieldMapping.toDCValue(field, (String) el));\n+                } else if (el instanceof OMText) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n+                } else {\n+                    System.err.println(\"node of type: \" + el.getClass());", "originalCommit": "af38c36bdb094d91f934565d79bab66e29679363", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "url": "https://github.com/DSpace/DSpace/commit/76d2e067108a3b7099e5e901cf69d47bb6d71396", "message": "added Logger", "committedDate": "2020-07-20T15:53:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2OTY1Ng==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460169656", "bodyText": "I'm not seeing where this new dependency is needed within this PR?  Could you point it out?  I'd like to make the comment here more specific to call out the exact Class where this dependency is needed (is it PubMedImportService? or something else that needs this?).  So, I'd rather this say something like Needed to support PubMed API call in [ClassName]", "author": "tdonohue", "createdAt": "2020-07-24T16:47:00Z", "path": "dspace-api/pom.xml", "diffHunk": "@@ -622,6 +622,12 @@\n             <artifactId>jersey-client</artifactId>\n             <version>${jersey.version}</version>\n         </dependency>\n+        <!-- This was added to support the pubmed api call -->\n+        <dependency>\n+            <groupId>org.glassfish.jersey.inject</groupId>\n+            <artifactId>jersey-hk2</artifactId>\n+            <version>${jersey.version}</version>", "originalCommit": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM4NDI1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r464384257", "bodyText": "Need it to allow dependency injection in Jersey, this library is never used explicitly in this PR.\nFix the following exception:\nCaused by: java.lang.IllegalStateException: InjectionManagerFactory not found.\nat org.glassfish.jersey.internal.inject.Injections.lambda$lookupInjectionManagerFactory$0(Injections.java:74)\nat java.base/java.util.Optional.orElseThrow(Optional.java:408)\nat org.glassfish.jersey.internal.inject.Injections.lookupInjectionManagerFactory(Injections.java:74\nat org.glassfish.jersey.internal.inject.Injections.createInjectionManager(Injections.java:44)\nat org.glassfish.jersey.client.ClientConfig$State.initRuntime(ClientConfig.java:412)\nat org.glassfish.jersey.internal.util.collection.Values$LazyValueImpl.get(Values.java:317)\nat org.glassfish.jersey.client.ClientConfig.getRuntime(ClientConfig.java:807)\nat org.glassfish.jersey.client.ClientRequest.getClientRuntime(ClientRequest.java:219)\nat org.glassfish.jersey.client.ClientRequest.getInjectionManager(ClientRequest.java:610)\nat org.glassfish.jersey.client.JerseyWebTarget.onBuilder(JerseyWebTarget.java:364)\nat org.glassfish.jersey.client.JerseyWebTarget.request(JerseyWebTarget.java:207)\nat org.glassfish.jersey.client.JerseyWebTarget.request(JerseyWebTarget.java:36)\nat org.dspace.importer.external.pubmed.service.PubmedImportMetadataSourceServiceImpl$GetRecord.call(PubmedImportMetadataSourceServiceImpl.java:332)\nat org.dspace.importer.external.pubmed.service.PubmedImportMetadataSourceServiceImpl$GetRecord.call(PubmedImportMetadataSourceServiceImpl.java:1)\nat org.dspace.importer.external.service.components.AbstractRemoteMetadataSource.retry(AbstractRemoteMetadataSource.java:171)\n... 119 more", "author": "pasqualecvl", "createdAt": "2020-08-03T12:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2OTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjQwNA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236404", "bodyText": "Please add JavaDocs to this private Class.  All classes (private or public) need JavaDocs.", "author": "tdonohue", "createdAt": "2020-07-24T19:04:36Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {", "originalCommit": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjU5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236591", "bodyText": "Again, private, internal class needs JavaDocs", "author": "tdonohue", "createdAt": "2020-07-24T19:04:59Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {", "originalCommit": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjY4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236689", "bodyText": "Same here, needs Javadocs", "author": "tdonohue", "createdAt": "2020-07-24T19:05:11Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+\n+        private SearchByQueryCallable(String queryString, Integer maxResult, Integer start) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+            query.addParameter(\"start\", start);\n+            query.addParameter(\"count\", maxResult);\n+        }\n+\n+        private SearchByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class SearchByIdCallable implements Callable<List<ImportRecord>> {", "originalCommit": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjc3Mg==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236772", "bodyText": "Again, needs JavaDocs", "author": "tdonohue", "createdAt": "2020-07-24T19:05:22Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+\n+        private SearchByQueryCallable(String queryString, Integer maxResult, Integer start) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+            query.addParameter(\"start\", start);\n+            query.addParameter(\"count\", maxResult);\n+        }\n+\n+        private SearchByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class SearchByIdCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+        private SearchByIdCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+        private SearchByIdCallable(String id) {\n+            this.query = new Query();\n+            query.addParameter(\"id\", id);\n+        }\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String arxivid = query.getParameterAsClass(\"id\", String.class);\n+            if (StringUtils.isNotBlank(arxivid)) {\n+                arxivid = arxivid.trim();\n+                if (arxivid.startsWith(\"http://arxiv.org/abs/\")) {\n+                    arxivid = arxivid.substring(\"http://arxiv.org/abs/\".length());\n+                } else if (arxivid.toLowerCase().startsWith(\"arxiv:\")) {\n+                    arxivid = arxivid.substring(\"arxiv:\".length());\n+                }\n+            }\n+            WebTarget local = webTarget.queryParam(\"id_list\", arxivid);\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class FindMatchingRecordCallable implements Callable<List<ImportRecord>> {", "originalCommit": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25bed852d39d0a95fdd90af77017346495ff521e", "url": "https://github.com/DSpace/DSpace/commit/25bed852d39d0a95fdd90af77017346495ff521e", "message": "Add comment, rewrite ArxivIdMetadataContributor", "committedDate": "2020-07-28T23:19:20Z", "type": "commit"}, {"oid": "afd6436c5c3b65697692c741244b258f9a94546b", "url": "https://github.com/DSpace/DSpace/commit/afd6436c5c3b65697692c741244b258f9a94546b", "message": "Clean code", "committedDate": "2020-07-28T23:44:25Z", "type": "commit"}, {"oid": "4c1e4432d108fb5a32b95367f83aa71ac11a0dd3", "url": "https://github.com/DSpace/DSpace/commit/4c1e4432d108fb5a32b95367f83aa71ac11a0dd3", "message": "Merge remote-tracking branch 'refs/remotes/origin/main'\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/submit/lookup/ArXivService.java\n\tdspace-api/src/main/java/org/dspace/submit/lookup/PubmedService.java", "committedDate": "2020-07-29T13:14:07Z", "type": "commit"}, {"oid": "1406a4c2e669b0dea1f9499eacfac033dbc7dddf", "url": "https://github.com/DSpace/DSpace/commit/1406a4c2e669b0dea1f9499eacfac033dbc7dddf", "message": "Update pom.xml, ArXivService.java, and PubmedService.java", "committedDate": "2020-07-31T15:08:23Z", "type": "commit"}, {"oid": "e35084cf239067f1118fcca5e3793aeda264d220", "url": "https://github.com/DSpace/DSpace/commit/e35084cf239067f1118fcca5e3793aeda264d220", "message": "rollback dspace.cfg changes", "committedDate": "2020-07-31T15:13:18Z", "type": "commit"}, {"oid": "774e3893f9806b0da4f6c9606cd0e21f6d016932", "url": "https://github.com/DSpace/DSpace/commit/774e3893f9806b0da4f6c9606cd0e21f6d016932", "message": "Add fix from DS-4530", "committedDate": "2020-08-03T12:22:48Z", "type": "commit"}, {"oid": "9ee5762c3492ee4bd9edfb3f650b88d70619fb6c", "url": "https://github.com/DSpace/DSpace/commit/9ee5762c3492ee4bd9edfb3f650b88d70619fb6c", "message": "return 400 in external source if no record were found", "committedDate": "2020-08-03T13:20:50Z", "type": "commit"}, {"oid": "bdcf064660b471b37061b33eb90b5927362c5e14", "url": "https://github.com/DSpace/DSpace/commit/bdcf064660b471b37061b33eb90b5927362c5e14", "message": "return 400 on arxiv in no record were found", "committedDate": "2020-08-03T13:21:30Z", "type": "commit"}, {"oid": "1f1bd9ee811bf1be8fadd5444947076004916641", "url": "https://github.com/DSpace/DSpace/commit/1f1bd9ee811bf1be8fadd5444947076004916641", "message": "Merge branch 'main' into DS-4515_submit-external-source", "committedDate": "2020-08-11T13:16:44Z", "type": "commit"}, {"oid": "c733576f5010a48e089231a7560fa0832feac6f0", "url": "https://github.com/DSpace/DSpace/commit/c733576f5010a48e089231a7560fa0832feac6f0", "message": "Fix conflict", "committedDate": "2020-08-12T13:37:51Z", "type": "commit"}, {"oid": "052e775bc532cd81d196b298b11fa855d7051183", "url": "https://github.com/DSpace/DSpace/commit/052e775bc532cd81d196b298b11fa855d7051183", "message": "Fix conflict on live import", "committedDate": "2020-08-12T14:48:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDU2MA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r469934560", "bodyText": "Can you add the exception (resulting in a stack trace) to the log.error", "author": "benbosman", "createdAt": "2020-08-13T13:03:43Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathMetadatumContributor.java", "diffHunk": "@@ -157,12 +161,12 @@ public void setQuery(String query) {\n                 } else if (el instanceof OMText) {\n                     values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n                 } else {\n-                    System.err.println(\"node of type: \" + el.getClass());\n+                    log.error(\"node of type: \" + el.getClass());\n                 }\n             }\n             return values;\n         } catch (JaxenException e) {\n-            System.err.println(query);\n+            log.error(query);", "originalCommit": "afd6436c5c3b65697692c741244b258f9a94546b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ef44b15876c7ca9c5e36e96941167a0a3f61db8", "url": "https://github.com/DSpace/DSpace/commit/2ef44b15876c7ca9c5e36e96941167a0a3f61db8", "message": "lof exception in SimpleXPathMetadataContributor", "committedDate": "2020-08-13T14:35:21Z", "type": "commit"}, {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "url": "https://github.com/DSpace/DSpace/commit/fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "message": "Improve Java on ArXivImportMetadataSourceServiceImpl", "committedDate": "2020-08-13T15:01:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM3NQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474795375", "bodyText": "This FIXME can be removed. You've already switched to using ExternalDataObject below", "author": "tdonohue", "createdAt": "2020-08-21T16:15:00Z", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/LiveImportDataProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.service.components.QuerySource;\n+\n+/**\n+ * This class allows to configure a Live Import Provider as an External Data Provider\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class LiveImportDataProvider implements ExternalDataProvider {\n+    /**\n+     * The {@link QuerySource} live import provider\n+     */\n+    private QuerySource querySource;\n+\n+    /**\n+     * An unique human readable identifier for this provider\n+     */\n+    private String sourceIdentifier;\n+\n+    private String recordIdMetadata;\n+\n+    private String displayMetadata = \"dc.title\";\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the SourceIdentifier for the ExternalDataProvider\n+     * @param sourceIdentifier   The UNIQUE sourceIdentifier to be set on any LiveImport data provider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the MetadataSource for the ExternalDataProvider\n+     * @param metadataSource {@link org.dspace.importer.external.service.components.MetadataSource} implementation used to process the input data\n+     */\n+    public void setMetadataSource(QuerySource querySource) {\n+        this.querySource = querySource;\n+    }\n+\n+    /**\n+     * This method set dublin core identifier to use as metadata id\n+     * @param recordIdMetadata dublin core identifier to use as metadata id\n+     */\n+    public void setRecordIdMetadata(String recordIdMetadata) {\n+        this.recordIdMetadata = recordIdMetadata;\n+    }\n+\n+    /**\n+     * This method set the dublin core identifier to display the title\n+     * @param displayMetadata metadata to use as title\n+     */\n+    public void setDisplayMetadata(String displayMetadata) {\n+        this.displayMetadata = displayMetadata;\n+    }\n+\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+        try {\n+            ExternalDataObject externalDataObject = getExternalDataObject(querySource.getRecord(id));\n+            return Optional.of(externalDataObject);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        Collection<ImportRecord> records;\n+        try {\n+            records = querySource.getRecords(query, start, limit);\n+            return records.stream().map(r -> getExternalDataObject(r)).collect(Collectors.toList());\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        try {\n+            return querySource.getRecordsCount(query);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    /**\n+     * Internal method to convert an ImportRecord to an ExternalDataObject\n+     * \n+     * FIXME it would be useful to remove ImportRecord at all in favor of the\n+     * ExternalDataObject", "originalCommit": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNTQ4Mg==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r477205482", "bodyText": "The fixme is mean to note that it would be useful to refactor the LiveImport framework to use directly the ExternalDataObject instead than it owns equivalent concept. This is out of scope of the current PR as it will imply a refactoring of the Live Import framework but essentially we found that the ExternalAuthority and the LiveImport have equivalent concepts that could be merged", "author": "abollini", "createdAt": "2020-08-26T10:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NjY1MA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474796650", "bodyText": "Based on discussion in the PR comments, I'd recommend we reword these comments to say:\n <!-- Required to support PubMed API call in \"PubmedImportMetadataSourceServiceImpl.GetRecord\" -->\nThis better clarifies the exact class which requires this dependency...so that we can ensure it gets updated as needed in the future.", "author": "tdonohue", "createdAt": "2020-08-21T16:17:28Z", "path": "dspace-api/pom.xml", "diffHunk": "@@ -325,6 +325,14 @@\n             <artifactId>apache-jena-libs</artifactId>\n             <type>pom</type>\n         </dependency>\n+        <!-- This was added to support the pubmed api call -->\n+        <!-- Makes runtime operations in Jersey Dependency Injection -->", "originalCommit": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5OTI1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474799259", "bodyText": "I think this FIXME also might already be fixed?  It looks like you are using MetadataValueDTO", "author": "tdonohue", "createdAt": "2020-08-21T16:22:24Z", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/LiveImportDataProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.service.components.QuerySource;\n+\n+/**\n+ * This class allows to configure a Live Import Provider as an External Data Provider\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class LiveImportDataProvider implements ExternalDataProvider {\n+    /**\n+     * The {@link QuerySource} live import provider\n+     */\n+    private QuerySource querySource;\n+\n+    /**\n+     * An unique human readable identifier for this provider\n+     */\n+    private String sourceIdentifier;\n+\n+    private String recordIdMetadata;\n+\n+    private String displayMetadata = \"dc.title\";\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the SourceIdentifier for the ExternalDataProvider\n+     * @param sourceIdentifier   The UNIQUE sourceIdentifier to be set on any LiveImport data provider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the MetadataSource for the ExternalDataProvider\n+     * @param metadataSource {@link org.dspace.importer.external.service.components.MetadataSource} implementation used to process the input data\n+     */\n+    public void setMetadataSource(QuerySource querySource) {\n+        this.querySource = querySource;\n+    }\n+\n+    /**\n+     * This method set dublin core identifier to use as metadata id\n+     * @param recordIdMetadata dublin core identifier to use as metadata id\n+     */\n+    public void setRecordIdMetadata(String recordIdMetadata) {\n+        this.recordIdMetadata = recordIdMetadata;\n+    }\n+\n+    /**\n+     * This method set the dublin core identifier to display the title\n+     * @param displayMetadata metadata to use as title\n+     */\n+    public void setDisplayMetadata(String displayMetadata) {\n+        this.displayMetadata = displayMetadata;\n+    }\n+\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+        try {\n+            ExternalDataObject externalDataObject = getExternalDataObject(querySource.getRecord(id));\n+            return Optional.of(externalDataObject);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        Collection<ImportRecord> records;\n+        try {\n+            records = querySource.getRecords(query, start, limit);\n+            return records.stream().map(r -> getExternalDataObject(r)).collect(Collectors.toList());\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        try {\n+            return querySource.getRecordsCount(query);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    /**\n+     * Internal method to convert an ImportRecord to an ExternalDataObject\n+     * \n+     * FIXME it would be useful to remove ImportRecord at all in favor of the\n+     * ExternalDataObject\n+     * \n+     * @param record\n+     * @return\n+     */\n+    private ExternalDataObject getExternalDataObject(ImportRecord record) {\n+        //return 400 if no record were found\n+        if (record == null) {\n+            throw new IllegalArgumentException(\"No record found for query or id\");\n+        }\n+        ExternalDataObject externalDataObject = new ExternalDataObject(sourceIdentifier);\n+        String id = getFirstValue(record, recordIdMetadata);\n+        String display = getFirstValue(record, displayMetadata);\n+        externalDataObject.setId(id);\n+        externalDataObject.setDisplayValue(display);\n+        externalDataObject.setValue(display);\n+        for (MetadatumDTO dto : record.getValueList()) {\n+            // FIXME it would be useful to remove MetadatumDTO in favor of MetadataValueDTO", "originalCommit": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNTk4MQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r477205981", "bodyText": "similar to https://github.com/DSpace/DSpace/pull/2824/files#r477205482 this for convert MetadatumDTO into MetadataValueDTO but it would be better if we only have MetadataValueDTO at all", "author": "abollini", "createdAt": "2020-08-26T10:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5OTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgwMTA0NQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474801045", "bodyText": "I don't understand this JavaDoc description.  What is the \"path parameter\" you are talking about?\nIt looks to me like this parseValue method is replacing the value of all the MetadatumDTOs by parsing out just the ending of the existing value (removing anything before a slash).  Is that correct?  If so, we should update this JavaDocs to say that...or give an example of what the values look like before and after this method runs.", "author": "tdonohue", "createdAt": "2020-08-21T16:25:55Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor extends SimpleXpathMetadatumContributor {\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        Collection<MetadatumDTO> values = super.contributeMetadata(t);\n+        parseValue(values);\n+        return values;\n+    }\n+\n+    /**\n+     * ArXiv doesn't return the item id. We have to get this from the path parameter", "originalCommit": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMTI1Mg==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r477231252", "bodyText": "It will be called, as the same as contributeMetadata, but \"values\" will be an empty array in any cases except on this line of the ArXiv XML (e.g.):\n    <id>http://arxiv.org/abs/1911.11405v1</id>\n\nbecause the OMElement have to match the XPath expression \"ns:id\" as defined in arxiv-integration.xml on dc.identifier.other metadatum.\nIn the matching case, values.value is http://arxiv.org/abs/1911.11405v1. We need 1911.11405v1 which is the ID. parseValue manipulate this string in order to extract the id and save it as metadatum value.", "author": "pasqualecvl", "createdAt": "2020-08-26T11:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgwMTA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyMDg3NA==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r477320874", "bodyText": "@pasqualecvl : Please add these details (or a summary of them) into the JavaDocs themselves, as it is a much better description of what the method is doing.  Even simply adding a line that says something like: ArXiv returns a full URL as in the <id> value, e.g.  http://arxiv.org/abs/1911.11405v1. This method parses out the identifier from the end of the URL, e.g. 1911.11405v1", "author": "tdonohue", "createdAt": "2020-08-26T13:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgwMTA0NQ=="}], "type": "inlineReview"}, {"oid": "fdc0cda30b065141ec6722d90bae4763bfe98624", "url": "https://github.com/DSpace/DSpace/commit/fdc0cda30b065141ec6722d90bae4763bfe98624", "message": "Update pom.xml\n\nAdd comment", "committedDate": "2020-08-26T12:27:56Z", "type": "commit"}, {"oid": "7422dafef5d511281b808a333785e5598aec5bc4", "url": "https://github.com/DSpace/DSpace/commit/7422dafef5d511281b808a333785e5598aec5bc4", "message": "Change javadoc on ArXivIdMetadataContributor.parseValue", "committedDate": "2020-08-27T14:22:29Z", "type": "commit"}, {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8", "url": "https://github.com/DSpace/DSpace/commit/397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8", "message": "Merge branch 'DS-4515_submit-external-source' of https://github.com/4Science/DSpace into DS-4515_submit-external-source", "committedDate": "2020-08-27T14:23:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NjIzMQ==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r482866231", "bodyText": "I assume this is a typing error, and it's not related to items?", "author": "benbosman", "createdAt": "2020-09-03T10:11:46Z", "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor extends SimpleXpathMetadatumContributor {\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        Collection<MetadatumDTO> values = super.contributeMetadata(t);\n+        parseValue(values);\n+        return values;\n+    }\n+\n+    /**\n+     * ArXiv returns a full URL as in the <id> value, e.g. http://arxiv.org/abs/1911.11405v1.\n+     * This method parses out the identifier from the end of the URL, e.g. 1911.11405v1.\n+     * \n+     * @param dtos Metadata which contains the items uri\n+     * @return the items ids", "originalCommit": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA2NjQxMg==", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r483066412", "bodyText": "Thanks for the update.\nI've included one very minor comment inline\n\nYes it was a typo, removed!\n\nI also tested the functionality. I was able to get arxiv working, but not pubmed. Can you share whether there's any specific config needed, or what queries you used for pubmed?\n\nNothing special.\nI've just tried with this request:\nhttp://localhost:8080/server/api/integration/externalsources/pubmed/entries?query=Antibiotic%20OR%20Antiviral\n\nAnd all works.\nHave you any error in logs?", "author": "pasqualecvl", "createdAt": "2020-09-03T15:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NjIzMQ=="}], "type": "inlineReview"}, {"oid": "1b4988d9d6df0b0c7dc87ed56e142be9d7bb736e", "url": "https://github.com/DSpace/DSpace/commit/1b4988d9d6df0b0c7dc87ed56e142be9d7bb736e", "message": "remove wrong comment", "committedDate": "2020-09-03T15:25:02Z", "type": "commit"}]}