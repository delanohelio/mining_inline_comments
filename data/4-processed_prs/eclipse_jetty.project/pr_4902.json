{"pr_number": 4902, "pr_title": "Issue #3428 - support javax websocket decoder lists in jetty-10", "pr_createdAt": "2020-05-21T23:37:41Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4902", "timeline": [{"oid": "4b19c19815b64b5215777fcbb8b3bdfb72cc473d", "url": "https://github.com/eclipse/jetty.project/commit/4b19c19815b64b5215777fcbb8b3bdfb72cc473d", "message": "Issue #3428 - Initial refactor to support javax websocket decoderLists\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-05-19T12:45:37Z", "type": "commit"}, {"oid": "8e554c7d1340457d33604f759ef2c33a8331cdff", "url": "https://github.com/eclipse/jetty.project/commit/8e554c7d1340457d33604f759ef2c33a8331cdff", "message": "Issue #3428 - fix decoder list matching to get test working\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-05-20T22:52:01Z", "type": "commit"}, {"oid": "43e3cdc4e3b7af1dc5c78d5b0192c98181661eb3", "url": "https://github.com/eclipse/jetty.project/commit/43e3cdc4e3b7af1dc5c78d5b0192c98181661eb3", "message": "Issue #3428 - cleanups and simplify MessageHandler registration\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-05-21T04:58:46Z", "type": "commit"}, {"oid": "9475662451eec41b629473429178736f7c402508", "url": "https://github.com/eclipse/jetty.project/commit/9475662451eec41b629473429178736f7c402508", "message": "Issue #3428 - add validation checks when adding decoders\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-05-21T08:44:46Z", "type": "commit"}, {"oid": "1690f69f3663151c450b222cb0e61e05774096ca", "url": "https://github.com/eclipse/jetty.project/commit/1690f69f3663151c450b222cb0e61e05774096ca", "message": "Issue #3428 - improve testing & warn if no decoder accepts message\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-05-28T00:21:28Z", "type": "commit"}, {"oid": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "url": "https://github.com/eclipse/jetty.project/commit/2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-3428-decoderLists", "committedDate": "2020-05-28T00:29:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzMzUyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446233529", "bodyText": "Since all the fields are package private, can you make this class package private too?\nAlso, should not the class be called JavaxWebSocketOnMessageArgs?\n\"Calling\" does not convey enough context to me, and the comment on the class seems to hint that this is only used for @OnMessage.\nFurthermore, do we really need this class? It only has 4 fields and a method and it's only ever called by the factory? Not against, but it's one more class to maintain.", "author": "sbordet", "createdAt": "2020-06-26T14:53:31Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketCallingArgs.java", "diffHunk": "@@ -0,0 +1,57 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common;\n+\n+import java.nio.ByteBuffer;\n+import javax.websocket.PongMessage;\n+import javax.websocket.Session;\n+\n+import org.eclipse.jetty.websocket.util.InvokerUtils;\n+\n+// The different kind of @OnMessage method parameter signatures expected.\n+public class JavaxWebSocketCallingArgs", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4ODY2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446788669", "bodyText": "Originally this had many more calling signatures here but I was able to remove most of them except the partial ones.\nI'll just get rid of this class now we only have 4.", "author": "lachlan-roberts", "createdAt": "2020-06-29T05:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzMzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNjg4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446236886", "bodyText": "IIRC, a method annotated with @onMessage can have the parameters in any order.\nIt is ok to return this specific order? Is the method handles machinery taking care of reordering them if necessary?", "author": "sbordet", "createdAt": "2020-06-26T14:58:56Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketCallingArgs.java", "diffHunk": "@@ -0,0 +1,57 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common;\n+\n+import java.nio.ByteBuffer;\n+import javax.websocket.PongMessage;\n+import javax.websocket.Session;\n+\n+import org.eclipse.jetty.websocket.util.InvokerUtils;\n+\n+// The different kind of @OnMessage method parameter signatures expected.\n+public class JavaxWebSocketCallingArgs\n+{\n+    static InvokerUtils.Arg[] getArgsFor(Class<?> objectType)\n+    {\n+        return new InvokerUtils.Arg[]{new InvokerUtils.Arg(Session.class), new InvokerUtils.Arg(objectType).required()};\n+    }\n+\n+    static final InvokerUtils.Arg[] textPartialCallingArgs = new InvokerUtils.Arg[]{\n+        new InvokerUtils.Arg(Session.class),\n+        new InvokerUtils.Arg(String.class).required(),\n+        new InvokerUtils.Arg(boolean.class).required()\n+    };", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4ODY5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446788697", "bodyText": "Yes, this is eventually passed to InvokerUtils.optionalMutatedInvoker() which can reorder the parameters and drop the optional ones to match the exact signature.", "author": "lachlan-roberts", "createdAt": "2020-06-29T05:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNjg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0OTQ2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446249469", "bodyText": "Please add a comment about why it is added at index 0.\nIn this way the decoder order is reversed, is that ok?\nThat is, if 2 decoders are added, the order will be reversed which may be unexpected, no?", "author": "sbordet", "createdAt": "2020-06-26T15:21:02Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/decoders/AvailableDecoders.java", "diffHunk": "@@ -200,107 +133,83 @@ private void add(Class<? extends Decoder> decoder, Class<? extends Decoder> inte\n         Class<?> objectType = ReflectUtils.findGenericClassFor(decoder, interfaceClass);\n         if (objectType == null)\n         {\n-            StringBuilder err = new StringBuilder();\n-            err.append(\"Unknown Decoder Object type declared for interface \");\n-            err.append(interfaceClass.getName());\n-            err.append(\" on class \");\n-            err.append(decoder);\n-            throw new InvalidWebSocketException(err.toString());\n+            String err = \"Unknown Decoder Object type declared for interface \" +\n+                interfaceClass.getName() + \" on class \" + decoder;\n+            throw new InvalidWebSocketException(err);\n         }\n \n-        try\n+        // Validate the decoder to be added against the existing registered decoders.\n+        for (RegisteredDecoder registered : registeredDecoders)\n         {\n-            RegisteredDecoder conflicts = registeredDecoders.stream()\n-                .filter(registered -> registered.isType(objectType))\n-                .filter(registered -> !registered.primitive)\n-                .findFirst()\n-                .get();\n-\n-            if (conflicts.decoder.equals(decoder) && conflicts.implementsInterface(interfaceClass))\n+            if (!registered.primitive && objectType.equals(registered.objectType))\n             {\n-                // Same decoder as what is there already, don't bother adding it again.\n-                return;\n+                // Streaming decoders can only have one decoder per object type.\n+                if (interfaceClass.equals(Decoder.TextStream.class) || interfaceClass.equals(Decoder.BinaryStream.class))\n+                    throw new InvalidWebSocketException(\"Multiple decoders for objectType\" + objectType);\n+\n+                // If we have the same objectType, then the interfaceTypes must be the same to form a decoder list.\n+                if (!registered.interfaceType.equals(interfaceClass))\n+                    throw new InvalidWebSocketException(\"Multiple decoders with different interface types for objectType \" + objectType);\n             }\n \n-            StringBuilder err = new StringBuilder();\n-            err.append(\"Duplicate Decoder Object type \");\n-            err.append(objectType.getName());\n-            err.append(\" in \");\n-            err.append(decoder.getName());\n-            err.append(\", previously declared in \");\n-            err.append(conflicts.decoder.getName());\n-            throw new InvalidWebSocketException(err.toString());\n-        }\n-        catch (NoSuchElementException e)\n-        {\n-            registeredDecoders.addFirst(new RegisteredDecoder(decoder, interfaceClass, objectType));\n+            // If this decoder is already registered for this interface type we can skip adding a duplicate.\n+            if (registered.decoder.equals(decoder) && registered.interfaceType.equals(interfaceClass))\n+                return;\n         }\n+\n+        registeredDecoders.add(0, new RegisteredDecoder(decoder, interfaceClass, objectType, config));", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg0NDIxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446844219", "bodyText": "This is so any decoders added by the endpoint take precedence over the primitive decoders. The decoders supplied by the endpoint config are given as a list:\nClientEndpointConfig.Builder.create()\n    .decoders(List.of(Decoder1.class, Decoder2.class))\n    .build();\nSo in this case should Decoder1 be tried before Decoder2? I don't think the spec goes into this much detail about it.", "author": "lachlan-roberts", "createdAt": "2020-06-29T08:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0OTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1Mzc5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446853796", "bodyText": "Looks like I can fix the precedence issue by just registering the configured decoders before the primitive ones, then I can avoid adding at index 0 here.", "author": "lachlan-roberts", "createdAt": "2020-06-29T08:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0OTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2MjIzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446862233", "bodyText": "I think the order should be preserved, to minimize surprises to applications.", "author": "sbordet", "createdAt": "2020-06-29T08:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0OTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1MDM1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446250351", "bodyText": "Splitting into 2 filter() calls is probably more readable.", "author": "sbordet", "createdAt": "2020-06-26T15:22:42Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/decoders/AvailableDecoders.java", "diffHunk": "@@ -200,107 +133,83 @@ private void add(Class<? extends Decoder> decoder, Class<? extends Decoder> inte\n         Class<?> objectType = ReflectUtils.findGenericClassFor(decoder, interfaceClass);\n         if (objectType == null)\n         {\n-            StringBuilder err = new StringBuilder();\n-            err.append(\"Unknown Decoder Object type declared for interface \");\n-            err.append(interfaceClass.getName());\n-            err.append(\" on class \");\n-            err.append(decoder);\n-            throw new InvalidWebSocketException(err.toString());\n+            String err = \"Unknown Decoder Object type declared for interface \" +\n+                interfaceClass.getName() + \" on class \" + decoder;\n+            throw new InvalidWebSocketException(err);\n         }\n \n-        try\n+        // Validate the decoder to be added against the existing registered decoders.\n+        for (RegisteredDecoder registered : registeredDecoders)\n         {\n-            RegisteredDecoder conflicts = registeredDecoders.stream()\n-                .filter(registered -> registered.isType(objectType))\n-                .filter(registered -> !registered.primitive)\n-                .findFirst()\n-                .get();\n-\n-            if (conflicts.decoder.equals(decoder) && conflicts.implementsInterface(interfaceClass))\n+            if (!registered.primitive && objectType.equals(registered.objectType))\n             {\n-                // Same decoder as what is there already, don't bother adding it again.\n-                return;\n+                // Streaming decoders can only have one decoder per object type.\n+                if (interfaceClass.equals(Decoder.TextStream.class) || interfaceClass.equals(Decoder.BinaryStream.class))\n+                    throw new InvalidWebSocketException(\"Multiple decoders for objectType\" + objectType);\n+\n+                // If we have the same objectType, then the interfaceTypes must be the same to form a decoder list.\n+                if (!registered.interfaceType.equals(interfaceClass))\n+                    throw new InvalidWebSocketException(\"Multiple decoders with different interface types for objectType \" + objectType);\n             }\n \n-            StringBuilder err = new StringBuilder();\n-            err.append(\"Duplicate Decoder Object type \");\n-            err.append(objectType.getName());\n-            err.append(\" in \");\n-            err.append(decoder.getName());\n-            err.append(\", previously declared in \");\n-            err.append(conflicts.decoder.getName());\n-            throw new InvalidWebSocketException(err.toString());\n-        }\n-        catch (NoSuchElementException e)\n-        {\n-            registeredDecoders.addFirst(new RegisteredDecoder(decoder, interfaceClass, objectType));\n+            // If this decoder is already registered for this interface type we can skip adding a duplicate.\n+            if (registered.decoder.equals(decoder) && registered.interfaceType.equals(interfaceClass))\n+                return;\n         }\n+\n+        registeredDecoders.add(0, new RegisteredDecoder(decoder, interfaceClass, objectType, config));\n+    }\n+\n+    public RegisteredDecoder getFirstRegisteredDecoder(Class<?> type)\n+    {\n+        return registeredDecoders.stream()\n+            .filter(registered -> registered.isType(type))\n+            .findFirst()\n+            .orElse(null);\n     }\n \n-    // TODO: consider removing (if not used)\n-    public List<RegisteredDecoder> supporting(Class<? extends Decoder> interfaceType)\n+    public List<RegisteredDecoder> getRegisteredDecoders(Class<?> returnType)\n     {\n         return registeredDecoders.stream()\n-            .filter(registered -> registered.implementsInterface(interfaceType))\n+            .filter(registered -> registered.isType(returnType))\n             .collect(Collectors.toList());\n     }\n \n-    public RegisteredDecoder getRegisteredDecoderFor(Class<?> type)\n+    public List<RegisteredDecoder> getRegisteredDecoders(Class<? extends Decoder> interfaceType, Class<?> returnType)\n     {\n         return registeredDecoders.stream()\n-            .filter(registered -> registered.isType(type))\n-            .findFirst()\n-            .orElse(null);\n+            .filter(registered -> registered.interfaceType.equals(interfaceType) && registered.isType(returnType))", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1NTA3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446255073", "bodyText": "protected fields should be avoided.\nMake them private and if really necessary, use package private methods to access them.\n_logger should be duplicated in all subclasses so we know whether we are logging from binary or text subclasses.\n_methodHandle is only used by subclasses, so better to have it private, with a method called by subclasses.\n_messageSink is weird because it is called from the constructor (which typically must no be done - leaks this as a partially constructed object), and only used in accept().\nI would prefer subclasses implement accept() and each have its own messageSink - thoughts?", "author": "sbordet", "createdAt": "2020-06-26T15:30:48Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/AbstractDecodedMessageSink.java", "diffHunk": "@@ -0,0 +1,99 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common.messages;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.websocket.Decoder;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.CoreSession;\n+import org.eclipse.jetty.websocket.core.Frame;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n+import org.eclipse.jetty.websocket.util.messages.MessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractDecodedMessageSink implements MessageSink\n+{\n+    protected final Logger _logger;\n+    protected final CoreSession _coreSession;\n+    protected final MethodHandle _methodHandle;\n+    protected final MessageSink _messageSink;", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4OTEyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446789124", "bodyText": "To me the current structure makes the most sense, where to create a DecodedMessageSink all you need to do is implement the getMessageSink method.\nAdding accept() to every version of the DecodedMessageSink is just going to duplicate the same method 4 times. What do you think about creating the MessageSink in the constructor and giving it to super. OR just passing in a Provider to the super constructor?", "author": "lachlan-roberts", "createdAt": "2020-06-29T05:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1NTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1NzA0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446257046", "bodyText": "This block is duplicated for the binary version. Can it be factored out into the base class?", "author": "sbordet", "createdAt": "2020-06-26T15:34:20Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedTextMessageSink.java", "diffHunk": "@@ -20,61 +20,58 @@\n \n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodType;\n+import java.util.List;\n import javax.websocket.CloseReason;\n import javax.websocket.DecodeException;\n import javax.websocket.Decoder;\n \n import org.eclipse.jetty.websocket.core.CoreSession;\n import org.eclipse.jetty.websocket.core.exception.CloseException;\n import org.eclipse.jetty.websocket.javax.common.JavaxWebSocketFrameHandlerFactory;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n import org.eclipse.jetty.websocket.util.messages.MessageSink;\n import org.eclipse.jetty.websocket.util.messages.StringMessageSink;\n \n-public class DecodedTextMessageSink<T> extends DecodedMessageSink<Decoder.Text<T>>\n+public class DecodedTextMessageSink<T> extends AbstractDecodedMessageSink.Basic<Decoder.Text<T>>\n {\n-    public DecodedTextMessageSink(CoreSession session,\n-                                  Decoder.Text<T> decoder,\n-                                  MethodHandle methodHandle)\n-        throws NoSuchMethodException, IllegalAccessException\n+    public DecodedTextMessageSink(CoreSession session, MethodHandle methodHandle, List<RegisteredDecoder> decoders)\n     {\n-        super(session, decoder, methodHandle);\n+        super(session, methodHandle, decoders);\n     }\n \n     @Override\n-    protected MethodHandle newRawMethodHandle() throws NoSuchMethodException, IllegalAccessException\n+    MessageSink getMessageSink() throws NoSuchMethodException, IllegalAccessException\n     {\n-        return JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup().findVirtual(DecodedTextMessageSink.class,\n-            \"onWholeMessage\", MethodType.methodType(void.class, String.class))\n+        MethodHandle methodHandle = JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup()\n+            .findVirtual(getClass(), \"onMessage\", MethodType.methodType(void.class, String.class))\n             .bindTo(this);\n-    }\n-\n-    @Override\n-    protected MessageSink newRawMessageSink(CoreSession session, MethodHandle rawMethodHandle)\n-    {\n-        return new StringMessageSink(session, rawMethodHandle);\n+        return new StringMessageSink(_coreSession, methodHandle);\n     }\n \n     @SuppressWarnings(\"Duplicates\")\n-    public void onWholeMessage(String wholeMessage)\n+    public void onMessage(String wholeMessage)\n     {\n-        if (!getDecoder().willDecode(wholeMessage))\n+        for (Decoder.Text<T> decoder : _decoders)\n         {\n-            logger.warn(\"Message lost, decoder \" + getDecoder().getClass().getName() + \"#willDecode() has rejected it.\");\n-            return;\n+            if (decoder.willDecode(wholeMessage))\n+            {\n+                try\n+                {\n+                    T obj = decoder.decode(wholeMessage);\n+                    _methodHandle.invoke(obj);\n+                    return;\n+                }\n+                catch (DecodeException e)\n+                {\n+                    throw new CloseException(CloseReason.CloseCodes.CANNOT_ACCEPT.getCode(), \"Unable to decode\", e);\n+                }\n+                catch (Throwable t)\n+                {\n+                    throw new CloseException(CloseReason.CloseCodes.CANNOT_ACCEPT.getCode(), \"Endpoint notification error\", t);\n+                }\n+            }", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4ODgxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446788819", "bodyText": "I tried factoring this out to the base class but couldn't do this well because there is no common base interface (something like Decoder.Whole) which has the willDecode() method, all the types inherit directly from Decoder. So I couldn't work out a way to remove this duplication.", "author": "lachlan-roberts", "createdAt": "2020-06-29T05:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1NzA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2MjU5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446262596", "bodyText": "Please remove empty line at 135 (in class GmtDecoder).", "author": "sbordet", "createdAt": "2020-06-26T15:44:18Z", "path": "jetty-websocket/websocket-javax-common/src/test/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedBinaryMessageSinkTest.java", "diffHunk": "@@ -72,8 +74,8 @@ public void testCalendar3Frames() throws Exception\n         CompletableFuture<Calendar> copyFuture = new CompletableFuture<>();\n         DecodedCalendarCopy copy = new DecodedCalendarCopy(copyFuture);\n         MethodHandle copyHandle = getAcceptHandle(copy, Calendar.class);\n-        Decoder.Binary<Calendar> decoder = new GmtDecoder();\n-        DecodedBinaryMessageSink sink = new DecodedBinaryMessageSink(AbstractSessionTest.session.getCoreSession(), decoder, copyHandle);\n+        List<RegisteredDecoder> decoders = toRegisteredDecoderList(GmtDecoder.class, Calendar.class);\n+        DecodedBinaryMessageSink<Calendar> sink = new DecodedBinaryMessageSink<>(AbstractSessionTest.session.getCoreSession(), copyHandle, decoders);\n ", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2NTI2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446265269", "bodyText": "I'd like to see a test with conflicting decoders that should lead to a deployment exception, is there one?\nAlso, I'd like to see a test about decoder precedence (i.e. 2 decoders decoding the same text, but the first should be used because the application specified them in a specific order).", "author": "sbordet", "createdAt": "2020-06-26T15:49:03Z", "path": "jetty-websocket/websocket-javax-tests/src/test/java/org/eclipse/jetty/websocket/javax/tests/coders/DecoderListTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.tests.coders;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+import javax.websocket.Decoder;\n+import javax.websocket.OnMessage;\n+import javax.websocket.Session;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.websocket.javax.client.internal.JavaxWebSocketClientContainer;\n+import org.eclipse.jetty.websocket.javax.common.decoders.AbstractDecoder;\n+import org.eclipse.jetty.websocket.javax.server.config.JavaxWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.javax.tests.EventSocket;\n+import org.eclipse.jetty.websocket.javax.tests.WSURI;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DecoderListTest", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3Mjg2NA==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446272864", "bodyText": "Can we get a message for this one?", "author": "joakime", "createdAt": "2020-06-26T16:02:24Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketFrameHandler.java", "diffHunk": "@@ -552,7 +570,7 @@ public void removeMessageHandler(MessageHandler handler)\n                         this.binarySink = null;\n                         break;\n                     default:\n-                        break; // TODO ISE?\n+                        throw new IllegalStateException();", "originalCommit": "2c1c25d5a78ecc9c87e14bc42fd9f0aa9096ee86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35e82c85ff07fb58d34bcb78d15c04541b229a3e", "url": "https://github.com/eclipse/jetty.project/commit/35e82c85ff07fb58d34bcb78d15c04541b229a3e", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-3428-decoderLists", "committedDate": "2020-06-29T01:33:03Z", "type": "commit"}, {"oid": "5da4d7e4601c9f04ee2bb51158b665aef1983da7", "url": "https://github.com/eclipse/jetty.project/commit/5da4d7e4601c9f04ee2bb51158b665aef1983da7", "message": "Issue #3428 - changes from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-06-29T05:37:47Z", "type": "commit"}, {"oid": "eb01603abbc85c216189eba868bf00e999b8fa8b", "url": "https://github.com/eclipse/jetty.project/commit/eb01603abbc85c216189eba868bf00e999b8fa8b", "message": "Issue #3428 - improve testing and ensure decoders are registered in correct order\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-06-29T08:41:54Z", "type": "commit"}, {"oid": "acf47624a37bdb2c7024c2b7b4eb5c3e48622e7d", "url": "https://github.com/eclipse/jetty.project/commit/acf47624a37bdb2c7024c2b7b4eb5c3e48622e7d", "message": "Issue #3428 - make AvailableDecoders only allow registration through EndpointConfig\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-06-29T09:01:00Z", "type": "commit"}, {"oid": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "url": "https://github.com/eclipse/jetty.project/commit/4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "message": "Issue #3428 - changes to AbstractDecodedMessageSink signature from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-06-29T10:34:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg3ODgwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446878802", "bodyText": "Pass coreSession to getMessageSink(), which should probably be renamed to newMessageSink().\nIn this way you can remove the getter for coreSession, which is only used in getMessageSink().", "author": "sbordet", "createdAt": "2020-06-29T09:04:45Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/AbstractDecodedMessageSink.java", "diffHunk": "@@ -0,0 +1,109 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common.messages;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.websocket.Decoder;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.CoreSession;\n+import org.eclipse.jetty.websocket.core.Frame;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n+import org.eclipse.jetty.websocket.util.messages.MessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractDecodedMessageSink implements MessageSink\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDecodedMessageSink.class);\n+\n+    private final CoreSession _coreSession;\n+    private final MethodHandle _methodHandle;\n+    private final MessageSink _messageSink;\n+\n+    public AbstractDecodedMessageSink(CoreSession coreSession, MethodHandle methodHandle)\n+    {\n+        _coreSession = coreSession;\n+        _methodHandle = methodHandle;\n+\n+        try\n+        {\n+            _messageSink = getMessageSink();", "originalCommit": "5da4d7e4601c9f04ee2bb51158b665aef1983da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg3OTQzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r446879431", "bodyText": "Rather than pulling out members to use them, have a protected invoke() method in this class.\nSubclasses will now just invoke it with the arguments.", "author": "sbordet", "createdAt": "2020-06-29T09:05:45Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/AbstractDecodedMessageSink.java", "diffHunk": "@@ -0,0 +1,109 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common.messages;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.websocket.Decoder;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.CoreSession;\n+import org.eclipse.jetty.websocket.core.Frame;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n+import org.eclipse.jetty.websocket.util.messages.MessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractDecodedMessageSink implements MessageSink\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDecodedMessageSink.class);\n+\n+    private final CoreSession _coreSession;\n+    private final MethodHandle _methodHandle;\n+    private final MessageSink _messageSink;\n+\n+    public AbstractDecodedMessageSink(CoreSession coreSession, MethodHandle methodHandle)\n+    {\n+        _coreSession = coreSession;\n+        _methodHandle = methodHandle;\n+\n+        try\n+        {\n+            _messageSink = getMessageSink();\n+        }\n+        catch (Exception e)\n+        {\n+            // Throwing from here is an error implementation of the DecodedMessageSink.\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public CoreSession getCoreSession()\n+    {\n+        return _coreSession;\n+    }\n+\n+    public MethodHandle getMethodHandle()", "originalCommit": "5da4d7e4601c9f04ee2bb51158b665aef1983da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMjI3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r447022277", "bodyText": "Can be made package private.", "author": "sbordet", "createdAt": "2020-06-29T14:38:57Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/AbstractDecodedMessageSink.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.javax.common.messages;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.websocket.CloseReason;\n+import javax.websocket.Decoder;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.CoreSession;\n+import org.eclipse.jetty.websocket.core.Frame;\n+import org.eclipse.jetty.websocket.core.exception.CloseException;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n+import org.eclipse.jetty.websocket.util.messages.MessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractDecodedMessageSink implements MessageSink\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDecodedMessageSink.class);\n+\n+    private final MethodHandle _methodHandle;\n+    private final MessageSink _messageSink;\n+\n+    public AbstractDecodedMessageSink(CoreSession coreSession, MethodHandle methodHandle)\n+    {\n+        _methodHandle = methodHandle;\n+\n+        try\n+        {\n+            _messageSink = newMessageSink(coreSession);\n+        }\n+        catch (Exception e)\n+        {\n+            // Throwing from here is an error implementation of the DecodedMessageSink.\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Invoke the MessageSink with the decoded message.\n+     * @param args the decoded message.\n+     */\n+    public void invoke(Object... args)", "originalCommit": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMjczMA==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r447022730", "bodyText": "Warning suppression can be removed.", "author": "sbordet", "createdAt": "2020-06-29T14:39:35Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedBinaryMessageSink.java", "diffHunk": "@@ -21,61 +21,58 @@\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodType;\n import java.nio.ByteBuffer;\n+import java.util.List;\n import javax.websocket.CloseReason;\n import javax.websocket.DecodeException;\n import javax.websocket.Decoder;\n \n import org.eclipse.jetty.websocket.core.CoreSession;\n import org.eclipse.jetty.websocket.core.exception.CloseException;\n import org.eclipse.jetty.websocket.javax.common.JavaxWebSocketFrameHandlerFactory;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n import org.eclipse.jetty.websocket.util.messages.ByteBufferMessageSink;\n import org.eclipse.jetty.websocket.util.messages.MessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DecodedBinaryMessageSink<T> extends DecodedMessageSink<Decoder.Binary<T>>\n+public class DecodedBinaryMessageSink<T> extends AbstractDecodedMessageSink.Basic<Decoder.Binary<T>>\n {\n-    public DecodedBinaryMessageSink(CoreSession session,\n-                                    Decoder.Binary<T> decoder,\n-                                    MethodHandle methodHandle)\n-        throws NoSuchMethodException, IllegalAccessException\n-    {\n-        super(session, decoder, methodHandle);\n-    }\n+    private static final Logger LOG = LoggerFactory.getLogger(DecodedBinaryMessageSink.class);\n \n-    @Override\n-    protected MethodHandle newRawMethodHandle() throws NoSuchMethodException, IllegalAccessException\n+    public DecodedBinaryMessageSink(CoreSession session, MethodHandle methodHandle, List<RegisteredDecoder> decoders)\n     {\n-        return JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup().findVirtual(DecodedBinaryMessageSink.class,\n-            \"onWholeMessage\", MethodType.methodType(void.class, ByteBuffer.class))\n-            .bindTo(this);\n+        super(session, methodHandle, decoders);\n     }\n \n     @Override\n-    protected MessageSink newRawMessageSink(CoreSession session, MethodHandle rawMethodHandle)\n+    MessageSink newMessageSink(CoreSession coreSession) throws Exception\n     {\n-        return new ByteBufferMessageSink(session, rawMethodHandle);\n+        MethodHandle methodHandle = JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup()\n+            .findVirtual(DecodedBinaryMessageSink.class, \"onWholeMessage\", MethodType.methodType(void.class, ByteBuffer.class))\n+            .bindTo(this);\n+        return new ByteBufferMessageSink(coreSession, methodHandle);\n     }\n \n     @SuppressWarnings(\"Duplicates\")", "originalCommit": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMzMxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r447023315", "bodyText": "Warning suppression can be removed.", "author": "sbordet", "createdAt": "2020-06-29T14:40:16Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedBinaryStreamMessageSink.java", "diffHunk": "@@ -18,58 +18,49 @@\n \n package org.eclipse.jetty.websocket.javax.common.messages;\n \n+import java.io.IOException;\n import java.io.InputStream;\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodType;\n+import java.util.List;\n import javax.websocket.CloseReason;\n import javax.websocket.DecodeException;\n import javax.websocket.Decoder;\n \n import org.eclipse.jetty.websocket.core.CoreSession;\n import org.eclipse.jetty.websocket.core.exception.CloseException;\n import org.eclipse.jetty.websocket.javax.common.JavaxWebSocketFrameHandlerFactory;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n import org.eclipse.jetty.websocket.util.messages.InputStreamMessageSink;\n import org.eclipse.jetty.websocket.util.messages.MessageSink;\n \n-public class DecodedBinaryStreamMessageSink<T> extends DecodedMessageSink<Decoder.BinaryStream<T>>\n+public class DecodedBinaryStreamMessageSink<T> extends AbstractDecodedMessageSink.Stream<Decoder.BinaryStream<T>>\n {\n-    public DecodedBinaryStreamMessageSink(CoreSession session,\n-                                          Decoder.BinaryStream<T> decoder,\n-                                          MethodHandle methodHandle)\n-        throws NoSuchMethodException, IllegalAccessException\n+    public DecodedBinaryStreamMessageSink(CoreSession session, MethodHandle methodHandle, List<RegisteredDecoder> decoders)\n     {\n-        super(session, decoder, methodHandle);\n+        super(session, methodHandle, decoders);\n     }\n \n     @Override\n-    protected MethodHandle newRawMethodHandle() throws NoSuchMethodException, IllegalAccessException\n+    MessageSink newMessageSink(CoreSession coreSession) throws Exception\n     {\n-        return JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup().findVirtual(DecodedBinaryStreamMessageSink.class,\n-            \"onStreamStart\", MethodType.methodType(void.class, InputStream.class))\n+        MethodHandle methodHandle = JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup()\n+            .findVirtual(DecodedBinaryStreamMessageSink.class, \"onStreamStart\", MethodType.methodType(void.class, InputStream.class))\n             .bindTo(this);\n-    }\n-\n-    @Override\n-    protected MessageSink newRawMessageSink(CoreSession session, MethodHandle rawMethodHandle)\n-    {\n-        return new InputStreamMessageSink(session, rawMethodHandle);\n+        return new InputStreamMessageSink(coreSession, methodHandle);\n     }\n \n     @SuppressWarnings(\"Duplicates\")", "originalCommit": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMzYwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r447023607", "bodyText": "Warning suppression can be removed.", "author": "sbordet", "createdAt": "2020-06-29T14:40:39Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedTextMessageSink.java", "diffHunk": "@@ -20,61 +20,58 @@\n \n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodType;\n+import java.util.List;\n import javax.websocket.CloseReason;\n import javax.websocket.DecodeException;\n import javax.websocket.Decoder;\n \n import org.eclipse.jetty.websocket.core.CoreSession;\n import org.eclipse.jetty.websocket.core.exception.CloseException;\n import org.eclipse.jetty.websocket.javax.common.JavaxWebSocketFrameHandlerFactory;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n import org.eclipse.jetty.websocket.util.messages.MessageSink;\n import org.eclipse.jetty.websocket.util.messages.StringMessageSink;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DecodedTextMessageSink<T> extends DecodedMessageSink<Decoder.Text<T>>\n+public class DecodedTextMessageSink<T> extends AbstractDecodedMessageSink.Basic<Decoder.Text<T>>\n {\n-    public DecodedTextMessageSink(CoreSession session,\n-                                  Decoder.Text<T> decoder,\n-                                  MethodHandle methodHandle)\n-        throws NoSuchMethodException, IllegalAccessException\n-    {\n-        super(session, decoder, methodHandle);\n-    }\n+    private static final Logger LOG = LoggerFactory.getLogger(DecodedTextMessageSink.class);\n \n-    @Override\n-    protected MethodHandle newRawMethodHandle() throws NoSuchMethodException, IllegalAccessException\n+    public DecodedTextMessageSink(CoreSession session, MethodHandle methodHandle, List<RegisteredDecoder> decoders)\n     {\n-        return JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup().findVirtual(DecodedTextMessageSink.class,\n-            \"onWholeMessage\", MethodType.methodType(void.class, String.class))\n-            .bindTo(this);\n+        super(session, methodHandle, decoders);\n     }\n \n     @Override\n-    protected MessageSink newRawMessageSink(CoreSession session, MethodHandle rawMethodHandle)\n+    MessageSink newMessageSink(CoreSession coreSession) throws NoSuchMethodException, IllegalAccessException\n     {\n-        return new StringMessageSink(session, rawMethodHandle);\n+        MethodHandle methodHandle = JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup()\n+            .findVirtual(getClass(), \"onMessage\", MethodType.methodType(void.class, String.class))\n+            .bindTo(this);\n+        return new StringMessageSink(coreSession, methodHandle);\n     }\n \n     @SuppressWarnings(\"Duplicates\")", "originalCommit": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNDA1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4902#discussion_r447024059", "bodyText": "Warning suppression can be removed.", "author": "sbordet", "createdAt": "2020-06-29T14:41:16Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/messages/DecodedTextStreamMessageSink.java", "diffHunk": "@@ -18,58 +18,49 @@\n \n package org.eclipse.jetty.websocket.javax.common.messages;\n \n+import java.io.IOException;\n import java.io.Reader;\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodType;\n+import java.util.List;\n import javax.websocket.CloseReason;\n import javax.websocket.DecodeException;\n import javax.websocket.Decoder;\n \n import org.eclipse.jetty.websocket.core.CoreSession;\n import org.eclipse.jetty.websocket.core.exception.CloseException;\n import org.eclipse.jetty.websocket.javax.common.JavaxWebSocketFrameHandlerFactory;\n+import org.eclipse.jetty.websocket.javax.common.decoders.RegisteredDecoder;\n import org.eclipse.jetty.websocket.util.messages.MessageSink;\n import org.eclipse.jetty.websocket.util.messages.ReaderMessageSink;\n \n-public class DecodedTextStreamMessageSink<T> extends DecodedMessageSink<Decoder.TextStream<T>>\n+public class DecodedTextStreamMessageSink<T> extends AbstractDecodedMessageSink.Stream<Decoder.TextStream<T>>\n {\n-    public DecodedTextStreamMessageSink(CoreSession session,\n-                                        Decoder.TextStream<T> decoder,\n-                                        MethodHandle methodHandle)\n-        throws NoSuchMethodException, IllegalAccessException\n+    public DecodedTextStreamMessageSink(CoreSession session, MethodHandle methodHandle, List<RegisteredDecoder> decoders)\n     {\n-        super(session, decoder, methodHandle);\n+        super(session, methodHandle, decoders);\n     }\n \n     @Override\n-    protected MethodHandle newRawMethodHandle() throws NoSuchMethodException, IllegalAccessException\n+    MessageSink newMessageSink(CoreSession coreSession) throws Exception\n     {\n-        return JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup().findVirtual(DecodedTextStreamMessageSink.class,\n-            \"onStreamStart\", MethodType.methodType(void.class, Reader.class))\n+        MethodHandle methodHandle = JavaxWebSocketFrameHandlerFactory.getServerMethodHandleLookup()\n+            .findVirtual(DecodedTextStreamMessageSink.class, \"onStreamStart\", MethodType.methodType(void.class, Reader.class))\n             .bindTo(this);\n-    }\n-\n-    @Override\n-    protected MessageSink newRawMessageSink(CoreSession session, MethodHandle rawMethodHandle)\n-    {\n-        return new ReaderMessageSink(session, rawMethodHandle);\n+        return new ReaderMessageSink(coreSession, methodHandle);\n     }\n \n     @SuppressWarnings(\"Duplicates\")", "originalCommit": "4fdf52bd55af21122c0285fc1c29a8b6468b34e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "32b29a3ceda41329170d254bac3bb431544630ac", "url": "https://github.com/eclipse/jetty.project/commit/32b29a3ceda41329170d254bac3bb431544630ac", "message": "fix DecoderListsTest and cleanup code\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-06-30T01:18:36Z", "type": "commit"}]}