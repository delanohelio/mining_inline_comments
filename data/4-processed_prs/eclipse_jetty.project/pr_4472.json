{"pr_number": 4472, "pr_title": "Issue #4462 - Prevent jetty 10 WebSocket close deadlocks", "pr_createdAt": "2020-01-10T05:11:29Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4472", "timeline": [{"oid": "18850d2572e4c58d2e061c48d03256bbf2e0b39e", "url": "https://github.com/eclipse/jetty.project/commit/18850d2572e4c58d2e061c48d03256bbf2e0b39e", "message": "Issue #4462 - Replicate problems from WS close deadlock with testcases\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-10T02:47:57Z", "type": "commit"}, {"oid": "4349ec383f5452cff204a4d4f83b0f3d9dbd931c", "url": "https://github.com/eclipse/jetty.project/commit/4349ec383f5452cff204a4d4f83b0f3d9dbd931c", "message": "Issue #4462 - do not use SharedBlockingCallback for jetty WS close\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-10T04:49:54Z", "type": "commit"}, {"oid": "de903ec1db15c43787613f58010339700bb2ecb9", "url": "https://github.com/eclipse/jetty.project/commit/de903ec1db15c43787613f58010339700bb2ecb9", "message": "add missing licence header\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-10T05:13:03Z", "type": "commit"}, {"oid": "151fa256589c2f6f57fc9f95142fe44a9bbd5a7b", "url": "https://github.com/eclipse/jetty.project/commit/151fa256589c2f6f57fc9f95142fe44a9bbd5a7b", "message": "Ignore any  closes after the initial websocket close.\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-12T23:50:33Z", "type": "commit"}, {"oid": "c9fd77c31e2416610ebe76d881b90bcff76c2059", "url": "https://github.com/eclipse/jetty.project/commit/c9fd77c31e2416610ebe76d881b90bcff76c2059", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-4462-WSCloseWithLockHeld", "committedDate": "2020-01-12T23:54:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYyMTczMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r365621731", "bodyText": "@gregw using this AtomicBoolean to make sure any subsequent closes are just a NOOP.", "author": "lachlan-roberts", "createdAt": "2020-01-12T23:57:15Z", "path": "jetty-websocket/websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketRemoteEndpoint.java", "diffHunk": "@@ -74,13 +75,18 @@ public void close()\n      */\n     public void close(int statusCode, String reason)\n     {\n-        try (SharedBlockingCallback.Blocker b = blocker.acquire())\n+        if (!closed.compareAndSet(false, true))", "originalCommit": "c9fd77c31e2416610ebe76d881b90bcff76c2059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYzNTM3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r365635377", "bodyText": "But I think this should be moved to the CoreSession.", "author": "lachlan-roberts", "createdAt": "2020-01-13T02:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYyMTczMQ=="}], "type": "inlineReview"}, {"oid": "755cdce92b4b88ab314373ea5a1faa052e82945c", "url": "https://github.com/eclipse/jetty.project/commit/755cdce92b4b88ab314373ea5a1faa052e82945c", "message": "subsequent closes are prevented now with WSCoreSession close\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-13T03:12:39Z", "type": "commit"}, {"oid": "7aba5467336f2e8f9f516b299a03f3963a6bddef", "url": "https://github.com/eclipse/jetty.project/commit/7aba5467336f2e8f9f516b299a03f3963a6bddef", "message": "Use new class BlockingCallback instead of SharedBlockingCallback\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-13T03:47:58Z", "type": "commit"}, {"oid": "f07bba960e973b5dd140a8df1caf160e8d8c6432", "url": "https://github.com/eclipse/jetty.project/commit/f07bba960e973b5dd140a8df1caf160e8d8c6432", "message": "add licence header\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-13T04:30:06Z", "type": "commit"}, {"oid": "979b2888d86873146337d026aac40f60fcea847b", "url": "https://github.com/eclipse/jetty.project/commit/979b2888d86873146337d026aac40f60fcea847b", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-4462-WSCloseWithLockHeld", "committedDate": "2020-01-13T21:45:34Z", "type": "commit"}, {"oid": "61a316f9446c86c23b3f252e46188519db1de749", "url": "https://github.com/eclipse/jetty.project/commit/61a316f9446c86c23b3f252e46188519db1de749", "message": "Move prevention of duplicate closes back to the jetty and javax APIs\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-13T23:49:47Z", "type": "commit"}, {"oid": "451415848b808096747c77e954b9eb1ef9a73e04", "url": "https://github.com/eclipse/jetty.project/commit/451415848b808096747c77e954b9eb1ef9a73e04", "message": "attempt to fix long build time and fix test cases\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-14T06:25:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzI3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366773271", "bodyText": "Just a nitpick, but I'd call this just closed.", "author": "sbordet", "createdAt": "2020-01-15T09:34:03Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketSession.java", "diffHunk": "@@ -54,14 +55,14 @@\n {\n     private static final Logger LOG = Log.getLogger(JavaxWebSocketSession.class);\n \n-    protected final SharedBlockingCallback blocking = new SharedBlockingCallback();\n     private final JavaxWebSocketContainer container;\n     private final FrameHandler.CoreSession coreSession;\n     private final JavaxWebSocketFrameHandler frameHandler;\n     private final EndpointConfig config;\n     private final AvailableDecoders availableDecoders;\n     private final AvailableEncoders availableEncoders;\n     private final Map<String, String> pathParameters;\n+    private final AtomicBoolean closeInitiated = new AtomicBoolean(false);", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzYyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366773624", "bodyText": "I don't think we want to log and swallow the exception here. I would remove the catch - it's a RuntimeException and if it happens let it flow out.", "author": "sbordet", "createdAt": "2020-01-15T09:34:47Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketSession.java", "diffHunk": "@@ -194,9 +192,18 @@ public void close() throws IOException\n     @Override\n     public void close(CloseReason closeReason) throws IOException\n     {\n-        try (SharedBlockingCallback.Blocker blocker = blocking.acquire())\n+        if (!closeInitiated.compareAndSet(false, true))\n+            return;\n+\n+        try\n+        {\n+            BlockingCallback b = new BlockingCallback();\n+            coreSession.close(closeReason.getCloseCode().getCode(), closeReason.getReasonPhrase(), b);\n+            b.block();\n+        }\n+        catch (RuntimeException e)\n         {\n-            coreSession.close(closeReason.getCloseCode().getCode(), closeReason.getReasonPhrase(), blocker);\n+            LOG.warn(e);", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMTE4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366821186", "bodyText": "If the CoreSession was already closed (we didn't initiate the close here so closeInitiated is still false), then closing would throw an ISE because we have already been closed.", "author": "lachlan-roberts", "createdAt": "2020-01-15T11:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMjA0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366822048", "bodyText": "But this is more of an issue on the jetty API case where the close signature does not throw any exceptions.", "author": "lachlan-roberts", "createdAt": "2020-01-15T11:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMzQ5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366823499", "bodyText": "@lachlan-roberts concurrent closes should not throw IMHO, nto even from core. They are possible and they are not rare at all, so I'd rather fix core to not throw ISE on concurrent closes, but just make it idempotent (i.e. no operation if already closed).", "author": "sbordet", "createdAt": "2020-01-15T11:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgzODY1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366838650", "bodyText": "@sbordet the CoreSession close takes a callback, we fail the callback which indicates that the frame was not sent. If you don't care about whether the frame was sent or not you can give it NOOP and ignore the result.\nIn that case for this method we could not use the BlockingCallback altogether and just go:\ncoreSession.close(closeCode, reasonPhrase, NOOP);", "author": "lachlan-roberts", "createdAt": "2020-01-15T12:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NDcyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366774723", "bodyText": "See above, just closed.", "author": "sbordet", "createdAt": "2020-01-15T09:37:01Z", "path": "jetty-websocket/websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketRemoteEndpoint.java", "diffHunk": "@@ -37,9 +41,11 @@\n \n public class JettyWebSocketRemoteEndpoint implements org.eclipse.jetty.websocket.api.RemoteEndpoint\n {\n+    private static final Logger LOG = Log.getLogger(JettyWebSocketRemoteEndpoint.class);\n+\n     private final FrameHandler.CoreSession coreSession;\n+    private final AtomicBoolean closeInitiated = new AtomicBoolean(false);", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NDgyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366774821", "bodyText": "Ditto above.", "author": "sbordet", "createdAt": "2020-01-15T09:37:13Z", "path": "jetty-websocket/websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketRemoteEndpoint.java", "diffHunk": "@@ -74,13 +73,18 @@ public void close()\n      */\n     public void close(int statusCode, String reason)\n     {\n-        try (SharedBlockingCallback.Blocker b = blocker.acquire())\n+        if (!closeInitiated.compareAndSet(false, true))\n+            return;\n+\n+        try\n         {\n-            coreSession.close(statusCode, reason, b);\n+            BlockingCallback blockingCallback = new BlockingCallback();\n+            coreSession.close(statusCode, reason, blockingCallback);\n+            blockingCallback.block();\n         }\n-        catch (IOException e)\n+        catch (Throwable t)\n         {\n-            coreSession.close(Callback.NOOP);\n+            LOG.warn(t);", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NTE3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366775175", "bodyText": "This seems a very specialized version that is only useful to WebSocket?", "author": "sbordet", "createdAt": "2020-01-15T09:37:56Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,62 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+\n+public class BlockingCallback implements Callback", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzI1NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366777255", "bodyText": "Please add a test where 2 closes are performed from 2 different threads. The path I would like to be tested is:\nThread T1 calls close() triggering abnormal close so that onWebSocketClose() gets called.\nIn onWebSocketClose() spawn a new thread T2 that calls close() and wait for T2 to finish.\nExpect T1 to finish (was deadlocking before).", "author": "sbordet", "createdAt": "2020-01-15T09:42:17Z", "path": "jetty-websocket/websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/ServerCloseTest.java", "diffHunk": "@@ -275,4 +276,27 @@ public void testOpenSessionCleanup() throws Exception\n             close(session);\n         }\n     }\n+\n+    @Test\n+    public void testHardClose() throws Exception\n+    {\n+        // Testing WebSocketSession.close() in onClosed() does not cause deadlock.\n+        ClientUpgradeRequest request = new ClientUpgradeRequest();\n+        request.setSubProtocols(\"closeInOnClose\");\n+        CloseTrackingEndpoint clientEndpoint = new CloseTrackingEndpoint();\n+\n+        URI wsUri = WSURI.toWebsocket(server.getURI().resolve(\"/ws\"));\n+        client.connect(clientEndpoint, wsUri, request).get(5, SECONDS);\n+\n+        // Hard close from the server. Server onClosed() will try to close again which should be a NOOP.\n+        AbstractCloseEndpoint serverEndpoint = serverEndpointCreator.pollLastCreated();\n+        serverEndpoint.getSession().close(StatusCode.SHUTDOWN, \"SHUTDOWN hard close\");\n+\n+        // Verify that client got close\n+        clientEndpoint.assertReceivedCloseEvent(5000, is(StatusCode.SHUTDOWN), containsString(\"SHUTDOWN hard close\"));\n+\n+        // Verify that server socket got close event\n+        assertTrue(serverEndpoint.closeLatch.await(5, SECONDS));\n+        assertThat(serverEndpoint.closeStatusCode, is(StatusCode.SHUTDOWN));\n+    }", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5Mzg5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368393896", "bodyText": "added another test for this below here testSecondCloseFromOnClosedInNewThread", "author": "lachlan-roberts", "createdAt": "2020-01-20T07:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5OTA3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366799078", "bodyText": "The use of the SharedBlockingCallback provided both mutual exclusion (waiting for a previously allocated blocker) as well as the BlockingCallback itself.\nIt turns out that the mutual exclusion is vulnerable to reentrancy, so that if the blocking operation calls another operation that needs the same SharedBlockingCallback, then we get deadlock.\nWe have seen that close can have that reentrant behaviour, as it calls user code, but I'm not sure that means we should give up on the mutual exclusion elsewhere.  For example are we sure we can allow two threads to simultaneously enter sendBinary?\nThus I'm not sure we should swap out all the SharedBlockingCallbacks, specially as we don't really know where else this reentrancy might be a problem.  So I think we need to at least modify SharedBlockingCallback to detect such reentrancy and to either do an ISE or perhaps optionally provide a non shared instance.   Perhaps in the methods we know that might be reentrant, we can pass in an extra arg to say that renentrancy is supported:\n        try (SharedBlockingCallback.Blocker b = session.getBlocking().acquire(true))\t\n\nIn this case, if the Blocker is already allocated, then we simply return a new instance that is never shared.", "author": "gregw", "createdAt": "2020-01-15T10:26:03Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketBasicRemote.java", "diffHunk": "@@ -65,10 +65,10 @@ public void sendBinary(ByteBuffer data) throws IOException\n         {\n             LOG.debug(\"sendBinary({})\", BufferUtil.toDetailString(data));\n         }\n-        try (SharedBlockingCallback.Blocker b = session.getBlocking().acquire())\n-        {\n-            sendFrame(new Frame(OpCode.BINARY).setPayload(data), b, false);\n-        }\n+", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgxNTc0MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366815741", "bodyText": "@gregw good point! But perhaps AutoLock is enough then?\nvoid send(ByteBuffer) \n{\n  try (AutoLock lock = _lock.lock()) // Provides exclusion.\n  {\n    BlockingCallback c = new BlockingCallback();\n    send(..., c);\n    c.block(); // Provides blocking semantic.\n  }\n}\nConcurrent close from different threads is now handled by the AtomicBoolean guard so it won't deadlock. We may still want to exclude a send() and a close().", "author": "sbordet", "createdAt": "2020-01-15T11:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5OTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgxOTEwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366819106", "bodyText": "Adding locks would return the mutual exclusion, but I'm kind of concerned that we've never noticed that SharedBlockingCallback is not reentrant before.\nSo I'd rather fix SharedBlockingCallback to a) detect and warn of such reentrancy; b) to handle it by providing a non-shared version.  That way we would not need to change code in many places.", "author": "gregw", "createdAt": "2020-01-15T11:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5OTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyODk2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366828961", "bodyText": "Why do we need this mutual exclusion for things like sendBinary I can't see why there is any advantage to this over letting core handle it.\nWith only using the BlockingCallback the entry gets queued in the WebSocketCoreSession flusher and then the thread blocks on the Callback until the frame is sent.\nWith the SharedBlockingCallback the thread blocks trying to get the Callback itself, then when it gets the callback it can give it to the CoreSession it goes in the flusher and we block on the Callback again.\nIt wouldn't take more memory to just put the frame in the flusher queue.", "author": "lachlan-roberts", "createdAt": "2020-01-15T11:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5OTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0MzQ2Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366843466", "bodyText": "Chatted to @sbordet  about this.\nWe kind of arrived at the conclusion that the websocket code doesn't need mutual exclusion, so your approach of avoiding using SharedBlockingCallback is good... especially as jetty-9 doesn't mutually exclude and just throws a pending exception. We should probably review it's usage everywhere... but that's another issue!\nHowever, we probably do need your BlockingCallback to have an idleTimeout mechanism to avoid waiting forever if the callback fails", "author": "gregw", "createdAt": "2020-01-15T12:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5OTA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMDg4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366820882", "bodyText": "SharedBlockingCallback has an idle timeout so we avoid waiting forever.", "author": "gregw", "createdAt": "2020-01-15T11:14:08Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,62 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+\n+public class BlockingCallback implements Callback\n+{\n+    private FutureCallback callback = new FutureCallback();\n+\n+    @Override\n+    public void succeeded()\n+    {\n+        callback.succeeded();\n+    }\n+\n+    @Override\n+    public void failed(Throwable x)\n+    {\n+        callback.failed(x);\n+    }\n+\n+    public void block() throws IOException\n+    {\n+        try\n+        {\n+            callback.get();", "originalCommit": "451415848b808096747c77e954b9eb1ef9a73e04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg4NzU4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r366887586", "bodyText": "In practice it seems to not have one set.\nSee #3279 and #2061", "author": "joakime", "createdAt": "2020-01-15T13:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMDg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MjM0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367152346", "bodyText": "Does SharedBlockingCallback have an idle timeout? I can't see it or how to use it.\nBut I will try adding one to BlockingCallback.", "author": "lachlan-roberts", "createdAt": "2020-01-15T22:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMDg4Mg=="}], "type": "inlineReview"}, {"oid": "0b0a03a57c240fb2c35dcee560c2b529b8a8111d", "url": "https://github.com/eclipse/jetty.project/commit/0b0a03a57c240fb2c35dcee560c2b529b8a8111d", "message": "add timeout to BlockingCallback for WS use this is idleTimeout + 1000ms\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-15T23:18:25Z", "type": "commit"}, {"oid": "103d6eab017d6f2880d79a5910a50f7557cd726b", "url": "https://github.com/eclipse/jetty.project/commit/103d6eab017d6f2880d79a5910a50f7557cd726b", "message": "Core throws ClosedChannelException instead of ISE if send after closed\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-16T00:00:42Z", "type": "commit"}, {"oid": "645f0eb3788c5cbfca63480223015022274780ff", "url": "https://github.com/eclipse/jetty.project/commit/645f0eb3788c5cbfca63480223015022274780ff", "message": "update testing to test close from separate thread after hard close\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-16T00:25:51Z", "type": "commit"}, {"oid": "58f61de64f5250a10ee14b3840acd399d47893e0", "url": "https://github.com/eclipse/jetty.project/commit/58f61de64f5250a10ee14b3840acd399d47893e0", "message": "fix tests\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-16T04:11:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1MjI3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367252279", "bodyText": "if the idle timeout is 0, this is wrong.  You should only +1000 to timeouts >0", "author": "gregw", "createdAt": "2020-01-16T06:37:35Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketBasicRemote.java", "diffHunk": "@@ -134,27 +134,32 @@ public void sendText(String partialMessage, boolean isLast) throws IOException\n         {\n             LOG.debug(\"sendText({},{})\", TextUtil.hint(partialMessage), isLast);\n         }\n-        try (SharedBlockingCallback.Blocker b = session.getBlocking().acquire())\n+\n+        Frame frame;\n+        switch (messageType)\n         {\n-            Frame frame;\n-            switch (messageType)\n-            {\n-                case -1:\n-                    // New message!\n-                    frame = new Frame(OpCode.TEXT);\n-                    break;\n-                case OpCode.TEXT:\n-                    frame = new Frame(OpCode.CONTINUATION);\n-                    break;\n-                case OpCode.BINARY:\n-                    throw new IllegalStateException(\"Cannot send a partial TEXT message: BINARY message in progress\");\n-                default:\n-                    throw new IllegalStateException(\"Cannot send a partial TEXT message: unrecognized active message type \" + OpCode.name(messageType));\n-            }\n-\n-            frame.setPayload(BufferUtil.toBuffer(partialMessage, UTF_8));\n-            frame.setFin(isLast);\n-            sendFrame(frame, b, false);\n+            case -1:\n+                // New message!\n+                frame = new Frame(OpCode.TEXT);\n+                break;\n+            case OpCode.TEXT:\n+                frame = new Frame(OpCode.CONTINUATION);\n+                break;\n+            case OpCode.BINARY:\n+                throw new IllegalStateException(\"Cannot send a partial TEXT message: BINARY message in progress\");\n+            default:\n+                throw new IllegalStateException(\"Cannot send a partial TEXT message: unrecognized active message type \" + OpCode.name(messageType));\n         }\n+\n+        frame.setPayload(BufferUtil.toBuffer(partialMessage, UTF_8));\n+        frame.setFin(isLast);\n+        BlockingCallback b = newBlockingCallback();\n+        sendFrame(frame, b, false);\n+        b.block();\n+    }\n+\n+    private BlockingCallback newBlockingCallback()\n+    {\n+        return new BlockingCallback(getIdleTimeout() + 1000);", "originalCommit": "58f61de64f5250a10ee14b3840acd399d47893e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NzQ1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367257451", "bodyText": "oops yep I'll fix", "author": "lachlan-roberts", "createdAt": "2020-01-16T06:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1MjI3OQ=="}], "type": "inlineReview"}, {"oid": "ffee8bfce63dce83ad0b3ceb77ad85416985138f", "url": "https://github.com/eclipse/jetty.project/commit/ffee8bfce63dce83ad0b3ceb77ad85416985138f", "message": "do not add 1000ms to idleTimeout if it is not greater than 0\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-16T08:01:44Z", "type": "commit"}, {"oid": "b3c214df198d15f08e00f2b9874c312008ac87ff", "url": "https://github.com/eclipse/jetty.project/commit/b3c214df198d15f08e00f2b9874c312008ac87ff", "message": "javax SessionTracker guards for thrown IOExceptions from close\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-16T08:23:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0Njk3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367346977", "bodyText": "Just because I'm paranoid, I think this constructor should be eliminated.\nAnd any setting for \"infinite\" or \"no-timeout\" should also be eliminated.", "author": "joakime", "createdAt": "2020-01-16T10:40:16Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,84 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class BlockingCallback implements Callback\n+{\n+    private FutureCallback callback = new FutureCallback();\n+    private final long timeout;\n+\n+    public BlockingCallback()", "originalCommit": "b3c214df198d15f08e00f2b9874c312008ac87ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NzUxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367347516", "bodyText": "This infinite timeout bothers me.\nI have flashbacks to #3279 and #2061", "author": "joakime", "createdAt": "2020-01-16T10:41:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,84 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class BlockingCallback implements Callback\n+{\n+    private FutureCallback callback = new FutureCallback();\n+    private final long timeout;\n+\n+    public BlockingCallback()\n+    {\n+        this(-1);\n+    }\n+\n+    public BlockingCallback(long timeout)\n+    {\n+        this.timeout = timeout;\n+    }\n+\n+    @Override\n+    public void succeeded()\n+    {\n+        callback.succeeded();\n+    }\n+\n+    @Override\n+    public void failed(Throwable x)\n+    {\n+        callback.failed(x);\n+    }\n+\n+    public void block() throws IOException\n+    {\n+        try\n+        {\n+            if (timeout > 0)\n+                callback.get(timeout, TimeUnit.MILLISECONDS);\n+            else\n+                callback.get();", "originalCommit": "b3c214df198d15f08e00f2b9874c312008ac87ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTEyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367695124", "bodyText": "This is a jetty-util class so it may be used for another scenario where the infinite timeout makes sense.", "author": "lachlan-roberts", "createdAt": "2020-01-16T23:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NzUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNzQyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367917429", "bodyText": "Brace at end of line?", "author": "sbordet", "createdAt": "2020-01-17T12:43:30Z", "path": "jetty-websocket/websocket-javax-common/src/main/java/org/eclipse/jetty/websocket/javax/common/JavaxWebSocketBasicRemote.java", "diffHunk": "@@ -134,27 +134,32 @@ public void sendText(String partialMessage, boolean isLast) throws IOException\n         {\n             LOG.debug(\"sendText({},{})\", TextUtil.hint(partialMessage), isLast);\n         }\n-        try (SharedBlockingCallback.Blocker b = session.getBlocking().acquire())\n+\n+        Frame frame;\n+        switch (messageType)\n         {\n-            Frame frame;\n-            switch (messageType)\n-            {\n-                case -1:\n-                    // New message!\n-                    frame = new Frame(OpCode.TEXT);\n-                    break;\n-                case OpCode.TEXT:\n-                    frame = new Frame(OpCode.CONTINUATION);\n-                    break;\n-                case OpCode.BINARY:\n-                    throw new IllegalStateException(\"Cannot send a partial TEXT message: BINARY message in progress\");\n-                default:\n-                    throw new IllegalStateException(\"Cannot send a partial TEXT message: unrecognized active message type \" + OpCode.name(messageType));\n-            }\n-\n-            frame.setPayload(BufferUtil.toBuffer(partialMessage, UTF_8));\n-            frame.setFin(isLast);\n-            sendFrame(frame, b, false);\n+            case -1:\n+                // New message!\n+                frame = new Frame(OpCode.TEXT);\n+                break;\n+            case OpCode.TEXT:\n+                frame = new Frame(OpCode.CONTINUATION);\n+                break;\n+            case OpCode.BINARY:\n+                throw new IllegalStateException(\"Cannot send a partial TEXT message: BINARY message in progress\");\n+            default:\n+                throw new IllegalStateException(\"Cannot send a partial TEXT message: unrecognized active message type \" + OpCode.name(messageType));\n         }\n+\n+        frame.setPayload(BufferUtil.toBuffer(partialMessage, UTF_8));\n+        frame.setFin(isLast);\n+        BlockingCallback b = newBlockingCallback();\n+        sendFrame(frame, b, false);\n+        b.block();\n     }\n+\n+    private BlockingCallback newBlockingCallback()\n+    {\n+        long idleTimeout = getIdleTimeout();\n+        return new BlockingCallback((idleTimeout > 0) ? idleTimeout + 1000 : idleTimeout);    }", "originalCommit": "b3c214df198d15f08e00f2b9874c312008ac87ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNzk5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367917994", "bodyText": "I don't understand this change? try-with-resources seems the right thing to do here.\nWhy did you keep the blocks if you are not using try-with-resources?", "author": "sbordet", "createdAt": "2020-01-17T12:45:18Z", "path": "jetty-websocket/websocket-javax-tests/src/test/java/org/eclipse/jetty/websocket/javax/tests/server/SessionTrackingTest.java", "diffHunk": "@@ -104,22 +104,22 @@ public void testAddRemoveSessions() throws Exception\n         EventSocket clientSocket2 = new EventSocket();\n         EventSocket clientSocket3 = new EventSocket();\n \n-        try (Session session1 = client.connectToServer(clientSocket1, server.getWsUri().resolve(\"/session-info/1\")))\n+        Session session1 = client.connectToServer(clientSocket1, server.getWsUri().resolve(\"/session-info/1\"));", "originalCommit": "b3c214df198d15f08e00f2b9874c312008ac87ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5NTkwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368395902", "bodyText": "The close says it should throw IOException, so if we have a closed channel it throws ClosedChannelException, and because we are already explicitly closing the try-with-resources just always fails.\nI can re-structure the code to remove the blocks.", "author": "lachlan-roberts", "createdAt": "2020-01-20T07:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1Nzk2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368657967", "bodyText": "But in a double close() the second should be a no-op, no? Only in core it throws, but this is javax.", "author": "sbordet", "createdAt": "2020-01-20T17:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4NjYwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r371586601", "bodyText": "The signature javax close signature declares we throw IOException.", "author": "lachlan-roberts", "createdAt": "2020-01-28T02:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNzk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxOTM1NA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r367919354", "bodyText": "This test should block and wait for the thread (and therefore the close()) to finish, and then return from onWebSocketClose(). In this way we guarantee that we don't deadlock.", "author": "sbordet", "createdAt": "2020-01-17T12:49:06Z", "path": "jetty-websocket/websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/CloseInOnCloseEndpointNewThread.java", "diffHunk": "@@ -0,0 +1,31 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.server;\n+\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+\n+public class CloseInOnCloseEndpointNewThread extends AbstractCloseEndpoint\n+{\n+    @Override\n+    public void onWebSocketClose(int statusCode, String reason)\n+    {\n+        new Thread(() -> getSession().close(StatusCode.SERVER_ERROR, \"this should be a noop\")).start();\n+        super.onWebSocketClose(statusCode, reason);", "originalCommit": "b3c214df198d15f08e00f2b9874c312008ac87ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5NzIxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368397212", "bodyText": "Why expected to be different to using CloseInOnCloseEndpoint, which still does the blocking close but is done in the same thread?", "author": "lachlan-roberts", "createdAt": "2020-01-20T07:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxOTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1OTU5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368659590", "bodyText": "Because you are stating in the test what is the behavior that must happen.\nIf you revert the code to use SharedBlockingCallback or a Lock, this test will fail because it waits indefinitely.\nYour comments assumes how the code works and so you ask \"why writing a test since I know how the code works\".\nThat is exactly why you write tests.", "author": "sbordet", "createdAt": "2020-01-20T17:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxOTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0NDk0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368744949", "bodyText": "I'm not asking \"why writing a test since I know how the code works\", I already had the test to reproduce the deadlock, which is the same thing as this without the\nnew Thread(() ->  part. Was just asking why we want to start a new thread to do the close in this version of it.", "author": "lachlan-roberts", "createdAt": "2020-01-20T22:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxOTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0NzM4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r368747381", "bodyText": "Because testing it with 2 threads will ensure that concurrent closes will work, while testing from a single thread does not - locks employed could be reentrant.", "author": "sbordet", "createdAt": "2020-01-20T22:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxOTM1NA=="}], "type": "inlineReview"}, {"oid": "4b72768d4a869507844466a4d958cbb532063941", "url": "https://github.com/eclipse/jetty.project/commit/4b72768d4a869507844466a4d958cbb532063941", "message": "improve testing\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-20T07:07:52Z", "type": "commit"}, {"oid": "702edbed74f253a33444bb581c1f24c7afd4f986", "url": "https://github.com/eclipse/jetty.project/commit/702edbed74f253a33444bb581c1f24c7afd4f986", "message": "changes from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-20T07:22:34Z", "type": "commit"}, {"oid": "d70e51b6f2ab875baec7e69b6af0bb88c2dc7773", "url": "https://github.com/eclipse/jetty.project/commit/d70e51b6f2ab875baec7e69b6af0bb88c2dc7773", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-4462-WSCloseWithLockHeld", "committedDate": "2020-01-21T01:58:56Z", "type": "commit"}, {"oid": "bfe1fc08a406cff1e8fbc6b6222161ee32540344", "url": "https://github.com/eclipse/jetty.project/commit/bfe1fc08a406cff1e8fbc6b6222161ee32540344", "message": "fix checkstyle violation in WebSocketCloseTest\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-21T02:08:58Z", "type": "commit"}, {"oid": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "url": "https://github.com/eclipse/jetty.project/commit/c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "message": "remove test in WebSocketCloseTest now in FlushTest\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-21T03:09:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDQ4MA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370510480", "bodyText": "The only thing this class does is to have a block() throws IOException method.\nCan't we just add the method to FutureCallback instead of proliferating these Callback implementations?", "author": "sbordet", "createdAt": "2020-01-24T08:05:30Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,84 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class BlockingCallback implements Callback", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5Mjk3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r371592977", "bodyText": "BlockingCallback has now been merged with FutureCallback", "author": "lachlan-roberts", "createdAt": "2020-01-28T03:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDYxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370510616", "bodyText": "This field should be final, but I'd like to see this class go away better.", "author": "sbordet", "createdAt": "2020-01-24T08:06:01Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/BlockingCallback.java", "diffHunk": "@@ -0,0 +1,84 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class BlockingCallback implements Callback\n+{\n+    private FutureCallback callback = new FutureCallback();", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDk1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370510950", "bodyText": "Why shutdown() calls start()?", "author": "sbordet", "createdAt": "2020-01-24T08:07:25Z", "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/FlushTest.java", "diffHunk": "@@ -0,0 +1,140 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.core;\n+\n+import java.nio.channels.ClosedChannelException;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.client.WebSocketCoreClient;\n+import org.eclipse.jetty.websocket.core.server.WebSocketNegotiator;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FlushTest\n+{\n+    private WebSocketServer server;\n+    private TestFrameHandler serverHandler = new TestFrameHandler();\n+    private WebSocketCoreClient client;\n+    private WebSocketComponents components = new WebSocketComponents();\n+\n+    @BeforeEach\n+    public void startup() throws Exception\n+    {\n+        WebSocketNegotiator negotiator = WebSocketNegotiator.from((negotiation) -> serverHandler);\n+        server = new WebSocketServer(negotiator);\n+        client = new WebSocketCoreClient(null, components);\n+\n+        server.start();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void shutdown() throws Exception\n+    {\n+        server.start();\n+        client.start();", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5Mjg5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r371592895", "bodyText": "fixed", "author": "lachlan-roberts", "createdAt": "2020-01-28T03:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMjYxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370512619", "bodyText": "There is a Callback.Completable class that you can use, rather than manually do this.", "author": "sbordet", "createdAt": "2020-01-24T08:13:18Z", "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/FlushTest.java", "diffHunk": "@@ -0,0 +1,140 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.core;\n+\n+import java.nio.channels.ClosedChannelException;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.websocket.core.client.WebSocketCoreClient;\n+import org.eclipse.jetty.websocket.core.server.WebSocketNegotiator;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FlushTest\n+{\n+    private WebSocketServer server;\n+    private TestFrameHandler serverHandler = new TestFrameHandler();\n+    private WebSocketCoreClient client;\n+    private WebSocketComponents components = new WebSocketComponents();\n+\n+    @BeforeEach\n+    public void startup() throws Exception\n+    {\n+        WebSocketNegotiator negotiator = WebSocketNegotiator.from((negotiation) -> serverHandler);\n+        server = new WebSocketServer(negotiator);\n+        client = new WebSocketCoreClient(null, components);\n+\n+        server.start();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void shutdown() throws Exception\n+    {\n+        server.start();\n+        client.start();\n+    }\n+\n+    @Test\n+    public void testStandardFlush() throws Exception\n+    {\n+        TestFrameHandler clientHandler = new TestFrameHandler();\n+        CompletableFuture<FrameHandler.CoreSession> connect = client.connect(clientHandler, server.getUri());\n+        connect.get(5, TimeUnit.SECONDS);\n+\n+        // Send a batched frame.\n+        clientHandler.sendFrame(new Frame(OpCode.TEXT, \"text payload\"), Callback.NOOP, true);\n+\n+        // We have batched the frame and not sent it.\n+        assertNull(serverHandler.receivedFrames.poll(1, TimeUnit.SECONDS));\n+\n+        // Once we flush the frame is received.\n+        clientHandler.getCoreSession().flush(Callback.NOOP);\n+        Frame frame = Objects.requireNonNull(serverHandler.receivedFrames.poll(5, TimeUnit.SECONDS));\n+        assertThat(frame.getOpCode(), is(OpCode.TEXT));\n+        assertThat(frame.getPayloadAsUTF8(), is(\"text payload\"));\n+\n+        clientHandler.sendClose();\n+        frame = Objects.requireNonNull(serverHandler.receivedFrames.poll(5, TimeUnit.SECONDS));\n+        assertThat(CloseStatus.getCloseStatus(frame).getCode(), is(CloseStatus.NO_CODE));\n+        assertTrue(clientHandler.closed.await(5, TimeUnit.SECONDS));\n+        assertNull(clientHandler.getError());\n+        assertThat(clientHandler.closeStatus.getCode(), is(CloseStatus.NO_CODE));\n+    }\n+\n+    @Test\n+    public void testFlushOnCloseFrame() throws Exception\n+    {\n+        TestFrameHandler clientHandler = new TestFrameHandler();\n+        CompletableFuture<FrameHandler.CoreSession> connect = client.connect(clientHandler, server.getUri());\n+        connect.get(5, TimeUnit.SECONDS);\n+\n+        // Send a batched frame.\n+        clientHandler.sendFrame(new Frame(OpCode.TEXT, \"text payload\"), Callback.NOOP, true);\n+\n+        // We have batched the frame and not sent it.\n+        assertNull(serverHandler.receivedFrames.poll(1, TimeUnit.SECONDS));\n+\n+        // Sending the close initiates the flush and the frame is received.\n+        clientHandler.sendClose();\n+        Frame frame = Objects.requireNonNull(serverHandler.receivedFrames.poll(5, TimeUnit.SECONDS));\n+        assertThat(frame.getOpCode(), is(OpCode.TEXT));\n+        assertThat(frame.getPayloadAsUTF8(), is(\"text payload\"));\n+\n+        frame = Objects.requireNonNull(serverHandler.receivedFrames.poll(5, TimeUnit.SECONDS));\n+        assertThat(CloseStatus.getCloseStatus(frame).getCode(), is(CloseStatus.NO_CODE));\n+        assertTrue(clientHandler.closed.await(5, TimeUnit.SECONDS));\n+        assertNull(clientHandler.getError());\n+        assertThat(clientHandler.closeStatus.getCode(), is(CloseStatus.NO_CODE));\n+    }\n+\n+    @Test\n+    public void testFlushAfterClose() throws Exception\n+    {\n+        TestFrameHandler clientHandler = new TestFrameHandler();\n+        CompletableFuture<FrameHandler.CoreSession> connect = client.connect(clientHandler, server.getUri());\n+        connect.get(5, TimeUnit.SECONDS);\n+\n+        clientHandler.sendClose();\n+        assertTrue(clientHandler.closed.await(5, TimeUnit.SECONDS));\n+        assertNull(clientHandler.getError());\n+\n+        CompletableFuture<Throwable> failed = new CompletableFuture<>();\n+        Callback flushCallback = new Callback()\n+        {\n+            @Override\n+            public void failed(Throwable x)\n+            {\n+                failed.complete(x);\n+            }\n+        };", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxNDI4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370514284", "bodyText": "This test seems to test an implementation behavior that is IMHO wrong.\nIf I close NORMAL, and the callback succeeds, then any close after that will fail with a ClosedChannelException and it must not overtake a previous successful close.\nFrom the point of view of the behavior, it breaks the least surprise because I would think that the first successful close is retained, as the second close has failed.", "author": "sbordet", "createdAt": "2020-01-24T08:18:44Z", "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/WebSocketCloseTest.java", "diffHunk": "@@ -425,6 +428,50 @@ public void testAbnormalCloseStatusIsHardClose(String scheme) throws Exception\n         assertThat(CloseStatus.getCloseStatus(frame).getCode(), is(CloseStatus.SERVER_ERROR));\n     }\n \n+    @ParameterizedTest\n+    @ValueSource(strings = {WS_SCHEME, WSS_SCHEME})\n+    public void doubleClose(String scheme) throws Exception\n+    {\n+        setup(State.OPEN, scheme);\n+\n+        CountDownLatchCallback callback1 = new CountDownLatchCallback();\n+        server.handler.getCoreSession().close(CloseStatus.SERVER_ERROR, \"server error should succeed\", callback1);\n+        CountDownLatchCallback callback2 = new CountDownLatchCallback();\n+        server.handler.getCoreSession().close(CloseStatus.PROTOCOL, \"protocol error should fail\", callback2);\n+\n+        assertTrue(callback1.succeeded.await(5, TimeUnit.SECONDS));\n+        assertThat(callback2.failed.get(5, TimeUnit.SECONDS), instanceOf(ClosedChannelException.class));\n+\n+        assertTrue(server.handler.closed.await(5, TimeUnit.SECONDS));\n+        assertThat(server.handler.closeStatus.getCode(), is(CloseStatus.SERVER_ERROR));\n+        assertThat(server.handler.closeStatus.getReason(), containsString(\"server error should succeed\"));\n+\n+        Frame frame = receiveFrame(client.getInputStream());\n+        assertThat(CloseStatus.getCloseStatus(frame).getCode(), is(CloseStatus.SERVER_ERROR));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {WS_SCHEME, WSS_SCHEME})\n+    public void doubleCloseAbnormalOvertakesNormalClose(String scheme) throws Exception\n+    {\n+        setup(State.OPEN, scheme);\n+\n+        CountDownLatchCallback callback1 = new CountDownLatchCallback();\n+        server.handler.getCoreSession().close(CloseStatus.NORMAL, \"normal close (client does not complete close handshake)\", callback1);\n+        CountDownLatchCallback callback2 = new CountDownLatchCallback();\n+        server.handler.getCoreSession().close(CloseStatus.SERVER_ERROR, \"error close should overtake normal close\", callback2);\n+\n+        assertTrue(callback1.succeeded.await(5, TimeUnit.SECONDS));\n+        assertThat(callback2.failed.get(5, TimeUnit.SECONDS), instanceOf(ClosedChannelException.class));\n+\n+        assertTrue(server.handler.closed.await(5, TimeUnit.SECONDS));\n+        assertThat(server.handler.closeStatus.getCode(), is(CloseStatus.SERVER_ERROR));\n+        assertThat(server.handler.closeStatus.getReason(), containsString(\"error close should overtake normal close\"));\n+\n+        Frame frame = receiveFrame(client.getInputStream());\n+        assertThat(CloseStatus.getCloseStatus(frame).getCode(), is(CloseStatus.NORMAL));\n+    }", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4NjAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r371586005", "bodyText": "As we discussed in the call, currently abnormal status codes are coded to hard close the connection. So if one is sent in the middle of a close handshake it will interrupt the close handshake and the connection will be closed because of the abnormal status code and not because of the successful close handshake response.\nThe success or failure of the close callback indicates only whether the close frame could be sent, the onClosed notification tells you the actual reason for the close which could be different for various reasons.", "author": "lachlan-roberts", "createdAt": "2020-01-28T02:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxNDI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxNDgxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r370514817", "bodyText": "I don't think you need this class, use Callback.Completable instead.", "author": "sbordet", "createdAt": "2020-01-24T08:20:35Z", "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/WebSocketCloseTest.java", "diffHunk": "@@ -587,4 +634,22 @@ public boolean isOpen()\n             return handler.getCoreSession().isOutputOpen();\n         }\n     }\n+\n+    public static class CountDownLatchCallback implements Callback\n+    {\n+        public CountDownLatch succeeded = new CountDownLatch(1);\n+        public CompletableFuture<Throwable> failed = new CompletableFuture<>();\n+\n+        @Override\n+        public void succeeded()\n+        {\n+            succeeded.countDown();\n+        }\n+\n+        @Override\n+        public void failed(Throwable x)\n+        {\n+            failed.complete(x);\n+        }\n+    }", "originalCommit": "c595144341fc7d4bfa63a511383d8b18ca1cdd7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e4477a17edad08e7c3e1b9677535d8cc1527c98b", "url": "https://github.com/eclipse/jetty.project/commit/e4477a17edad08e7c3e1b9677535d8cc1527c98b", "message": "combine BlockingCallback with FutureCallback\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-28T02:12:49Z", "type": "commit"}, {"oid": "968dc4b57a08a109658b51a551c676be302705fe", "url": "https://github.com/eclipse/jetty.project/commit/968dc4b57a08a109658b51a551c676be302705fe", "message": "changes from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-28T02:47:59Z", "type": "commit"}, {"oid": "c2728ed382915d101602434ae0c8f89568db9b7a", "url": "https://github.com/eclipse/jetty.project/commit/c2728ed382915d101602434ae0c8f89568db9b7a", "message": "add test to cement behavior for double normal close\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-01-28T03:17:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3MDg1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4472#discussion_r371670856", "bodyText": "I'm wondering if we should repeat the pattern (mistake?) of HTTP here.  With HTTP we have a separately configurable blocking timeout, that only if not set do we default to idleTimeout.     This way we can handle (if need be) the timeouts for sending a huge frame that might take longer than the idle timeout, even though it is never actually idle.\nHowever, in HTTP, we have deprecated the blocking timeout in favour of the data rate mechanisms....  Which we don't really have here (but are probably good ideas for @ extensions?), but it may still be good to have to turn off the blocking timeout if we have confidence in our callback mechanism.\n@sbordet - thoughts?  I'm only making this a comment as I don't think we should hold this PR up while we ponder this.", "author": "gregw", "createdAt": "2020-01-28T08:51:24Z", "path": "jetty-websocket/websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketRemoteEndpoint.java", "diffHunk": "@@ -265,10 +254,14 @@ public SocketAddress getRemoteAddress()\n     @Override\n     public void flush() throws IOException\n     {\n-        try (SharedBlockingCallback.Blocker b = blocker.acquire())\n-        {\n-            coreSession.flush(b);\n-            b.block();\n-        }\n+        FutureCallback b = new FutureCallback();\n+        coreSession.flush(b);\n+        b.block(getBlockingTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    private long getBlockingTimeout()", "originalCommit": "c2728ed382915d101602434ae0c8f89568db9b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}