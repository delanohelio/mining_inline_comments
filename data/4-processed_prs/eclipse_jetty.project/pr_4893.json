{"pr_number": 4893, "pr_title": "Fixes #4892 - Non-blocking JSON parser.", "pr_createdAt": "2020-05-20T10:36:36Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4893", "timeline": [{"oid": "3ead429476cc82567631e40aa62376de7e178439", "url": "https://github.com/eclipse/jetty.project/commit/3ead429476cc82567631e40aa62376de7e178439", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nImplemented non-blocking JSON parser.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T10:35:16Z", "type": "commit"}, {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "url": "https://github.com/eclipse/jetty.project/commit/caf2592587d5c2ff2e94091ce6cfb672a861beaa", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nFixed copyright header.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T11:00:29Z", "type": "commit"}, {"oid": "bed046f01ce8019b61694ef62de867bed84a7d27", "url": "https://github.com/eclipse/jetty.project/commit/bed046f01ce8019b61694ef62de867bed84a7d27", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nFixed checkstyle.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T11:08:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyNTI5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427925293", "bodyText": "This will NPE if no convertor was registered", "author": "lorban", "createdAt": "2020-05-20T11:07:22Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+        this.stringBuilder = new Utf8StringBuilder(32);\n+        this.numberBuilder = new NumberBuilder();\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(ByteBuffer.wrap(bytes));\n+    }\n+\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (Character.isWhitespace((char)peek))\n+                                    buffer.position(position + 1);\n+                                else\n+                                    throw newInvalidJSON(buffer, \"invalid character after JSON data\");\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                    case NULL:\n+                    {\n+                        if (parseNull(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case TRUE:\n+                    {\n+                        if (parseTrue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case FALSE:\n+                    {\n+                        if (parseFalse(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case NUMBER:\n+                    {\n+                        if (parseNumber(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case STRING:\n+                    {\n+                        if (parseString(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ESCAPE:\n+                    {\n+                        if (parseEscape(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case UNICODE:\n+                    {\n+                        if (parseUnicode(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ARRAY:\n+                    {\n+                        if (parseArray(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT:\n+                    {\n+                        if (parseObject(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD:\n+                    {\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_NAME:\n+                    {\n+                        if (parseObjectFieldName(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_VALUE:\n+                    {\n+                        if (parseObjectFieldValue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    default:\n+                    {\n+                        throw new IllegalStateException(\"invalid state \" + state);\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    public <R> R eof()\n+    {\n+        try\n+        {\n+            if (stack.isEmpty())\n+                throw new IllegalStateException(\"no JSON parsed\");\n+\n+            while (true)\n+            {\n+                State state = stack.peek().state;\n+                switch (state)\n+                {\n+                    case NUMBER:\n+                    {\n+                        Number value = numberBuilder.value();\n+                        stack.pop();\n+                        stack.peek().value(value);\n+                        break;\n+                    }\n+                    case COMPLETE:\n+                    {\n+                        if (stack.peek().value == UNSET)\n+                            throw new IllegalStateException(\"invalid state \" + state);\n+                        return (R)complete();\n+                    }\n+                    default:\n+                    {\n+                        throw newInvalidJSON(BufferUtil.EMPTY_BUFFER, \"incomplete JSON\");\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    protected Map<String, Object> newObject(Context context)\n+    {\n+        return new HashMap<>();\n+    }\n+\n+    protected List<Object> newArray(Context context)\n+    {\n+        return new ArrayList<>();\n+    }\n+\n+    private Object complete()\n+    {\n+        Object result = stack.peek().value;\n+        reset();\n+        return result;\n+    }\n+\n+    private void reset()\n+    {\n+        stack.clear();\n+        chunks = null;\n+    }\n+\n+    private boolean parseAny(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '[':\n+                    if (parseArray(buffer))\n+                        return true;\n+                    break;\n+                case '{':\n+                    if (parseObject(buffer))\n+                        return true;\n+                    break;\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    if (parseNumber(buffer))\n+                        return true;\n+                    break;\n+                case '\"':\n+                    if (parseString(buffer))\n+                        return true;\n+                    break;\n+                case 'f':\n+                    if (parseFalse(buffer))\n+                        return true;\n+                    break;\n+                case 'n':\n+                    if (parseNull(buffer))\n+                        return true;\n+                    break;\n+                case 't':\n+                    if (parseTrue(buffer))\n+                        return true;\n+                    break;\n+                default:\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"unrecognized JSON value\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseNull(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'n':\n+                    if (stack.peek().state != State.NULL)\n+                    {\n+                        stack.push(State.NULL, 0);\n+                        parseNullCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                case 'u':\n+                    parseNullCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    int index = (Integer)stack.peek().value;\n+                    if (index == 2 || index == 3)\n+                        parseNullCharacter(buffer, index);\n+                    else\n+                        throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                    if (index == 3)\n+                    {\n+                        stack.pop();\n+                        stack.peek().value(null);\n+                        return true;\n+                    }\n+                    break;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseNullCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+    }\n+\n+    private boolean parseTrue(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 't':\n+                    if (stack.peek().state != State.TRUE)\n+                    {\n+                        stack.push(State.TRUE, 0);\n+                        parseTrueCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+                case 'r':\n+                    parseTrueCharacter(buffer, 1);\n+                    break;\n+                case 'u':\n+                    parseTrueCharacter(buffer, 2);\n+                    break;\n+                case 'e':\n+                    parseTrueCharacter(buffer, 3);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.TRUE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseTrueCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+    }\n+\n+    private boolean parseFalse(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'f':\n+                    if (stack.peek().state != State.FALSE)\n+                    {\n+                        stack.push(State.FALSE, 0);\n+                        parseFalseCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+                case 'a':\n+                    parseFalseCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    parseFalseCharacter(buffer, 2);\n+                    break;\n+                case 's':\n+                    parseFalseCharacter(buffer, 3);\n+                    break;\n+                case 'e':\n+                    parseFalseCharacter(buffer, 4);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.FALSE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseFalseCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+    }\n+\n+    private boolean parseNumber(ByteBuffer buffer)\n+    {\n+        if (stack.peek().state != State.NUMBER)\n+            stack.push(State.NUMBER, numberBuilder);\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '+':\n+                case '-':\n+                    if (numberBuilder.appendSign(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '.':\n+                case 'E':\n+                case 'e':\n+                    if (numberBuilder.appendAlpha(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    numberBuilder.appendDigit(currentByte);\n+                    break;\n+                default:\n+                    buffer.position(buffer.position() - 1);\n+                    Number value = numberBuilder.value();\n+                    stack.pop();\n+                    stack.peek().value(value);\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseString(ByteBuffer buffer)\n+    {\n+        Frame frame = stack.peek();\n+        if (buffer.hasRemaining() && frame.state != State.STRING)\n+        {\n+            String result = factory.cached(buffer);\n+            if (result != null)\n+            {\n+                frame.value(result);\n+                return true;\n+            }\n+        }\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiter, handle push and pop in this method.\n+                case '\"':\n+                {\n+                    if (stack.peek().state != State.STRING)\n+                    {\n+                        stack.push(State.STRING, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        String string = stringBuilder.toString();\n+                        stringBuilder.reset();\n+                        stack.pop();\n+                        stack.peek().value(string);\n+                        return true;\n+                    }\n+                }\n+                case '\\\\':\n+                {\n+                    buffer.position(buffer.position() - 1);\n+                    if (parseEscape(buffer))\n+                        break;\n+                    return false;\n+                }\n+                default:\n+                {\n+                    stringBuilder.append(currentByte);\n+                    break;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscape(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '\\\\':\n+                    if (stack.peek().state != State.ESCAPE)\n+                    {\n+                        stack.push(State.ESCAPE, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        return parseEscapeCharacter((char)currentByte);\n+                    }\n+                case '\"':\n+                case '/':\n+                    return parseEscapeCharacter((char)currentByte);\n+                case 'b':\n+                    return parseEscapeCharacter('\\b');\n+                case 'f':\n+                    return parseEscapeCharacter('\\f');\n+                case 'n':\n+                    return parseEscapeCharacter('\\n');\n+                case 'r':\n+                    return parseEscapeCharacter('\\r');\n+                case 't':\n+                    return parseEscapeCharacter('\\t');\n+                case 'u':\n+                    stack.push(State.UNICODE, ByteBuffer.allocate(4));\n+                    return parseUnicode(buffer);\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid escape sequence\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscapeCharacter(char escape)\n+    {\n+        stack.pop();\n+        stringBuilder.append(escape);\n+        return true;\n+    }\n+\n+    private boolean parseUnicode(ByteBuffer buffer)\n+    {\n+        // Expect 4 hex digits.\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            ByteBuffer hex = (ByteBuffer)stack.peek().value;\n+            hex.put(hexToByte(buffer, currentByte));\n+            if (!hex.hasRemaining())\n+            {\n+                int result = (hex.get(0) << 12) +\n+                    (hex.get(1) << 8) +\n+                    (hex.get(2) << 4) +\n+                    (hex.get(3));\n+                stack.pop();\n+                // Also done with escape parsing.\n+                stack.pop();\n+                stringBuilder.append((char)result);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private byte hexToByte(ByteBuffer buffer, byte currentByte)\n+    {\n+        try\n+        {\n+            return TypeUtil.convertHexDigit(currentByte);\n+        }\n+        catch (Throwable x)\n+        {\n+            throw newInvalidJSON(buffer, \"invalid hex digit\");\n+        }\n+    }\n+\n+    private boolean parseArray(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '[':\n+                {\n+                    buffer.get();\n+                    stack.push(State.ARRAY, newArray(stack));\n+                    break;\n+                }\n+                case ']':\n+                {\n+                    buffer.get();\n+                    Object array = stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(array);\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    buffer.get();\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        if (parseAny(buffer))\n+                        {\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObject(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '{':\n+                {\n+                    if (stack.peek().state != State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT, newObject(stack));\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid object\");\n+                }\n+                case '}':\n+                {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> object = (Map<String, Object>)stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(convertObject(object));\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(currentByte))\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        buffer.position(buffer.position() - 1);\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectField(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT_FIELD, UNSET);\n+                        if (parseObjectFieldName(buffer))\n+                        {\n+                            // We are not done yet, parse the value.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else if (stack.peek().state == State.OBJECT_FIELD_VALUE)\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldName(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT_FIELD)\n+                    {\n+                        stack.push(State.OBJECT_FIELD_NAME, UNSET);\n+                        if (parseString(buffer))\n+                        {\n+                            // We are not done yet, parse until the ':'.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+                case ':':\n+                {\n+                    buffer.get();\n+                    // We are done with the field name.\n+                    String fieldName = (String)stack.peek().value;\n+                    stack.pop();\n+                    // Change state to parse the field value.\n+                    stack.push(fieldName, State.OBJECT_FIELD_VALUE, UNSET);\n+                    return true;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldValue(ByteBuffer buffer)\n+    {\n+        if (stack.peek().value == UNSET)\n+        {\n+            if (!parseAny(buffer))\n+                return false;\n+        }\n+\n+        // We are done with the field value.\n+        Frame frame = stack.peek();\n+        Object value = frame.value;\n+        String name = frame.name;\n+        stack.pop();\n+        // We are done with the field.\n+        stack.pop();\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> map = (Map<String, Object>)stack.peek().value;\n+        map.put(name, value);\n+\n+        return true;\n+    }\n+\n+    private Object convertObject(Map<String, Object> object)\n+    {\n+        Object result = convertObject(\"x-class\", object);\n+        if (result == null)\n+        {\n+            result = convertObject(\"class\", object);\n+            if (result == null)\n+                return object;\n+        }\n+        return result;\n+    }\n+\n+    private Object convertObject(String fieldName, Map<String, Object> object)\n+    {\n+        String className = (String)object.get(fieldName);\n+        if (className == null)\n+            return null;\n+\n+        JSON.Convertible convertible = toConvertible(className);\n+        if (convertible != null)\n+        {\n+            convertible.fromJSON(object);\n+            return convertible;\n+        }\n+\n+        JSON.Convertor convertor = factory.convertors.get(className);", "originalCommit": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAwMjU0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428002540", "bodyText": "I added a getConvertor(String) in the Factory and use it here.", "author": "sbordet", "createdAt": "2020-05-20T13:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyNTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyOTk3NA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427929974", "bodyText": "This constructor is useless as it's only ever called with (null, null)", "author": "lorban", "createdAt": "2020-05-20T11:16:21Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+        this.stringBuilder = new Utf8StringBuilder(32);\n+        this.numberBuilder = new NumberBuilder();\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(ByteBuffer.wrap(bytes));\n+    }\n+\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (Character.isWhitespace((char)peek))\n+                                    buffer.position(position + 1);\n+                                else\n+                                    throw newInvalidJSON(buffer, \"invalid character after JSON data\");\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                    case NULL:\n+                    {\n+                        if (parseNull(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case TRUE:\n+                    {\n+                        if (parseTrue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case FALSE:\n+                    {\n+                        if (parseFalse(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case NUMBER:\n+                    {\n+                        if (parseNumber(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case STRING:\n+                    {\n+                        if (parseString(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ESCAPE:\n+                    {\n+                        if (parseEscape(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case UNICODE:\n+                    {\n+                        if (parseUnicode(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ARRAY:\n+                    {\n+                        if (parseArray(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT:\n+                    {\n+                        if (parseObject(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD:\n+                    {\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_NAME:\n+                    {\n+                        if (parseObjectFieldName(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_VALUE:\n+                    {\n+                        if (parseObjectFieldValue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    default:\n+                    {\n+                        throw new IllegalStateException(\"invalid state \" + state);\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    public <R> R eof()\n+    {\n+        try\n+        {\n+            if (stack.isEmpty())\n+                throw new IllegalStateException(\"no JSON parsed\");\n+\n+            while (true)\n+            {\n+                State state = stack.peek().state;\n+                switch (state)\n+                {\n+                    case NUMBER:\n+                    {\n+                        Number value = numberBuilder.value();\n+                        stack.pop();\n+                        stack.peek().value(value);\n+                        break;\n+                    }\n+                    case COMPLETE:\n+                    {\n+                        if (stack.peek().value == UNSET)\n+                            throw new IllegalStateException(\"invalid state \" + state);\n+                        return (R)complete();\n+                    }\n+                    default:\n+                    {\n+                        throw newInvalidJSON(BufferUtil.EMPTY_BUFFER, \"incomplete JSON\");\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    protected Map<String, Object> newObject(Context context)\n+    {\n+        return new HashMap<>();\n+    }\n+\n+    protected List<Object> newArray(Context context)\n+    {\n+        return new ArrayList<>();\n+    }\n+\n+    private Object complete()\n+    {\n+        Object result = stack.peek().value;\n+        reset();\n+        return result;\n+    }\n+\n+    private void reset()\n+    {\n+        stack.clear();\n+        chunks = null;\n+    }\n+\n+    private boolean parseAny(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '[':\n+                    if (parseArray(buffer))\n+                        return true;\n+                    break;\n+                case '{':\n+                    if (parseObject(buffer))\n+                        return true;\n+                    break;\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    if (parseNumber(buffer))\n+                        return true;\n+                    break;\n+                case '\"':\n+                    if (parseString(buffer))\n+                        return true;\n+                    break;\n+                case 'f':\n+                    if (parseFalse(buffer))\n+                        return true;\n+                    break;\n+                case 'n':\n+                    if (parseNull(buffer))\n+                        return true;\n+                    break;\n+                case 't':\n+                    if (parseTrue(buffer))\n+                        return true;\n+                    break;\n+                default:\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"unrecognized JSON value\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseNull(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'n':\n+                    if (stack.peek().state != State.NULL)\n+                    {\n+                        stack.push(State.NULL, 0);\n+                        parseNullCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                case 'u':\n+                    parseNullCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    int index = (Integer)stack.peek().value;\n+                    if (index == 2 || index == 3)\n+                        parseNullCharacter(buffer, index);\n+                    else\n+                        throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                    if (index == 3)\n+                    {\n+                        stack.pop();\n+                        stack.peek().value(null);\n+                        return true;\n+                    }\n+                    break;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseNullCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+    }\n+\n+    private boolean parseTrue(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 't':\n+                    if (stack.peek().state != State.TRUE)\n+                    {\n+                        stack.push(State.TRUE, 0);\n+                        parseTrueCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+                case 'r':\n+                    parseTrueCharacter(buffer, 1);\n+                    break;\n+                case 'u':\n+                    parseTrueCharacter(buffer, 2);\n+                    break;\n+                case 'e':\n+                    parseTrueCharacter(buffer, 3);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.TRUE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseTrueCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+    }\n+\n+    private boolean parseFalse(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'f':\n+                    if (stack.peek().state != State.FALSE)\n+                    {\n+                        stack.push(State.FALSE, 0);\n+                        parseFalseCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+                case 'a':\n+                    parseFalseCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    parseFalseCharacter(buffer, 2);\n+                    break;\n+                case 's':\n+                    parseFalseCharacter(buffer, 3);\n+                    break;\n+                case 'e':\n+                    parseFalseCharacter(buffer, 4);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.FALSE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseFalseCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+    }\n+\n+    private boolean parseNumber(ByteBuffer buffer)\n+    {\n+        if (stack.peek().state != State.NUMBER)\n+            stack.push(State.NUMBER, numberBuilder);\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '+':\n+                case '-':\n+                    if (numberBuilder.appendSign(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '.':\n+                case 'E':\n+                case 'e':\n+                    if (numberBuilder.appendAlpha(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    numberBuilder.appendDigit(currentByte);\n+                    break;\n+                default:\n+                    buffer.position(buffer.position() - 1);\n+                    Number value = numberBuilder.value();\n+                    stack.pop();\n+                    stack.peek().value(value);\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseString(ByteBuffer buffer)\n+    {\n+        Frame frame = stack.peek();\n+        if (buffer.hasRemaining() && frame.state != State.STRING)\n+        {\n+            String result = factory.cached(buffer);\n+            if (result != null)\n+            {\n+                frame.value(result);\n+                return true;\n+            }\n+        }\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiter, handle push and pop in this method.\n+                case '\"':\n+                {\n+                    if (stack.peek().state != State.STRING)\n+                    {\n+                        stack.push(State.STRING, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        String string = stringBuilder.toString();\n+                        stringBuilder.reset();\n+                        stack.pop();\n+                        stack.peek().value(string);\n+                        return true;\n+                    }\n+                }\n+                case '\\\\':\n+                {\n+                    buffer.position(buffer.position() - 1);\n+                    if (parseEscape(buffer))\n+                        break;\n+                    return false;\n+                }\n+                default:\n+                {\n+                    stringBuilder.append(currentByte);\n+                    break;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscape(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '\\\\':\n+                    if (stack.peek().state != State.ESCAPE)\n+                    {\n+                        stack.push(State.ESCAPE, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        return parseEscapeCharacter((char)currentByte);\n+                    }\n+                case '\"':\n+                case '/':\n+                    return parseEscapeCharacter((char)currentByte);\n+                case 'b':\n+                    return parseEscapeCharacter('\\b');\n+                case 'f':\n+                    return parseEscapeCharacter('\\f');\n+                case 'n':\n+                    return parseEscapeCharacter('\\n');\n+                case 'r':\n+                    return parseEscapeCharacter('\\r');\n+                case 't':\n+                    return parseEscapeCharacter('\\t');\n+                case 'u':\n+                    stack.push(State.UNICODE, ByteBuffer.allocate(4));\n+                    return parseUnicode(buffer);\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid escape sequence\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscapeCharacter(char escape)\n+    {\n+        stack.pop();\n+        stringBuilder.append(escape);\n+        return true;\n+    }\n+\n+    private boolean parseUnicode(ByteBuffer buffer)\n+    {\n+        // Expect 4 hex digits.\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            ByteBuffer hex = (ByteBuffer)stack.peek().value;\n+            hex.put(hexToByte(buffer, currentByte));\n+            if (!hex.hasRemaining())\n+            {\n+                int result = (hex.get(0) << 12) +\n+                    (hex.get(1) << 8) +\n+                    (hex.get(2) << 4) +\n+                    (hex.get(3));\n+                stack.pop();\n+                // Also done with escape parsing.\n+                stack.pop();\n+                stringBuilder.append((char)result);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private byte hexToByte(ByteBuffer buffer, byte currentByte)\n+    {\n+        try\n+        {\n+            return TypeUtil.convertHexDigit(currentByte);\n+        }\n+        catch (Throwable x)\n+        {\n+            throw newInvalidJSON(buffer, \"invalid hex digit\");\n+        }\n+    }\n+\n+    private boolean parseArray(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '[':\n+                {\n+                    buffer.get();\n+                    stack.push(State.ARRAY, newArray(stack));\n+                    break;\n+                }\n+                case ']':\n+                {\n+                    buffer.get();\n+                    Object array = stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(array);\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    buffer.get();\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        if (parseAny(buffer))\n+                        {\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObject(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '{':\n+                {\n+                    if (stack.peek().state != State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT, newObject(stack));\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid object\");\n+                }\n+                case '}':\n+                {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> object = (Map<String, Object>)stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(convertObject(object));\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(currentByte))\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        buffer.position(buffer.position() - 1);\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectField(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT_FIELD, UNSET);\n+                        if (parseObjectFieldName(buffer))\n+                        {\n+                            // We are not done yet, parse the value.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else if (stack.peek().state == State.OBJECT_FIELD_VALUE)\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldName(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT_FIELD)\n+                    {\n+                        stack.push(State.OBJECT_FIELD_NAME, UNSET);\n+                        if (parseString(buffer))\n+                        {\n+                            // We are not done yet, parse until the ':'.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+                case ':':\n+                {\n+                    buffer.get();\n+                    // We are done with the field name.\n+                    String fieldName = (String)stack.peek().value;\n+                    stack.pop();\n+                    // Change state to parse the field value.\n+                    stack.push(fieldName, State.OBJECT_FIELD_VALUE, UNSET);\n+                    return true;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldValue(ByteBuffer buffer)\n+    {\n+        if (stack.peek().value == UNSET)\n+        {\n+            if (!parseAny(buffer))\n+                return false;\n+        }\n+\n+        // We are done with the field value.\n+        Frame frame = stack.peek();\n+        Object value = frame.value;\n+        String name = frame.name;\n+        stack.pop();\n+        // We are done with the field.\n+        stack.pop();\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> map = (Map<String, Object>)stack.peek().value;\n+        map.put(name, value);\n+\n+        return true;\n+    }\n+\n+    private Object convertObject(Map<String, Object> object)\n+    {\n+        Object result = convertObject(\"x-class\", object);\n+        if (result == null)\n+        {\n+            result = convertObject(\"class\", object);\n+            if (result == null)\n+                return object;\n+        }\n+        return result;\n+    }\n+\n+    private Object convertObject(String fieldName, Map<String, Object> object)\n+    {\n+        String className = (String)object.get(fieldName);\n+        if (className == null)\n+            return null;\n+\n+        JSON.Convertible convertible = toConvertible(className);\n+        if (convertible != null)\n+        {\n+            convertible.fromJSON(object);\n+            return convertible;\n+        }\n+\n+        JSON.Convertor convertor = factory.convertors.get(className);\n+        if (convertor != null)\n+            return convertor.fromJSON(object);\n+\n+        return null;\n+    }\n+\n+    private JSON.Convertible toConvertible(String className)\n+    {\n+        try\n+        {\n+            Class<?> klass = Loader.loadClass(className);\n+            if (JSON.Convertible.class.isAssignableFrom(klass))\n+                return (JSON.Convertible)klass.getConstructor().newInstance();\n+            return null;\n+        }\n+        catch (Throwable x)\n+        {\n+            throw new IllegalArgumentException(x);\n+        }\n+    }\n+\n+    protected RuntimeException newInvalidJSON(ByteBuffer buffer, String message)\n+    {\n+        Utf8StringBuilder builder = new Utf8StringBuilder();\n+        builder.append(System.lineSeparator());\n+        int position = buffer.position();\n+        if (factory.isDetailedParseException())\n+        {\n+            chunks.forEach(chunk -> builder.append(buffer));\n+        }\n+        else\n+        {\n+            buffer.position(0);\n+            builder.append(buffer);\n+            buffer.position(position);\n+        }\n+        builder.append(System.lineSeparator());\n+        String indent = \"\";\n+        if (position > 1)\n+        {\n+            char[] chars = new char[position - 1];\n+            Arrays.fill(chars, ' ');\n+            indent = new String(chars);\n+        }\n+        builder.append(indent);\n+        builder.append(\"^ \");\n+        builder.append(message);\n+        return new IllegalArgumentException(builder.toString());\n+    }\n+\n+    public interface Context\n+    {\n+        public int depth();\n+    }\n+\n+    private enum State\n+    {\n+        COMPLETE, NULL, TRUE, FALSE, NUMBER, STRING, ESCAPE, UNICODE, ARRAY, OBJECT, OBJECT_FIELD, OBJECT_FIELD_NAME, OBJECT_FIELD_VALUE\n+    }\n+\n+    private static class Frame\n+    {\n+        private String name;\n+        private State state;\n+        private Object value;\n+\n+        private Frame(State state, Object value)", "originalCommit": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk5NzMxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427997312", "bodyText": "Removed.", "author": "sbordet", "createdAt": "2020-05-20T13:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyOTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTk4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427931985", "bodyText": "Shouldn't this constructor be package-private?", "author": "lorban", "createdAt": "2020-05-20T11:20:27Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)", "originalCommit": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk5NTYzNw==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427995637", "bodyText": "No, it should be public to allow subclassing from other packages.", "author": "sbordet", "createdAt": "2020-05-20T13:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NDgwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428074800", "bodyText": "Wouldn't that be protected?", "author": "lorban", "createdAt": "2020-05-20T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTE2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428119169", "bodyText": "If it is protected you cannot instantiate it directly. For example, if in the future we allow configuration of the parser instance, this would not be possible:\nclass MyFactory extends AsyncJSON.Factory {\n  @Override\n  public AsyncJSON newAsyncJSON() {\n    AsyncJSON result = new AsyncJSON(this); // Does not compile.\n    result.setFoo(\"bar\");\n    System.err.println(result);\n    return result;\n  }\n}\nSure you can call super to get the instance, but not if you want to customize the instance creation, etc.\nI feel in this case we don't gain much with protected, that instead becomes most of the times just an annoyance (because I can work it around anyway, just with more code).", "author": "sbordet", "createdAt": "2020-05-20T15:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMjc0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427932740", "bodyText": "You probably want to initialize the stack in the constructor, or remove the initializations of stringBuilder and numberBuilder from the constructor.", "author": "lorban", "createdAt": "2020-05-20T11:22:01Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();", "originalCommit": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk5NzExMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427997111", "bodyText": "Okay", "author": "sbordet", "createdAt": "2020-05-20T13:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMjc0MA=="}], "type": "inlineReview"}, {"oid": "f2ef054b289167c98e51f49867eaf32ebdf6dca3", "url": "https://github.com/eclipse/jetty.project/commit/f2ef054b289167c98e51f49867eaf32ebdf6dca3", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nAdded javadocs.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T12:03:30Z", "type": "commit"}, {"oid": "9ad7ff795e5ec5139981ce384303baa14171c687", "url": "https://github.com/eclipse/jetty.project/commit/9ad7ff795e5ec5139981ce384303baa14171c687", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T13:12:24Z", "type": "commit"}, {"oid": "e588a1bd9da8e4cc6131ad2fac672b8feeff750e", "url": "https://github.com/eclipse/jetty.project/commit/e588a1bd9da8e4cc6131ad2fac672b8feeff750e", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nAdded parse(byte[], int, int).\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T14:14:05Z", "type": "commit"}, {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7", "url": "https://github.com/eclipse/jetty.project/commit/d16ce1234998e5dc29057267b843cd6d57d37fd7", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-05-20T22:35:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ4NDU5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428484592", "bodyText": "The value needs to be encoded/escaped when used as the key.", "author": "gregw", "createdAt": "2020-05-21T07:12:14Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1358 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+import org.eclipse.jetty.util.ajax.JSON.Convertible;\n+import org.eclipse.jetty.util.ajax.JSON.Convertor;\n+\n+/**\n+ * <p>A non-blocking JSON parser that can parse partial JSON strings.</p>\n+ * <p>Usage:</p>\n+ * <pre>\n+ * AsyncJSON parser = new AsyncJSON.Factory().newAsyncJSON();\n+ *\n+ * // Feed the parser with partial JSON string content.\n+ * parser.parse(chunk1);\n+ * parser.parse(chunk2);\n+ *\n+ * // Tell the parser that the JSON string content\n+ * // is terminated and get the JSON object back.\n+ * Map&lt;String, Object&gt; object = parser.complete();\n+ * </pre>\n+ * <p>After the call to {@link #complete()} the parser can be reused to parse\n+ * another JSON string.</p>\n+ * <p>Custom objects can be created by specifying a {@code \"class\"} or\n+ * {@code \"x-class\"} field:</p>\n+ * <pre>\n+ * String json = \"\"\"\n+ * {\n+ *   \"x-class\": \"com.acme.Person\",\n+ *   \"firstName\": \"John\",\n+ *   \"lastName\": \"Doe\",\n+ *   \"age\": 42\n+ * }\n+ * \"\"\"\n+ *\n+ * parser.parse(json);\n+ * com.acme.Person person = parser.complete();\n+ * </pre>\n+ * <p>Class {@code com.acme.Person} must either implement {@link Convertible},\n+ * or be mapped with a {@link Convertor} via {@link Factory#putConvertor(String, Convertor)}.</p>\n+ */\n+public class AsyncJSON\n+{\n+    /**\n+     * <p>The factory that creates AsyncJSON instances.</p>\n+     * <p>The factory can be configured with custom {@link Convertor}s,\n+     * and with cached strings that will not be allocated if they can\n+     * be looked up from the cache.</p>\n+     */\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        /**\n+         * @return whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        /**\n+         * @param detailedParseException whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        /**\n+         * @param value the string to cache\n+         */\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);", "originalCommit": "d16ce1234998e5dc29057267b843cd6d57d37fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b", "url": "https://github.com/eclipse/jetty.project/commit/b9466823c8b7dc9e4a01b78ee8eec900b24f201b", "message": "Issue #4892 Async JSON\n\nHandle encoded cached strings (or not).\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-05-21T09:44:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428591672", "bodyText": "This whitespace list seems awfully narrow.", "author": "joakime", "createdAt": "2020-05-21T11:17:05Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -1115,6 +1115,20 @@ protected RuntimeException newInvalidJSON(ByteBuffer buffer, String message)\n         return new IllegalArgumentException(builder.toString());\n     }\n \n+    private static boolean isWhitespace(byte ws)\n+    {\n+        switch (ws)\n+        {\n+            case ' ':\n+            case '\\n':\n+            case '\\r':\n+            case '\\t':\n+                return true;\n+            default:\n+                return false;", "originalCommit": "d16ce1234998e5dc29057267b843cd6d57d37fd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MzA0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428593048", "bodyText": "Here's mozilla's take on whitespace - https://developer.mozilla.org/en-US/docs/Glossary/whitespace", "author": "joakime", "createdAt": "2020-05-21T11:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMTU0MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428601541", "bodyText": "All the JSON specs agree on those 4 chars only.\nhttps://tools.ietf.org/html/rfc7159#section-2", "author": "sbordet", "createdAt": "2020-05-21T11:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMjM4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428602386", "bodyText": "The JSON RFC clearly states that only those four characters are to be considered whitespaces: https://tools.ietf.org/html/rfc8259 (top of page 5).", "author": "lorban", "createdAt": "2020-05-21T11:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxOTQ4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428619487", "bodyText": "okay.", "author": "joakime", "createdAt": "2020-05-21T12:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5NTM2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428595368", "bodyText": "If this check is outside of the JSON document, then this version of isWhitespace is too restrictive. right?\nThe isWhitespace(byte) method is valid only for within a JSON document.", "author": "joakime", "createdAt": "2020-05-21T11:26:38Z", "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1389 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+import org.eclipse.jetty.util.ajax.JSON.Convertible;\n+import org.eclipse.jetty.util.ajax.JSON.Convertor;\n+\n+/**\n+ * <p>A non-blocking JSON parser that can parse partial JSON strings.</p>\n+ * <p>Usage:</p>\n+ * <pre>\n+ * AsyncJSON parser = new AsyncJSON.Factory().newAsyncJSON();\n+ *\n+ * // Feed the parser with partial JSON string content.\n+ * parser.parse(chunk1);\n+ * parser.parse(chunk2);\n+ *\n+ * // Tell the parser that the JSON string content\n+ * // is terminated and get the JSON object back.\n+ * Map&lt;String, Object&gt; object = parser.complete();\n+ * </pre>\n+ * <p>After the call to {@link #complete()} the parser can be reused to parse\n+ * another JSON string.</p>\n+ * <p>Custom objects can be created by specifying a {@code \"class\"} or\n+ * {@code \"x-class\"} field:</p>\n+ * <pre>\n+ * String json = \"\"\"\n+ * {\n+ *   \"x-class\": \"com.acme.Person\",\n+ *   \"firstName\": \"John\",\n+ *   \"lastName\": \"Doe\",\n+ *   \"age\": 42\n+ * }\n+ * \"\"\"\n+ *\n+ * parser.parse(json);\n+ * com.acme.Person person = parser.complete();\n+ * </pre>\n+ * <p>Class {@code com.acme.Person} must either implement {@link Convertible},\n+ * or be mapped with a {@link Convertor} via {@link Factory#putConvertor(String, Convertor)}.</p>\n+ */\n+public class AsyncJSON\n+{\n+    /**\n+     * <p>The factory that creates AsyncJSON instances.</p>\n+     * <p>The factory can be configured with custom {@link Convertor}s,\n+     * and with cached strings that will not be allocated if they can\n+     * be looked up from the cache.</p>\n+     */\n+    public static class Factory\n+    {\n+        private Trie<CachedString> cache;\n+        private Map<String, Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        /**\n+         * @return whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        /**\n+         * @param detailedParseException whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        /**\n+         * @param value the string to cache\n+         * @return whether the value can be cached\n+         */\n+        public boolean cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+\n+            CachedString cached = new CachedString(value);\n+            if (cached.isCacheable())\n+            {\n+                cache.put(cached.encoded, cached);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * <p>Attempts to return a cached string from the buffer bytes.</p>\n+         * <p>In case of a cache hit, the string is returned and the buffer\n+         * position updated.</p>\n+         * <p>In case of cache miss, {@code null} is returned and the buffer\n+         * position is left unaltered.</p>\n+         *\n+         * @param buffer the buffer to lookup the string from\n+         * @return a cached string or {@code null}\n+         */\n+        protected String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                CachedString result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.encoded.length());\n+                    return result.value;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * @return a new parser instance\n+         */\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        /**\n+         * <p>Associates the given {@link Convertor} to the given class name.</p>\n+         *\n+         * @param className the domain class name such as {@code com.acme.Person}\n+         * @param convertor the {@link Convertor} that converts {@code Map} to domain objects\n+         */\n+        public void putConvertor(String className, Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        /**\n+         * <p>Removes the {@link Convertor} associated with the given class name.</p>\n+         *\n+         * @param className the class name associated with the {@link Convertor}\n+         * @return the {@link Convertor} associated with the class name, or {@code null}\n+         */\n+        public Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+\n+        /**\n+         * <p>Returns the {@link Convertor} associated with the given class name, if any.</p>\n+         *\n+         * @param className the class name associated with the {@link Convertor}\n+         * @return the {@link Convertor} associated with the class name, or {@code null}\n+         */\n+        public Convertor getConvertor(String className)\n+        {\n+            return convertors == null ? null : convertors.get(className);\n+        }\n+\n+        private static class CachedString\n+        {\n+            private final String encoded;\n+            private final String value;\n+\n+            private CachedString(String value)\n+            {\n+                this.encoded = JSON.toString(value);\n+                this.value = value;\n+            }\n+\n+            private boolean isCacheable()\n+            {\n+                for (int i = encoded.length(); i-- > 0;)\n+                {\n+                    char c = encoded.charAt(i);\n+                    if (c > 127)\n+                        return false;\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final FrameStack stack = new FrameStack();\n+    private final NumberBuilder numberBuilder = new NumberBuilder();\n+    private final Utf8StringBuilder stringBuilder = new Utf8StringBuilder(32);\n+    private final Factory factory;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given bytes chunk.</p>\n+     *\n+     * @param bytes the bytes to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given bytes chunk.</p>\n+     *\n+     * @param bytes the bytes to parse\n+     * @param offset the offset to start parsing from\n+     * @param length the number of bytes to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(byte[] bytes, int offset, int length)\n+    {\n+        return parse(ByteBuffer.wrap(bytes, offset, length));\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given buffer chunk.</p>\n+     *\n+     * @param buffer the buffer to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (isWhitespace(peek))", "originalCommit": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMjYxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428602617", "bodyText": "This is a JSON document that must be delimited by other means, e.g. HTTP framing or WebSocket message framing.\nAs such it is part of the JSON document until complete() is called.", "author": "sbordet", "createdAt": "2020-05-21T11:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5NTM2OA=="}], "type": "inlineReview"}]}