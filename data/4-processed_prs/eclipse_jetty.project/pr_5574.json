{"pr_number": 5574, "pr_title": "Issue #5499 - Reduce buffer allocations and copying from ByteAccumulator", "pr_createdAt": "2020-11-05T06:36:36Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5574", "timeline": [{"oid": "1f5b446462944a7a0d36053c09770774b640a9cc", "url": "https://github.com/eclipse/jetty.project/commit/1f5b446462944a7a0d36053c09770774b640a9cc", "message": "Fix issue #5499\n\nthis PR let the ByteAccumulator recyclable. after invoke ByteAccumulator.transferTo method\nwe can invoke ByteAccumulator.recycle method to reuse byte[] via ByteAccumulator.newByteBuffer method\n\nSigned-off-by: Baoyi Chen <chen.bao.yi@qq.com>", "committedDate": "2020-10-30T16:08:30Z", "type": "commit"}, {"oid": "05dafb89ab5eb6dc961d3bc0ae84682b560289cd", "url": "https://github.com/eclipse/jetty.project/commit/05dafb89ab5eb6dc961d3bc0ae84682b560289cd", "message": "Move work on ByteAccumulator to jetty-util\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-05T02:42:47Z", "type": "commit"}, {"oid": "145bcff64916420dd5e02722dbaf48dc77e93786", "url": "https://github.com/eclipse/jetty.project/commit/145bcff64916420dd5e02722dbaf48dc77e93786", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-9.4.x-ByteAccumulator", "committedDate": "2020-11-05T02:43:00Z", "type": "commit"}, {"oid": "a3c3e24cab543ab501ec1267015326fb2de63adb", "url": "https://github.com/eclipse/jetty.project/commit/a3c3e24cab543ab501ec1267015326fb2de63adb", "message": "Use the ByteBufferPool in the ByteAccumulator\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-05T03:38:19Z", "type": "commit"}, {"oid": "7bcae9968b562926f1037b213ee5dbe42b858775", "url": "https://github.com/eclipse/jetty.project/commit/7bcae9968b562926f1037b213ee5dbe42b858775", "message": "allow writing directly into the ByteAccumulator\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-05T06:19:05Z", "type": "commit"}, {"oid": "6e9572215b30df8e00cb52238b3703f699819523", "url": "https://github.com/eclipse/jetty.project/commit/6e9572215b30df8e00cb52238b3703f699819523", "message": "ByteAccumulator transferTo expects buffer in fill mode.\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-05T08:11:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2NTk3OA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517865978", "bodyText": "Can you call this nextBuffer or ensureBuffer or something not get to try to make it clear that you are accessing a buffer that is held and managed by the accumulator", "author": "gregw", "createdAt": "2020-11-05T08:23:05Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 3;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer getBuffer()\n+    {\n+        return getBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer getBuffer(int minAllocationSize)", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3NjQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518576476", "bodyText": "I'm not sold that either on either of these names, but I have changed to ensureBuffer for now.", "author": "lachlan-roberts", "createdAt": "2020-11-06T07:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2NTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2NzEwMw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517867103", "bodyText": "Why is the while needed here?  Wont the getBuffer always return a buffer with enough space to put the passed buffer into?", "author": "gregw", "createdAt": "2020-11-05T08:25:01Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 3;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer getBuffer()\n+    {\n+        return getBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer getBuffer(int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= MIN_SPACE)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);\n+            _buffers.add(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    public void copyBytes(byte[] buf, int offset, int length)\n+    {\n+        copyBuffer(BufferUtil.toBuffer(buf, offset, length));\n+    }\n+\n+    public void copyBuffer(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            ByteBuffer b = getBuffer(buffer.remaining());\n+            int pos = BufferUtil.flipToFill(b);\n+            BufferUtil.put(buffer, b);\n+            BufferUtil.flipToFlush(b, pos);\n+        }", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNTAyNg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518435026", "bodyText": "No, the buffer may have space left over from the previous write. In that case this space will be filled first before allocating a new buffer.", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MjM3NA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518582374", "bodyText": "Ah yes - I think we need to work on the signature of ensureBuffer to make that clearer... standby for suggestion....", "author": "gregw", "createdAt": "2020-11-06T08:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2NzEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MDEyNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517870124", "bodyText": "Perhaps also have a method ByteBuffer takeBuffer() which can take a single buffer from the pool with all the contents. This could be the the originally allocated one if _buffers.size()==1, or a newly allocated one.\n... but only add this method if you can find a use for it.", "author": "gregw", "createdAt": "2020-11-05T08:30:03Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 3;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer getBuffer()\n+    {\n+        return getBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer getBuffer(int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= MIN_SPACE)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);\n+            _buffers.add(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    public void copyBytes(byte[] buf, int offset, int length)\n+    {\n+        copyBuffer(BufferUtil.toBuffer(buf, offset, length));\n+    }\n+\n+    public void copyBuffer(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            ByteBuffer b = getBuffer(buffer.remaining());\n+            int pos = BufferUtil.flipToFill(b);\n+            BufferUtil.put(buffer, b);\n+            BufferUtil.flipToFlush(b, pos);\n+        }\n+    }\n+\n+    public void writeTo(ByteBuffer buffer)\n+    {\n+        int pos = BufferUtil.flipToFill(buffer);\n+        for (ByteBuffer bb : _buffers)\n+        {\n+            buffer.put(bb);\n+        }\n+        BufferUtil.flipToFlush(buffer, pos);\n+    }\n+\n+    public void writeTo(OutputStream out) throws IOException\n+    {\n+        for (ByteBuffer bb : _buffers)\n+        {\n+            BufferUtil.writeTo(bb, out);\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        for (ByteBuffer buffer : _buffers)\n+        {\n+            _bufferPool.release(buffer);\n+        }\n+        _buffers.clear();\n+    }", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTIzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517871235", "bodyText": "this could be a use for ByteAccumulator.takeByteBuffer.\nNote that I prefer using take  rather than to if the caller becomes responsible for releasing the returned buffer", "author": "gregw", "createdAt": "2020-11-05T08:31:49Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,144 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private ByteBuffer _combinedByteBuffer;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a ByteBuffer.\n+     * @return the content in a ByteBuffer.\n+     */\n+    public ByteBuffer toByteBuffer()", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNTQ5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518435493", "bodyText": "Right now it is not the responsibility of the caller to release this buffer, it is released on close().", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MzM1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518583352", "bodyText": "But the buffer that is returned comes from the the pool and is not released in close.\nSo that is the buffer I'm talking about.  If his was a takeBuffer method then we could pass control of an existing buffer and avoid a copy", "author": "gregw", "createdAt": "2020-11-06T08:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTc2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517871765", "bodyText": "Is there really a need to remember the combined ByteBuffer?", "author": "gregw", "createdAt": "2020-11-05T08:32:42Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,144 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private ByteBuffer _combinedByteBuffer;", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNTQyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518435422", "bodyText": "We need to remember it so that we release it when close() is called.", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTA3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518585077", "bodyText": "I think it is wrong for this class to manage the releasing of the combined buffer.  Isn't that mostly passed along a chain and will be released when processing is complete.    I still lean towards takeBuffer semantics.", "author": "gregw", "createdAt": "2020-11-06T08:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzMDEzNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521230134", "bodyText": "I think this behaviour can be implemented in ByteBufferAccumulator with 2 methods:\n\ntoBuffer will create a single buffer of all the contents, it will release any buffers in the list and the list will end up containing just the new single buffer.  Any subsequent calls to toBuffer will get the same buffer back. Any calls to add more content will just allocate another buffer in the list.  Buffer will be release with close\ntakeBuffer will create a single buffer of all the contents, it will release any buffers in the list and clear it.   It is the callers responsibility to release the returned buffer.", "author": "gregw", "createdAt": "2020-11-11T09:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MjAxMA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517872010", "bodyText": "Is while loop needed?", "author": "gregw", "createdAt": "2020-11-05T08:33:09Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,144 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private ByteBuffer _combinedByteBuffer;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a ByteBuffer.\n+     * @return the content in a ByteBuffer.\n+     */\n+    public ByteBuffer toByteBuffer()\n+    {\n+        int length = _accumulator.getLength();\n+        if (length == 0)\n+            return BufferUtil.EMPTY_BUFFER;\n+\n+        if (_combinedByteBuffer != null && length == _combinedByteBuffer.remaining())\n+            return _combinedByteBuffer;\n+\n+        ByteBuffer buffer = _bufferPool.acquire(_size, false);\n+        _accumulator.writeTo(buffer);\n+        if (_combinedByteBuffer != null)\n+        {\n+            _bufferPool.release(_combinedByteBuffer);\n+            _combinedByteBuffer = buffer;\n+        }\n+\n+        return buffer;\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a byte array.\n+     * @return the content in a byte array.\n+     */\n+    public byte[] toByteArray()\n+    {\n+        int length = _accumulator.getLength();\n+        if (length == 0)\n+            return new byte[0];\n+\n+        byte[] bytes = new byte[_size];\n+        ByteBuffer buffer = BufferUtil.toBuffer(bytes);\n+        _accumulator.writeTo(buffer);\n+        return bytes;\n+    }\n+\n+    public int size()\n+    {\n+        return _accumulator.getLength();\n+    }\n+\n+    @Override\n+    public void write(int b)\n+    {\n+        write(new byte[]{(byte)b}, 0, 1);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len)\n+    {\n+        write(BufferUtil.toBuffer(b, off, len));\n+    }\n+\n+    public void write(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNTUyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518435525", "bodyText": "It is needed because you could get a buffer from the _accumulator which does not have enough remaining space to fill all the content. The second call to getBuffer will then allocate a new buffer.", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MjQ3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517872473", "bodyText": "You need to null/release _combinedByteBuffer here or just not have it it.", "author": "gregw", "createdAt": "2020-11-05T08:33:50Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,144 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private ByteBuffer _combinedByteBuffer;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a ByteBuffer.\n+     * @return the content in a ByteBuffer.\n+     */\n+    public ByteBuffer toByteBuffer()\n+    {\n+        int length = _accumulator.getLength();\n+        if (length == 0)\n+            return BufferUtil.EMPTY_BUFFER;\n+\n+        if (_combinedByteBuffer != null && length == _combinedByteBuffer.remaining())\n+            return _combinedByteBuffer;\n+\n+        ByteBuffer buffer = _bufferPool.acquire(_size, false);\n+        _accumulator.writeTo(buffer);\n+        if (_combinedByteBuffer != null)\n+        {\n+            _bufferPool.release(_combinedByteBuffer);\n+            _combinedByteBuffer = buffer;\n+        }\n+\n+        return buffer;\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a byte array.\n+     * @return the content in a byte array.\n+     */\n+    public byte[] toByteArray()\n+    {\n+        int length = _accumulator.getLength();\n+        if (length == 0)\n+            return new byte[0];\n+\n+        byte[] bytes = new byte[_size];\n+        ByteBuffer buffer = BufferUtil.toBuffer(bytes);\n+        _accumulator.writeTo(buffer);\n+        return bytes;\n+    }\n+\n+    public int size()\n+    {\n+        return _accumulator.getLength();\n+    }\n+\n+    @Override\n+    public void write(int b)\n+    {\n+        write(new byte[]{(byte)b}, 0, 1);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len)\n+    {\n+        write(BufferUtil.toBuffer(b, off, len));\n+    }\n+\n+    public void write(ByteBuffer buffer)\n+    {", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3NTM0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517875343", "bodyText": "Are the copy methods actually used now?   Isn't the accumulator filled by calling getBuffer and writing directly to that?\nIf we don't need the copy methods then deprecate or remove these methods.\nAlternately leave ByteAccumulator as is and deprecate the whole class.  Instead directly use ByteBufferAccumulator", "author": "gregw", "createdAt": "2020-11-05T08:38:46Z", "path": "jetty-websocket/websocket-common/src/main/java/org/eclipse/jetty/websocket/common/extensions/compress/ByteAccumulator.java", "diffHunk": "@@ -19,56 +19,77 @@\n package org.eclipse.jetty.websocket.common.extensions.compress;\n \n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n \n+import org.eclipse.jetty.io.ByteBufferAccumulator;\n+import org.eclipse.jetty.io.ByteBufferPool;\n import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.websocket.api.MessageTooLargeException;\n \n-public class ByteAccumulator\n+public class ByteAccumulator implements AutoCloseable\n {\n-    private final List<byte[]> chunks = new ArrayList<>();\n+    private final ByteBufferAccumulator accumulator;\n     private final int maxSize;\n     private int length = 0;\n \n     public ByteAccumulator(int maxOverallBufferSize)\n     {\n-        this.maxSize = maxOverallBufferSize;\n+        this(maxOverallBufferSize, null);\n     }\n \n-    public void copyChunk(byte[] buf, int offset, int length)\n+    public ByteAccumulator(int maxOverallBufferSize, ByteBufferPool byteBufferPool)\n     {\n-        if (this.length + length > maxSize)\n-        {\n-            String err = String.format(\"Resulting message size [%,d] is too large for configured max of [%,d]\", this.length + length, maxSize);\n-            throw new MessageTooLargeException(err);\n-        }\n+        this.maxSize = maxOverallBufferSize;\n+        this.accumulator = new ByteBufferAccumulator(byteBufferPool);\n+    }\n \n-        byte[] copy = new byte[length - offset];\n-        System.arraycopy(buf, offset, copy, 0, length);\n+    public int getLength()\n+    {\n+        return accumulator.getLength();\n+    }\n \n-        chunks.add(copy);\n-        this.length += length;\n+    public ByteBuffer getBuffer(int minAllocationSize)\n+    {\n+        return accumulator.getBuffer(minAllocationSize);\n     }\n \n-    public int getLength()\n+    public void copyChunk(byte[] buf, int offset, int length)", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNjE2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518436163", "bodyText": "I think we need to maintain the ByteAccumulator to not break anyone. I have tried to only add new methods and not change the signatures of existing ones. So these copy methods stay.\nI will deprecate the whole class.", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3NTM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTkxMg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518585912", "bodyText": "Then I'd just leave the entire implementation as it was - and we don't use it.", "author": "gregw", "createdAt": "2020-11-06T08:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3NTM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNTU4MA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521125580", "bodyText": "We have to use it because it is used in method signatures.\nprotected ByteAccumulator newByteAccumulator();\nprotected void forwardIncoming(Frame frame, ByteAccumulator accumulator);\nprotected void decompress(ByteAccumulator accumulator, ByteBuffer buf);\n\nI think this is the best we can do, it still works if you use it the original way, but it has additional methods to use it more efficiently.", "author": "lachlan-roberts", "createdAt": "2020-11-11T05:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3NTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3NjY2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r517876667", "bodyText": "Do we really need these copy methods?", "author": "gregw", "createdAt": "2020-11-05T08:40:47Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 3;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer getBuffer()\n+    {\n+        return getBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer getBuffer(int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= MIN_SPACE)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);\n+            _buffers.add(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    public void copyBytes(byte[] buf, int offset, int length)\n+    {\n+        copyBuffer(BufferUtil.toBuffer(buf, offset, length));\n+    }\n+\n+    public void copyBuffer(ByteBuffer buffer)", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNDk4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518434983", "bodyText": "This should have a min size that it will go to. Say we have a buffer with 10 bytes remaining, we probably don't want to requesting a buffer that small.\nSomething like:\nbuffer = _bufferPool.acquire(Math.max(minAllocationSize, 1024), false);", "author": "lachlan-roberts", "createdAt": "2020-11-05T23:35:23Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 3;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer getBuffer()\n+    {\n+        return getBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer getBuffer(int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= MIN_SPACE)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);", "originalCommit": "6e9572215b30df8e00cb52238b3703f699819523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIwNzk1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521207952", "bodyText": "The buffer pools already do that.", "author": "gregw", "createdAt": "2020-11-11T08:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNDk4Mw=="}], "type": "inlineReview"}, {"oid": "3c44df0724150c1247702fadee1b9fc5045f9975", "url": "https://github.com/eclipse/jetty.project/commit/3c44df0724150c1247702fadee1b9fc5045f9975", "message": "changes from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-06T03:09:13Z", "type": "commit"}, {"oid": "8dc0d9932d7e73170b80daa6a3fa06ce9ab2e543", "url": "https://github.com/eclipse/jetty.project/commit/8dc0d9932d7e73170b80daa6a3fa06ce9ab2e543", "message": "adjust minimum space in ByteBufferAccumulator before buffer allocation\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-06T07:52:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NDExNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518584115", "bodyText": "So I was confused by the signature. So how about this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ByteBuffer ensureBuffer(int minAllocationSize)\n          \n          \n            \n                public ByteBuffer ensureBuffer(int minCapacity, int minAllicationSize)\n          \n      \n    \n    \n  \n\nSo you pass in both the minim capacity and the size that you'd like to allocate at", "author": "gregw", "createdAt": "2020-11-06T08:09:45Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 8;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer ensureBuffer()\n+    {\n+        return ensureBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer ensureBuffer(int minAllocationSize)", "originalCommit": "8dc0d9932d7e73170b80daa6a3fa06ce9ab2e543", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTcyNg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518585726", "bodyText": "What is the minCapacity used for?", "author": "lachlan-roberts", "createdAt": "2020-11-06T08:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NjM4OA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518586388", "bodyText": "It replaces your MIN_SPACE (Edit:  I got your name wrong :)", "author": "gregw", "createdAt": "2020-11-06T08:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NDExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NDQwMw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518584403", "bodyText": "Not sure that you need to do this as the pool implementations already quantise and roundup capacity.", "author": "gregw", "createdAt": "2020-11-06T08:10:22Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,115 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private static final int MIN_SPACE = 8;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024;\n+\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer ensureBuffer()\n+    {\n+        return ensureBuffer(DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    public ByteBuffer ensureBuffer(int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= MIN_SPACE)\n+        {\n+            buffer = _bufferPool.acquire(Math.max(DEFAULT_BUFFER_SIZE, minAllocationSize), false);", "originalCommit": "8dc0d9932d7e73170b80daa6a3fa06ce9ab2e543", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTYxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518585614", "bodyText": "How could the combined buffer ever have the wrong length?", "author": "gregw", "createdAt": "2020-11-06T08:13:07Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,149 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private ByteBuffer _combinedByteBuffer;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a ByteBuffer.\n+     * @return the content in a ByteBuffer.\n+     */\n+    public ByteBuffer toByteBuffer()\n+    {\n+        int length = _accumulator.getLength();\n+        if (length == 0)\n+            return BufferUtil.EMPTY_BUFFER;\n+\n+        if (_combinedByteBuffer != null && length == _combinedByteBuffer.remaining())", "originalCommit": "8dc0d9932d7e73170b80daa6a3fa06ce9ab2e543", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NzU5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518587595", "bodyText": "If no write has happened since the combinedBuffer was made then length will be same as the remaining in the buffer.", "author": "lachlan-roberts", "createdAt": "2020-11-06T08:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NzkyNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r518587924", "bodyText": "I think this has changed now that we clear the buffer when it is written.", "author": "lachlan-roberts", "createdAt": "2020-11-06T08:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4NTYxNA=="}], "type": "inlineReview"}, {"oid": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "url": "https://github.com/eclipse/jetty.project/commit/595d4bfcc422c5965e55a8146d7bc87842dafe8e", "message": "changes from review\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-11T11:18:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0MjkzNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521342934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ByteBuffer takeByteBuffer()\n          \n          \n            \n                {\n          \n          \n            \n                    int length = getLength();\n          \n          \n            \n                    ByteBuffer combinedBuffer = _bufferPool.acquire(length, false);\n          \n          \n            \n                    for (ByteBuffer buffer : _buffers)\n          \n          \n            \n                    {\n          \n          \n            \n                        combinedBuffer.put(buffer);\n          \n          \n            \n                    }\n          \n          \n            \n                    return combinedBuffer;\n          \n          \n            \n                }\n          \n          \n            \n                public ByteBuffer takeByteBuffer()\n          \n          \n            \n                {\n          \n          \n            \n                    int length = getLength();\n          \n          \n            \n                    switch(length)\n          \n          \n            \n                    {\n          \n          \n            \n                        case 0:\n          \n          \n            \n                            return null; // TODO or empty buffer from pool?\n          \n          \n            \n                        case 1:\n          \n          \n            \n                            return _buffers.remove(0);\n          \n          \n            \n                        default:\n          \n          \n            \n                    \u00a0       ByteBuffer combinedBuffer = _bufferPool.acquire(length, false);\n          \n          \n            \n                    \u00a0       for (ByteBuffer buffer : _buffers)\n          \n          \n            \n                    \u00a0       {\n          \n          \n            \n                        \u00a0       combinedBuffer.put(buffer);\n          \n          \n            \n                        \u00a0       _bufferPool.release(buffer);\n          \n          \n            \n                    \u00a0       }\n          \n          \n            \n                    \u00a0       _buffers.clear();\n          \n          \n            \n                   \u00a0        return combinedBuffer;\n          \n          \n            \n                   \u00a0}\n          \n          \n            \n                }", "author": "gregw", "createdAt": "2020-11-11T13:02:59Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,138 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer ensureBuffer(int minSize, int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= minSize)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);\n+            _buffers.add(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    public void copyBytes(byte[] buf, int offset, int length)\n+    {\n+        copyBuffer(BufferUtil.toBuffer(buf, offset, length));\n+    }\n+\n+    public void copyBuffer(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            ByteBuffer b = ensureBuffer(0, buffer.remaining());\n+            int pos = BufferUtil.flipToFill(b);\n+            BufferUtil.put(buffer, b);\n+            BufferUtil.flipToFlush(b, pos);\n+        }\n+    }\n+\n+    public ByteBuffer takeByteBuffer()\n+    {\n+        int length = getLength();\n+        ByteBuffer combinedBuffer = _bufferPool.acquire(length, false);\n+        for (ByteBuffer buffer : _buffers)\n+        {\n+            combinedBuffer.put(buffer);\n+        }\n+        return combinedBuffer;\n+    }", "originalCommit": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NTgyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521655822", "bodyText": "I don't really like the idea of returning null from here, it will introduce null checks everywhere this is used.\nHow can we get empty buffer from pool, will _bufferPool.aquire(0, false) work, because that's what we are currently doing for 0 length.", "author": "lachlan-roberts", "createdAt": "2020-11-11T21:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0MjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1ODYxMg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521658612", "bodyText": "This also makes it so you can only call takeBuffer() once, but you can call toBuffer() multiple times and get the same buffer.\nWhy wouldn't we just release these buffers on close() like we would do in other cases?", "author": "lachlan-roberts", "createdAt": "2020-11-11T21:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0MjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NzU4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r522247585", "bodyText": "Because the idea of takeBuffer is that you take the buffer and all it's data, hence it can't be called again.\nThe intent is that once you call takeBuffer you will pass the resulting buffer along some further chain of events and then only release it once it is free.\nfreeing the buffer on close makes no sense for most uses, as we want to have a accumulator that lives as long as the connection, during which time it may create many buffers that are taken and passed on.\nHappy not to return null.", "author": "gregw", "createdAt": "2020-11-12T16:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0MjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0MzI5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521343292", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    _buffers.forEach(_bufferPool::release);\n          \n          \n            \n                    _buffers.clear();", "author": "gregw", "createdAt": "2020-11-11T13:03:42Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,138 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBuffer ensureBuffer(int minSize, int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) <= minSize)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);\n+            _buffers.add(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    public void copyBytes(byte[] buf, int offset, int length)\n+    {\n+        copyBuffer(BufferUtil.toBuffer(buf, offset, length));\n+    }\n+\n+    public void copyBuffer(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            ByteBuffer b = ensureBuffer(0, buffer.remaining());\n+            int pos = BufferUtil.flipToFill(b);\n+            BufferUtil.put(buffer, b);\n+            BufferUtil.flipToFlush(b, pos);\n+        }\n+    }\n+\n+    public ByteBuffer takeByteBuffer()\n+    {\n+        int length = getLength();\n+        ByteBuffer combinedBuffer = _bufferPool.acquire(length, false);\n+        for (ByteBuffer buffer : _buffers)\n+        {\n+            combinedBuffer.put(buffer);\n+        }\n+        return combinedBuffer;\n+    }\n+\n+    public ByteBuffer toByteBuffer()\n+    {\n+        if (_buffers.size() == 1)\n+            return _buffers.get(0);\n+\n+        ByteBuffer combinedBuffer = takeByteBuffer();\n+        _buffers.forEach(_bufferPool::release);\n+        _buffers.clear();", "originalCommit": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NDE1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521344151", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ByteBufferPool _bufferPool;", "author": "gregw", "createdAt": "2020-11-11T13:05:08Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,114 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;", "originalCommit": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NDY2MA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521344660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n          \n          \n            \n                    _accumulator = new ByteBufferAccumulator(bufferPool);\n          \n          \n            \n                    _accumulator = new ByteBufferAccumulator((bufferPool == null) ? new NullByteBufferPool() : bufferPool);", "author": "gregw", "createdAt": "2020-11-11T13:06:04Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,114 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);", "originalCommit": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NTA5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r521345093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ByteBuffer toByteBuffer()\n          \n          \n            \n                {\n          \n          \n            \n                    return _accumulator.toByteBuffer();\n          \n          \n            \n                }\n          \n          \n            \n                public ByteBuffer toByteBuffer()\n          \n          \n            \n                {\n          \n          \n            \n                    return _accumulator.toByteBuffer();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public ByteBuffer takeByteBuffer()\n          \n          \n            \n                {\n          \n          \n            \n                    return _accumulator.takeByteBuffer();\n          \n          \n            \n                }", "author": "gregw", "createdAt": "2020-11-11T13:06:50Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferOutputStream2.java", "diffHunk": "@@ -0,0 +1,114 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This class implements an output stream in which the data is written into a list of ByteBuffer,\n+ * the buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * Designed to mimic {@link java.io.ByteArrayOutputStream} but with better memory usage, and less copying.\n+ */\n+public class ByteBufferOutputStream2 extends OutputStream\n+{\n+    private final ByteBufferAccumulator _accumulator;\n+    private final ByteBufferPool _bufferPool;\n+    private int _size = 0;\n+\n+    public ByteBufferOutputStream2()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferOutputStream2(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+        _accumulator = new ByteBufferAccumulator(bufferPool);\n+    }\n+\n+    /**\n+     * Get an aggregated content written to the OutputStream in a ByteBuffer.\n+     * @return the content in a ByteBuffer.\n+     */\n+    public ByteBuffer toByteBuffer()\n+    {\n+        return _accumulator.toByteBuffer();\n+    }\n+", "originalCommit": "595d4bfcc422c5965e55a8146d7bc87842dafe8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d75e6de1b27d72a6ddd8d75759a1deefa76b75b9", "url": "https://github.com/eclipse/jetty.project/commit/d75e6de1b27d72a6ddd8d75759a1deefa76b75b9", "message": "add takeByteBuffer method to ByteBufferOutputStream2\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-11T21:48:50Z", "type": "commit"}, {"oid": "e0031e0585c4c464cc12d285c2c41f2d0e6ec9ea", "url": "https://github.com/eclipse/jetty.project/commit/e0031e0585c4c464cc12d285c2c41f2d0e6ec9ea", "message": "Issue #5499 - takeBuffer releases all the buffers in the list\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-12T22:22:57Z", "type": "commit"}, {"oid": "e7bed39239e6e4b8309803a14fa0702380d65bd9", "url": "https://github.com/eclipse/jetty.project/commit/e7bed39239e6e4b8309803a14fa0702380d65bd9", "message": "Issue #5499 - add javadoc for ByteBufferAccumulator\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-12T22:56:32Z", "type": "commit"}, {"oid": "a1aa5dcd14c77f7ccb15cd2dbe8ce21e18b5cb7f", "url": "https://github.com/eclipse/jetty.project/commit/a1aa5dcd14c77f7ccb15cd2dbe8ce21e18b5cb7f", "message": "Issue #5499 - use ByteBufferAccumulator for websocket compression\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-16T07:33:38Z", "type": "commit"}, {"oid": "5788fe609dae59ca82dfc21489f41e5bba3add40", "url": "https://github.com/eclipse/jetty.project/commit/5788fe609dae59ca82dfc21489f41e5bba3add40", "message": "Fix ByteBufferAccumulator minSize\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-16T07:43:22Z", "type": "commit"}, {"oid": "7c46d96fcea0a1f6c328f472916a39875786b89b", "url": "https://github.com/eclipse/jetty.project/commit/7c46d96fcea0a1f6c328f472916a39875786b89b", "message": "Issue #5499 - add tests for ByteBufferAccumulator\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-17T06:11:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMzM4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r525023383", "bodyText": "you have both a length field and getLength method on the accumulator.  Use one or the other.", "author": "gregw", "createdAt": "2020-11-17T09:53:50Z", "path": "jetty-websocket/websocket-common/src/main/java/org/eclipse/jetty/websocket/common/extensions/compress/ByteAccumulator.java", "diffHunk": "@@ -19,56 +19,92 @@\n package org.eclipse.jetty.websocket.common.extensions.compress;\n \n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n \n+import org.eclipse.jetty.io.ByteBufferAccumulator;\n+import org.eclipse.jetty.io.ByteBufferPool;\n import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.websocket.api.MessageTooLargeException;\n \n-public class ByteAccumulator\n+/**\n+ * @deprecated use {@link ByteBufferAccumulator} instead.\n+ */\n+@Deprecated\n+public class ByteAccumulator implements AutoCloseable\n {\n-    private final List<byte[]> chunks = new ArrayList<>();\n+    private static final int MIN_SPACE = 8;\n+\n+    private final ByteBufferAccumulator accumulator;\n     private final int maxSize;\n     private int length = 0;\n \n     public ByteAccumulator(int maxOverallBufferSize)\n+    {\n+        this(maxOverallBufferSize, null);\n+    }\n+\n+    public ByteAccumulator(int maxOverallBufferSize, ByteBufferPool byteBufferPool)\n     {\n         this.maxSize = maxOverallBufferSize;\n+        this.accumulator = new ByteBufferAccumulator(byteBufferPool);\n     }\n \n-    public void copyChunk(byte[] buf, int offset, int length)\n+    public int getLength()\n     {\n-        if (this.length + length > maxSize)\n+        return accumulator.getLength();", "originalCommit": "7c46d96fcea0a1f6c328f472916a39875786b89b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNDI0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r525034246", "bodyText": "Yep, should be using length here.\nNote that the getLength() on the ByteBufferAccumulator is inefficient, it adds up the remaining on all buffers each time. So thats why we are using this length field.", "author": "lachlan-roberts", "createdAt": "2020-11-17T10:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMzM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzODY4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r533238681", "bodyText": "check overflow as well here", "author": "gregw", "createdAt": "2020-12-01T09:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMzM4Mw=="}], "type": "inlineReview"}, {"oid": "f63a741b0f0131300fb5d8e1e040e1c74a73c059", "url": "https://github.com/eclipse/jetty.project/commit/f63a741b0f0131300fb5d8e1e040e1c74a73c059", "message": "use local length field for ByteAccumulator.getLength()\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-17T10:16:38Z", "type": "commit"}, {"oid": "2629845f173a8e14f287a393d17192685a229eb6", "url": "https://github.com/eclipse/jetty.project/commit/2629845f173a8e14f287a393d17192685a229eb6", "message": "update ByteAccumulator length on copies\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-17T11:16:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQyMjA5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r532422091", "bodyText": "Hardcoding non-direct buffer type maybe isn't that wise. How about making that boolean a constructor parameter?", "author": "lorban", "createdAt": "2020-11-30T08:34:57Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,199 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * Accumulates data into a list of ByteBuffers which can then be combined into a single buffer or written to an OutputStream.\n+ * The buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * The method {@link #ensureBuffer(int, int)} is used to write directly to the last buffer stored in the buffer list,\n+ * if there is less than a certain amount of space available in that buffer then a new one will be allocated and returned instead.\n+ * @see #ensureBuffer(int, int)\n+ */\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    /**\n+     * Get the amount of bytes which have been accumulated.\n+     * This will add up the remaining of each buffer in the accumulator.\n+     * @return the total length of the content in the accumulator.\n+     */\n+    public int getLength()\n+    {\n+        int length = 0;\n+        for (ByteBuffer buffer : _buffers)\n+            length += buffer.remaining();\n+        return length;\n+    }\n+\n+    public ByteBufferPool getByteBufferPool()\n+    {\n+        return _bufferPool;\n+    }\n+\n+    /**\n+     * Get the last buffer of the accumulator, this can be written to directly to avoid copying into the accumulator.\n+     * @param minAllocationSize new buffers will be allocated to have at least this size.\n+     * @return a buffer with at least {@code minSize} space to write into.\n+     */\n+    public ByteBuffer ensureBuffer(int minAllocationSize)\n+    {\n+        return ensureBuffer(1, minAllocationSize);\n+    }\n+\n+    /**\n+     * Get the last buffer of the accumulator, this can be written to directly to avoid copying into the accumulator.\n+     * @param minSize the smallest amount of remaining space before a new buffer is allocated.\n+     * @param minAllocationSize new buffers will be allocated to have at least this size.\n+     * @return a buffer with at least {@code minSize} space to write into.\n+     */\n+    public ByteBuffer ensureBuffer(int minSize, int minAllocationSize)\n+    {\n+        ByteBuffer buffer = _buffers.isEmpty() ? BufferUtil.EMPTY_BUFFER : _buffers.get(_buffers.size() - 1);\n+        if (BufferUtil.space(buffer) < minSize)\n+        {\n+            buffer = _bufferPool.acquire(minAllocationSize, false);", "originalCommit": "2629845f173a8e14f287a393d17192685a229eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1OTYyMA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r532959620", "bodyText": "In the usages of this we are assuming it is an indirect buffer so we can write directly to the underlying array. But I can put it in the constructor and specify that we want indirect where this is used.", "author": "lachlan-roberts", "createdAt": "2020-11-30T23:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQyMjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5ODczMw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r533298733", "bodyText": "Nah, that does not look useful after all. Keep it the way it is.", "author": "lorban", "createdAt": "2020-12-01T10:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQyMjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzMDIxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r532430214", "bodyText": "This length accumulation could potentially overflow Integer.MAX_VALUE. We should handle this by either returning a long from here, or detecting the integer overflow and throwing an exception.", "author": "lorban", "createdAt": "2020-11-30T08:49:16Z", "path": "jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferAccumulator.java", "diffHunk": "@@ -0,0 +1,199 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.io;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jetty.util.BufferUtil;\n+\n+/**\n+ * Accumulates data into a list of ByteBuffers which can then be combined into a single buffer or written to an OutputStream.\n+ * The buffer list automatically grows as data is written to it, the buffers are taken from the\n+ * supplied {@link ByteBufferPool} or freshly allocated if one is not supplied.\n+ *\n+ * The method {@link #ensureBuffer(int, int)} is used to write directly to the last buffer stored in the buffer list,\n+ * if there is less than a certain amount of space available in that buffer then a new one will be allocated and returned instead.\n+ * @see #ensureBuffer(int, int)\n+ */\n+public class ByteBufferAccumulator implements AutoCloseable\n+{\n+    private final List<ByteBuffer> _buffers = new ArrayList<>();\n+    private final ByteBufferPool _bufferPool;\n+\n+    public ByteBufferAccumulator()\n+    {\n+        this(null);\n+    }\n+\n+    public ByteBufferAccumulator(ByteBufferPool bufferPool)\n+    {\n+        _bufferPool = (bufferPool == null) ? new NullByteBufferPool() : bufferPool;\n+    }\n+\n+    /**\n+     * Get the amount of bytes which have been accumulated.\n+     * This will add up the remaining of each buffer in the accumulator.\n+     * @return the total length of the content in the accumulator.\n+     */\n+    public int getLength()", "originalCommit": "2629845f173a8e14f287a393d17192685a229eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzNDIwMA==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r533234200", "bodyText": "Since the accumulation needs to eventually fit into a single buffer, the int should do with overflow detection elsewhere.\nAn ultimate buffer abstraction could allow for chains of buffers that can be gather written for a long length, but not this abstraction", "author": "gregw", "createdAt": "2020-12-01T09:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzMDIxNA=="}], "type": "inlineReview"}, {"oid": "a51b5db209de7186dcd99d324e230506624a5d6a", "url": "https://github.com/eclipse/jetty.project/commit/a51b5db209de7186dcd99d324e230506624a5d6a", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-9.4.x-ByteAccumulator", "committedDate": "2020-11-30T22:45:45Z", "type": "commit"}, {"oid": "602cd7e5c0b613b17bfa7ca4a8a18874a07a2e6b", "url": "https://github.com/eclipse/jetty.project/commit/602cd7e5c0b613b17bfa7ca4a8a18874a07a2e6b", "message": "throw ArithmeticException on integer overflow from size\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-30T22:51:09Z", "type": "commit"}, {"oid": "6dce1cbffd0768bd172108aba2523f0a17f548f0", "url": "https://github.com/eclipse/jetty.project/commit/6dce1cbffd0768bd172108aba2523f0a17f548f0", "message": "Make ByteBufferAccumulator direct configurable\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-11-30T23:07:18Z", "type": "commit"}, {"oid": "8aedc50048fa114f964903d61b8b30aeece83463", "url": "https://github.com/eclipse/jetty.project/commit/8aedc50048fa114f964903d61b8b30aeece83463", "message": "fix missing usage of the new _direct field in ByteBufferAccumulator\n\nSigned-off-by: Lachlan Roberts <lachlan@webtide.com>", "committedDate": "2020-12-01T13:07:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyOTA0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r533929046", "bodyText": "close() method invoked by DeflateFrameExtension.java#L64\nand PerMessageDeflateExtension.java#L81\ntransferTo method no need add extra close method", "author": "leonchen83", "createdAt": "2020-12-02T06:39:01Z", "path": "jetty-websocket/websocket-common/src/main/java/org/eclipse/jetty/websocket/common/extensions/compress/ByteAccumulator.java", "diffHunk": "@@ -19,56 +19,92 @@\n package org.eclipse.jetty.websocket.common.extensions.compress;\n \n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n \n+import org.eclipse.jetty.io.ByteBufferAccumulator;\n+import org.eclipse.jetty.io.ByteBufferPool;\n import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.websocket.api.MessageTooLargeException;\n \n-public class ByteAccumulator\n+/**\n+ * @deprecated use {@link ByteBufferAccumulator} instead.\n+ */\n+@Deprecated\n+public class ByteAccumulator implements AutoCloseable\n {\n-    private final List<byte[]> chunks = new ArrayList<>();\n+    private static final int MIN_SPACE = 8;\n+\n+    private final ByteBufferAccumulator accumulator;\n     private final int maxSize;\n     private int length = 0;\n \n     public ByteAccumulator(int maxOverallBufferSize)\n+    {\n+        this(maxOverallBufferSize, null);\n+    }\n+\n+    public ByteAccumulator(int maxOverallBufferSize, ByteBufferPool byteBufferPool)\n     {\n         this.maxSize = maxOverallBufferSize;\n+        this.accumulator = new ByteBufferAccumulator(byteBufferPool, false);\n     }\n \n-    public void copyChunk(byte[] buf, int offset, int length)\n+    public int getLength()\n     {\n-        if (this.length + length > maxSize)\n+        return length;\n+    }\n+\n+    public ByteBuffer ensureBuffer(int minAllocationSize)\n+    {\n+        return accumulator.ensureBuffer(MIN_SPACE, minAllocationSize);\n+    }\n+\n+    public void addLength(int read)\n+    {\n+        length += read;\n+        if (length > maxSize)\n         {\n-            String err = String.format(\"Resulting message size [%,d] is too large for configured max of [%,d]\", this.length + length, maxSize);\n+            String err = String.format(\"Resulting message size [%d] is too large for configured max of [%d]\", length, maxSize);\n             throw new MessageTooLargeException(err);\n         }\n-\n-        byte[] copy = new byte[length - offset];\n-        System.arraycopy(buf, offset, copy, 0, length);\n-\n-        chunks.add(copy);\n-        this.length += length;\n     }\n \n-    public int getLength()\n+    public void copyChunk(byte[] buf, int offset, int length)\n     {\n-        return length;\n+        copyChunk(BufferUtil.toBuffer(buf, offset, length));\n     }\n \n-    public void transferTo(ByteBuffer buffer)\n+    public void copyChunk(ByteBuffer buffer)\n     {\n-        if (buffer.remaining() < length)\n+        int remaining = buffer.remaining();\n+        if (length + remaining > maxSize)\n         {\n-            throw new IllegalArgumentException(String.format(\"Not enough space in ByteBuffer remaining [%d] for accumulated buffers length [%d]\",\n-                buffer.remaining(), length));\n+            String err = String.format(\"Resulting message size [%d] is too large for configured max of [%d]\", length + remaining, maxSize);\n+            throw new MessageTooLargeException(err);\n         }\n \n-        int position = buffer.position();\n-        for (byte[] chunk : chunks)\n+        length += remaining;\n+        accumulator.copyBuffer(buffer);\n+    }\n+\n+    public void transferTo(ByteBuffer buffer)\n+    {\n+        // For some reason this method expects the buffer in fill mode but returns a buffer in flush mode.\n+        BufferUtil.flipToFlush(buffer, 0);\n+\n+        int availableSpace = BufferUtil.space(buffer);\n+        if (availableSpace < length)\n         {\n-            buffer.put(chunk, 0, chunk.length);\n+            String err = String.format(\"Not enough space in ByteBuffer remaining [%d] for accumulated buffers length [%d]\", availableSpace, length);\n+            throw new IllegalArgumentException(err);\n         }\n-        BufferUtil.flipToFlush(buffer, position);\n+\n+        accumulator.writeTo(buffer);\n+        close();", "originalCommit": "8aedc50048fa114f964903d61b8b30aeece83463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1MjcwNw==", "url": "https://github.com/eclipse/jetty.project/pull/5574#discussion_r534552707", "bodyText": "I did this to preserve the behaviour of this class with the previous usage.\nBefore these changes it was not AutoCloseable, so it would have been used like this with no closing:\nByteAccumulator acc = new ByteAccumulator();\nacc.copyChunk(something);\n...\nacc.transferTo(combinedBuffer);\nSo in this way we can be more lenient on the usage of ByteAccumulator by supporting the deprecated way of using it, and now we have the replacement ByteBufferAccumulator which is more strict and must be used with an explicit call to close().", "author": "lachlan-roberts", "createdAt": "2020-12-02T23:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyOTA0Ng=="}], "type": "inlineReview"}, {"oid": "8b3cffb49f6efebb62d1e4e91309ebffaf3cb089", "url": "https://github.com/eclipse/jetty.project/commit/8b3cffb49f6efebb62d1e4e91309ebffaf3cb089", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-9.4.x-ByteAccumulator", "committedDate": "2020-12-08T03:34:55Z", "type": "commit"}, {"oid": "41cffa0bc4dc26ec315d1a0baa5969f18768d3b5", "url": "https://github.com/eclipse/jetty.project/commit/41cffa0bc4dc26ec315d1a0baa5969f18768d3b5", "message": "Merge remote-tracking branch 'origin/jetty-9.4.x' into jetty-9.4.x-ByteAccumulator", "committedDate": "2020-12-15T05:49:23Z", "type": "commit"}]}