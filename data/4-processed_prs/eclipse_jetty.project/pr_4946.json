{"pr_number": 4946, "pr_title": "Jetty 9.4.x 4855 h2spec failures", "pr_createdAt": "2020-06-05T17:49:02Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4946", "timeline": [{"oid": "e721717b3c2492819557708cad29ce8d063809cd", "url": "https://github.com/eclipse/jetty.project/commit/e721717b3c2492819557708cad29ce8d063809cd", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nCode cleanups.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-05T17:20:29Z", "type": "commit"}, {"oid": "fd053aae0962002000ea994e49005441ec945761", "url": "https://github.com/eclipse/jetty.project/commit/fd053aae0962002000ea994e49005441ec945761", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nIn case of bad usage of the API, we don't want to close()\nthe stream but just fail the callback, because the stream\nmay be performing actions triggered by a legit API usage.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-05T17:27:48Z", "type": "commit"}, {"oid": "9dec284cc2afeeb49d3f4fce4a0656d8d98c6d48", "url": "https://github.com/eclipse/jetty.project/commit/9dec284cc2afeeb49d3f4fce4a0656d8d98c6d48", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nIn case of a call to `AsyncListener.onError()`, applications may decide to call\nAsyncContext.complete() and that would be a correct usage of the Servlet API.\n\nThis case was not well handled and was wrongly producing a WARN log with an\n`IllegalStateException`.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-05T17:31:32Z", "type": "commit"}, {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f", "url": "https://github.com/eclipse/jetty.project/commit/8d606368297183bb89bd309e38772b6c2a47aa5f", "message": "Fixes #4855 - Occasional h2spec failures on CI\n\nCompletely rewritten `HttpTransportOverHTTP2.TransportCallback`.\nThe rewrite handles correctly asynchronous failures that now are executed\nsequentially (and not concurrently) with writes.\nIf a write is in progress, the failure will just change the state and at the\nend of the write a check on the state will determine what actions to take.\n\nA session failure is now handled in HTTP2Session by first failing all the\nstreams - which notifies the Stream.Listeners - and then failing the session\n- which notifies the Session.Listener.\nThe stream failures are executed concurrently by dispatching each one to a\ndifferent thread; this means that the stream failure callbacks are executed\nconcurrently (likely sending RST_STREAM frames).\nThe session failure callback is completed only when all the stream failure\ncallbacks have completed, to ensure that a GOAWAY frame is processed after\nall the RST_STREAM frames.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-05T17:46:22Z", "type": "commit"}, {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0", "url": "https://github.com/eclipse/jetty.project/commit/82529e614f71fbc36d9212377376a33f2d4220f0", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nFixed notification of HTTP2Session.abort(), that must fail all the streams\nbefore failing the session.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-05T20:48:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjc3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436482777", "bodyText": "Is this method still required?  It doesn't override any contract?", "author": "gregw", "createdAt": "2020-06-08T06:37:03Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HTTP2ServerConnection.java", "diffHunk": "@@ -245,22 +246,10 @@ public boolean onSessionTimeout(Throwable failure)\n \n     public void onSessionFailure(Throwable failure, Callback callback)\n     {\n-        ISession session = getSession();\n         if (LOG.isDebugEnabled())\n-            LOG.debug(\"Processing failure on {}: {}\", session, failure);\n-        Collection<Stream> streams = session.getStreams();\n-        if (streams.isEmpty())\n-        {\n-            callback.succeeded();\n-        }\n-        else\n-        {\n-            CountingCallback counter = new CountingCallback(callback, streams.size());\n-            for (Stream stream : streams)\n-            {\n-                onStreamFailure((IStream)stream, failure, counter);\n-            }\n-        }\n+            LOG.debug(\"Processing session failure on {}\", getSession(), failure);\n+        // All the streams have already been failed, just succeed the callback.", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MTQ2MA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436851460", "bodyText": "@sbordet ?", "author": "gregw", "createdAt": "2020-06-08T16:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MzUyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436483521", "bodyText": "Some comments on how we could get to these states between preSend and postSend would be good.", "author": "gregw", "createdAt": "2020-06-08T06:38:59Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDAxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484015", "bodyText": "Why does SUCCEED just remember stuff while this one moves the state on? Comments needed", "author": "gregw", "createdAt": "2020-06-08T06:40:16Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDM0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484348", "bodyText": "should _commit be nulled so we know we can only call it once?", "author": "gregw", "createdAt": "2020-06-08T06:41:15Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDY3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484676", "bodyText": "what if callback is null?  I think it is an ISE, so that should be explicitly thrown", "author": "gregw", "createdAt": "2020-06-08T06:42:10Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTA4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485089", "bodyText": "comment", "author": "gregw", "createdAt": "2020-06-08T06:43:18Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTIyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485228", "bodyText": "the race with whom?", "author": "gregw", "createdAt": "2020-06-08T06:43:44Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states", "originalCommit": "8d606368297183bb89bd309e38772b6c2a47aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "url": "https://github.com/eclipse/jetty.project/commit/42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nAdded javadocs after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-08T08:37:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436534346", "bodyText": "Since all lambdas passed to this method are always capturing, I see no point in passing it the Callback. I think changing the signature here to accept a Runnable instead of a Consumer would be slightly more readable.", "author": "lorban", "createdAt": "2020-06-08T08:30:42Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "originalCommit": "82529e614f71fbc36d9212377376a33f2d4220f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NTY0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436565648", "bodyText": "I agree.  At the very least the param name needs to be changed to sendFrame.", "author": "gregw", "createdAt": "2020-06-08T09:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5MjcyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436592723", "bodyText": "I like the Consumer<Callback> for 2 reasons:\n\nit allows TransportCallback.send() to give to the Consumer some other callback if needs to without having the sendXXXFrame() methods be aware of what callback to use\nit keeps the semantic of the sendXXXFrame() clear: they take a callback parameter, and therefore they are asynchronous", "author": "sbordet", "createdAt": "2020-06-08T10:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5NDg4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436594882", "bodyText": "@sbordet if you keep the Consumer it has to have a better name than consumer.   I think sendFrame is best as it indicates what the Consumer is meant to do.", "author": "gregw", "createdAt": "2020-06-08T10:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNTEzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436535136", "bodyText": "These states and their transitions should be javadoc'ed as it's not easy to grok what the FSM looks like by reading the code.", "author": "lorban", "createdAt": "2020-06-08T08:32:07Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to fail was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        IDLE, PRE_SEND, POST_SEND, SUCCEED, FAIL, FAILED", "originalCommit": "82529e614f71fbc36d9212377376a33f2d4220f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5MjgzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436592833", "bodyText": "Done.", "author": "sbordet", "createdAt": "2020-06-08T10:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MDYxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436540611", "bodyText": "I find this new method's signature and default implementation surprising. I would have expected that the error and reason parameters to go away especially since the overriding implementations just ignore them. Plus the fact that the default implementation drops the failure in favor of calling the deprecated implementation instead of directly succeeding the callback also makes me scratch my head.\nMaybe FailureFrame.getFailure() should return some sort of H2Exception that wraps the original exception as well as containing the reason and error code?", "author": "lorban", "createdAt": "2020-06-08T08:42:08Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/api/Stream.java", "diffHunk": "@@ -227,8 +227,24 @@ default boolean onIdleTimeout(Stream stream, Throwable x)\n          * @param stream the stream\n          * @param error the error code\n          * @param reason the error reason, or null\n+         * @param failure the failure\n          * @param callback the callback to complete when the failure has been handled\n          */\n+        default void onFailure(Stream stream, int error, String reason, Throwable failure, Callback callback)", "originalCommit": "82529e614f71fbc36d9212377376a33f2d4220f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5NTAzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436595035", "bodyText": "This is at the HTTP/2 low-level API so our implementation may not use error and reason but users of these APIs may.\nHowever, there are cases where we still have a failure but not an associated error (e.g. idle timeout and aborts).", "author": "sbordet", "createdAt": "2020-06-08T10:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MDYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NzU3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436567576", "bodyText": "I don't like the PRE_SEND,  POST_SEND and SUCCEEDnames as they are confusing in that during PRE_SEND sending is happening and in POST_SEND the send is pending.\nHow about: IDLE -> SENDING -> PENDING -> SUCCEEDED -> FAILED\nI think ING and ED names line up better with our practises elsewhere.", "author": "gregw", "createdAt": "2020-06-08T09:29:00Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n+    /**\n+     * <p>Send states for {@link TransportCallback}.</p>\n+     *\n+     * @see TransportCallback\n+     */\n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        /**\n+         * <p>No send initiated or in progress.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #PRE_SEND}, when {@link TransportCallback#send(Callback, boolean, Consumer)}\n+         *   is called by the transport to initiate a send</li>\n+         *   <li>{@link #FAILED}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called by an asynchronous failure</li>\n+         * </ul>\n+         */\n+        IDLE,\n+        /**\n+         * <p>A send is initiated; the nested callback in {@link TransportCallback}\n+         * cannot be notified while in this state.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #SUCCEED}, when {@link TransportCallback#succeeded()}\n+         *   is called synchronously because the send succeeded</li>\n+         *   <li>{@link #FAIL}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called synchronously because the send failed</li>\n+         *   <li>{@link #POST_SEND}, when {@link TransportCallback#postSend()}\n+         *   is called before the send completes</li>\n+         * </ul>\n+         */\n+        PRE_SEND,", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5Nzg2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436597865", "bodyText": "They are not correct.\nSUCCEED and FAIL are commands, it's what postSend() should do, either succeed by calling succeeded() or fail by calling failed(Throwable).\nI'm ok with PRE_SEND -> SENDING and POST_SEND -> PENDING, but I need 2 more states for SUCCEED and FAIL as commands about what to do next.\nFAILED is a terminal state (so it cannot be used for the command), but we don't have a SUCCEEDED terminal state (we go back to IDLE).", "author": "sbordet", "createdAt": "2020-06-08T10:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2OTU0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436569540", "bodyText": "rename method to onSending", "author": "gregw", "createdAt": "2020-06-08T09:32:43Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMTAxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436601012", "bodyText": "Perhaps, after we agree on state names.", "author": "sbordet", "createdAt": "2020-06-08T10:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2OTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MjQ4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572486", "bodyText": "This is not one case but two. Also needs comments:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                default:\n          \n          \n            \n                                {\n          \n          \n            \n                                    Throwable failure = _failure;\n          \n          \n            \n                                    if (failure == null)\n          \n          \n            \n                                        failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n          \n          \n            \n                                    return failure;\n          \n          \n            \n                                }\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                    // better comment that an async failure happened while we were just about to send something\n          \n          \n            \n                                    return _failure;\n          \n          \n            \n                                default:\n          \n          \n            \n                                    return new IllegalStateException(\"Invalid transport state: \" + _state);", "author": "gregw", "createdAt": "2020-06-08T09:38:00Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5OTgxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436599813", "bodyText": "FAIL here is an illegal state.\nFAILED here is legal and I can return failure like you propose.\nHowever, is that what you meant?", "author": "sbordet", "createdAt": "2020-06-08T10:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MjQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Mjc3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572779", "bodyText": "rename to onSent", "author": "gregw", "createdAt": "2020-06-08T09:38:34Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMTA3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436601071", "bodyText": "Perhaps, after we agree on state names.", "author": "sbordet", "createdAt": "2020-06-08T10:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Mjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MzQ0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436573446", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _state = State.POST_SEND;\n          \n          \n            \n                                    // The send has not yet completed, wait for success or failure\n          \n          \n            \n                                    _state = State.PENDING;", "author": "gregw", "createdAt": "2020-06-08T09:39:43Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NDIxMA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436574210", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    // The send has already completed successfully but callback not yet called, we can process callback now\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;", "author": "gregw", "createdAt": "2020-06-08T09:41:02Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMjQ0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436602445", "bodyText": "This is wrong, here succeeded() has already been called.", "author": "sbordet", "createdAt": "2020-06-08T10:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NjY0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436576643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    // The send has already failed (either synchronously or asynchronously), but callback not yet called, so handle now\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;", "author": "gregw", "createdAt": "2020-06-08T09:45:15Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Nzk2MA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436577960", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else if (callback != null )\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                        else\n          \n          \n            \n                            threw new IllegalStateException();", "author": "gregw", "createdAt": "2020-06-08T09:47:45Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "originalCommit": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMDY5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436600691", "bodyText": "Nope, callback cannot be null - if it is then we would have a bad state and we handle it already in the default case.\nPlus I don't want to throw from this class but fail the callback instead.", "author": "sbordet", "createdAt": "2020-06-08T10:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Nzk2MA=="}], "type": "inlineReview"}, {"oid": "4c9bd59ae2b720b46d58bf1fc61e8f067993b5fb", "url": "https://github.com/eclipse/jetty.project/commit/4c9bd59ae2b720b46d58bf1fc61e8f067993b5fb", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nMore comments after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-08T10:42:47Z", "type": "commit"}, {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "url": "https://github.com/eclipse/jetty.project/commit/ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-08T11:20:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627476", "bodyText": "I think we should null _callback whenever we take it.", "author": "gregw", "createdAt": "2020-06-08T11:28:59Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwNzI2NA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436707264", "bodyText": "It is in reset() few lines below.", "author": "sbordet", "createdAt": "2020-06-08T13:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627885", "bodyText": "if we null _callback when we take it, we can throw ISE here if it is not null", "author": "gregw", "createdAt": "2020-06-08T11:29:52Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcyNzMyNw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436727327", "bodyText": "Don't want to throw from this class, it will just hang the server.", "author": "sbordet", "createdAt": "2020-06-08T13:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MjEwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436852100", "bodyText": "If we get here with a non null callback, then the server is as good as dead anyway.  At least the exception will tell us why!", "author": "gregw", "createdAt": "2020-06-08T16:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTQzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629438", "bodyText": "I kind of think the timeout should win this race.  Who knows what else has been closed already by the timeout, plus the timeout might be due to a really slow generation of the frame.", "author": "gregw", "createdAt": "2020-06-08T11:33:05Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMDE3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436730172", "bodyText": "Nope, we should support ignoring idle timeouts in case the application is idle as per Servlet specification, so if we were just unlucky here we should ignore the idle timeout.\nI think we should enforce the idle timeout only when we are PENDING, i.e. really sure that we have initiated a write but it won't complete in time.", "author": "sbordet", "createdAt": "2020-06-08T14:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTg2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629869", "bodyText": "just inline the idleTimeout method here.", "author": "gregw", "createdAt": "2020-06-08T11:34:09Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMDgyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436730820", "bodyText": "Nah, it nicely complements the succeed() and fail() methods, with logging callback action.", "author": "sbordet", "createdAt": "2020-06-08T14:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMDk2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436630965", "bodyText": "perhaps onCompleteSuccess  to tie in with common behaviour of IteratingCallback?", "author": "gregw", "createdAt": "2020-06-08T11:36:25Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMTU2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436731567", "bodyText": "Not a big fan, as we are not iterating here.", "author": "sbordet", "createdAt": "2020-06-08T14:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMTYwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436631607", "bodyText": "Is this an unrelated fix?", "author": "gregw", "createdAt": "2020-06-08T11:38:04Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().\n+            else if (_requestState != RequestState.COMPLETE)", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMjY4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436732686", "bodyText": "Correct, it has been introduced in a separate commit, 9dec284.", "author": "sbordet", "createdAt": "2020-06-08T14:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMjE5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436632192", "bodyText": "this comment comment is outside the if, so should be phrased as a conditional, or moved inside the if body", "author": "gregw", "createdAt": "2020-06-08T11:39:32Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().", "originalCommit": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczNDk5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436734994", "bodyText": "I'm not a big fan of comments outside if/else that just say what the if/else is doing.\nI'm for removing both.", "author": "sbordet", "createdAt": "2020-06-08T14:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMjE5Mg=="}], "type": "inlineReview"}, {"oid": "56d3a6ef5da40438ea25b304563ccc03e1555e5b", "url": "https://github.com/eclipse/jetty.project/commit/56d3a6ef5da40438ea25b304563ccc03e1555e5b", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-08T14:15:41Z", "type": "commit"}, {"oid": "26ad5857e8d58ea28efc91b5e1966d02e60d33f6", "url": "https://github.com/eclipse/jetty.project/commit/26ad5857e8d58ea28efc91b5e1966d02e60d33f6", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nFixed reset() to remember the failure.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-06-09T10:01:32Z", "type": "commit"}]}