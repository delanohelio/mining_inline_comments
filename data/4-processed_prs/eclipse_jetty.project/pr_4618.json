{"pr_number": 4618, "pr_title": "Issue #4400 - Review HttpClient's ContentProvider.", "pr_createdAt": "2020-02-28T13:43:35Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4618", "timeline": [{"oid": "1393c0e92bc16efb852624bd3de3a575cafddfa7", "url": "https://github.com/eclipse/jetty.project/commit/1393c0e92bc16efb852624bd3de3a575cafddfa7", "message": "Issue #4400 - Review HttpClient's ContentProvider.\n\nIntroduced Request.Content with a reactive model to provide\nrequest content.\nIntroduced RequestContentAdapter to wrap ContentProviders\ninto Request.Content.\nUpdated implementation to use the reactive model rather than\nthe old pull model.\nReimplemented all ContentProviders in terms of Request.Content.\nConverted most of the tests from ContentProvider to Request.Content.\nUpdated proxy servlets and documentation.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-02-28T13:40:48Z", "type": "commit"}, {"oid": "f8d9f82eff80e698f77103ee0add8bcfe762fcb5", "url": "https://github.com/eclipse/jetty.project/commit/f8d9f82eff80e698f77103ee0add8bcfe762fcb5", "message": "Merged branch 'jetty-10.0.x' into 'jetty-10.0.x-4400-review_httpclient_content'.", "committedDate": "2020-03-18T10:40:11Z", "type": "commit"}, {"oid": "e215d071c8604705ad1d56607ab28449201afb55", "url": "https://github.com/eclipse/jetty.project/commit/e215d071c8604705ad1d56607ab28449201afb55", "message": "Merged branch 'jetty-10.0.x' into 'jetty-10.0.x-4400-review_httpclient_content'.", "committedDate": "2020-03-23T15:24:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NDY2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r396564662", "bodyText": "Why don't we use the Flow.Publisher API as a base for this rather than create our own near identical version of it?", "author": "gregw", "createdAt": "2020-03-23T16:02:33Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/api/Request.java", "diffHunk": "@@ -615,4 +634,136 @@ public default void onFailure(Request request, Throwable failure)\n         {\n         }\n     }\n+\n+    /**\n+     * <p>A reactive model to produce request content, similar to {@link java.util.concurrent.Flow.Publisher}.</p>\n+     * <p>Implementations receive the content consumer via {@link #subscribe(Consumer, boolean)},\n+     * and return a {@link Subscription} as the link between producer and consumer.</p>\n+     * <p>Content producers must notify content to the consumer only if there is demand.</p>\n+     * <p>Content consumers can generate demand for content by invoking {@link Subscription#demand()}.</p>\n+     */\n+    public interface Content", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzNzYwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r396837600", "bodyText": "For these reasons:\n\nthe Flow APIs have to obey the reactivestreams specification and we don't strictly want to do that (e.g. demand() does not take a long)\nwe need some content-specific behavior that cannot be encoded in the simpler interfaces provided by reactivestreams (e.g. 100-Continue)\nwe need to have clear paths for failures that are completely absent from reactivestreams, in both directions (the producer fails, or the consumer fails).\nFlow.Subscriber.onNext(T) is not enough, as we would need to allocate all the times an object that wraps (buffer, last, callback)", "author": "sbordet", "createdAt": "2020-03-24T00:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2ODI0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397068242", "bodyText": "why is this assuming that a content can't ber in simultaneous subscriptions?\nCan't a reproducible content be sent to two different requests at the same time?\nI don't think the abstract content should hold onto a subscription reference at all. it just needs logic like:\n    boolean oneTimeused;\n    ...\n    if (!isReproducible|())\n    {\n      if (oneTimeUsed)\n          throw ISE(...);\n      oneTimeUsed = true;\n    }\n    ...", "author": "gregw", "createdAt": "2020-03-24T11:03:36Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.io.EOFException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Subscription subscription;\n+    private Throwable failure;\n+\n+    protected AbstractRequestContent(String contentType)\n+    {\n+        this.contentType = contentType;\n+    }\n+\n+    @Override\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    @Override\n+    public Subscription subscribe(Consumer consumer, boolean emitInitialContent)\n+    {\n+        Subscription oldSubscription;\n+        Subscription newSubscription;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (subscription != null && !isReproducible())\n+                throw new IllegalStateException(\"Multiple subscriptions not supported on \" + this);\n+            oldSubscription = subscription;\n+            newSubscription = subscription = newSubscription(consumer, emitInitialContent, failure);\n+        }\n+        if (oldSubscription != null)\n+            oldSubscription.fail(new EOFException(\"Content replay\"));", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5NTA3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397095075", "bodyText": "@gregw having multiple subscriptions for the same content is not a use case that we need implemented. If someone wants to do that, the API does not forbid it, but we don't need it.\nIt will be quite complicated to implement multiple subscriptions, as one will be slower than the other, and now you need a policy to decide whether the chunks should be provided independently, or wait for all the subscribers to demand, etc.\nThe fact that the subscription is overwritten in case of reproducible content is because the same content may be reproduced in a subsequent request (e.g. 302 or 401), so the subscriptions are sequential (not simultaneous), but only ever one is active.", "author": "sbordet", "createdAt": "2020-03-24T11:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2ODI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1NzQ4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397657485", "bodyText": "Why isn't it a use case we need to support?  I can see a web spider/crawler wanting to send the same content to many servers so why shouldn't we be able to wrap up a ByteBuffer as a content and send it  multiple times?\nIt is fine if some/many/most of our Contents cannot do this, as it would be complex for some.   But there is no reason to prevent it in the Abstract and no reason not to support it in the ByteBuffer case at the very least.", "author": "gregw", "createdAt": "2020-03-25T07:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2ODI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MDk1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397070952", "bodyText": "why is failure delivered to the content and not directly to the subscription?\nIf a specific request fails, that should only affect that requests subscription and not subsequent or concurrent subscriptions for the same content.", "author": "gregw", "createdAt": "2020-03-24T11:08:43Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.io.EOFException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Subscription subscription;\n+    private Throwable failure;\n+\n+    protected AbstractRequestContent(String contentType)\n+    {\n+        this.contentType = contentType;\n+    }\n+\n+    @Override\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    @Override\n+    public Subscription subscribe(Consumer consumer, boolean emitInitialContent)\n+    {\n+        Subscription oldSubscription;\n+        Subscription newSubscription;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (subscription != null && !isReproducible())\n+                throw new IllegalStateException(\"Multiple subscriptions not supported on \" + this);\n+            oldSubscription = subscription;\n+            newSubscription = subscription = newSubscription(consumer, emitInitialContent, failure);\n+        }\n+        if (oldSubscription != null)\n+            oldSubscription.fail(new EOFException(\"Content replay\"));\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Content subscription for {}: {}\", this, consumer);\n+        return newSubscription;\n+    }\n+\n+    protected abstract Subscription newSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure);\n+\n+    @Override\n+    public void fail(Throwable failure)", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwMDAzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397100033", "bodyText": "why is failure delivered to the content and not directly to the subscription?\n\nBecause the content may not have a subscription yet when the failure happens.\nFor example, you send a request with content, but all connections are busy and it remains queued (so there is no subscription yet). Time passes and the request fails because of total timeout before it has the chance to even be sent.\nThat is also why newSubscription(...) takes a failure argument: if the implementation subscribes exactly a moment after the content has been failed, then also the subscription is failed immediately.", "author": "sbordet", "createdAt": "2020-03-24T12:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1OTA2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397659065", "bodyText": "But that assumes that a Content can only be used for one request and there is nothing in the contract that makes that apparent.\nI think failures have to be directly delivered to all Subscriptions.    IF failures are to be delivered to Content as well, that should be separate and perhaps only to non reproducible contents... or maybe only non reproducible contents act on them  or perhaps only a OneTimeContent sub interface has the failure callback?", "author": "gregw", "createdAt": "2020-03-25T07:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NTM1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397075353", "bodyText": "needs javadoc (and perhaps a better names?) for what fields mean, specially emitInitialContent and committed.  A state diagram or table might help!", "author": "gregw", "createdAt": "2020-03-24T11:16:38Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.io.EOFException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Subscription subscription;\n+    private Throwable failure;\n+\n+    protected AbstractRequestContent(String contentType)\n+    {\n+        this.contentType = contentType;\n+    }\n+\n+    @Override\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    @Override\n+    public Subscription subscribe(Consumer consumer, boolean emitInitialContent)\n+    {\n+        Subscription oldSubscription;\n+        Subscription newSubscription;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (subscription != null && !isReproducible())\n+                throw new IllegalStateException(\"Multiple subscriptions not supported on \" + this);\n+            oldSubscription = subscription;\n+            newSubscription = subscription = newSubscription(consumer, emitInitialContent, failure);\n+        }\n+        if (oldSubscription != null)\n+            oldSubscription.fail(new EOFException(\"Content replay\"));\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Content subscription for {}: {}\", this, consumer);\n+        return newSubscription;\n+    }\n+\n+    protected abstract Subscription newSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure);\n+\n+    @Override\n+    public void fail(Throwable failure)\n+    {\n+        Subscription subscription = null;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (this.failure == null)\n+            {\n+                this.failure = failure;\n+                subscription = this.subscription;\n+            }\n+        }\n+        if (subscription != null)\n+            subscription.fail(failure);\n+    }\n+\n+    public abstract class AbstractSubscription implements Subscription\n+    {\n+        private final Consumer consumer;\n+        private final boolean emitInitialContent;\n+        private Throwable failure;\n+        private int demand;\n+        private boolean stalled;\n+        private boolean committed;", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwMzMxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397103316", "bodyText": "Will do.", "author": "sbordet", "createdAt": "2020-03-24T12:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MzU2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r398793562", "bodyText": "emitInitialContent ????", "author": "gregw", "createdAt": "2020-03-26T18:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTk0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r400009940", "bodyText": "@sbordet I would still like to see javadoc on the what/why/how of emitInitialContent\nMaybe a state diagram/table wouldn't hurt either.", "author": "gregw", "createdAt": "2020-03-30T08:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NjU5OA==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397076598", "bodyText": "you are missing committed and submitInitialContent", "author": "gregw", "createdAt": "2020-03-24T11:18:54Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.io.EOFException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Subscription subscription;\n+    private Throwable failure;\n+\n+    protected AbstractRequestContent(String contentType)\n+    {\n+        this.contentType = contentType;\n+    }\n+\n+    @Override\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    @Override\n+    public Subscription subscribe(Consumer consumer, boolean emitInitialContent)\n+    {\n+        Subscription oldSubscription;\n+        Subscription newSubscription;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (subscription != null && !isReproducible())\n+                throw new IllegalStateException(\"Multiple subscriptions not supported on \" + this);\n+            oldSubscription = subscription;\n+            newSubscription = subscription = newSubscription(consumer, emitInitialContent, failure);\n+        }\n+        if (oldSubscription != null)\n+            oldSubscription.fail(new EOFException(\"Content replay\"));\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Content subscription for {}: {}\", this, consumer);\n+        return newSubscription;\n+    }\n+\n+    protected abstract Subscription newSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure);\n+\n+    @Override\n+    public void fail(Throwable failure)\n+    {\n+        Subscription subscription = null;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (this.failure == null)\n+            {\n+                this.failure = failure;\n+                subscription = this.subscription;\n+            }\n+        }\n+        if (subscription != null)\n+            subscription.fail(failure);\n+    }\n+\n+    public abstract class AbstractSubscription implements Subscription\n+    {\n+        private final Consumer consumer;\n+        private final boolean emitInitialContent;\n+        private Throwable failure;\n+        private int demand;\n+        private boolean stalled;\n+        private boolean committed;\n+\n+        public AbstractSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure)\n+        {\n+            this.consumer = consumer;\n+            this.emitInitialContent = emitInitialContent;\n+            this.failure = failure;\n+            this.stalled = true;\n+        }\n+\n+        @Override\n+        public void demand()\n+        {\n+            boolean produce;\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                ++demand;\n+                produce = stalled;\n+                if (stalled)\n+                    stalled = false;\n+            }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Content demand, producing {} for {}\", produce, this);\n+            if (produce)\n+                produce();\n+        }\n+\n+        private void produce()\n+        {\n+            while (true)\n+            {\n+                Throwable failure;\n+                boolean committed;\n+                try (AutoLock ignored = lock.lock())\n+                {\n+                    failure = this.failure;\n+                    committed = this.committed;\n+                }\n+                if (failure != null)\n+                {\n+                    notifyFailure(failure);\n+                    return;\n+                }\n+\n+                if (committed || emitInitialContent)\n+                {\n+                    try\n+                    {\n+                        if (!produceContent(this::processContent))\n+                            return;\n+                    }\n+                    catch (Throwable x)\n+                    {\n+                        // Fail and loop around to notify the failure.\n+                        fail(x);\n+                    }\n+                }\n+                else\n+                {\n+                    if (!processContent(BufferUtil.EMPTY_BUFFER, false, Callback.NOOP))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        protected abstract boolean produceContent(Producer producer) throws Exception;\n+\n+        @Override\n+        public void fail(Throwable failure)\n+        {\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                if (this.failure == null)\n+                    this.failure = failure;\n+            }\n+        }\n+\n+        private boolean processContent(ByteBuffer content, boolean last, Callback callback)\n+        {\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                committed = true;\n+                --demand;\n+            }\n+\n+            if (content != null)\n+                notifyContent(content, last, callback);\n+            else\n+                callback.succeeded();\n+\n+            boolean noDemand;\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                noDemand = demand == 0;\n+                if (noDemand)\n+                    stalled = true;\n+            }\n+            if (noDemand)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"No demand, processing stalled for {}\", this);\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        protected void notifyContent(ByteBuffer buffer, boolean last, Callback callback)\n+        {\n+            try\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Notifying content last={} {} for {}\", last, BufferUtil.toDetailString(buffer), this);\n+                consumer.onContent(buffer, last, callback);\n+            }\n+            catch (Throwable x)\n+            {\n+                callback.failed(x);\n+                fail(x);\n+            }\n+        }\n+\n+        private void notifyFailure(Throwable failure)\n+        {\n+            try\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Notifying failure for {}\", this, failure);\n+                consumer.onFailure(failure);\n+            }\n+            catch (Exception x)\n+            {\n+                LOG.trace(\"Failure while notifying content failure {}\", failure, x);\n+            }\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            int demand;\n+            boolean stalled;\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                demand = this.demand;\n+                stalled = this.stalled;", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwNTQ1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397105452", "bodyText": "Will do.", "author": "sbordet", "createdAt": "2020-03-24T12:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NzcyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397077725", "bodyText": "what is the implementation mean to do?  call notifyContent?", "author": "gregw", "createdAt": "2020-03-24T11:20:58Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.io.EOFException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Subscription subscription;\n+    private Throwable failure;\n+\n+    protected AbstractRequestContent(String contentType)\n+    {\n+        this.contentType = contentType;\n+    }\n+\n+    @Override\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    @Override\n+    public Subscription subscribe(Consumer consumer, boolean emitInitialContent)\n+    {\n+        Subscription oldSubscription;\n+        Subscription newSubscription;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (subscription != null && !isReproducible())\n+                throw new IllegalStateException(\"Multiple subscriptions not supported on \" + this);\n+            oldSubscription = subscription;\n+            newSubscription = subscription = newSubscription(consumer, emitInitialContent, failure);\n+        }\n+        if (oldSubscription != null)\n+            oldSubscription.fail(new EOFException(\"Content replay\"));\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Content subscription for {}: {}\", this, consumer);\n+        return newSubscription;\n+    }\n+\n+    protected abstract Subscription newSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure);\n+\n+    @Override\n+    public void fail(Throwable failure)\n+    {\n+        Subscription subscription = null;\n+        try (AutoLock ignored = lock.lock())\n+        {\n+            if (this.failure == null)\n+            {\n+                this.failure = failure;\n+                subscription = this.subscription;\n+            }\n+        }\n+        if (subscription != null)\n+            subscription.fail(failure);\n+    }\n+\n+    public abstract class AbstractSubscription implements Subscription\n+    {\n+        private final Consumer consumer;\n+        private final boolean emitInitialContent;\n+        private Throwable failure;\n+        private int demand;\n+        private boolean stalled;\n+        private boolean committed;\n+\n+        public AbstractSubscription(Consumer consumer, boolean emitInitialContent, Throwable failure)\n+        {\n+            this.consumer = consumer;\n+            this.emitInitialContent = emitInitialContent;\n+            this.failure = failure;\n+            this.stalled = true;\n+        }\n+\n+        @Override\n+        public void demand()\n+        {\n+            boolean produce;\n+            try (AutoLock ignored = lock.lock())\n+            {\n+                ++demand;\n+                produce = stalled;\n+                if (stalled)\n+                    stalled = false;\n+            }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Content demand, producing {} for {}\", produce, this);\n+            if (produce)\n+                produce();\n+        }\n+\n+        private void produce()\n+        {\n+            while (true)\n+            {\n+                Throwable failure;\n+                boolean committed;\n+                try (AutoLock ignored = lock.lock())\n+                {\n+                    failure = this.failure;\n+                    committed = this.committed;\n+                }\n+                if (failure != null)\n+                {\n+                    notifyFailure(failure);\n+                    return;\n+                }\n+\n+                if (committed || emitInitialContent)\n+                {\n+                    try\n+                    {\n+                        if (!produceContent(this::processContent))\n+                            return;\n+                    }\n+                    catch (Throwable x)\n+                    {\n+                        // Fail and loop around to notify the failure.\n+                        fail(x);\n+                    }\n+                }\n+                else\n+                {\n+                    if (!processContent(BufferUtil.EMPTY_BUFFER, false, Callback.NOOP))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        protected abstract boolean produceContent(Producer producer) throws Exception;", "originalCommit": "e215d071c8604705ad1d56607ab28449201afb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwNDI4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r397104284", "bodyText": "Will add javadocs.\nThe implementation is supposed to produce some content and give it to the Producer argument, or throw an exception if it cannot produce content.", "author": "sbordet", "createdAt": "2020-03-24T12:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NzcyNQ=="}], "type": "inlineReview"}, {"oid": "9fec1f43e07692f9cb80ae9390ff457e0421d91d", "url": "https://github.com/eclipse/jetty.project/commit/9fec1f43e07692f9cb80ae9390ff457e0421d91d", "message": "Issue #4400 - Review HttpClient's ContentProvider.\n\nImproved javadocs and comment as per initial review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-03-24T15:42:53Z", "type": "commit"}, {"oid": "0f2ddc8c9f1ab0e677e3b6999992b2d88a0bc838", "url": "https://github.com/eclipse/jetty.project/commit/0f2ddc8c9f1ab0e677e3b6999992b2d88a0bc838", "message": "Issue #4400 - Review HttpClient's ContentProvider.\n\nReview updates.\n* Now AbstractRequestContent supports multiple subscriptions.\n* Reviewed abort() path to fail the content and the subscription\n  and notify FailureListener sequentially with other listeners.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-03-26T16:46:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5NzgzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4618#discussion_r398797836", "bodyText": "This is still not stateless.\nConsider a ByteBufferContent that is shared between many requests to many servers... if just one of those request fails in the queue before a connection is made (perhaps it is an unknown host), then this failure will be set on the shared content here and will fail all the requests that share this content.\nA reusable content must be stateless.  A non-reusable one can have state like failure if really needed.", "author": "gregw", "createdAt": "2020-03-26T18:26:36Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/AbstractRequestContent.java", "diffHunk": "@@ -0,0 +1,275 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.util;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>Partial implementation of {@link Request.Content}.</p>\n+ * <p>Manages a single subscription at a time (multiple simultaneous subscriptions are not allowed).</p>\n+ */\n+public abstract class AbstractRequestContent implements Request.Content\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestContent.class);\n+\n+    private final AutoLock lock = new AutoLock();\n+    private final String contentType;\n+    private Throwable failure;", "originalCommit": "0f2ddc8c9f1ab0e677e3b6999992b2d88a0bc838", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "708115f6095bd65052dbf5ff93fddcf9b1a16053", "url": "https://github.com/eclipse/jetty.project/commit/708115f6095bd65052dbf5ff93fddcf9b1a16053", "message": "Issue #4400 - Review HttpClient's ContentProvider.\n\nReview updates.\n* Updated AbstractRequestContent (and subclasses) failure handling.\n* Updated MultiPartRequestContent failure handling.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-03-27T14:33:21Z", "type": "commit"}, {"oid": "e224be650b0a31a248dac3902ec31bce9e1862fa", "url": "https://github.com/eclipse/jetty.project/commit/e224be650b0a31a248dac3902ec31bce9e1862fa", "message": "Issue #4400 - Review HttpClient's ContentProvider.\n\nReview updates.\nClosing MultiPartRequestContent before sending it.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-03-30T10:34:21Z", "type": "commit"}, {"oid": "6ed952a9c02983016d91ed36eb56e1904aaa7695", "url": "https://github.com/eclipse/jetty.project/commit/6ed952a9c02983016d91ed36eb56e1904aaa7695", "message": "Merges 'jetty-10.0.x' into 'jetty-10.0.x-4400-review_httpclient_content'.", "committedDate": "2020-03-30T10:49:39Z", "type": "commit"}]}