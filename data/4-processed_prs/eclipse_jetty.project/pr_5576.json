{"pr_number": 5576, "pr_title": "Fix #5575 SEARCH method", "pr_createdAt": "2020-11-05T09:14:55Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5576", "timeline": [{"oid": "17cee2ac6469049b2820ec34b51badb7aa1c6db3", "url": "https://github.com/eclipse/jetty.project/commit/17cee2ac6469049b2820ec34b51badb7aa1c6db3", "message": "Fix #5575 SEARCH method\n\nFix #5575 SEARCH and PATCH methods", "committedDate": "2020-11-05T09:14:12Z", "type": "commit"}, {"oid": "b8f03e2a8d5d80f4c253ca5234ab2c15608d5cb4", "url": "https://github.com/eclipse/jetty.project/commit/b8f03e2a8d5d80f4c253ca5234ab2c15608d5cb4", "message": "Added REPORT method\nBetter test", "committedDate": "2020-11-05T10:33:23Z", "type": "commit"}, {"oid": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "url": "https://github.com/eclipse/jetty.project/commit/d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "message": " + Added all IANA methods\n + Used Trie for most lookups\n + Fixed ArrayTernayTrie lookup", "committedDate": "2020-11-05T17:25:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1Njk1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518256953", "bodyText": "Do we want to document what this means?", "author": "joakime", "createdAt": "2020-11-05T18:03:53Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,189 +26,161 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI,\n-    PATCH,\n-    SEARCH,\n-    REPORT;\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(false, true),\n+    BASELINE_CONTROL(false, true),\n+    BIND(false, true),\n+    CHECKIN(false, true),\n+    CHECKOUT(false, true),\n+    CONNECT(false, false),\n+    COPY(false, true),\n+    DELETE(false, true),\n+    GET(true, true),\n+    HEAD(true, true),\n+    LABEL(false, true),\n+    LINK(false, true),\n+    LOCK(false, false),\n+    MERGE(false, true),\n+    MKACTIVITY(false, true),\n+    MKCALENDAR(false, true),\n+    MKCOL(false, true),\n+    MKREDIRECTREF(false, true),\n+    MKWORKSPACE(false, true),\n+    MOVE(false, true),\n+    OPTIONS(true, true),\n+    ORDERPATCH(false, true),\n+    PATCH(false, false),\n+    POST(false, false),\n+    PRI(true, true),\n+    PROPFIND(true, true),\n+    PROPPATCH(false, true),\n+    PUT(false, true),\n+    REBIND(false, true),\n+    REPORT(true, true),\n+    SEARCH(true, true),\n+    TRACE(true, true),\n+    UNBIND(false, true),\n+    UNCHECKOUT(false, true),\n+    UNLINK(false, true),\n+    UNLOCK(false, true),\n+    UPDATE(false, true),\n+    UPDATEREDIRECTREF(false, true),\n+    VERSION_CONTROL(false, true),\n+\n+    // Other methods\n+    PROXY(false, false);\n+\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final boolean _safe;\n+    private final boolean _idempotent;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    HttpMethod(boolean safe, boolean idempotent)\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                switch (bytes[position + 1])\n-                {\n-                    case 'O':\n-                        if (bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                            return POST;\n-                        return null;\n-                    case 'R':\n-                        if (bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                            return PRI;\n-                        if (bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                            return PROXY;\n-                        return null;\n-                    case 'U':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                            return PUT;\n-                        return null;\n-                    case 'A':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == 'C' && length >= 6 && bytes[position + 4] == 'H' && bytes[position + 5] == ' ')\n-                            return PATCH;\n-                        return null;\n-                    default:\n-                        return null;\n-                }\n-\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-            case 'S':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'R' && length >= 7 &&\n-                    bytes[position + 4] == 'C' && bytes[position + 5] == 'H' && bytes[position + 6] == ' ')\n-                    return SEARCH;\n-                break;\n-            case 'R':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'P' && bytes[position + 3] == 'O' && length >= 7 &&\n-                    bytes[position + 4] == 'R' && bytes[position + 5] == 'T' && bytes[position + 6] == ' ')\n-                    return REPORT;\n-                break;\n-            default:\n-                break;\n-        }\n-        return null;\n+        _method = toString().replace('_', '-');\n+        _safe = safe;\n+        _idempotent = idempotent;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    public byte[] getBytes()\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        return _bytes;\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n-\n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    public boolean isSafe()", "originalCommit": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MDQ2Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518580466", "bodyText": "done", "author": "gregw", "createdAt": "2020-11-06T08:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1Njk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1NzIxMg==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518257212", "bodyText": "Do we want to document what this means too?", "author": "joakime", "createdAt": "2020-11-05T18:04:16Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,189 +26,161 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI,\n-    PATCH,\n-    SEARCH,\n-    REPORT;\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(false, true),\n+    BASELINE_CONTROL(false, true),\n+    BIND(false, true),\n+    CHECKIN(false, true),\n+    CHECKOUT(false, true),\n+    CONNECT(false, false),\n+    COPY(false, true),\n+    DELETE(false, true),\n+    GET(true, true),\n+    HEAD(true, true),\n+    LABEL(false, true),\n+    LINK(false, true),\n+    LOCK(false, false),\n+    MERGE(false, true),\n+    MKACTIVITY(false, true),\n+    MKCALENDAR(false, true),\n+    MKCOL(false, true),\n+    MKREDIRECTREF(false, true),\n+    MKWORKSPACE(false, true),\n+    MOVE(false, true),\n+    OPTIONS(true, true),\n+    ORDERPATCH(false, true),\n+    PATCH(false, false),\n+    POST(false, false),\n+    PRI(true, true),\n+    PROPFIND(true, true),\n+    PROPPATCH(false, true),\n+    PUT(false, true),\n+    REBIND(false, true),\n+    REPORT(true, true),\n+    SEARCH(true, true),\n+    TRACE(true, true),\n+    UNBIND(false, true),\n+    UNCHECKOUT(false, true),\n+    UNLINK(false, true),\n+    UNLOCK(false, true),\n+    UPDATE(false, true),\n+    UPDATEREDIRECTREF(false, true),\n+    VERSION_CONTROL(false, true),\n+\n+    // Other methods\n+    PROXY(false, false);\n+\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final boolean _safe;\n+    private final boolean _idempotent;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    HttpMethod(boolean safe, boolean idempotent)\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                switch (bytes[position + 1])\n-                {\n-                    case 'O':\n-                        if (bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                            return POST;\n-                        return null;\n-                    case 'R':\n-                        if (bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                            return PRI;\n-                        if (bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                            return PROXY;\n-                        return null;\n-                    case 'U':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                            return PUT;\n-                        return null;\n-                    case 'A':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == 'C' && length >= 6 && bytes[position + 4] == 'H' && bytes[position + 5] == ' ')\n-                            return PATCH;\n-                        return null;\n-                    default:\n-                        return null;\n-                }\n-\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-            case 'S':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'R' && length >= 7 &&\n-                    bytes[position + 4] == 'C' && bytes[position + 5] == 'H' && bytes[position + 6] == ' ')\n-                    return SEARCH;\n-                break;\n-            case 'R':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'P' && bytes[position + 3] == 'O' && length >= 7 &&\n-                    bytes[position + 4] == 'R' && bytes[position + 5] == 'T' && bytes[position + 6] == ' ')\n-                    return REPORT;\n-                break;\n-            default:\n-                break;\n-        }\n-        return null;\n+        _method = toString().replace('_', '-');\n+        _safe = safe;\n+        _idempotent = idempotent;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    public byte[] getBytes()\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        return _bytes;\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n-\n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    public boolean isSafe()\n+    {\n+        return _safe;\n+    }\n \n-    static\n+    public boolean isIdempotent()", "originalCommit": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MDUwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518580506", "bodyText": "done", "author": "gregw", "createdAt": "2020-11-06T08:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1NzIxMg=="}], "type": "inlineReview"}, {"oid": "f4349fab5668d278476d7b3effaf9baa4a90c601", "url": "https://github.com/eclipse/jetty.project/commit/f4349fab5668d278476d7b3effaf9baa4a90c601", "message": " + Added javadoc for isSafe and isIdempotent", "committedDate": "2020-11-06T08:01:16Z", "type": "commit"}, {"oid": "064158e3dbcc7d6d8f41f2cc020c80e12a56f49d", "url": "https://github.com/eclipse/jetty.project/commit/064158e3dbcc7d6d8f41f2cc020c80e12a56f49d", "message": " + Use enum to encapsulate fact that all safe methods are idempotent... helps with readability", "committedDate": "2020-11-06T08:28:43Z", "type": "commit"}, {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8", "url": "https://github.com/eclipse/jetty.project/commit/235923acb70825c63c9eabfd94a023b6954b72c8", "message": " + replaced dodgey call to toString in constructor with explicit method string", "committedDate": "2020-11-06T08:32:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyODQxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518628414", "bodyText": "This cache is used by HPackContext, and you changed it from case-insensitive to case-sensitive. Was that on purpose?", "author": "lorban", "createdAt": "2020-11-06T09:33:01Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);", "originalCommit": "235923acb70825c63c9eabfd94a023b6954b72c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc5MjQ3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518792473", "bodyText": "oops no.", "author": "gregw", "createdAt": "2020-11-06T14:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyODQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc5MzAyMA==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518793020", "bodyText": "Let me add a test to check I don't do that again....", "author": "gregw", "createdAt": "2020-11-06T14:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyODQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNTc4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518805785", "bodyText": "No I didn't!!! the insensitive cache is INSENSITIVE_CACHE. The CACHE is correctly passed false for insensitive!", "author": "gregw", "createdAt": "2020-11-06T14:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyODQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyOTMyNA==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518629324", "bodyText": "It is still used by HttpParser.", "author": "lorban", "createdAt": "2020-11-06T09:34:33Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        int len = limit - position;\n+        if (limit > 3)\n+        {\n+            // Short cut for GET\n+            if (bytes[position] == 'G' && bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n+                return GET;\n+            // Otherwise lookup in the Trie\n+            return LOOK_AHEAD.getBest(bytes, position, len);\n+        }\n+        return null;\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used", "originalCommit": "235923acb70825c63c9eabfd94a023b6954b72c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNjAyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518806025", "bodyText": "Now this is an opps- deprecated the wrong one!", "author": "gregw", "createdAt": "2020-11-06T14:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyOTMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0MDEwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518640101", "bodyText": "Is that extra LOOK_AHEAD trie worth it? Since it is just a copy of the CACHE one with the extra whitespace, wouldn't something like the following be as fast and avoid duplication?\nHttpMethod method = CACHE.getBest(buffer, 0, buffer.remaining());\nif (method == null)\n    return null;\n\nint whitespaceIndex = method.name().length();\nif (buffer.remaining() == whitespaceIndex)\n    return null;\n\nbyte b = buffer.get(whitespaceIndex);\nreturn b == ' ' ? method : null;", "author": "lorban", "createdAt": "2020-11-06T09:53:03Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        int len = limit - position;\n+        if (limit > 3)\n+        {\n+            // Short cut for GET\n+            if (bytes[position] == 'G' && bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n+                return GET;\n+            // Otherwise lookup in the Trie\n+            return LOOK_AHEAD.getBest(bytes, position, len);\n+        }\n+        return null;\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used\n+     */\n+    @Deprecated\n+    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n     {\n-        return toString();\n+        return LOOK_AHEAD.getBest(buffer, 0, buffer.remaining());", "originalCommit": "235923acb70825c63c9eabfd94a023b6954b72c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNzcyNg==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518807726", "bodyText": "That looks like the kind of thing your PR in 10 can resolve :)\nPlus I kept it separate from CACHE as I wanted to allow you to remove the CACHE if it is not used for getBest.", "author": "gregw", "createdAt": "2020-11-06T15:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0MDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxMDU3NA==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518810574", "bodyText": "Also look at the impl I just did.  I think the buffer.getInt lookup could be nice and fast for the GET method, so could make it very worth it... but I'm guessing it is faster.", "author": "gregw", "createdAt": "2020-11-06T15:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0MDEwMQ=="}], "type": "inlineReview"}, {"oid": "f1802a23eb91c650baf31938ecdada78c69c3b94", "url": "https://github.com/eclipse/jetty.project/commit/f1802a23eb91c650baf31938ecdada78c69c3b94", "message": "Updates from review", "committedDate": "2020-11-06T15:04:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxOTkwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518819901", "bodyText": "You can get rid of the String method parameter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    _method = method;\n          \n          \n            \n                    _method = name().replace('_','-');\n          \n      \n    \n    \n  \n\nThat works.", "author": "joakime", "createdAt": "2020-11-06T15:20:12Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,192 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;", "originalCommit": "f1802a23eb91c650baf31938ecdada78c69c3b94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyNTIwMw==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518825203", "bodyText": "I added this proposed change to PR #5578", "author": "joakime", "createdAt": "2020-11-06T15:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxOTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgzMDk1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518830953", "bodyText": "I was doing that but with toString() instead of name().  It worked fine... until it suddenly stopped working when I did another change, because toString wasn't stable in the constructor.   I'm guessing it is OK to call name() as it is after the call to the super constructor, so I can't see how that can be wrong.   When your PR is CI green, then let's merge.", "author": "gregw", "createdAt": "2020-11-06T15:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxOTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgzMjk2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518832967", "bodyText": "Looking at commit d10b15c the toString() was referencing the _method you were trying to initialize in the constructor.", "author": "joakime", "createdAt": "2020-11-06T15:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxOTkwMQ=="}], "type": "inlineReview"}, {"oid": "3e94fae5e8c5c3c5e2c19515f8c3c61b5bcb3144", "url": "https://github.com/eclipse/jetty.project/commit/3e94fae5e8c5c3c5e2c19515f8c3c61b5bcb3144", "message": "Issue #5575 - simpler HttpMethod enum\n\nSigned-off-by: Joakim Erdfelt <joakim.erdfelt@gmail.com>", "committedDate": "2020-11-06T15:26:58Z", "type": "commit"}, {"oid": "5e062b5052ba75e25345cec3af516493d82b44f9", "url": "https://github.com/eclipse/jetty.project/commit/5e062b5052ba75e25345cec3af516493d82b44f9", "message": "Merge pull request #5578 from eclipse/jetty-9.4.x-5575-SEARCH-smaller\n\nIssue #5575 - simpler HttpMethod enum", "committedDate": "2020-11-06T21:05:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MzU4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r520543582", "bodyText": "Is this really necessary?\nDoes this really produce any measurable performance improvement? (have you jmh'd this?)", "author": "joakime", "createdAt": "2020-11-10T13:01:01Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,192 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(Type.IDEMPOTENT),\n+    BASELINE_CONTROL(Type.IDEMPOTENT),\n+    BIND(Type.IDEMPOTENT),\n+    CHECKIN(Type.IDEMPOTENT),\n+    CHECKOUT(Type.IDEMPOTENT),\n+    CONNECT(Type.NORMAL),\n+    COPY(Type.IDEMPOTENT),\n+    DELETE(Type.IDEMPOTENT),\n+    GET(Type.SAFE),\n+    HEAD(Type.SAFE),\n+    LABEL(Type.IDEMPOTENT),\n+    LINK(Type.IDEMPOTENT),\n+    LOCK(Type.NORMAL),\n+    MERGE(Type.IDEMPOTENT),\n+    MKACTIVITY(Type.IDEMPOTENT),\n+    MKCALENDAR(Type.IDEMPOTENT),\n+    MKCOL(Type.IDEMPOTENT),\n+    MKREDIRECTREF(Type.IDEMPOTENT),\n+    MKWORKSPACE(Type.IDEMPOTENT),\n+    MOVE(Type.IDEMPOTENT),\n+    OPTIONS(Type.SAFE),\n+    ORDERPATCH(Type.IDEMPOTENT),\n+    PATCH(Type.NORMAL),\n+    POST(Type.NORMAL),\n+    PRI(Type.SAFE),\n+    PROPFIND(Type.SAFE),\n+    PROPPATCH(Type.IDEMPOTENT),\n+    PUT(Type.IDEMPOTENT),\n+    REBIND(Type.IDEMPOTENT),\n+    REPORT(Type.SAFE),\n+    SEARCH(Type.SAFE),\n+    TRACE(Type.SAFE),\n+    UNBIND(Type.IDEMPOTENT),\n+    UNCHECKOUT(Type.IDEMPOTENT),\n+    UNLINK(Type.IDEMPOTENT),\n+    UNLOCK(Type.IDEMPOTENT),\n+    UPDATE(Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(Type.IDEMPOTENT),\n+    VERSION_CONTROL(Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n-    {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+    HttpMethod(Type type)\n+    {\n+        _method = name().replace('_', '-');\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    private static final int ACL_AS_INT = ('A' & 0xff) << 24 | ('C' & 0xFF) << 16 | ('L' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int GET_AS_INT = ('G' & 0xff) << 24 | ('E' & 0xFF) << 16 | ('T' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int PRI_AS_INT = ('P' & 0xff) << 24 | ('R' & 0xFF) << 16 | ('I' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int PUT_AS_INT = ('P' & 0xff) << 24 | ('U' & 0xFF) << 16 | ('T' & 0xFF) << 8 | (' ' & 0xFF);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used\n+     */\n+    @Deprecated\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        return LOOK_AHEAD.getBest(bytes, position, limit - position);\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n     {\n-        return toString();\n+        int len = buffer.remaining();\n+        // Short cut for 3 char methods, mostly for GET optimisation\n+        if (len > 3)", "originalCommit": "5e062b5052ba75e25345cec3af516493d82b44f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcyOTUwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r520729509", "bodyText": "The getInt switch is an order of magnitude better.  Interestingly the Map is slightly better than the Trie in this case sensitive case, but the map needs to allocate.\nSo doing this benchmark has convinced me I should do the getInt trick for POST and HEAD as well!\nBenchmark                                                     Mode  Cnt          Score         Error   Units\nHttpMethodBenchmark.testIntSwitch                            thrpt   10  234190385.517 \u00b1 1954845.858   ops/s\nHttpMethodBenchmark.testIntSwitch:\u00b7gc.alloc.rate.norm        thrpt   10         \u2248 10\u207b\u2075                  B/op\nHttpMethodBenchmark.testMapGet                               thrpt   10   21957916.326 \u00b1  507531.533   ops/s\nHttpMethodBenchmark.testMapGet:\u00b7gc.alloc.rate.norm           thrpt   10         48.000 \u00b1       0.001    B/op\nHttpMethodBenchmark.testTrieGetBest                          thrpt   10   18475001.742 \u00b1  205942.699   ops/s\nHttpMethodBenchmark.testTrieGetBest:\u00b7gc.alloc.rate.norm      thrpt   10         \u2248 10\u207b\u2074                  B/op", "author": "gregw", "createdAt": "2020-11-10T17:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MzU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc0MjgyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r520742828", "bodyText": "Extending the int switch to POST and benchmarking against MOVE which doesn't have the optimisation gives:\nBenchmark                                                     Mode  Cnt          Score          Error   Units\nHttpMethodBenchmark.testHttpMethodMove                       thrpt   10   10435118.064 \u00b1   240925.892   ops/s\nHttpMethodBenchmark.testHttpMethodMove:\u00b7gc.alloc.rate.norm   thrpt   10         \u2248 10\u207b\u2074                   B/op\nHttpMethodBenchmark.testHttpMethodPost                       thrpt   10  148142781.323 \u00b1 14602351.496   ops/s\nHttpMethodBenchmark.testHttpMethodPost:\u00b7gc.alloc.rate.norm   thrpt   10         \u2248 10\u207b\u2075                   B/op\nHttpMethodBenchmark.testIntSwitch                            thrpt   10  206759099.264 \u00b1  6371501.120   ops/s\nHttpMethodBenchmark.testIntSwitch:\u00b7gc.alloc.rate.norm        thrpt   10         \u2248 10\u207b\u2075                   B/op\nHttpMethodBenchmark.testMapGet                               thrpt   10   20527043.581 \u00b1   415407.826   ops/s\nHttpMethodBenchmark.testMapGet:\u00b7gc.alloc.rate.norm           thrpt   10         48.000 \u00b1        0.001    B/op\nHttpMethodBenchmark.testTrieGetBest                          thrpt   10   18573224.811 \u00b1   591011.908   ops/s\nHttpMethodBenchmark.testTrieGetBest:\u00b7gc.alloc.rate.norm      thrpt   10         \u2248 10\u207b\u2074                   B/op\n\nSo even the slightly more complex lookup for POST easily beats the non optimised MOVE by an order of magnitude.\nMakes me wonder if we shouldn't make Trie (or is it now an Index) that uses getLong and getInt for most of the work!", "author": "gregw", "createdAt": "2020-11-10T17:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MzU4Mg=="}], "type": "inlineReview"}, {"oid": "bf98ae26e74c7b166892c24dab0f28cd7221f5cb", "url": "https://github.com/eclipse/jetty.project/commit/bf98ae26e74c7b166892c24dab0f28cd7221f5cb", "message": "Update from review\n\n + added benchmark\n + optimised POST and HEAD", "committedDate": "2020-11-10T17:31:53Z", "type": "commit"}]}