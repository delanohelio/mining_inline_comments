{"pr_number": 4803, "pr_title": "Solve lock contention creating HTTP2 streams (#2188) \u2026", "pr_createdAt": "2020-04-23T09:59:46Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4803", "timeline": [{"oid": "615f29e8580c2e02393397d7a2b334e426d6cf77", "url": "https://github.com/eclipse/jetty.project/commit/615f29e8580c2e02393397d7a2b334e426d6cf77", "message": "Solve lock contention creating HTTP2 streams (#2188) while fixing race condition that breaks http channels recycling (#4695)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-23T10:07:32Z", "type": "forcePushed"}, {"oid": "359284fe6682af6354a6109359aa3b94ce613686", "url": "https://github.com/eclipse/jetty.project/commit/359284fe6682af6354a6109359aa3b94ce613686", "message": "Solve lock contention creating HTTP2 streams (#2188) while fixing race condition that breaks http channels recycling (#4695)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-23T12:07:14Z", "type": "forcePushed"}, {"oid": "4d4f6002948820a60e0a6489816584b87dfcacdd", "url": "https://github.com/eclipse/jetty.project/commit/4d4f6002948820a60e0a6489816584b87dfcacdd", "message": "Solve lock contention creating HTTP2 streams (#2188) while fixing race condition that breaks http channels recycling (#4695)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-23T14:24:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyODQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415628476", "bodyText": "Remove this line.", "author": "sbordet", "createdAt": "2020-04-27T08:48:21Z", "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/ConcurrentStreamCreationTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.MetaData;\n+import org.eclipse.jetty.http2.api.Session;\n+import org.eclipse.jetty.http2.api.Stream;\n+import org.eclipse.jetty.http2.api.server.ServerSessionListener;\n+import org.eclipse.jetty.http2.frames.HeadersFrame;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Promise;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConcurrentStreamCreationTest extends AbstractTest\n+{\n+    @Test\n+    public void testConcurrentStreamCreation() throws Exception\n+    {\n+        int threads = 64;\n+        int runs = 1;\n+        int iterations = 1024;\n+        int total = threads * runs * iterations;\n+        CountDownLatch serverLatch = new CountDownLatch(total);\n+        start(new ServerSessionListener.Adapter()\n+        {\n+            @Override\n+            public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n+            {\n+                MetaData.Response response = new MetaData.Response(HttpVersion.HTTP_2, HttpStatus.OK_200, new HttpFields());\n+                HeadersFrame responseFrame = new HeadersFrame(stream.getId(), response, null, true);\n+                stream.headers(responseFrame, Callback.NOOP);\n+                serverLatch.countDown();\n+                return null;\n+            }\n+        }, h2 -> h2.setMaxConcurrentStreams(total));\n+\n+        Session session = newClient(new Session.Listener.Adapter());\n+\n+        CyclicBarrier barrier = new CyclicBarrier(threads);\n+        CountDownLatch clientLatch = new CountDownLatch(total);\n+        Promise<Stream> promise = new Promise.Adapter<Stream>()\n+        {\n+            @Override\n+            public void succeeded(Stream stream)\n+            {\n+                clientLatch.countDown();\n+            }\n+        };\n+        long start = System.nanoTime();\n+        IntStream.range(0, threads).forEach(i -> new Thread(() ->\n+        {\n+            try\n+            {\n+                barrier.await();\n+                IntStream.range(0, runs).forEach(j ->\n+                        IntStream.range(0, iterations).forEach(k ->\n+                        {\n+                            MetaData.Request request = newRequest(\"GET\", new HttpFields());\n+                            HeadersFrame requestFrame = new HeadersFrame(request, null, true);\n+                            session.newStream(requestFrame, promise, new Stream.Listener.Adapter());\n+//                            ((HTTP2Session)session).newStreamOld(requestFrame, promise, new Stream.Listener.Adapter());", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NTg1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415675853", "bodyText": "ok", "author": "lorban", "createdAt": "2020-04-27T09:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyODQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyOTI0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415629249", "bodyText": "Remove System.err.", "author": "sbordet", "createdAt": "2020-04-27T08:49:22Z", "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/ConcurrentStreamCreationTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.MetaData;\n+import org.eclipse.jetty.http2.api.Session;\n+import org.eclipse.jetty.http2.api.Stream;\n+import org.eclipse.jetty.http2.api.server.ServerSessionListener;\n+import org.eclipse.jetty.http2.frames.HeadersFrame;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Promise;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConcurrentStreamCreationTest extends AbstractTest\n+{\n+    @Test\n+    public void testConcurrentStreamCreation() throws Exception\n+    {\n+        int threads = 64;\n+        int runs = 1;\n+        int iterations = 1024;\n+        int total = threads * runs * iterations;\n+        CountDownLatch serverLatch = new CountDownLatch(total);\n+        start(new ServerSessionListener.Adapter()\n+        {\n+            @Override\n+            public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n+            {\n+                MetaData.Response response = new MetaData.Response(HttpVersion.HTTP_2, HttpStatus.OK_200, new HttpFields());\n+                HeadersFrame responseFrame = new HeadersFrame(stream.getId(), response, null, true);\n+                stream.headers(responseFrame, Callback.NOOP);\n+                serverLatch.countDown();\n+                return null;\n+            }\n+        }, h2 -> h2.setMaxConcurrentStreams(total));\n+\n+        Session session = newClient(new Session.Listener.Adapter());\n+\n+        CyclicBarrier barrier = new CyclicBarrier(threads);\n+        CountDownLatch clientLatch = new CountDownLatch(total);\n+        Promise<Stream> promise = new Promise.Adapter<Stream>()\n+        {\n+            @Override\n+            public void succeeded(Stream stream)\n+            {\n+                clientLatch.countDown();\n+            }\n+        };\n+        long start = System.nanoTime();\n+        IntStream.range(0, threads).forEach(i -> new Thread(() ->\n+        {\n+            try\n+            {\n+                barrier.await();\n+                IntStream.range(0, runs).forEach(j ->\n+                        IntStream.range(0, iterations).forEach(k ->\n+                        {\n+                            MetaData.Request request = newRequest(\"GET\", new HttpFields());\n+                            HeadersFrame requestFrame = new HeadersFrame(request, null, true);\n+                            session.newStream(requestFrame, promise, new Stream.Listener.Adapter());\n+//                            ((HTTP2Session)session).newStreamOld(requestFrame, promise, new Stream.Listener.Adapter());\n+                        }));\n+            }\n+            catch (Throwable x)\n+            {\n+                x.printStackTrace();\n+            }\n+        }).start());\n+        assertTrue(clientLatch.await(total, TimeUnit.MILLISECONDS), String.format(\"Missing streams on client: %d/%d\", clientLatch.getCount(), total));\n+        long elapsed = System.nanoTime() - start;\n+        System.err.println(\"elapsed = \" + elapsed);", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NjAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415676005", "bodyText": "ok", "author": "lorban", "createdAt": "2020-04-27T09:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyOTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTE0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415631140", "bodyText": "I think this test ends too early, as a lot of responses will still be in-flight to the client when the test ends and stop() is called.\nYou should probably add another latch in the client Stream.Listener to be sure that all responses arrived.", "author": "sbordet", "createdAt": "2020-04-27T08:51:58Z", "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/ConcurrentStreamCreationTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.MetaData;\n+import org.eclipse.jetty.http2.api.Session;\n+import org.eclipse.jetty.http2.api.Stream;\n+import org.eclipse.jetty.http2.api.server.ServerSessionListener;\n+import org.eclipse.jetty.http2.frames.HeadersFrame;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Promise;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConcurrentStreamCreationTest extends AbstractTest\n+{\n+    @Test\n+    public void testConcurrentStreamCreation() throws Exception\n+    {\n+        int threads = 64;\n+        int runs = 1;\n+        int iterations = 1024;\n+        int total = threads * runs * iterations;\n+        CountDownLatch serverLatch = new CountDownLatch(total);\n+        start(new ServerSessionListener.Adapter()\n+        {\n+            @Override\n+            public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n+            {\n+                MetaData.Response response = new MetaData.Response(HttpVersion.HTTP_2, HttpStatus.OK_200, new HttpFields());\n+                HeadersFrame responseFrame = new HeadersFrame(stream.getId(), response, null, true);\n+                stream.headers(responseFrame, Callback.NOOP);\n+                serverLatch.countDown();\n+                return null;\n+            }\n+        }, h2 -> h2.setMaxConcurrentStreams(total));\n+\n+        Session session = newClient(new Session.Listener.Adapter());\n+\n+        CyclicBarrier barrier = new CyclicBarrier(threads);\n+        CountDownLatch clientLatch = new CountDownLatch(total);\n+        Promise<Stream> promise = new Promise.Adapter<Stream>()\n+        {\n+            @Override\n+            public void succeeded(Stream stream)\n+            {\n+                clientLatch.countDown();\n+            }\n+        };\n+        long start = System.nanoTime();\n+        IntStream.range(0, threads).forEach(i -> new Thread(() ->\n+        {\n+            try\n+            {\n+                barrier.await();\n+                IntStream.range(0, runs).forEach(j ->\n+                        IntStream.range(0, iterations).forEach(k ->\n+                        {\n+                            MetaData.Request request = newRequest(\"GET\", new HttpFields());\n+                            HeadersFrame requestFrame = new HeadersFrame(request, null, true);\n+                            session.newStream(requestFrame, promise, new Stream.Listener.Adapter());\n+//                            ((HTTP2Session)session).newStreamOld(requestFrame, promise, new Stream.Listener.Adapter());\n+                        }));\n+            }\n+            catch (Throwable x)\n+            {\n+                x.printStackTrace();\n+            }\n+        }).start());\n+        assertTrue(clientLatch.await(total, TimeUnit.MILLISECONDS), String.format(\"Missing streams on client: %d/%d\", clientLatch.getCount(), total));\n+        long elapsed = System.nanoTime() - start;\n+        System.err.println(\"elapsed = \" + elapsed);\n+        assertTrue(serverLatch.await(total, TimeUnit.MILLISECONDS), String.format(\"Missing streams on server: %d/%d\", serverLatch.getCount(), total));", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3OTQ0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415679445", "bodyText": "ok", "author": "lorban", "createdAt": "2020-04-27T10:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzNzU0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415637545", "bodyText": "Remove extra line, and link the spec section. Also, finish the comment: \"Concurrent thread will only...\"\nI know it's my stuff and I left it incomplete, but please complete it \ud83d\ude03", "author": "sbordet", "createdAt": "2020-04-27T09:00:57Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4Njg5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415686894", "bodyText": "sure.", "author": "lorban", "createdAt": "2020-04-27T10:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzNzU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NTIyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415645228", "bodyText": "I would remove this constructor, as it is only used by the implementation. I would prefer to not expose it to applications.", "author": "sbordet", "createdAt": "2020-04-27T09:12:08Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/frames/PushPromiseFrame.java", "diffHunk": "@@ -26,6 +26,16 @@\n     private final int promisedStreamId;\n     private final MetaData metaData;\n \n+    public PushPromiseFrame(int streamId, MetaData metaData)\n+    {\n+        this(streamId, 0, metaData);\n+    }\n+\n+    public PushPromiseFrame(int promisedStreamId, PushPromiseFrame frame)\n+    {\n+        this(frame.getStreamId(), promisedStreamId, frame.getMetaData());\n+    }", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODUwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415688503", "bodyText": "sure.", "author": "lorban", "createdAt": "2020-04-27T10:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NjAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415646005", "bodyText": "If this constructor is only used by the implementation, remove it so it's not expose to applications.", "author": "sbordet", "createdAt": "2020-04-27T09:13:12Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/frames/HeadersFrame.java", "diffHunk": "@@ -41,6 +41,11 @@ public HeadersFrame(MetaData metaData, PriorityFrame priority, boolean endStream\n         this(0, metaData, priority, endStream);\n     }\n \n+    public HeadersFrame(int streamId, PriorityFrame priority, HeadersFrame other)\n+    {\n+        this(streamId, other.getMetaData(), priority, other.isEndStream());\n+    }\n+", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODkzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415688930", "bodyText": "Sure.", "author": "lorban", "createdAt": "2020-04-27T10:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NjIzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415646234", "bodyText": "Remove extra line.", "author": "sbordet", "createdAt": "2020-04-27T09:13:30Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = frame.getStreamId();\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PriorityFrame(streamId, frame);\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId = frame.getStreamId();\n+                if (streamId <= 0)\n+                {\n+                    synchronized (this)\n+                    {\n+                        streamId = localStreamIds.getAndAdd(2);\n+                        slots.offer(slot);\n+                    }\n+                    PriorityFrame priority = frame.getPriority();\n+                    priority = priority == null ? null : new PriorityFrame(streamId, priority);\n+                    frame = new HeadersFrame(streamId, priority, frame);\n+                }\n+                else\n+                {\n+                    synchronized (this)\n+                    {\n+                        slots.offer(slot);\n+                    }\n+                }\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void push(PushPromiseFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId;\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PushPromiseFrame(streamId, frame);\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void fillSlotWithNewLocalStream(Slot slot, Frame frame, Promise<Stream> promise, Stream.Listener listener, int streamId)\n+        {\n+            IStream stream = createLocalStream(streamId);\n+            stream.setListener(listener);\n+            slot.entry = new ControlEntry(frame, stream, new StreamPromiseCallback(promise, stream));\n+            flush();\n+        }\n+\n+        private void removeSlotAndFailPromise(Slot slot, Promise<Stream> promise, Throwable x)\n+        {\n+            synchronized (this)\n+            {\n+                slots.remove(slot);\n+            }\n+            flush();\n+            promise.failed(x);\n+        }\n+\n+        private void flush()\n+        {\n+            Thread thread = Thread.currentThread();\n+            boolean queued = false;\n+            while (true)\n+            {\n+                ControlEntry entry = null;\n+                synchronized (this)\n+                {\n+                    if (flushing != null && flushing != thread)\n+                        return;\n+                    flushing = thread;\n+\n+                    Slot slot = slots.peek();\n+                    if (slot != null)\n+                        entry = slot.entry;\n+                    if (entry == null)\n+                    {\n+                        flushing = null;\n+                        break;\n+                    }\n+                    slots.poll();\n+                }\n+                queued |= flusher.append(entry);\n+            }\n+            if (queued)\n+                flusher.iterate();\n+        }\n+\n+        private class Slot\n+        {\n+            private volatile ControlEntry entry;\n+        }\n+    }\n+", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MDM2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415690362", "bodyText": "ok", "author": "lorban", "createdAt": "2020-04-27T10:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0NjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2MDI0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415660240", "bodyText": "Can we find a better method name? It's not about filling, because it also flushes.\nHow about just createLocalStream(...)?", "author": "sbordet", "createdAt": "2020-04-27T09:33:50Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = frame.getStreamId();\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PriorityFrame(streamId, frame);\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId = frame.getStreamId();\n+                if (streamId <= 0)\n+                {\n+                    synchronized (this)\n+                    {\n+                        streamId = localStreamIds.getAndAdd(2);\n+                        slots.offer(slot);\n+                    }\n+                    PriorityFrame priority = frame.getPriority();\n+                    priority = priority == null ? null : new PriorityFrame(streamId, priority);\n+                    frame = new HeadersFrame(streamId, priority, frame);\n+                }\n+                else\n+                {\n+                    synchronized (this)\n+                    {\n+                        slots.offer(slot);\n+                    }\n+                }\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void push(PushPromiseFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId;\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PushPromiseFrame(streamId, frame);\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void fillSlotWithNewLocalStream(Slot slot, Frame frame, Promise<Stream> promise, Stream.Listener listener, int streamId)", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMDY4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415700687", "bodyText": "I renamed it to createLocalStream despite the fact that this name clashes with the enclosing class' similarly named method. Despite this, I still find that name better.", "author": "lorban", "createdAt": "2020-04-27T10:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2MDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2Mjc0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415662740", "bodyText": "I think this block of code above should be outside the try as the only method that throws is fillSlot....\nPerhaps with the introduction of newSlot() this becomes cleaner?", "author": "sbordet", "createdAt": "2020-04-27T09:37:47Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = frame.getStreamId();\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PriorityFrame(streamId, frame);\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId = frame.getStreamId();\n+                if (streamId <= 0)\n+                {\n+                    synchronized (this)\n+                    {\n+                        streamId = localStreamIds.getAndAdd(2);\n+                        slots.offer(slot);\n+                    }\n+                    PriorityFrame priority = frame.getPriority();\n+                    priority = priority == null ? null : new PriorityFrame(streamId, priority);\n+                    frame = new HeadersFrame(streamId, priority, frame);\n+                }\n+                else\n+                {\n+                    synchronized (this)\n+                    {\n+                        slots.offer(slot);\n+                    }\n+                }", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNTE5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415705195", "bodyText": "I tried to factor out what was common between priority, newStream and push. Hopefully that'll make those methods more readable.", "author": "lorban", "createdAt": "2020-04-27T10:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2Mjc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2MzEyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415663121", "bodyText": "Remove if only used by the implementation.", "author": "sbordet", "createdAt": "2020-04-27T09:38:19Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/frames/PriorityFrame.java", "diffHunk": "@@ -41,6 +41,11 @@ public PriorityFrame(int streamId, int parentStreamId, int weight, boolean exclu\n         this.exclusive = exclusive;\n     }\n \n+    public PriorityFrame(int streamId, PriorityFrame other)\n+    {\n+        this(streamId, other.getParentStreamId(), other.getWeight(), other.isExclusive());\n+    }\n+", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MTIyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415691225", "bodyText": "ok", "author": "lorban", "createdAt": "2020-04-27T10:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2MzEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2Mzg5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415663899", "bodyText": "\"crescent\"?", "author": "gregw", "createdAt": "2020-04-27T09:39:28Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NTI2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415785265", "bodyText": "replaced with stream ids are monotonically increasing", "author": "lorban", "createdAt": "2020-04-27T12:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2Mzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2NDI2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415664267", "bodyText": "missing end of sentence?", "author": "gregw", "createdAt": "2020-04-27T09:40:02Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4MjU4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415782583", "bodyText": "fixed.", "author": "lorban", "createdAt": "2020-04-27T12:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2NDI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MTM3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415671377", "bodyText": "So if another thread is just about the set the entry, then it will immediately call flush afterwards. Because flush grabs the lock, it will either be blocked while this thread exits from here, or this thread will have completed.... either way, it will be the other thread that continues flushing.\nMaybe some comments to well explain that.", "author": "gregw", "createdAt": "2020-04-27T09:50:37Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = frame.getStreamId();\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PriorityFrame(streamId, frame);\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId = frame.getStreamId();\n+                if (streamId <= 0)\n+                {\n+                    synchronized (this)\n+                    {\n+                        streamId = localStreamIds.getAndAdd(2);\n+                        slots.offer(slot);\n+                    }\n+                    PriorityFrame priority = frame.getPriority();\n+                    priority = priority == null ? null : new PriorityFrame(streamId, priority);\n+                    frame = new HeadersFrame(streamId, priority, frame);\n+                }\n+                else\n+                {\n+                    synchronized (this)\n+                    {\n+                        slots.offer(slot);\n+                    }\n+                }\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void push(PushPromiseFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId;\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PushPromiseFrame(streamId, frame);\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void fillSlotWithNewLocalStream(Slot slot, Frame frame, Promise<Stream> promise, Stream.Listener listener, int streamId)\n+        {\n+            IStream stream = createLocalStream(streamId);\n+            stream.setListener(listener);\n+            slot.entry = new ControlEntry(frame, stream, new StreamPromiseCallback(promise, stream));\n+            flush();\n+        }\n+\n+        private void removeSlotAndFailPromise(Slot slot, Promise<Stream> promise, Throwable x)\n+        {\n+            synchronized (this)\n+            {\n+                slots.remove(slot);\n+            }\n+            flush();\n+            promise.failed(x);\n+        }\n+\n+        private void flush()\n+        {\n+            Thread thread = Thread.currentThread();\n+            boolean queued = false;\n+            while (true)\n+            {\n+                ControlEntry entry = null;\n+                synchronized (this)\n+                {\n+                    if (flushing != null && flushing != thread)\n+                        return;\n+                    flushing = thread;\n+\n+                    Slot slot = slots.peek();\n+                    if (slot != null)\n+                        entry = slot.entry;\n+                    if (entry == null)\n+                    {\n+                        flushing = null;", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mjk3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415792976", "bodyText": "you're right, I added a comment describing that mechanism.", "author": "lorban", "createdAt": "2020-04-27T13:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDU5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415674599", "bodyText": "I very much prefer the style of fields starting with _ as it makes viewing code outside of an IDE so much better.   Jetty only stopped doing this after a hostile takeover of the style by @sbordet and @joakime :)\nAnyway, why do we need flushing to be a Thread?  Can't it just be a boolean as it is only changed inside the sync block?   In fact do we need it at all?  Any thread flushing will hold the lock until the queue is empty or it sees a null entry.   Any other thread calling flush may as well just poll rather than checking flushing?", "author": "gregw", "createdAt": "2020-04-27T09:55:26Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1647,4 +1589,149 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are strictly crescent.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     *\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = frame.getStreamId();\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PriorityFrame(streamId, frame);\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId = frame.getStreamId();\n+                if (streamId <= 0)\n+                {\n+                    synchronized (this)\n+                    {\n+                        streamId = localStreamIds.getAndAdd(2);\n+                        slots.offer(slot);\n+                    }\n+                    PriorityFrame priority = frame.getPriority();\n+                    priority = priority == null ? null : new PriorityFrame(streamId, priority);\n+                    frame = new HeadersFrame(streamId, priority, frame);\n+                }\n+                else\n+                {\n+                    synchronized (this)\n+                    {\n+                        slots.offer(slot);\n+                    }\n+                }\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void push(PushPromiseFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            try\n+            {\n+                int streamId;\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+                frame = new PushPromiseFrame(streamId, frame);\n+\n+                fillSlotWithNewLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                removeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void fillSlotWithNewLocalStream(Slot slot, Frame frame, Promise<Stream> promise, Stream.Listener listener, int streamId)\n+        {\n+            IStream stream = createLocalStream(streamId);\n+            stream.setListener(listener);\n+            slot.entry = new ControlEntry(frame, stream, new StreamPromiseCallback(promise, stream));\n+            flush();\n+        }\n+\n+        private void removeSlotAndFailPromise(Slot slot, Promise<Stream> promise, Throwable x)\n+        {\n+            synchronized (this)\n+            {\n+                slots.remove(slot);\n+            }\n+            flush();\n+            promise.failed(x);\n+        }\n+\n+        private void flush()\n+        {\n+            Thread thread = Thread.currentThread();\n+            boolean queued = false;\n+            while (true)\n+            {\n+                ControlEntry entry = null;\n+                synchronized (this)\n+                {\n+                    if (flushing != null && flushing != thread)", "originalCommit": "4d4f6002948820a60e0a6489816584b87dfcacdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTA1OA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415801058", "bodyText": "Even better: using an AtomicBoolean to track the flushing status, flush-skipping threads can bail out of that method without even acquiring the lock.", "author": "lorban", "createdAt": "2020-04-27T13:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMjQ5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415802491", "bodyText": "I don't think it works. The exit condition must check the queue and reset flushing atomically.", "author": "sbordet", "createdAt": "2020-04-27T13:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5Mjk4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415892986", "bodyText": "@sbordet You're right; and since the check happens within the while loop, we must be able to discriminate between the first time the thread runs the loop and another thread noticing that the flushing in is progress. Hence, a ternary state is needed so the thread reference does that job. I'll revert my AtomicBoolean change.", "author": "lorban", "createdAt": "2020-04-27T15:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxMzYyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415713621", "bodyText": "Ah, no. The \"close\" event happens before notifying the listener of the response.\nSo this really needs to be a response latch, and you should override onHeaders() and check that you got a response code 200, then countDown the response latch.", "author": "sbordet", "createdAt": "2020-04-27T10:56:26Z", "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/ConcurrentStreamCreationTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.MetaData;\n+import org.eclipse.jetty.http2.api.Session;\n+import org.eclipse.jetty.http2.api.Stream;\n+import org.eclipse.jetty.http2.api.server.ServerSessionListener;\n+import org.eclipse.jetty.http2.frames.HeadersFrame;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Promise;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConcurrentStreamCreationTest extends AbstractTest\n+{\n+    @Test\n+    public void testConcurrentStreamCreation() throws Exception\n+    {\n+        int threads = 64;\n+        int runs = 1;\n+        int iterations = 1024;\n+        int total = threads * runs * iterations;\n+        CountDownLatch serverLatch = new CountDownLatch(total);\n+        start(new ServerSessionListener.Adapter()\n+        {\n+            @Override\n+            public Stream.Listener onNewStream(Stream stream, HeadersFrame frame)\n+            {\n+                MetaData.Response response = new MetaData.Response(HttpVersion.HTTP_2, HttpStatus.OK_200, new HttpFields());\n+                HeadersFrame responseFrame = new HeadersFrame(stream.getId(), response, null, true);\n+                stream.headers(responseFrame, Callback.NOOP);\n+                serverLatch.countDown();\n+                return null;\n+            }\n+        }, h2 -> h2.setMaxConcurrentStreams(total));\n+\n+        Session session = newClient(new Session.Listener.Adapter());\n+\n+        CyclicBarrier barrier = new CyclicBarrier(threads);\n+        CountDownLatch clientLatch = new CountDownLatch(total);\n+        CountDownLatch clientStreamLatch = new CountDownLatch(runs);\n+        Promise<Stream> promise = new Promise.Adapter<Stream>()\n+        {\n+            @Override\n+            public void succeeded(Stream stream)\n+            {\n+                clientLatch.countDown();\n+            }\n+        };\n+        IntStream.range(0, threads).forEach(i -> new Thread(() ->\n+        {\n+            try\n+            {\n+                barrier.await();\n+                IntStream.range(0, runs).forEach(j ->\n+                        IntStream.range(0, iterations).forEach(k ->\n+                        {\n+                            MetaData.Request request = newRequest(\"GET\", new HttpFields());\n+                            HeadersFrame requestFrame = new HeadersFrame(request, null, true);\n+                            session.newStream(requestFrame, promise, new Stream.Listener.Adapter()\n+                            {\n+                                @Override\n+                                public void onClosed(Stream stream)\n+                                {\n+                                    clientStreamLatch.countDown();", "originalCommit": "3048f3fafc26ad606cf4061b670b341535fc66bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4NDY2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r415884669", "bodyText": "Ok, done.", "author": "lorban", "createdAt": "2020-04-27T14:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxMzYyMQ=="}], "type": "inlineReview"}, {"oid": "3aab1f72ae9bf9d4a1ab7bbe2292e22b96122dd9", "url": "https://github.com/eclipse/jetty.project/commit/3aab1f72ae9bf9d4a1ab7bbe2292e22b96122dd9", "message": "review changes #5\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-27T15:06:37Z", "type": "forcePushed"}, {"oid": "a6cf2c116a818f3499d88b1b7503dba57f49b5ac", "url": "https://github.com/eclipse/jetty.project/commit/a6cf2c116a818f3499d88b1b7503dba57f49b5ac", "message": "review changes #5\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-28T09:17:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NzU0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r417187547", "bodyText": "There is a mixed style in this look that makes it hard to read.  I also think that perhaps there is a bug in the different handling between peeking a null slot (no more slots) and seeing a slot with a null entry (another thread will come and finish flushing).   Perhaps the loop should be:\n            while (true)\n            {\n                ControlEntry entry = null;\n                synchronized (this)\n                {\n                    if (flushing == null)\n                        flushing = thread;\n                    else if (flushing != thread)\n                        return; // another thread is flushing\n\n                    Slot slot = slots.peek();\n                    if (slot == null)\n                        break; // No more slots, so we may iterate on the flusher\n                        \n                    entry = slot.entry;\n                    if (entry == null)\n                    {\n                        flushing = null;\n                        return; // Another thread will finish the flush\n                    }\n                    slots.poll();\n                }\n                queued |= flusher.append(entry);\n            }\n            if (queued)\n                flusher.iterate();\n        }", "author": "gregw", "createdAt": "2020-04-29T09:36:44Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Session.java", "diffHunk": "@@ -1648,4 +1590,155 @@ private void complete()\n             terminate(failure);\n         }\n     }\n+\n+    /**\n+     * SPEC: It is required that stream ids are monotonically increasing.\n+     * Here we use a queue to atomically create the stream id and\n+     * claim the slot in the queue. Concurrent threads will only\n+     * flush up to the slot with a non-null entry to make sure\n+     * frames are sent strictly in their stream id order.\n+     * See https://tools.ietf.org/html/rfc7540#section-5.1.1.\n+     */\n+    private class StreamCreator\n+    {\n+        private final Queue<Slot> slots = new ArrayDeque<>();\n+        private Thread flushing;\n+\n+        private int priority(PriorityFrame frame, Callback callback)\n+        {\n+            Slot slot = new Slot();\n+            int currentStreamId = frame.getStreamId();\n+            int streamId = reserveSlot(slot, currentStreamId);\n+\n+            if (currentStreamId <= 0)\n+                frame = new PriorityFrame(streamId, frame.getParentStreamId(), frame.getWeight(), frame.isExclusive());\n+\n+            slot.entry = new ControlEntry(frame, null, callback);\n+            flush();\n+            return streamId;\n+        }\n+\n+        private void newStream(HeadersFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            int currentStreamId = frame.getStreamId();\n+            int streamId = reserveSlot(slot, currentStreamId);\n+\n+            if (currentStreamId <= 0)\n+            {\n+                PriorityFrame priority = frame.getPriority();\n+                priority = priority == null ? null : new PriorityFrame(streamId, priority.getParentStreamId(), priority.getWeight(), priority.isExclusive());\n+                frame = new HeadersFrame(streamId, frame.getMetaData(), priority, frame.isEndStream());\n+            }\n+\n+            try\n+            {\n+                createLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                freeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private void push(PushPromiseFrame frame, Promise<Stream> promise, Stream.Listener listener)\n+        {\n+            Slot slot = new Slot();\n+            int streamId = reserveSlot(slot, 0);\n+            frame = new PushPromiseFrame(frame.getStreamId(), streamId, frame.getMetaData());\n+\n+            try\n+            {\n+                createLocalStream(slot, frame, promise, listener, streamId);\n+            }\n+            catch (Throwable x)\n+            {\n+                freeSlotAndFailPromise(slot, promise, x);\n+            }\n+        }\n+\n+        private int reserveSlot(Slot slot, int streamId)\n+        {\n+            if (streamId <= 0)\n+            {\n+                synchronized (this)\n+                {\n+                    streamId = localStreamIds.getAndAdd(2);\n+                    slots.offer(slot);\n+                }\n+            }\n+            else\n+            {\n+                synchronized (this)\n+                {\n+                    slots.offer(slot);\n+                }\n+            }\n+            return streamId;\n+        }\n+\n+        private void createLocalStream(Slot slot, Frame frame, Promise<Stream> promise, Stream.Listener listener, int streamId)\n+        {\n+            IStream stream = HTTP2Session.this.createLocalStream(streamId);\n+            stream.setListener(listener);\n+            slot.entry = new ControlEntry(frame, stream, new StreamPromiseCallback(promise, stream));\n+            flush();\n+        }\n+\n+        private void freeSlotAndFailPromise(Slot slot, Promise<Stream> promise, Throwable x)\n+        {\n+            synchronized (this)\n+            {\n+                slots.remove(slot);\n+            }\n+            flush();\n+            promise.failed(x);\n+        }\n+\n+        /**\n+         * Flush goes over the entries of the slots queue to flush the entries,\n+         * until either one of the following two conditions is true:\n+         *  - The queue is empty.\n+         *  - It reaches a slot with a null entry.\n+         *  When a slot with a null entry is encountered, this means a concurrent thread reserved a slot\n+         *  but hasn't set its entry yet. Since entries must be flushed in order, the thread encountering\n+         *  the null entry must bail out and it is up to the concurrent thread to finish up flushing.\n+         *  Note that only one thread can flush at any one time, if two threads happen to call flush\n+         *  concurrently, one will do the work while the other will bail out, so it is safe that all\n+         *  threads call flush after they're done reserving a slot and setting the entry.\n+         */\n+        private void flush()\n+        {\n+            Thread thread = Thread.currentThread();\n+            boolean queued = false;\n+            while (true)\n+            {\n+                ControlEntry entry = null;\n+                synchronized (this)\n+                {\n+                    if (flushing != null && flushing != thread)\n+                        return;\n+                    flushing = thread;\n+\n+                    Slot slot = slots.peek();\n+                    if (slot != null)\n+                        entry = slot.entry;\n+                    if (entry == null)\n+                    {\n+                        flushing = null;\n+                        break;\n+                    }\n+                    slots.poll();\n+                }\n+                queued |= flusher.append(entry);\n+            }\n+            if (queued)\n+                flusher.iterate();\n+        }", "originalCommit": "a6cf2c116a818f3499d88b1b7503dba57f49b5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzUwNA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r417203504", "bodyText": "I agree on the intent of adding a comment about why we exit the loop.\nHowever, the case where slot==null must set flushing=null before breaking.\nAnd the case entry==null must break, not return, to iterate over previous slots that may have been queued to flush.", "author": "sbordet", "createdAt": "2020-04-29T10:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NzU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwNDI3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4803#discussion_r417204270", "bodyText": "I like the extra comments explaining the reasons for exiting the loop and the fact that the entry variable doesn't have to be initialized to null (despite the fact that your snippet still initializes it). Let me update the PR with those changes.", "author": "lorban", "createdAt": "2020-04-29T10:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NzU0Nw=="}], "type": "inlineReview"}, {"oid": "69001d3360b34b78f1738cdf2f7690dff434d082", "url": "https://github.com/eclipse/jetty.project/commit/69001d3360b34b78f1738cdf2f7690dff434d082", "message": "review changes #6\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-29T10:24:41Z", "type": "forcePushed"}, {"oid": "b80706cf5929b381c1d4dbbc9fcda519d34820b7", "url": "https://github.com/eclipse/jetty.project/commit/b80706cf5929b381c1d4dbbc9fcda519d34820b7", "message": "review changes #6\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-29T10:26:11Z", "type": "forcePushed"}, {"oid": "6729a6f68907eeaa6e30919e6a1b1341ac04bf31", "url": "https://github.com/eclipse/jetty.project/commit/6729a6f68907eeaa6e30919e6a1b1341ac04bf31", "message": "Solve lock contention creating HTTP2 streams (#2188) while fixing race condition that breaks http channels recycling (#4695)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-29T12:25:51Z", "type": "commit"}, {"oid": "6729a6f68907eeaa6e30919e6a1b1341ac04bf31", "url": "https://github.com/eclipse/jetty.project/commit/6729a6f68907eeaa6e30919e6a1b1341ac04bf31", "message": "Solve lock contention creating HTTP2 streams (#2188) while fixing race condition that breaks http channels recycling (#4695)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-29T12:25:51Z", "type": "forcePushed"}]}