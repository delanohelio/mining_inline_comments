{"pr_number": 4519, "pr_title": "Composable connection factories", "pr_createdAt": "2020-01-24T17:46:37Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4519", "timeline": [{"oid": "0a27e73e0d4b11758bc545dd12d2d48ad60a30f9", "url": "https://github.com/eclipse/jetty.project/commit/0a27e73e0d4b11758bc545dd12d2d48ad60a30f9", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T07:54:23Z", "type": "forcePushed"}, {"oid": "aad0223277ecab7eb29d28782e4fa629197ed26b", "url": "https://github.com/eclipse/jetty.project/commit/aad0223277ecab7eb29d28782e4fa629197ed26b", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T07:55:26Z", "type": "forcePushed"}, {"oid": "1c48f7bc72659479e584b1621e0bb4c3085e1db7", "url": "https://github.com/eclipse/jetty.project/commit/1c48f7bc72659479e584b1621e0bb4c3085e1db7", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T09:14:18Z", "type": "forcePushed"}, {"oid": "b78249584055f218b9239d1beb2bd1219df16587", "url": "https://github.com/eclipse/jetty.project/commit/b78249584055f218b9239d1beb2bd1219df16587", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T09:25:06Z", "type": "forcePushed"}, {"oid": "b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "url": "https://github.com/eclipse/jetty.project/commit/b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T09:52:23Z", "type": "forcePushed"}, {"oid": "0f11755d945cd7669fbcc687b06a920d7d076faf", "url": "https://github.com/eclipse/jetty.project/commit/0f11755d945cd7669fbcc687b06a920d7d076faf", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T11:14:32Z", "type": "forcePushed"}, {"oid": "37009e5f1250021fbfe10058c54dcacd47c0c340", "url": "https://github.com/eclipse/jetty.project/commit/37009e5f1250021fbfe10058c54dcacd47c0c340", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:15:57Z", "type": "forcePushed"}, {"oid": "8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "url": "https://github.com/eclipse/jetty.project/commit/8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:19:39Z", "type": "forcePushed"}, {"oid": "0f3571591d917f43e8602533c69d20afb66478bb", "url": "https://github.com/eclipse/jetty.project/commit/0f3571591d917f43e8602533c69d20afb66478bb", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:21:10Z", "type": "forcePushed"}, {"oid": "7a4802e013b6393f39766bdd94bd182efe2a840e", "url": "https://github.com/eclipse/jetty.project/commit/7a4802e013b6393f39766bdd94bd182efe2a840e", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:30:43Z", "type": "forcePushed"}, {"oid": "25934950dc51eae678f2538937175bc888f436ae", "url": "https://github.com/eclipse/jetty.project/commit/25934950dc51eae678f2538937175bc888f436ae", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:33:30Z", "type": "forcePushed"}, {"oid": "309f3cc6d9ffab47137be45f4f11d8146aee3a5d", "url": "https://github.com/eclipse/jetty.project/commit/309f3cc6d9ffab47137be45f4f11d8146aee3a5d", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T12:54:47Z", "type": "forcePushed"}, {"oid": "0f158f7ca2fb44f3048c5e72677f13e212c507c0", "url": "https://github.com/eclipse/jetty.project/commit/0f158f7ca2fb44f3048c5e72677f13e212c507c0", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T16:08:11Z", "type": "forcePushed"}, {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343", "url": "https://github.com/eclipse/jetty.project/commit/268c42a0656a0110777d870ad7715d4b68c2a343", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-27T16:36:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NjU5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371656599", "bodyText": "Breaking change, can you revert?", "author": "sbordet", "createdAt": "2020-01-28T08:15:29Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/HttpClientProxyProtocolTest.java", "diffHunk": "@@ -173,8 +174,8 @@ public void testClientProxyProtocolV2WithVectors() throws Exception\n             protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws IOException\n             {\n                 EndPoint endPoint = jettyRequest.getHttpChannel().getEndPoint();\n-                assertTrue(endPoint instanceof ProxyConnectionFactory.ProxyEndPoint);\n-                ProxyConnectionFactory.ProxyEndPoint proxyEndPoint = (ProxyConnectionFactory.ProxyEndPoint)endPoint;\n+                assertTrue(endPoint instanceof ProxyEndPoint);\n+                ProxyEndPoint proxyEndPoint = (ProxyEndPoint)endPoint;", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNjgyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371836820", "bodyText": "Yes. Next push will have this class back where it originally was.", "author": "lorban", "createdAt": "2020-01-28T14:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NjU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NzA1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657056", "bodyText": "I was thinking DetectorConnectionFactory as a better name?", "author": "sbordet", "createdAt": "2020-01-28T08:16:40Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNzM5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371837394", "bodyText": "I'm okay with your proposal, let me rename this class.", "author": "lorban", "createdAt": "2020-01-28T14:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzc5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657797", "bodyText": "Since AbstractConnectionFactory is-a ContainerLifeCycle, you don't want to manage the lifecycle directly in the way above.\nYou just add the children as beans in the constructor, and ContainerLifeCycle will take care of starting and stopping them.", "author": "sbordet", "createdAt": "2020-01-28T08:18:48Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzMzQ1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371833452", "bodyText": "That makes sense, let me modify this, thanks!", "author": "lorban", "createdAt": "2020-01-28T14:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzg3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657871", "bodyText": "Ditto above.", "author": "sbordet", "createdAt": "2020-01-28T08:18:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception\n+    {\n+        super.doStop();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).stop();\n+        }", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzMzUyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371833525", "bodyText": "Ditto too.", "author": "lorban", "createdAt": "2020-01-28T14:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MDI2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371660267", "bodyText": "Use inputBufferSize from AbstractConnectionFactory. Directness could be hardcoded (to true).", "author": "sbordet", "createdAt": "2020-01-28T08:25:04Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception\n+    {\n+        super.doStop();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).stop();\n+        }\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        ConnectionFactory nextRecognizedConnectionFactory = getRecognizedConnectionFactory(connector, endPoint);\n+        ConnectionFactory nextNotRecognizedConnectionFactory = getNotRecognizedConnectionFactory(connector, endPoint);\n+        LOG.debug(\"Upgrade topology: from {} to {} on recognition, {} on non-recognition\", getProtocol(), nextRecognizedConnectionFactory.getProtocol(), nextNotRecognizedConnectionFactory.getProtocol());\n+        return configure(new OptionalConnection(endPoint, connector, _sensingConnectionFactories, nextRecognizedConnectionFactory, nextNotRecognizedConnectionFactory), connector, endPoint);\n+    }\n+\n+    protected ConnectionFactory getRecognizedConnectionFactory(Connector connector, EndPoint endPoint)\n+    {\n+        String nextProtocol = _nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocol = SensingConnectionFactory.findNextProtocol(connector, getProtocol());\n+        if (nextProtocol == null)\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        return connector.getConnectionFactory(nextProtocol);\n+    }\n+\n+    protected ConnectionFactory getNotRecognizedConnectionFactory(Connector connector, EndPoint endPoint)\n+    {\n+        return getRecognizedConnectionFactory(connector, endPoint);\n+    }\n+\n+    static class OptionalConnection extends AbstractConnection implements Connection.UpgradeFrom\n+    {\n+        private final Connector _connector;\n+        private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+        private final ConnectionFactory _nextRecognizedConnectionFactory;\n+        private final ConnectionFactory _nextNotRecognizedConnectionFactory;\n+        private final ByteBuffer _buffer;\n+\n+        protected OptionalConnection(EndPoint endp, Connector connector, List<SensingConnectionFactory> sensingConnectionFactories, ConnectionFactory nextRecognizedConnectionFactory, ConnectionFactory nextNotRecognizedConnectionFactory)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _sensingConnectionFactories = sensingConnectionFactories;\n+            _nextRecognizedConnectionFactory = nextRecognizedConnectionFactory;\n+            _nextNotRecognizedConnectionFactory = nextNotRecognizedConnectionFactory;\n+            _buffer = connector.getByteBufferPool().acquire(1024, true); // TODO make the buffer size & directility configurable", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4MjI1OA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371882258", "bodyText": "Thanks for the pointer, I'll change the code accordingly.", "author": "lorban", "createdAt": "2020-01-28T15:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MDI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MTk0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371661942", "bodyText": "Perhaps this interface can be embedded as ConnectionFactory.Detecting?", "author": "sbordet", "createdAt": "2020-01-28T08:29:42Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/SensingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Iterator;\n+\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+public interface SensingConnectionFactory extends ConnectionFactory", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0MDQ3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371840473", "bodyText": "While it itself implements ConnectionFactory? Why not although maybe a bit surprising.", "author": "lorban", "createdAt": "2020-01-28T14:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjEwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371662100", "bodyText": "Remove this method, just keep the one from ConnectionFactory.", "author": "sbordet", "createdAt": "2020-01-28T08:30:06Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/SensingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Iterator;\n+\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+public interface SensingConnectionFactory extends ConnectionFactory\n+{\n+    enum SensingOutcome\n+    {\n+        RECOGNIZED,\n+        NOT_RECOGNIZED,\n+        NEED_MORE_BYTES\n+    }\n+\n+    SensingOutcome sense(ByteBuffer buffer);\n+\n+    Connection newConnection(Connector connector, EndPoint endPoint, ConnectionFactory next);", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4NDA4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371884084", "bodyText": "I agree that a second newConnection is rather confusing, but there is still the need for a mechanism to pass the ConnectionFactory to upgrade to when detection succeeds.\nI'm going to change this in my next push, but we'll probably need to discuss this more in depth.", "author": "lorban", "createdAt": "2020-01-28T15:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjIyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371662224", "bodyText": "Do we really need this?", "author": "sbordet", "createdAt": "2020-01-28T08:30:27Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/TerminatingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,96 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+/**\n+ * A connection factory that always closes the connection.\n+ */\n+public class TerminatingConnectionFactory extends AbstractConnectionFactory", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNDgzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371834838", "bodyText": "No, after our discussion I checked and I can confirm that it is possible to get rid of this connection factory and replace it with a simpler callback mechanism. My next push will have this change.", "author": "lorban", "createdAt": "2020-01-28T14:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2Mzc2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371663768", "bodyText": "No helpers for tests, if possible.\nThe tests become hard to read because you have to jump to other source files, and they may introduce bugs, and we don't want to write a test framework - tests should be as simple as possible.", "author": "sbordet", "createdAt": "2020-01-28T08:34:44Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ProxyTestingHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jetty.server.handler.ErrorHandler;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+public class ProxyTestingHelper", "originalCommit": "268c42a0656a0110777d870ad7715d4b68c2a343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNjAyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371836022", "bodyText": "Fair. Let me find a way to get rid of it.", "author": "lorban", "createdAt": "2020-01-28T14:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2Mzc2OA=="}], "type": "inlineReview"}, {"oid": "f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "url": "https://github.com/eclipse/jetty.project/commit/f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-28T16:04:41Z", "type": "forcePushed"}, {"oid": "420620749673d54917e9850c24ab86cfae133851", "url": "https://github.com/eclipse/jetty.project/commit/420620749673d54917e9850c24ab86cfae133851", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-28T16:08:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzOTUyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371939525", "bodyText": "Why have this Proxy-or-TLS factory?\nIsn't the idea of composable factories to have a ProxyFactory and a TlsFactory and one or the other will recognise the bytes.", "author": "gregw", "createdAt": "2020-01-28T17:12:04Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalProxySslConnectionFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+\n+/**\n+ * <p>A ConnectionFactory whose connections detect whether the first bytes are\n+ * proxy or TLS bytes and upgrades to either a TLS connection or to another configurable\n+ * connection.</p>\n+ */\n+public class OptionalProxySslConnectionFactory extends DetectorConnectionFactory", "originalCommit": "420620749673d54917e9850c24ab86cfae133851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzNjc3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372236772", "bodyText": "You're right, configuring the connection factories as proxy, optional ssl, http has the exact same effect. Let me get rid of this class.", "author": "lorban", "createdAt": "2020-01-29T08:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzOTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTg4MA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372289880", "bodyText": "I find it a little surprising that we still need OptionalSslConnectionFactory and ProxyConnectionFactory as concrete instances of DetectorConnectionFactory.  If they are needed for backwards compatibility then they should be deprecated.\nI was expecting to see DetectorConnectionFactory directly used, potentially as part of initialising an AbstractConnector that is given some Detecting factories with no way to select between them.\nIs it true that the following are all valid options:\n\nSSL or ProxyV1 or ProxyV2\n(ProxyV1 or ProxyV2) then SSL\n(ProxyV1 or ProxyV2) then optional SSL\nSSL then (ProxyV1 or ProxyV2)\noptional SSL then (ProxyV1 or ProxyV2)", "author": "gregw", "createdAt": "2020-01-29T10:04:21Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalSslConnectionFactory.java", "diffHunk": "@@ -35,191 +31,76 @@\n  * TLS bytes and upgrades to either a TLS connection or to another configurable\n  * connection.</p>\n  */\n-public class OptionalSslConnectionFactory extends AbstractConnectionFactory\n+public class OptionalSslConnectionFactory extends DetectorConnectionFactory", "originalCommit": "fc1fabddfdd2342389b3c6b9c0519f5fe94c9ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMyMzcwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372323706", "bodyText": "The last 2 I would say that don't make much sense, as you want proxy to always be the outermost one - although I guess it should be possible to configure DetectorConnectionFactory in such way if one needs to.", "author": "sbordet", "createdAt": "2020-01-29T11:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MDYxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372360613", "bodyText": "@gregw what you're proposing certainly is possible, it all depends upon the contract we want to have.\nGiven this comment and the one below, I think the three of us should meet to get that sorted.", "author": "lorban", "createdAt": "2020-01-29T12:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTkyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372289924", "bodyText": "Could this behaviour be moved out of this factory into a BadHttpRequestConnectionFactory, so tht the normal detecting logic would choose between an SSL factory and a factory that responds to GE with a 400?", "author": "gregw", "createdAt": "2020-01-29T10:04:27Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalSslConnectionFactory.java", "diffHunk": "@@ -35,191 +31,76 @@\n  * TLS bytes and upgrades to either a TLS connection or to another configurable\n  * connection.</p>\n  */\n-public class OptionalSslConnectionFactory extends AbstractConnectionFactory\n+public class OptionalSslConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(OptionalSslConnection.class);\n-    private static final int TLS_ALERT_FRAME_TYPE = 0x15;\n-    private static final int TLS_HANDSHAKE_FRAME_TYPE = 0x16;\n-    private static final int TLS_MAJOR_VERSION = 3;\n+    private static final Logger LOG = Log.getLogger(OptionalSslConnectionFactory.class);\n \n-    private final SslConnectionFactory sslConnectionFactory;\n-    private final String otherProtocol;\n+    private final boolean _terminateWhenNotRecognized;\n \n     /**\n      * <p>Creates a new ConnectionFactory whose connections can upgrade to TLS or another protocol.</p>\n-     * <p>If {@code otherProtocol} is {@code null}, and the first bytes are not TLS, then\n-     * {@link #otherProtocol(ByteBuffer, EndPoint)} is called.</p>\n      *\n      * @param sslConnectionFactory The SslConnectionFactory to use if the first bytes are TLS\n-     * @param otherProtocol the protocol of the ConnectionFactory to use if the first bytes are not TLS,\n+     * @param nextProtocol the protocol of the ConnectionFactory to use if the first bytes are not TLS,\n      * or null to explicitly handle the non-TLS case\n      */\n-    public OptionalSslConnectionFactory(SslConnectionFactory sslConnectionFactory, String otherProtocol)\n+    public OptionalSslConnectionFactory(SslConnectionFactory sslConnectionFactory, String nextProtocol)\n     {\n-        super(\"ssl|other\");\n-        this.sslConnectionFactory = sslConnectionFactory;\n-        this.otherProtocol = otherProtocol;\n-    }\n-\n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endPoint)\n-    {\n-        return configure(new OptionalSslConnection(endPoint, connector), connector, endPoint);\n-    }\n-\n-    /**\n-     * @param buffer The buffer with the first bytes of the connection\n-     * @return whether the bytes seem TLS bytes\n-     */\n-    protected boolean seemsTLS(ByteBuffer buffer)\n-    {\n-        int tlsFrameType = buffer.get(0) & 0xFF;\n-        int tlsMajorVersion = buffer.get(1) & 0xFF;\n-        return (tlsFrameType == TLS_HANDSHAKE_FRAME_TYPE || tlsFrameType == TLS_ALERT_FRAME_TYPE) && tlsMajorVersion == TLS_MAJOR_VERSION;\n+        super(nextProtocol, sslConnectionFactory);\n+        _terminateWhenNotRecognized = nextProtocol == null;\n     }\n \n     /**\n-     * <p>Callback method invoked when {@code otherProtocol} is {@code null}\n-     * and the first bytes are not TLS.</p>\n+     * <p>Callback method invoked when the detected bytes are not TLS.</p>\n      * <p>This typically happens when a client is trying to connect to a TLS\n      * port using the {@code http} scheme (and not the {@code https} scheme).</p>\n      *\n      * @param buffer The buffer with the first bytes of the connection\n      * @param endPoint The connection EndPoint object\n-     * @see #seemsTLS(ByteBuffer)\n+     * @param connector The connector object\n      */\n-    protected void otherProtocol(ByteBuffer buffer, EndPoint endPoint)\n+    protected void nextProtocol(ByteBuffer buffer, EndPoint endPoint, Connector connector)\n     {\n-        // There are always at least 2 bytes.\n-        int byte1 = buffer.get(0) & 0xFF;\n-        int byte2 = buffer.get(1) & 0xFF;\n-        if (byte1 == 'G' && byte2 == 'E')\n+        if (!_terminateWhenNotRecognized)\n         {\n-            // Plain text HTTP to an HTTPS port,\n-            // write a minimal response.\n-            String body =\n-                \"<!DOCTYPE html>\\r\\n\" +\n-                    \"<html>\\r\\n\" +\n-                    \"<head><title>Bad Request</title></head>\\r\\n\" +\n-                    \"<body>\" +\n-                    \"<h1>Bad Request</h1>\" +\n-                    \"<p>HTTP request to HTTPS port</p>\" +\n-                    \"</body>\\r\\n\" +\n-                    \"</html>\";\n-            String response =\n-                \"HTTP/1.1 400 Bad Request\\r\\n\" +\n-                    \"Content-Type: text/html\\r\\n\" +\n-                    \"Content-Length: \" + body.length() + \"\\r\\n\" +\n-                    \"Connection: close\\r\\n\" +\n-                    \"\\r\\n\" +\n-                    body;\n-            Callback.Completable completable = new Callback.Completable();\n-            endPoint.write(completable, ByteBuffer.wrap(response.getBytes(StandardCharsets.US_ASCII)));\n-            completable.whenComplete((r, x) -> endPoint.close());\n+            // upgrade to the next protocol\n+            super.nextProtocol(buffer, endPoint, connector);\n         }\n         else\n         {\n-            endPoint.close();\n-        }\n-    }\n-\n-    private class OptionalSslConnection extends AbstractConnection implements Connection.UpgradeFrom\n-    {\n-        private final Connector connector;\n-        private final ByteBuffer buffer;\n-\n-        public OptionalSslConnection(EndPoint endPoint, Connector connector)\n-        {\n-            super(endPoint, connector.getExecutor());\n-            this.connector = connector;\n-            this.buffer = BufferUtil.allocateDirect(1536);\n-        }\n-\n-        @Override\n-        public void onOpen()\n-        {\n-            super.onOpen();\n-            fillInterested();\n-        }\n-\n-        @Override\n-        public void onFillable()\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    int filled = getEndPoint().fill(buffer);\n-                    if (filled > 0)\n-                    {\n-                        // Always have at least 2 bytes.\n-                        if (BufferUtil.length(buffer) >= 2)\n-                        {\n-                            upgrade(buffer);\n-                            break;\n-                        }\n-                    }\n-                    else if (filled == 0)\n-                    {\n-                        fillInterested();\n-                        break;\n-                    }\n-                    else\n-                    {\n-                        close();\n-                        break;\n-                    }\n-                }\n-            }\n-            catch (IOException x)\n-            {\n-                LOG.warn(x);\n-                close();\n-            }\n-        }\n-\n-        @Override\n-        public ByteBuffer onUpgradeFrom()\n-        {\n-            return buffer;\n-        }\n-\n-        private void upgrade(ByteBuffer buffer)\n-        {\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"Read {}\", BufferUtil.toDetailString(buffer));\n+            LOG.warn(\"Detected non-TLS bytes, but no other protocol to upgrade to for {}\", endPoint);\n \n-            EndPoint endPoint = getEndPoint();\n-            if (seemsTLS(buffer))\n+            // There are always at least 2 bytes.\n+            int byte1 = buffer.get(0) & 0xFF;\n+            int byte2 = buffer.get(1) & 0xFF;\n+            connector.getByteBufferPool().release(buffer);\n+            if (byte1 == 'G' && byte2 == 'E')", "originalCommit": "fc1fabddfdd2342389b3c6b9c0519f5fe94c9ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMyOTk2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372329968", "bodyText": "Can you detail this? You would like this to be a generic behavior, rather than just something that OptionalSslConnectionFactory does?", "author": "sbordet", "createdAt": "2020-01-29T11:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODY5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372358690", "bodyText": "I originally implemented such connection factory but @sbordet did not like it :-)\nI'd be happy to re-introduce it.", "author": "lorban", "createdAt": "2020-01-29T12:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMzU5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373123594", "bodyText": "Remove this, it's not necessary. This interface must only have detect().\nThe abstraction of being able to detect is orthogonal with whether it has a \"next\" protocol, so the 2 must not be mixed.", "author": "sbordet", "createdAt": "2020-01-30T18:40:30Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ConnectionFactory.java", "diffHunk": "@@ -85,4 +86,51 @@\n          */\n         Connection upgradeConnection(Connector connector, EndPoint endPoint, MetaData.Request upgradeRequest, HttpFields responseFields) throws BadMessageException;\n     }\n+\n+    /**\n+     * <p>Connections created by this factory MUST implement {@link Connection.UpgradeTo}.</p>\n+     */\n+    interface Detecting extends ConnectionFactory\n+    {\n+        /**\n+         * The possible outcomes of the {@link #detect(ByteBuffer)} method.\n+         */\n+        enum Detection\n+        {\n+            /**\n+             * A {@link Detecting} can work with the given bytes.\n+             */\n+            RECOGNIZED,\n+            /**\n+             * A {@link Detecting} cannot work with the given bytes.\n+             */\n+            NOT_RECOGNIZED,\n+            /**\n+             * A {@link Detecting} requires more bytes to make a decision.\n+             */\n+            NEED_MORE_BYTES\n+        }\n+\n+        /**\n+         * <p>Check the bytes in the given {@code buffer} to figure out if this {@link Detecting} instance\n+         * can work with them or not.</p>\n+         * <p>The {@code buffer} MUST be left untouched by this method: bytes MUST NOT be consumed and MUST NOT be modified.</p>\n+         * @param buffer the buffer.\n+         * @return One of:\n+         * <ul>\n+         * <li>{@link Detection#RECOGNIZED} if this {@link Detecting} instance can work with the bytes in the buffer</li>\n+         * <li>{@link Detection#NOT_RECOGNIZED} if this {@link Detecting} instance cannot work with the bytes in the buffer</li>\n+         * <li>{@link Detection#NEED_MORE_BYTES} if this {@link Detecting} instance requires more bytes to make a decision</li>\n+         * </ul>\n+         */\n+        Detection detect(ByteBuffer buffer);\n+\n+        /**\n+         * Has this instance been configured with a next protocol? A {@link DetectorConnectionFactory} won't allow\n+         * {@link Detecting} instances that do not have a configured next protocol.\n+         * @return true if a next protocol has been configured, false otherwise.\n+         */\n+        boolean isNextProtocolConfigured();", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwMTc1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373401759", "bodyText": "It is necessary if we want to prevent -for instance- a ProxyConnectionFactory with no configured next protocol inside a DetectorConnectionFactory.\nI agree that this method makes ConnectionFactory.Detecting a bit uglier than it could be, but OTOH this allows catching invalid configurations early and reporting a clear error message. Without this, we cannot detect if a ProxyConnectionFactory used in a DetectorConnectionFactory has a configured next protocol as we agreed in solution 1 to enforce.\nPlease check testDetectorWithProxyThatHasNoNextProto() and testDetectorWithSslThatHasNoNextProto in DetectorConnectionFactoryTest for examples of such configuration we want to reject.", "author": "lorban", "createdAt": "2020-01-31T10:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzODM1OA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373138358", "bodyText": "So the problem is that we cannot pass a function to the constructor that references this, so we need DetectionSuccessful for the function, but then DetectionUnsuccessfulTrampoline to workaround referencing this.\nThis to me means that it's the wrong solution. If we need to reference this, then all of the above should be part of the subclass itself and so an overridable method can do the job.\nThe overridable method will get rid of these 2 interfaces and all the machinery that they require.", "author": "sbordet", "createdAt": "2020-01-30T19:08:57Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,322 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected static final DetectionUnsuccessfulTrampoline UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE = (connectionFactory, connector, endPoint, buffer) ->\n+    {\n+        String nextProtocol = connectionFactory.findNextProtocol(connector);\n+        if (nextProtocol == null)\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        }\n+        upgradeToProtocol(nextProtocol, connector, endPoint, buffer);\n+    };\n+\n+    private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        this(UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE, detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, then\n+     * {@link DetectionUnsuccessful#onDetectionUnsuccessful(Connector, EndPoint, ByteBuffer)} is called.</p>\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessful} instance that is going to be called back when no {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(DetectionUnsuccessful detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        this(detectionUnsuccessful == null ? null : (connectionFactory, connector, endPoint, buffer) -> detectionUnsuccessful.onDetectionUnsuccessful(connector, endPoint, buffer), detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * TODO javadoc\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessfulTrampoline} instance that is going to be called back when no\n+     * {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    protected DetectorConnectionFactory(DetectionUnsuccessfulTrampoline detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        _detectionUnsuccessful = Objects.requireNonNull(detectionUnsuccessful);\n+        if (!(this instanceof Detecting))\n+        {\n+            // DetectorConnectionFactory subclasses that also implement Detecting can safely bypass this check as only\n+            // their internal Detecting instances need a next protocol.\n+            for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+            {\n+                if (!detectingConnectionFactory.isNextProtocolConfigured())\n+                    throw new IllegalStateException(\"Detecting connection factories must be explicitly configured with a next protocol\");\n+            }\n+        }\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+                return Detecting.Detection.RECOGNIZED;\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+        }\n+        return allDetectionNotRecognized ? Detecting.Detection.NOT_RECOGNIZED : Detecting.Detection.NEED_MORE_BYTES;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified protocol, disposing of the given resources when needed.\n+     * @param protocol the protocol to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected static void upgradeToProtocol(String protocol, Connector connector, EndPoint endPoint, ByteBuffer buffer)\n+    {\n+        ConnectionFactory nextConnectionFactory = connector.getConnectionFactory(protocol);\n+        Connection nextConnection = nextConnectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+        }\n+\n+        endPoint.upgrade(nextConnection);\n+        connector.getByteBufferPool().release(buffer);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector, _detectingConnectionFactories, _detectionUnsuccessful), connector, endPoint);\n+    }\n+\n+    class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final List<Detecting> _detectingConnectionFactories;\n+        private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+        private final ByteBuffer _buffer;\n+\n+        protected DetectorConnection(EndPoint endp, Connector connector, List<Detecting> detectingConnectionFactories, DetectionUnsuccessfulTrampoline detectionUnsuccessful)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _detectingConnectionFactories = detectingConnectionFactories;\n+            _detectionUnsuccessful = detectionUnsuccessful;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (fill < 0)\n+                    {\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Failed to detect upgrade target on {} for {}\", _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"DetectorConnection error for \" + getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            boolean noMagicFound = true;\n+            for (Detecting detectingConnectionFactory : _detectingConnectionFactories)\n+            {\n+                Detecting.Detection detection = detectingConnectionFactory.detect(_buffer);\n+                if (detection == Detecting.Detection.RECOGNIZED)\n+                {\n+                    // this DetectingConnectionFactory recognized those bytes -> upgrade to the next one\n+                    Connection nextConnection = detectingConnectionFactory.newConnection(_connector, getEndPoint());\n+                    if (!(nextConnection instanceof UpgradeTo))\n+                    {\n+                        releaseAndClose();\n+                        throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+                    }\n+                    getEndPoint().upgrade(nextConnection);\n+                    _connector.getByteBufferPool().release(_buffer);\n+                    return true;\n+                }\n+                noMagicFound &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+            }\n+\n+            if (noMagicFound)\n+            {\n+                // no DetectingConnectionFactory recognized those bytes -> call no recognition callback\n+                _detectionUnsuccessful.onDetectionUnsuccessful(DetectorConnectionFactory.this, _connector, getEndPoint(), _buffer);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void releaseAndClose()\n+        {\n+            _connector.getByteBufferPool().release(_buffer);\n+            close();\n+        }\n+\n+        @Override\n+        public void onUpgradeTo(ByteBuffer prefilled)\n+        {\n+            if (BufferUtil.hasContent(prefilled))\n+                BufferUtil.append(_buffer, prefilled);\n+        }\n+\n+        @Override\n+        public ByteBuffer onUpgradeFrom()\n+        {\n+            return _buffer;\n+        }\n+    }\n+\n+    /**\n+     * A functional interface whose instances are used as callbacks when protocol detection is unsuccessful.\n+     */\n+    @FunctionalInterface\n+    interface DetectionUnsuccessful\n+    {\n+        /**\n+         * This method is called back when protocol detection is unsuccessful. Instances of this interface are responsible\n+         * for disposing of the {@code buffer} and the {@code endpoint}.\n+         * @param connector the connector.\n+         * @param endPoint the endpoint.\n+         * @param buffer the buffer containing the bytes.\n+         */\n+        void onDetectionUnsuccessful(Connector connector, EndPoint endPoint, ByteBuffer buffer);\n+    }\n+\n+    /**\n+     * Equivalent to {@link DetectionUnsuccessful} but used internally to allow subclasses to pass to {@code super} an instance\n+     * that can callback a member method.\n+     * <p>Only subclasses of {@link DetectorConnectionFactory} who require calling back a member method need this interface.</p>\n+     */\n+    @FunctionalInterface\n+    protected interface DetectionUnsuccessfulTrampoline\n+    {\n+        /**\n+         * This method is called back when protocol detection is unsuccessful. Instances of this interface are responsible\n+         * for disposing of the {@code buffer} and the {@code endpoint}.\n+         * @param connectionFactory the detector that performed the detection.\n+         * @param connector the connector.\n+         * @param endPoint the endpoint.\n+         * @param buffer the buffer containing the bytes.\n+         */\n+        void onDetectionUnsuccessful(DetectorConnectionFactory connectionFactory, Connector connector, EndPoint endPoint, ByteBuffer buffer);\n+    }", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4MDE1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373380152", "bodyText": "Okay, I'll do this.", "author": "lorban", "createdAt": "2020-01-31T09:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzODM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzOTkzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373139934", "bodyText": "Drop \"magic\", you can just use boolean detected = false.", "author": "sbordet", "createdAt": "2020-01-30T19:11:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,322 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected static final DetectionUnsuccessfulTrampoline UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE = (connectionFactory, connector, endPoint, buffer) ->\n+    {\n+        String nextProtocol = connectionFactory.findNextProtocol(connector);\n+        if (nextProtocol == null)\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        }\n+        upgradeToProtocol(nextProtocol, connector, endPoint, buffer);\n+    };\n+\n+    private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        this(UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE, detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, then\n+     * {@link DetectionUnsuccessful#onDetectionUnsuccessful(Connector, EndPoint, ByteBuffer)} is called.</p>\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessful} instance that is going to be called back when no {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(DetectionUnsuccessful detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        this(detectionUnsuccessful == null ? null : (connectionFactory, connector, endPoint, buffer) -> detectionUnsuccessful.onDetectionUnsuccessful(connector, endPoint, buffer), detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * TODO javadoc\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessfulTrampoline} instance that is going to be called back when no\n+     * {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    protected DetectorConnectionFactory(DetectionUnsuccessfulTrampoline detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        _detectionUnsuccessful = Objects.requireNonNull(detectionUnsuccessful);\n+        if (!(this instanceof Detecting))\n+        {\n+            // DetectorConnectionFactory subclasses that also implement Detecting can safely bypass this check as only\n+            // their internal Detecting instances need a next protocol.\n+            for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+            {\n+                if (!detectingConnectionFactory.isNextProtocolConfigured())\n+                    throw new IllegalStateException(\"Detecting connection factories must be explicitly configured with a next protocol\");\n+            }\n+        }\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+                return Detecting.Detection.RECOGNIZED;\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+        }\n+        return allDetectionNotRecognized ? Detecting.Detection.NOT_RECOGNIZED : Detecting.Detection.NEED_MORE_BYTES;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified protocol, disposing of the given resources when needed.\n+     * @param protocol the protocol to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected static void upgradeToProtocol(String protocol, Connector connector, EndPoint endPoint, ByteBuffer buffer)\n+    {\n+        ConnectionFactory nextConnectionFactory = connector.getConnectionFactory(protocol);\n+        Connection nextConnection = nextConnectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+        }\n+\n+        endPoint.upgrade(nextConnection);\n+        connector.getByteBufferPool().release(buffer);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector, _detectingConnectionFactories, _detectionUnsuccessful), connector, endPoint);\n+    }\n+\n+    class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final List<Detecting> _detectingConnectionFactories;\n+        private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+        private final ByteBuffer _buffer;\n+\n+        protected DetectorConnection(EndPoint endp, Connector connector, List<Detecting> detectingConnectionFactories, DetectionUnsuccessfulTrampoline detectionUnsuccessful)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _detectingConnectionFactories = detectingConnectionFactories;\n+            _detectionUnsuccessful = detectionUnsuccessful;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (fill < 0)\n+                    {\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Failed to detect upgrade target on {} for {}\", _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"DetectorConnection error for \" + getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            boolean noMagicFound = true;", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4Nzk1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373387950", "bodyText": "Using boolean detected = false would inverse the logic so I renamed the variable detectionUnsuccessful instead.", "author": "lorban", "createdAt": "2020-01-31T09:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzOTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjIxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373142218", "bodyText": "We have a LeakTrackingByteBufferPool that you can use.", "author": "sbordet", "createdAt": "2020-01-30T19:16:44Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM5OTc2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373399769", "bodyText": "I had a look at LeakTrackingByteBufferPool and it cannot detect the leak I'm purposefully creating in testBufferLeakIsDetected. I'll see how I can reconcile both.", "author": "lorban", "createdAt": "2020-01-31T10:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NjE2MA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373146160", "bodyText": "Move http up, and use http.getProtocol() rather than HttpVersion.HTTP_1_1.asString().", "author": "sbordet", "createdAt": "2020-01-30T19:24:25Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4NTcwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373385701", "bodyText": "Sure, let me do it.", "author": "lorban", "createdAt": "2020-01-31T09:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NjE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NzA4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373147087", "bodyText": "Better name would be testDetectionUnsuccessfulUpgradesToFirstAfter()?", "author": "sbordet", "createdAt": "2020-01-30T19:26:11Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4NjI4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373386281", "bodyText": "I changed this test's name to testDetectionUnsuccessfulUpgradesToNextProtocol.", "author": "lorban", "createdAt": "2020-01-31T09:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NzA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0OTA0MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373149041", "bodyText": "Why there is an extra \\n at the end?", "author": "sbordet", "createdAt": "2020-01-30T19:30:03Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+        assertThat(response, Matchers.containsString(\"pathInfo=/path\"));\n+        assertThat(response, Matchers.containsString(\"local=5.6.7.8:222\"));\n+        assertThat(response, Matchers.containsString(\"remote=1.2.3.4:111\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpWithSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpWithSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        // SSL matched, so the upgrade was made to HTTP which does not understand the proxy request\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 400\"));\n+    }\n+\n+    @Test\n+    void testDetectorToNextDetector() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory proxyDetector = new DetectorConnectionFactory(proxy);\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, proxyDetector.getProtocol());\n+        DetectorConnectionFactory sslDetector = new DetectorConnectionFactory(ssl);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(sslDetector, proxyDetector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        // SSL matched, so the upgrade was made to proxy which itself upgraded to HTTP\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+        assertThat(response, Matchers.containsString(\"pathInfo=/path\"));\n+        assertThat(response, Matchers.containsString(\"local=5.6.7.8:222\"));\n+        assertThat(response, Matchers.containsString(\"remote=1.2.3.4:111\"));\n+    }\n+\n+    @Test\n+    void testDetectorWithDetectionUnsuccessfulLambda() throws Exception\n+    {\n+        AtomicBoolean detectionSuccessful = new AtomicBoolean(true);\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory((connector, endPoint, buffer) ->\n+        {\n+            if (!detectionSuccessful.compareAndSet(true, false))\n+                throw new AssertionError(\"DetectionUnsuccessful callback should only have been called once\");\n+\n+            // omitting this will leak the buffer\n+            connector.getByteBufferPool().release(buffer);\n+\n+            Callback.Completable completable = new Callback.Completable();\n+            endPoint.write(completable, ByteBuffer.wrap(\"No upgrade for you\".getBytes(StandardCharsets.US_ASCII)));\n+            completable.whenComplete((r, x) -> endPoint.close());\n+        }, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertEquals(\"No upgrade for you\\n\", response);", "originalCommit": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4MzgxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373383816", "bodyText": "It's an artifact of the getResponse method. I agree that it's confusing so I'll clean this up to make both the generated and the expected strings identical.", "author": "lorban", "createdAt": "2020-01-31T09:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0OTA0MQ=="}], "type": "inlineReview"}, {"oid": "559eb525afbd61dba26b8bf63b42e8b44353961e", "url": "https://github.com/eclipse/jetty.project/commit/559eb525afbd61dba26b8bf63b42e8b44353961e", "message": "refactor ProxyConnectionFactory to make use of common upgrade code\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-31T10:44:58Z", "type": "forcePushed"}, {"oid": "6af519bbc641de69dfeff5143e0324a0b83f3372", "url": "https://github.com/eclipse/jetty.project/commit/6af519bbc641de69dfeff5143e0324a0b83f3372", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-01-31T16:07:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373766435", "bodyText": "If more than one factory returns RECOGNIZED, should that instead be treated as NEED_MORE_BYTES?  This way an individual factory does not need to know how many bytes are required to disambiguate from other protocols.", "author": "gregw", "createdAt": "2020-02-01T08:23:29Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        String protocol = sb.toString();\n+        LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, detectingConnectionFactories);\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;", "originalCommit": "6af519bbc641de69dfeff5143e0324a0b83f3372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3ODMyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374078328", "bodyText": "Currently, the same functionality can be achieved by cleverly ordering the detecting connection factories. Maybe that should be documented?\nHowever, we could do what you're proposing as an improvement at the cost of a slightly more complex implementation, but I'm not certain it would be worth the effort, at least for now.", "author": "lorban", "createdAt": "2020-02-03T12:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4MzY5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374183692", "bodyText": "I would still like to avoid the need to \"cleverly order\" factories if at all possible.  Is the extra code really that more complex?", "author": "gregw", "createdAt": "2020-02-03T15:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyNjIzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374526238", "bodyText": "Well, thinking about it more I wonder what we could do in the case that more than one Detecting instance recognizes the bytes, besides eventually logging that?\nApart from troubleshooting conflicts between multiple detect() implementations, this wouldn't help, would it?", "author": "lorban", "createdAt": "2020-02-04T08:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQ2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373766462", "bodyText": "Once a factory says not recognized, should it be removed from the list for further iterations?", "author": "gregw", "createdAt": "2020-02-01T08:24:27Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        String protocol = sb.toString();\n+        LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, detectingConnectionFactories);\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;\n+            }\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;", "originalCommit": "6af519bbc641de69dfeff5143e0324a0b83f3372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTM2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374079369", "bodyText": "It's an optimization we could add, again at the cost of a slightly more complex implementation.\nIn practice, as long as the DetectorConnectionFactory isn't initialized with dozens of Detecting instances and only a small number of bytes are required to perform a detection this shouldn't make a difference IMHO.", "author": "lorban", "createdAt": "2020-02-03T12:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4NDI5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374184292", "bodyText": "I'm fine with not doing this optimisation now, but are the method signatures structured in such a way it can be done later without needing to break API?", "author": "gregw", "createdAt": "2020-02-03T15:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNDI5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374514297", "bodyText": "I'm positive the API wouldn't have to change to implement that optimization.", "author": "lorban", "createdAt": "2020-02-04T07:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQ2Mg=="}], "type": "inlineReview"}, {"oid": "0fd060c89b19f17071b1666552cf9e7028d00643", "url": "https://github.com/eclipse/jetty.project/commit/0fd060c89b19f17071b1666552cf9e7028d00643", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-03T15:49:23Z", "type": "forcePushed"}, {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec", "url": "https://github.com/eclipse/jetty.project/commit/75b47195927b1cf9f2e33dcb1838acfa675714ec", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-03T15:56:53Z", "type": "commit"}, {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec", "url": "https://github.com/eclipse/jetty.project/commit/75b47195927b1cf9f2e33dcb1838acfa675714ec", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-03T15:56:53Z", "type": "forcePushed"}, {"oid": "37edc016d2d3f4c006b5f5835b75fa019080a421", "url": "https://github.com/eclipse/jetty.project/commit/37edc016d2d3f4c006b5f5835b75fa019080a421", "message": "improve debug logs\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T08:21:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MzI3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374563276", "bodyText": "Please add an early return testing for BufferUtil.isEmpty(_buffer).", "author": "sbordet", "createdAt": "2020-02-04T09:38:51Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,294 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory implements ConnectionFactory.Detecting\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    private final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    private static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalArgumentException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = Arrays.stream(detectingConnectionFactories).map(ConnectionFactory::getProtocol).collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        String protocol = String.join(\"|\", protocols);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Performs a detection using multiple {@link ConnectionFactory.Detecting} instances and returns the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    @Override\n+    public Detecting.Detection detect(ByteBuffer buffer)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, _detectingConnectionFactories);\n+        boolean needMoreBytes = true;\n+        for (Detecting detectingConnectionFactory : _detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, _detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;\n+            }\n+            needMoreBytes &= detection == Detection.NEED_MORE_BYTES;\n+        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detection {} from buffer {} using {}\", (needMoreBytes ? \"requires more bytes\" : \"not recognized\"), buffer, _detectingConnectionFactories);\n+        return needMoreBytes ? Detection.NEED_MORE_BYTES : Detection.NOT_RECOGNIZED;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified connection factory, disposing of the given resources when needed.\n+     * @param connectionFactory the connection factory to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     */\n+    protected static void upgradeToConnectionFactory(ConnectionFactory connectionFactory, Connector connector, EndPoint endPoint) throws IllegalStateException\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Upgrading to connection factory {}\", connectionFactory);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot upgrade: connection factory must not be null for \" + endPoint);\n+        Connection nextConnection = connectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName() + \" for \" + endPoint);\n+        endPoint.upgrade(nextConnection);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Upgraded to connection factory {} and released buffer\", connectionFactory);\n+    }\n+\n+    /**\n+     * <p>Callback method called when detection was unsuccessful.\n+     * This implementation upgrades to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected void nextProtocol(Connector connector, EndPoint endPoint, ByteBuffer buffer) throws IllegalStateException\n+    {\n+        String nextProtocol = findNextProtocol(connector);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detector {} detection unsuccessful, found '{}' as the next protocol to upgrade to\", getProtocol(), nextProtocol);\n+        if (nextProtocol == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + getProtocol() + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endPoint);\n+        upgradeToConnectionFactory(connector.getConnectionFactory(nextProtocol), connector, endPoint);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector), connector, endPoint);\n+    }\n+\n+    private class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final ByteBuffer _buffer;\n+\n+        private DetectorConnection(EndPoint endp, Connector connector)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onUpgradeTo(ByteBuffer prefilled)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Detector {} copying prefilled buffer {}\", getProtocol(), BufferUtil.toDetailString(prefilled));\n+            if (BufferUtil.hasContent(prefilled))\n+                BufferUtil.append(_buffer, prefilled);\n+        }\n+\n+        @Override\n+        public ByteBuffer onUpgradeFrom()\n+        {\n+            return _buffer;\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Detector {} filled buffer with {} bytes\", getProtocol(), fill);\n+                    if (fill < 0)\n+                    {\n+                        _connector.getByteBufferPool().release(_buffer);\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Detector {} failed to detect upgrade target on {} for {}\", getProtocol(), _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"Detector {} error for {}\", getProtocol(), getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Detector {} performing detection with {} bytes\", getProtocol(), _buffer.remaining());", "originalCommit": "75b47195927b1cf9f2e33dcb1838acfa675714ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMTMxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374611312", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-02-04T11:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MzI3Ng=="}], "type": "inlineReview"}, {"oid": "58b1db610c96befe7c0d3eca7c57a07eb7be7cc7", "url": "https://github.com/eclipse/jetty.project/commit/58b1db610c96befe7c0d3eca7c57a07eb7be7cc7", "message": "detectAndUpgrade() shortcut on empty buffer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T09:49:27Z", "type": "commit"}, {"oid": "c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "url": "https://github.com/eclipse/jetty.project/commit/c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T11:21:02Z", "type": "forcePushed"}, {"oid": "943b86b8dd2f034c56038e296920ca825ffbe4ea", "url": "https://github.com/eclipse/jetty.project/commit/943b86b8dd2f034c56038e296920ca825ffbe4ea", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T11:36:44Z", "type": "forcePushed"}, {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "url": "https://github.com/eclipse/jetty.project/commit/5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T11:42:35Z", "type": "commit"}, {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "url": "https://github.com/eclipse/jetty.project/commit/5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-04T11:42:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375686153", "bodyText": "again a constant? why 6 not 7 now?", "author": "gregw", "createdAt": "2020-02-06T08:03:47Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ProxyConnectionFactory.java", "diffHunk": "@@ -46,252 +45,281 @@\n  *\n  * @see <a href=\"http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\">http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt</a>\n  */\n-public class ProxyConnectionFactory extends AbstractConnectionFactory\n+public class ProxyConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n     public static final String TLS_VERSION = \"TLS_VERSION\";\n+    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n \n-    private final String _next;\n-    private int _maxProxyHeader = 1024;\n-\n-    /**\n-     * Proxy Connection Factory that uses the next ConnectionFactory\n-     * on the connector as the next protocol\n-     */\n     public ProxyConnectionFactory()\n     {\n-        super(\"proxy\");\n-        _next = null;\n+        this(null);\n     }\n \n     public ProxyConnectionFactory(String nextProtocol)\n     {\n-        super(\"proxy\");\n-        _next = nextProtocol;\n+        super(new ProxyV1ConnectionFactory(nextProtocol), new ProxyV2ConnectionFactory(nextProtocol));\n     }\n \n-    public int getMaxProxyHeader()\n+    private static ConnectionFactory findNextConnectionFactory(String nextProtocol, Connector connector, String currentProtocol, EndPoint endp)\n     {\n-        return _maxProxyHeader;\n+        currentProtocol = \"[\" + currentProtocol + \"]\";\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"finding connection factory following {} for protocol {}\", currentProtocol, nextProtocol);\n+        String nextProtocolToFind = nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocolToFind = AbstractConnectionFactory.findNextProtocol(connector, currentProtocol);\n+        if (nextProtocolToFind == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + currentProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        ConnectionFactory connectionFactory = connector.getConnectionFactory(nextProtocolToFind);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot find protocol '\" + nextProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"found next connection factory {} for protocol {}\", connectionFactory, nextProtocol);\n+        return connectionFactory;\n     }\n \n-    public void setMaxProxyHeader(int maxProxyHeader)\n+    public int getMaxProxyHeader()\n     {\n-        _maxProxyHeader = maxProxyHeader;\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        return v2.getMaxProxyHeader();\n     }\n \n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endp)\n+    public void setMaxProxyHeader(int maxProxyHeader)\n     {\n-        String next = _next;\n-        if (next == null)\n-        {\n-            for (Iterator<String> i = connector.getProtocols().iterator(); i.hasNext(); )\n-            {\n-                String p = i.next();\n-                if (getProtocol().equalsIgnoreCase(p))\n-                {\n-                    next = i.next();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return new ProxyProtocolV1orV2Connection(endp, connector, next);\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        v2.setMaxProxyHeader(maxProxyHeader);\n     }\n \n-    public class ProxyProtocolV1orV2Connection extends AbstractConnection\n+    private static class ProxyV1ConnectionFactory extends AbstractConnectionFactory implements Detecting\n     {\n-        // Only do a tiny read to figure out what PROXY version it is.\n-        private final ByteBuffer _buffer = BufferUtil.allocate(16);\n-        private final Connector _connector;\n-        private final String _next;\n+        private static final byte[] SIGNATURE = \"PROXY\".getBytes(StandardCharsets.US_ASCII);\n \n-        protected ProxyProtocolV1orV2Connection(EndPoint endp, Connector connector, String next)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-        }\n+        private final String _nextProtocol;\n \n-        @Override\n-        public void onOpen()\n+        private ProxyV1ConnectionFactory(String nextProtocol)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            super(\"proxy\");\n+            this._nextProtocol = nextProtocol;\n         }\n \n         @Override\n-        public void onFillable()\n+        public Detection detect(ByteBuffer buffer)\n         {\n-            try\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 attempting detection with {} bytes\", buffer.remaining());\n+            if (buffer.remaining() < SIGNATURE.length)\n             {\n-                while (BufferUtil.space(_buffer) > 0)\n-                {\n-                    // Read data\n-                    int fill = getEndPoint().fill(_buffer);\n-                    if (fill < 0)\n-                    {\n-                        getEndPoint().shutdownOutput();\n-                        return;\n-                    }\n-                    if (fill == 0)\n-                    {\n-                        fillInterested();\n-                        return;\n-                    }\n-                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 detection requires more bytes\");\n+                return Detection.NEED_MORE_BYTES;\n+            }\n \n-                // Is it a V1?\n-                switch (_buffer.get(0))\n+            for (int i = 0; i < SIGNATURE.length; i++)\n+            {\n+                byte signatureByte = SIGNATURE[i];\n+                byte byteInBuffer = buffer.get(i);\n+                if (byteInBuffer != signatureByte)\n                 {\n-                    case 'P':\n-                    {\n-                        ProxyProtocolV1Connection v1 = new ProxyProtocolV1Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v1);\n-                        return;\n-                    }\n-                    case 0x0D:\n-                    {\n-                        ProxyProtocolV2Connection v2 = new ProxyProtocolV2Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v2);\n-                        return;\n-                    }\n-                    default:\n-                    {\n-                        LOG.warn(\"Not PROXY protocol for {}\", getEndPoint());\n-                        close();\n-                        break;\n-                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 detection unsuccessful\");\n+                    return Detection.NOT_RECOGNIZED;\n                 }\n             }\n-            catch (Throwable x)\n-            {\n-                LOG.warn(\"PROXY error for \" + getEndPoint(), x);\n-                close();\n-            }\n-        }\n-    }\n-\n-    public static class ProxyProtocolV1Connection extends AbstractConnection\n-    {\n-        // 0     1 2       3       4 5 6\n-        // 98765432109876543210987654321\n-        // PROXY P R.R.R.R L.L.L.L R Lrn\n-\n-        private static final int[] SIZE = {29, 23, 21, 13, 5, 3, 1};\n-        private final Connector _connector;\n-        private final String _next;\n-        private final StringBuilder _builder = new StringBuilder();\n-        private final String[] _fields = new String[6];\n-        private int _index;\n-        private int _length;\n \n-        protected ProxyProtocolV1Connection(EndPoint endp, Connector connector, String next, ByteBuffer buffer)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-            _length = buffer.remaining();\n-            parse(buffer);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 detection succeeded\");\n+            return Detection.RECOGNIZED;\n         }\n \n         @Override\n-        public void onOpen()\n+        public Connection newConnection(Connector connector, EndPoint endp)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            ConnectionFactory nextConnectionFactory = findNextConnectionFactory(_nextProtocol, connector, getProtocol(), endp);\n+            return configure(new ProxyProtocolV1Connection(endp, connector, nextConnectionFactory), connector, endp);\n         }\n \n-        private boolean parse(ByteBuffer buffer)\n+        private static class ProxyProtocolV1Connection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n         {\n-            // Parse fields\n-            while (buffer.hasRemaining())\n+            // 0     1 2       3       4 5 6\n+            // 98765432109876543210987654321\n+            // PROXY P R.R.R.R L.L.L.L R Lrn\n+\n+            private final Connector _connector;\n+            private final ConnectionFactory _next;\n+            private final ByteBuffer _buffer;\n+            private final StringBuilder _builder = new StringBuilder();\n+            private final String[] _fields = new String[6];\n+            private int _index;\n+            private int _length;\n+\n+            private ProxyProtocolV1Connection(EndPoint endp, Connector connector, ConnectionFactory next)\n             {\n-                byte b = buffer.get();\n-                if (_index < 6)\n+                super(endp, connector.getExecutor());\n+                _connector = connector;\n+                _next = next;\n+                _buffer = _connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+            }\n+\n+            @Override\n+            public void onFillable()\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 onFillable current index = \", _index);\n+                try\n                 {\n-                    if (b == ' ' || b == '\\r')\n-                    {\n-                        _fields[_index++] = _builder.toString();\n-                        _builder.setLength(0);\n-                        if (b == '\\r')\n-                            _index = 6;\n-                    }\n-                    else if (b < ' ')\n-                    {\n-                        LOG.warn(\"Bad character {} for {}\", b & 0xFF, getEndPoint());\n-                        close();\n-                        return false;\n-                    }\n-                    else\n+                    while (_index < 7)\n                     {\n-                        _builder.append((char)b);\n+                        // Read data\n+                        int fill = getEndPoint().fill(_buffer);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"Proxy v1 filled buffer with {} bytes\", fill);\n+                        if (fill < 0)\n+                        {\n+                            _connector.getByteBufferPool().release(_buffer);\n+                            getEndPoint().shutdownOutput();\n+                            return;\n+                        }\n+                        if (fill == 0)\n+                        {\n+                            fillInterested();\n+                            return;\n+                        }\n+\n+                        if (parse())\n+                            break;\n                     }\n+\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 onFillable parsing done, now upgrading\");\n+                    upgrade();\n+                }\n+                catch (Throwable x)\n+                {\n+                    LOG.warn(\"Proxy v1 error for {}\", getEndPoint(), x);\n+                    releaseAndClose();\n                 }\n-                else\n+            }\n+\n+            @Override\n+            public void onOpen()\n+            {\n+                super.onOpen();\n+\n+                try\n                 {\n-                    if (b == '\\n')\n+                    while (_index < 7)\n                     {\n-                        _index = 7;\n-                        return true;\n+                        if (!parse())\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"Proxy v1 onOpen parsing ran out of bytes, marking as fillInterested\");\n+                            fillInterested();\n+                            return;\n+                        }\n                     }\n \n-                    LOG.warn(\"Bad CRLF for {}\", getEndPoint());\n-                    close();\n-                    return false;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 onOpen parsing done, now upgrading\");\n+                    upgrade();\n+                }\n+                catch (Throwable x)\n+                {\n+                    LOG.warn(\"Proxy v1 error for {}\", getEndPoint(), x);\n+                    releaseAndClose();\n                 }\n             }\n-            return true;\n-        }\n \n-        @Override\n-        public void onFillable()\n-        {\n-            try\n+            @Override\n+            public ByteBuffer onUpgradeFrom()\n             {\n-                ByteBuffer buffer = null;\n-                while (_index < 7)\n-                {\n-                    // Create a buffer that will not read too much data\n-                    // since once read it is impossible to push back for the \n-                    // real connection to read it.\n-                    int size = Math.max(1, SIZE[_index] - _builder.length());\n-                    if (buffer == null || buffer.capacity() != size)\n-                        buffer = BufferUtil.allocate(size);\n-                    else\n-                        BufferUtil.clear(buffer);\n+                return _buffer;\n+            }\n \n-                    // Read data\n-                    int fill = getEndPoint().fill(buffer);\n-                    if (fill < 0)\n+            @Override\n+            public void onUpgradeTo(ByteBuffer prefilled)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 copying prefilled buffer {}\", prefilled);\n+                if (BufferUtil.hasContent(prefilled))\n+                    BufferUtil.append(_buffer, prefilled);\n+            }\n+\n+            /**\n+             * @return true when parsing is done, false when more bytes are needed.\n+             */\n+            private boolean parse() throws IOException\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 parsing {}\", BufferUtil.toDetailString(_buffer));\n+                _length += _buffer.remaining();\n+\n+                // Parse fields\n+                while (_buffer.hasRemaining())\n+                {\n+                    byte b = _buffer.get();\n+                    if (_index < 6)", "originalCommit": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxMTQ1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375711450", "bodyText": "6 is the field index of the carriage return character. It used to be hardcoded, but I can make that a constant too.", "author": "lorban", "createdAt": "2020-02-06T09:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375686179", "bodyText": "maybe avoid hard coded 7.   Use a descriptive constant or is this <=_fields.length?", "author": "gregw", "createdAt": "2020-02-06T08:03:51Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ProxyConnectionFactory.java", "diffHunk": "@@ -46,252 +45,281 @@\n  *\n  * @see <a href=\"http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\">http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt</a>\n  */\n-public class ProxyConnectionFactory extends AbstractConnectionFactory\n+public class ProxyConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n     public static final String TLS_VERSION = \"TLS_VERSION\";\n+    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n \n-    private final String _next;\n-    private int _maxProxyHeader = 1024;\n-\n-    /**\n-     * Proxy Connection Factory that uses the next ConnectionFactory\n-     * on the connector as the next protocol\n-     */\n     public ProxyConnectionFactory()\n     {\n-        super(\"proxy\");\n-        _next = null;\n+        this(null);\n     }\n \n     public ProxyConnectionFactory(String nextProtocol)\n     {\n-        super(\"proxy\");\n-        _next = nextProtocol;\n+        super(new ProxyV1ConnectionFactory(nextProtocol), new ProxyV2ConnectionFactory(nextProtocol));\n     }\n \n-    public int getMaxProxyHeader()\n+    private static ConnectionFactory findNextConnectionFactory(String nextProtocol, Connector connector, String currentProtocol, EndPoint endp)\n     {\n-        return _maxProxyHeader;\n+        currentProtocol = \"[\" + currentProtocol + \"]\";\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"finding connection factory following {} for protocol {}\", currentProtocol, nextProtocol);\n+        String nextProtocolToFind = nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocolToFind = AbstractConnectionFactory.findNextProtocol(connector, currentProtocol);\n+        if (nextProtocolToFind == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + currentProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        ConnectionFactory connectionFactory = connector.getConnectionFactory(nextProtocolToFind);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot find protocol '\" + nextProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"found next connection factory {} for protocol {}\", connectionFactory, nextProtocol);\n+        return connectionFactory;\n     }\n \n-    public void setMaxProxyHeader(int maxProxyHeader)\n+    public int getMaxProxyHeader()\n     {\n-        _maxProxyHeader = maxProxyHeader;\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        return v2.getMaxProxyHeader();\n     }\n \n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endp)\n+    public void setMaxProxyHeader(int maxProxyHeader)\n     {\n-        String next = _next;\n-        if (next == null)\n-        {\n-            for (Iterator<String> i = connector.getProtocols().iterator(); i.hasNext(); )\n-            {\n-                String p = i.next();\n-                if (getProtocol().equalsIgnoreCase(p))\n-                {\n-                    next = i.next();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return new ProxyProtocolV1orV2Connection(endp, connector, next);\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        v2.setMaxProxyHeader(maxProxyHeader);\n     }\n \n-    public class ProxyProtocolV1orV2Connection extends AbstractConnection\n+    private static class ProxyV1ConnectionFactory extends AbstractConnectionFactory implements Detecting\n     {\n-        // Only do a tiny read to figure out what PROXY version it is.\n-        private final ByteBuffer _buffer = BufferUtil.allocate(16);\n-        private final Connector _connector;\n-        private final String _next;\n+        private static final byte[] SIGNATURE = \"PROXY\".getBytes(StandardCharsets.US_ASCII);\n \n-        protected ProxyProtocolV1orV2Connection(EndPoint endp, Connector connector, String next)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-        }\n+        private final String _nextProtocol;\n \n-        @Override\n-        public void onOpen()\n+        private ProxyV1ConnectionFactory(String nextProtocol)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            super(\"proxy\");\n+            this._nextProtocol = nextProtocol;\n         }\n \n         @Override\n-        public void onFillable()\n+        public Detection detect(ByteBuffer buffer)\n         {\n-            try\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 attempting detection with {} bytes\", buffer.remaining());\n+            if (buffer.remaining() < SIGNATURE.length)\n             {\n-                while (BufferUtil.space(_buffer) > 0)\n-                {\n-                    // Read data\n-                    int fill = getEndPoint().fill(_buffer);\n-                    if (fill < 0)\n-                    {\n-                        getEndPoint().shutdownOutput();\n-                        return;\n-                    }\n-                    if (fill == 0)\n-                    {\n-                        fillInterested();\n-                        return;\n-                    }\n-                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 detection requires more bytes\");\n+                return Detection.NEED_MORE_BYTES;\n+            }\n \n-                // Is it a V1?\n-                switch (_buffer.get(0))\n+            for (int i = 0; i < SIGNATURE.length; i++)\n+            {\n+                byte signatureByte = SIGNATURE[i];\n+                byte byteInBuffer = buffer.get(i);\n+                if (byteInBuffer != signatureByte)\n                 {\n-                    case 'P':\n-                    {\n-                        ProxyProtocolV1Connection v1 = new ProxyProtocolV1Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v1);\n-                        return;\n-                    }\n-                    case 0x0D:\n-                    {\n-                        ProxyProtocolV2Connection v2 = new ProxyProtocolV2Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v2);\n-                        return;\n-                    }\n-                    default:\n-                    {\n-                        LOG.warn(\"Not PROXY protocol for {}\", getEndPoint());\n-                        close();\n-                        break;\n-                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 detection unsuccessful\");\n+                    return Detection.NOT_RECOGNIZED;\n                 }\n             }\n-            catch (Throwable x)\n-            {\n-                LOG.warn(\"PROXY error for \" + getEndPoint(), x);\n-                close();\n-            }\n-        }\n-    }\n-\n-    public static class ProxyProtocolV1Connection extends AbstractConnection\n-    {\n-        // 0     1 2       3       4 5 6\n-        // 98765432109876543210987654321\n-        // PROXY P R.R.R.R L.L.L.L R Lrn\n-\n-        private static final int[] SIZE = {29, 23, 21, 13, 5, 3, 1};\n-        private final Connector _connector;\n-        private final String _next;\n-        private final StringBuilder _builder = new StringBuilder();\n-        private final String[] _fields = new String[6];\n-        private int _index;\n-        private int _length;\n \n-        protected ProxyProtocolV1Connection(EndPoint endp, Connector connector, String next, ByteBuffer buffer)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-            _length = buffer.remaining();\n-            parse(buffer);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 detection succeeded\");\n+            return Detection.RECOGNIZED;\n         }\n \n         @Override\n-        public void onOpen()\n+        public Connection newConnection(Connector connector, EndPoint endp)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            ConnectionFactory nextConnectionFactory = findNextConnectionFactory(_nextProtocol, connector, getProtocol(), endp);\n+            return configure(new ProxyProtocolV1Connection(endp, connector, nextConnectionFactory), connector, endp);\n         }\n \n-        private boolean parse(ByteBuffer buffer)\n+        private static class ProxyProtocolV1Connection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n         {\n-            // Parse fields\n-            while (buffer.hasRemaining())\n+            // 0     1 2       3       4 5 6\n+            // 98765432109876543210987654321\n+            // PROXY P R.R.R.R L.L.L.L R Lrn\n+\n+            private final Connector _connector;\n+            private final ConnectionFactory _next;\n+            private final ByteBuffer _buffer;\n+            private final StringBuilder _builder = new StringBuilder();\n+            private final String[] _fields = new String[6];\n+            private int _index;\n+            private int _length;\n+\n+            private ProxyProtocolV1Connection(EndPoint endp, Connector connector, ConnectionFactory next)\n             {\n-                byte b = buffer.get();\n-                if (_index < 6)\n+                super(endp, connector.getExecutor());\n+                _connector = connector;\n+                _next = next;\n+                _buffer = _connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+            }\n+\n+            @Override\n+            public void onFillable()\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 onFillable current index = \", _index);\n+                try\n                 {\n-                    if (b == ' ' || b == '\\r')\n-                    {\n-                        _fields[_index++] = _builder.toString();\n-                        _builder.setLength(0);\n-                        if (b == '\\r')\n-                            _index = 6;\n-                    }\n-                    else if (b < ' ')\n-                    {\n-                        LOG.warn(\"Bad character {} for {}\", b & 0xFF, getEndPoint());\n-                        close();\n-                        return false;\n-                    }\n-                    else\n+                    while (_index < 7)", "originalCommit": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxMTI2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375711268", "bodyText": "7 is the field index of the line feed character. It used to be hardcoded, but I can make that a constant.", "author": "lorban", "createdAt": "2020-02-06T09:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE3OQ=="}], "type": "inlineReview"}, {"oid": "386d9348ca3d0f95a9456dcaa92782bc2d1e73ec", "url": "https://github.com/eclipse/jetty.project/commit/386d9348ca3d0f95a9456dcaa92782bc2d1e73ec", "message": "Use contants for CR and LF fields index\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-06T09:06:33Z", "type": "commit"}]}