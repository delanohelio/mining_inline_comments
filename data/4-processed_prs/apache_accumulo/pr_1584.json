{"pr_number": 1584, "pr_title": "Moved ThriftClientHandler out of TabletServer for #1581", "pr_createdAt": "2020-04-08T21:53:03Z", "pr_url": "https://github.com/apache/accumulo/pull/1584", "timeline": [{"oid": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "url": "https://github.com/apache/accumulo/commit/8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "message": "Moved ThriftClientHandler, AssignmentHandler and UnloadTabletHandler into separate classes (#1581)", "committedDate": "2020-04-08T21:46:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzA3MQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406543071", "bodyText": "The visibility here should be package-private.", "author": "ctubbsii", "createdAt": "2020-04-10T00:15:34Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/AssignmentHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static org.apache.accumulo.server.problems.ProblemType.TABLET_LOAD;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TimerTask;\n+import java.util.TreeSet;\n+\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.master.thrift.TabletLoadState;\n+import org.apache.accumulo.core.metadata.schema.TabletMetadata;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.server.master.state.Assignment;\n+import org.apache.accumulo.server.master.state.TabletStateStore;\n+import org.apache.accumulo.server.problems.ProblemReport;\n+import org.apache.accumulo.server.problems.ProblemReports;\n+import org.apache.accumulo.server.util.MasterMetadataUtil;\n+import org.apache.accumulo.server.util.time.SimpleTimer;\n+import org.apache.accumulo.tserver.TabletServerResourceManager.TabletResourceManager;\n+import org.apache.accumulo.tserver.mastermessage.TabletStatusMessage;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletData;\n+import org.apache.hadoop.io.Text;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class AssignmentHandler implements Runnable {", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwMTQwOQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406801409", "bodyText": "Makes sense, I wasn't sure whether or not to go public or package private here.", "author": "andrewglowacki", "createdAt": "2020-04-10T15:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzQzMw==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406543433", "bodyText": "Rather than create new variables, methods, assignments for these, it might be simpler to just make the original's package-private, so the AssignmentHandler can access them from TabletServer.\nHaving these use the same reference to these objects as TabletServer makes it more obvious when evaluating the later synchronization, that these are actually referring to the same objects, and not a new object returned from these new methods. (Which will help prevent breakage by preventing the ability to change the implementation of the new methods.)", "author": "ctubbsii", "createdAt": "2020-04-10T00:17:00Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/AssignmentHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static org.apache.accumulo.server.problems.ProblemType.TABLET_LOAD;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TimerTask;\n+import java.util.TreeSet;\n+\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.master.thrift.TabletLoadState;\n+import org.apache.accumulo.core.metadata.schema.TabletMetadata;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.server.master.state.Assignment;\n+import org.apache.accumulo.server.master.state.TabletStateStore;\n+import org.apache.accumulo.server.problems.ProblemReport;\n+import org.apache.accumulo.server.problems.ProblemReports;\n+import org.apache.accumulo.server.util.MasterMetadataUtil;\n+import org.apache.accumulo.server.util.time.SimpleTimer;\n+import org.apache.accumulo.tserver.TabletServerResourceManager.TabletResourceManager;\n+import org.apache.accumulo.tserver.mastermessage.TabletStatusMessage;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletData;\n+import org.apache.hadoop.io.Text;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class AssignmentHandler implements Runnable {\n+  private static final Logger log = LoggerFactory.getLogger(AssignmentHandler.class);\n+  private final KeyExtent extent;\n+  private final int retryAttempt;\n+  private final SortedSet<KeyExtent> unopenedTablets;\n+  private final SortedSet<KeyExtent> openingTablets;\n+  private final OnlineTablets onlineTablets;\n+  private final TabletServer server;\n+\n+  public AssignmentHandler(TabletServer server, KeyExtent extent) {\n+    this(server, extent, 0);\n+  }\n+\n+  public AssignmentHandler(TabletServer server, KeyExtent extent, int retryAttempt) {\n+    this.server = server;\n+    this.onlineTablets = server.getOnlineTabletsRaw();\n+    this.unopenedTablets = server.getUnopenedTablets();\n+    this.openingTablets = server.getOpeningTablets();", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNDMyNQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406804325", "bodyText": "I like this proposition a better since it'll make it a lot easier to ensure the refactor is a 1-to-1 mapping. Does it make sense for these methods to exist down the road though to ease testing of ThriftClientHandler by itself? Or do you think TabletServer and ThriftClientHandler shouldn't need to be tested in isolation?", "author": "andrewglowacki", "createdAt": "2020-04-10T15:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkzOTg4Nw==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406939887", "bodyText": "I don't think they will need to be tested in isolation for now. They may make sense to be added in future, but for now, I think keeping the code smaller will help enable subsequent improvements.", "author": "ctubbsii", "createdAt": "2020-04-10T20:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NTMxMA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406545310", "bodyText": "updateMetrics can just be package-private. At the very least, this method can be package-private (but I don't think it's necessary to create a method).", "author": "ctubbsii", "createdAt": "2020-04-10T00:24:26Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -307,6 +194,10 @@ public TabletServerMinCMetrics getMinCMetrics() {\n     return mincMetrics;\n   }\n \n+  public TabletServerUpdateMetrics getUpdateMetrics() {\n+    return updateMetrics;\n+  }\n+", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNTA1Mg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406805052", "bodyText": "Makes sense.", "author": "andrewglowacki", "createdAt": "2020-04-10T15:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NjQ0Mg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406546442", "bodyText": "This is never used in this class. The watcher can be constructed in the ThriftClientHandler constructor, when it calls super(), and then references to this watcher can use that instance, which is already protected in ThriftClientHandler's super class.\nThere are more improvements which can be made with regard to this transactionWatcher object, but those can be left for future work.", "author": "ctubbsii", "createdAt": "2020-04-10T00:29:04Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -495,2084 +386,218 @@ private static long jitter() {\n \n   private final SessionManager sessionManager;\n \n-  private final WriteTracker writeTracker = new WriteTracker();\n-\n-  private final RowLocks rowLocks = new RowLocks();\n-\n   private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n   private final ReentrantLock recoveryLock = new ReentrantLock(true);\n   private ThriftClientHandler clientHandler;\n   private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n \n-  private class ThriftClientHandler extends ClientServiceHandler\n-      implements TabletClientService.Iface {\n-\n-    ThriftClientHandler() {\n-      super(getContext(), watcher, fs);\n-      log.debug(\"{} created\", ThriftClientHandler.class.getName());\n-    }\n-\n-    @Override\n-    public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n-        final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n-        throws ThriftSecurityException {\n-\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      try {\n-        return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-          List<TKeyExtent> failures = new ArrayList<>();\n-\n-          for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n-            TKeyExtent tke = entry.getKey();\n-            Map<String,MapFileInfo> fileMap = entry.getValue();\n-            Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n-            for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-              Path path = new Path(mapping.getKey());\n-              FileSystem ns = fs.getFileSystemByPath(path);\n-              path = ns.makeQualified(path);\n-              fileRefMap.put(new TabletFile(path), mapping.getValue());\n-            }\n-\n-            Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-            if (importTablet == null) {\n-              failures.add(tke);\n-            } else {\n-              try {\n-                importTablet.importMapFiles(tid, fileRefMap, setTime);\n-              } catch (IOException ioe) {\n-                log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                    ioe.getMessage());\n-                failures.add(tke);\n-              }\n-            }\n-          }\n-          return failures;\n-        });\n-      } catch (RuntimeException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n-        Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n-        throws ThriftSecurityException {\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-        tabletImports.forEach((tke, fileMap) -> {\n-          Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n-          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-            Path path = new Path(dir, mapping.getKey());\n-            FileSystem ns = fs.getFileSystemByPath(path);\n-            path = ns.makeQualified(path);\n-            newFileMap.put(new TabletFile(path), mapping.getValue());\n-          }\n-\n-          Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-          if (importTablet != null) {\n-            try {\n-              importTablet.importMapFiles(tid, newFileMap, setTime);\n-            } catch (IOException ioe) {\n-              log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                  ioe.getMessage());\n-            }\n-          }\n-        });\n-      });\n-\n-    }\n-\n-    private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n-      if (extent.isRootTablet() || extent.isMeta()) {\n-        // dispatcher is only for user tables\n-        return null;\n-      }\n-\n-      return getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n-    }\n-\n-    @Override\n-    public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n-        TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n-        long batchTimeOut, String contextArg, Map<String,String> executionHints)\n-        throws NotServingTabletException, ThriftSecurityException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n-      NamespaceId namespaceId;\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new NotServingTabletException(textent);\n-      }\n-      if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n-          authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.BAD_AUTHORIZATIONS);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      // wait for any writes that are in flight.. this done to ensure\n-      // consistency across client restarts... assume a client writes\n-      // to accumulo and dies while waiting for a confirmation from\n-      // accumulo... the client process restarts and tries to read\n-      // data from accumulo making the assumption that it will get\n-      // any writes previously made... however if the server side thread\n-      // processing the write from the dead client is still in progress,\n-      // the restarted client may not see the write unless we wait here.\n-      // this behavior is very important when the client is reading the\n-      // metadata\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(extent));\n-      }\n-\n-      Tablet tablet = getOnlineTablet(extent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(textent);\n-      }\n-\n-      HashSet<Column> columnSet = new HashSet<>();\n-      for (TColumn tcolumn : columns) {\n-        columnSet.add(new Column(tcolumn));\n-      }\n+  protected TransactionWatcher getWatcher() {\n+    return watcher;\n+  }", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNTk2NA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406805964", "bodyText": "Oh, yes, thanks! I caught this while I was refactoring 1.9 earlier but I missed it this time around.", "author": "andrewglowacki", "createdAt": "2020-04-10T15:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0MDU0MA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406940540", "bodyText": "There's actually another room for improvement (not in this PR... but subsequently): the ClientServiceHandler (parent class of ThriftClientHandler) only needs one parameter, not three: the server context. But, that's for a subsequent change.", "author": "ctubbsii", "createdAt": "2020-04-10T20:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0Nzk5OA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406547998", "bodyText": "I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on.\nHowever, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.", "author": "ctubbsii", "createdAt": "2020-04-10T00:35:32Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -495,2084 +386,218 @@ private static long jitter() {\n \n   private final SessionManager sessionManager;\n \n-  private final WriteTracker writeTracker = new WriteTracker();\n-\n-  private final RowLocks rowLocks = new RowLocks();\n-\n   private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n   private final ReentrantLock recoveryLock = new ReentrantLock(true);\n   private ThriftClientHandler clientHandler;\n   private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n \n-  private class ThriftClientHandler extends ClientServiceHandler\n-      implements TabletClientService.Iface {\n-\n-    ThriftClientHandler() {\n-      super(getContext(), watcher, fs);\n-      log.debug(\"{} created\", ThriftClientHandler.class.getName());\n-    }\n-\n-    @Override\n-    public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n-        final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n-        throws ThriftSecurityException {\n-\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      try {\n-        return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-          List<TKeyExtent> failures = new ArrayList<>();\n-\n-          for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n-            TKeyExtent tke = entry.getKey();\n-            Map<String,MapFileInfo> fileMap = entry.getValue();\n-            Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n-            for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-              Path path = new Path(mapping.getKey());\n-              FileSystem ns = fs.getFileSystemByPath(path);\n-              path = ns.makeQualified(path);\n-              fileRefMap.put(new TabletFile(path), mapping.getValue());\n-            }\n-\n-            Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-            if (importTablet == null) {\n-              failures.add(tke);\n-            } else {\n-              try {\n-                importTablet.importMapFiles(tid, fileRefMap, setTime);\n-              } catch (IOException ioe) {\n-                log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                    ioe.getMessage());\n-                failures.add(tke);\n-              }\n-            }\n-          }\n-          return failures;\n-        });\n-      } catch (RuntimeException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n-        Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n-        throws ThriftSecurityException {\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-        tabletImports.forEach((tke, fileMap) -> {\n-          Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n-          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-            Path path = new Path(dir, mapping.getKey());\n-            FileSystem ns = fs.getFileSystemByPath(path);\n-            path = ns.makeQualified(path);\n-            newFileMap.put(new TabletFile(path), mapping.getValue());\n-          }\n-\n-          Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-          if (importTablet != null) {\n-            try {\n-              importTablet.importMapFiles(tid, newFileMap, setTime);\n-            } catch (IOException ioe) {\n-              log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                  ioe.getMessage());\n-            }\n-          }\n-        });\n-      });\n-\n-    }\n-\n-    private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n-      if (extent.isRootTablet() || extent.isMeta()) {\n-        // dispatcher is only for user tables\n-        return null;\n-      }\n-\n-      return getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n-    }\n-\n-    @Override\n-    public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n-        TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n-        long batchTimeOut, String contextArg, Map<String,String> executionHints)\n-        throws NotServingTabletException, ThriftSecurityException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n-      NamespaceId namespaceId;\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new NotServingTabletException(textent);\n-      }\n-      if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n-          authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.BAD_AUTHORIZATIONS);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      // wait for any writes that are in flight.. this done to ensure\n-      // consistency across client restarts... assume a client writes\n-      // to accumulo and dies while waiting for a confirmation from\n-      // accumulo... the client process restarts and tries to read\n-      // data from accumulo making the assumption that it will get\n-      // any writes previously made... however if the server side thread\n-      // processing the write from the dead client is still in progress,\n-      // the restarted client may not see the write unless we wait here.\n-      // this behavior is very important when the client is reading the\n-      // metadata\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(extent));\n-      }\n-\n-      Tablet tablet = getOnlineTablet(extent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(textent);\n-      }\n-\n-      HashSet<Column> columnSet = new HashSet<>();\n-      for (TColumn tcolumn : columns) {\n-        columnSet.add(new Column(tcolumn));\n-      }\n+  protected TransactionWatcher getWatcher() {\n+    return watcher;\n+  }\n \n-      ScanParameters scanParams = new ScanParameters(batchSize, new Authorizations(authorizations),\n-          columnSet, ssiList, ssio, isolated, SamplerConfigurationImpl.fromThrift(tSamplerConfig),\n-          batchTimeOut, contextArg);\n+  protected TabletServerLogger getLogger() {\n+    return logger;\n+  }\n \n-      final SingleScanSession scanSession = new SingleScanSession(credentials, extent, scanParams,\n-          readaheadThreshold, executionHints);\n-      scanSession.scanner =\n-          tablet.createScanner(new Range(range), scanParams, scanSession.interruptFlag);\n+  protected String getLockID() {\n+    return lockID;\n+  }", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMTQwNg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406811406", "bodyText": "Makes sense. Unrelated, but I was wondering why this and some other variables weren't volatile, should they be?", "author": "andrewglowacki", "createdAt": "2020-04-10T15:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0Nzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0MDg0NQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406940845", "bodyText": "Not sure at this time. I'd have to investigate how they are used.", "author": "ctubbsii", "createdAt": "2020-04-10T20:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0Nzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzMTMxNQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408131315", "bodyText": "Unrelated, but I was wondering why this and some other variables weren't volatile, should they be?\n\nIf its not final and accessed by multiple threads outside of any lock then it seems like it should be.  That could be a follow on PR.", "author": "keith-turner", "createdAt": "2020-04-14T13:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0Nzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzMzYyMQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408133621", "bodyText": "However, I think this one should stay, because it provides access to a non-final field\n\nThere is at least one other field that is non final and that is clientAddress.", "author": "keith-turner", "createdAt": "2020-04-14T13:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0Nzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjA1Nw==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406552057", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected void serverStopRequested() {\n          \n          \n            \n                serverStopRequested = true;\n          \n          \n            \n              }\n          \n          \n            \n              void requestStop() {\n          \n          \n            \n                serverStopRequested = true;\n          \n          \n            \n              }", "author": "ctubbsii", "createdAt": "2020-04-10T00:52:56Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -495,2084 +386,218 @@ private static long jitter() {\n \n   private final SessionManager sessionManager;\n \n-  private final WriteTracker writeTracker = new WriteTracker();\n-\n-  private final RowLocks rowLocks = new RowLocks();\n-\n   private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n   private final ReentrantLock recoveryLock = new ReentrantLock(true);\n   private ThriftClientHandler clientHandler;\n   private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n \n-  private class ThriftClientHandler extends ClientServiceHandler\n-      implements TabletClientService.Iface {\n-\n-    ThriftClientHandler() {\n-      super(getContext(), watcher, fs);\n-      log.debug(\"{} created\", ThriftClientHandler.class.getName());\n-    }\n-\n-    @Override\n-    public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n-        final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n-        throws ThriftSecurityException {\n-\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      try {\n-        return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-          List<TKeyExtent> failures = new ArrayList<>();\n-\n-          for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n-            TKeyExtent tke = entry.getKey();\n-            Map<String,MapFileInfo> fileMap = entry.getValue();\n-            Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n-            for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-              Path path = new Path(mapping.getKey());\n-              FileSystem ns = fs.getFileSystemByPath(path);\n-              path = ns.makeQualified(path);\n-              fileRefMap.put(new TabletFile(path), mapping.getValue());\n-            }\n-\n-            Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-            if (importTablet == null) {\n-              failures.add(tke);\n-            } else {\n-              try {\n-                importTablet.importMapFiles(tid, fileRefMap, setTime);\n-              } catch (IOException ioe) {\n-                log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                    ioe.getMessage());\n-                failures.add(tke);\n-              }\n-            }\n-          }\n-          return failures;\n-        });\n-      } catch (RuntimeException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n-        Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n-        throws ThriftSecurityException {\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-        tabletImports.forEach((tke, fileMap) -> {\n-          Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n-          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-            Path path = new Path(dir, mapping.getKey());\n-            FileSystem ns = fs.getFileSystemByPath(path);\n-            path = ns.makeQualified(path);\n-            newFileMap.put(new TabletFile(path), mapping.getValue());\n-          }\n-\n-          Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-          if (importTablet != null) {\n-            try {\n-              importTablet.importMapFiles(tid, newFileMap, setTime);\n-            } catch (IOException ioe) {\n-              log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                  ioe.getMessage());\n-            }\n-          }\n-        });\n-      });\n-\n-    }\n-\n-    private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n-      if (extent.isRootTablet() || extent.isMeta()) {\n-        // dispatcher is only for user tables\n-        return null;\n-      }\n-\n-      return getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n-    }\n-\n-    @Override\n-    public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n-        TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n-        long batchTimeOut, String contextArg, Map<String,String> executionHints)\n-        throws NotServingTabletException, ThriftSecurityException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n-      NamespaceId namespaceId;\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new NotServingTabletException(textent);\n-      }\n-      if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n-          authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.BAD_AUTHORIZATIONS);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      // wait for any writes that are in flight.. this done to ensure\n-      // consistency across client restarts... assume a client writes\n-      // to accumulo and dies while waiting for a confirmation from\n-      // accumulo... the client process restarts and tries to read\n-      // data from accumulo making the assumption that it will get\n-      // any writes previously made... however if the server side thread\n-      // processing the write from the dead client is still in progress,\n-      // the restarted client may not see the write unless we wait here.\n-      // this behavior is very important when the client is reading the\n-      // metadata\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(extent));\n-      }\n-\n-      Tablet tablet = getOnlineTablet(extent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(textent);\n-      }\n-\n-      HashSet<Column> columnSet = new HashSet<>();\n-      for (TColumn tcolumn : columns) {\n-        columnSet.add(new Column(tcolumn));\n-      }\n+  protected TransactionWatcher getWatcher() {\n+    return watcher;\n+  }\n \n-      ScanParameters scanParams = new ScanParameters(batchSize, new Authorizations(authorizations),\n-          columnSet, ssiList, ssio, isolated, SamplerConfigurationImpl.fromThrift(tSamplerConfig),\n-          batchTimeOut, contextArg);\n+  protected TabletServerLogger getLogger() {\n+    return logger;\n+  }\n \n-      final SingleScanSession scanSession = new SingleScanSession(credentials, extent, scanParams,\n-          readaheadThreshold, executionHints);\n-      scanSession.scanner =\n-          tablet.createScanner(new Range(range), scanParams, scanSession.interruptFlag);\n+  protected String getLockID() {\n+    return lockID;\n+  }\n \n-      long sid = sessionManager.createSession(scanSession, true);\n+  protected HostAndPort getClientAddress() {\n+    return clientAddress;\n+  }\n \n-      ScanResult scanResult;\n-      try {\n-        scanResult = continueScan(tinfo, sid, scanSession);\n-      } catch (NoSuchScanIDException e) {\n-        log.error(\"The impossible happened\", e);\n-        throw new RuntimeException();\n-      } finally {\n-        sessionManager.unreserveSession(sid);\n-      }\n+  protected TabletServerResourceManager getResourceManager() {\n+    return resourceManager;\n+  }\n \n-      return new InitialScan(sid, scanResult);\n-    }\n+  protected SecurityOperation getSecurity() {\n+    return security;\n+  }\n \n-    @Override\n-    public ScanResult continueScan(TInfo tinfo, long scanID)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-      SingleScanSession scanSession = (SingleScanSession) sessionManager.reserveSession(scanID);\n-      if (scanSession == null) {\n-        throw new NoSuchScanIDException();\n-      }\n+  protected SessionManager getSessionManager() {\n+    return sessionManager;\n+  }\n \n-      try {\n-        return continueScan(tinfo, scanID, scanSession);\n-      } finally {\n-        sessionManager.unreserveSession(scanSession);\n-      }\n-    }\n+  protected GarbageCollectionLogger getGcLogger() {\n+    return gcLogger;\n+  }\n \n-    private ScanResult continueScan(TInfo tinfo, long scanID, SingleScanSession scanSession)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n+  protected TabletStatsKeeper getStatsKeeper() {\n+    return statsKeeper;\n+  }\n \n-      if (scanSession.nextBatchTask == null) {\n-        scanSession.nextBatchTask =\n-            new NextBatchTask(TabletServer.this, scanID, scanSession.interruptFlag);\n-        resourceManager.executeReadAhead(scanSession.extent, getScanDispatcher(scanSession.extent),\n-            scanSession, scanSession.nextBatchTask);\n-      }\n+  protected void serverStopRequested() {\n+    serverStopRequested = true;\n+  }", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjMxOA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406552318", "bodyText": "I noticed masterLockCache wasn't final. However, it should be final, and then doesn't need a getter (see previous comment about most of these getters).", "author": "ctubbsii", "createdAt": "2020-04-10T00:53:55Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -495,2084 +386,218 @@ private static long jitter() {\n \n   private final SessionManager sessionManager;\n \n-  private final WriteTracker writeTracker = new WriteTracker();\n-\n-  private final RowLocks rowLocks = new RowLocks();\n-\n   private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n   private final ReentrantLock recoveryLock = new ReentrantLock(true);\n   private ThriftClientHandler clientHandler;\n   private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n \n-  private class ThriftClientHandler extends ClientServiceHandler\n-      implements TabletClientService.Iface {\n-\n-    ThriftClientHandler() {\n-      super(getContext(), watcher, fs);\n-      log.debug(\"{} created\", ThriftClientHandler.class.getName());\n-    }\n-\n-    @Override\n-    public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n-        final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n-        throws ThriftSecurityException {\n-\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      try {\n-        return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-          List<TKeyExtent> failures = new ArrayList<>();\n-\n-          for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n-            TKeyExtent tke = entry.getKey();\n-            Map<String,MapFileInfo> fileMap = entry.getValue();\n-            Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n-            for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-              Path path = new Path(mapping.getKey());\n-              FileSystem ns = fs.getFileSystemByPath(path);\n-              path = ns.makeQualified(path);\n-              fileRefMap.put(new TabletFile(path), mapping.getValue());\n-            }\n-\n-            Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-            if (importTablet == null) {\n-              failures.add(tke);\n-            } else {\n-              try {\n-                importTablet.importMapFiles(tid, fileRefMap, setTime);\n-              } catch (IOException ioe) {\n-                log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                    ioe.getMessage());\n-                failures.add(tke);\n-              }\n-            }\n-          }\n-          return failures;\n-        });\n-      } catch (RuntimeException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n-        Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n-        throws ThriftSecurityException {\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-        tabletImports.forEach((tke, fileMap) -> {\n-          Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n-          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-            Path path = new Path(dir, mapping.getKey());\n-            FileSystem ns = fs.getFileSystemByPath(path);\n-            path = ns.makeQualified(path);\n-            newFileMap.put(new TabletFile(path), mapping.getValue());\n-          }\n-\n-          Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-          if (importTablet != null) {\n-            try {\n-              importTablet.importMapFiles(tid, newFileMap, setTime);\n-            } catch (IOException ioe) {\n-              log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                  ioe.getMessage());\n-            }\n-          }\n-        });\n-      });\n-\n-    }\n-\n-    private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n-      if (extent.isRootTablet() || extent.isMeta()) {\n-        // dispatcher is only for user tables\n-        return null;\n-      }\n-\n-      return getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n-    }\n-\n-    @Override\n-    public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n-        TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n-        long batchTimeOut, String contextArg, Map<String,String> executionHints)\n-        throws NotServingTabletException, ThriftSecurityException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n-      NamespaceId namespaceId;\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new NotServingTabletException(textent);\n-      }\n-      if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n-          authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.BAD_AUTHORIZATIONS);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      // wait for any writes that are in flight.. this done to ensure\n-      // consistency across client restarts... assume a client writes\n-      // to accumulo and dies while waiting for a confirmation from\n-      // accumulo... the client process restarts and tries to read\n-      // data from accumulo making the assumption that it will get\n-      // any writes previously made... however if the server side thread\n-      // processing the write from the dead client is still in progress,\n-      // the restarted client may not see the write unless we wait here.\n-      // this behavior is very important when the client is reading the\n-      // metadata\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(extent));\n-      }\n-\n-      Tablet tablet = getOnlineTablet(extent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(textent);\n-      }\n-\n-      HashSet<Column> columnSet = new HashSet<>();\n-      for (TColumn tcolumn : columns) {\n-        columnSet.add(new Column(tcolumn));\n-      }\n+  protected TransactionWatcher getWatcher() {\n+    return watcher;\n+  }\n \n-      ScanParameters scanParams = new ScanParameters(batchSize, new Authorizations(authorizations),\n-          columnSet, ssiList, ssio, isolated, SamplerConfigurationImpl.fromThrift(tSamplerConfig),\n-          batchTimeOut, contextArg);\n+  protected TabletServerLogger getLogger() {\n+    return logger;\n+  }\n \n-      final SingleScanSession scanSession = new SingleScanSession(credentials, extent, scanParams,\n-          readaheadThreshold, executionHints);\n-      scanSession.scanner =\n-          tablet.createScanner(new Range(range), scanParams, scanSession.interruptFlag);\n+  protected String getLockID() {\n+    return lockID;\n+  }\n \n-      long sid = sessionManager.createSession(scanSession, true);\n+  protected HostAndPort getClientAddress() {\n+    return clientAddress;\n+  }\n \n-      ScanResult scanResult;\n-      try {\n-        scanResult = continueScan(tinfo, sid, scanSession);\n-      } catch (NoSuchScanIDException e) {\n-        log.error(\"The impossible happened\", e);\n-        throw new RuntimeException();\n-      } finally {\n-        sessionManager.unreserveSession(sid);\n-      }\n+  protected TabletServerResourceManager getResourceManager() {\n+    return resourceManager;\n+  }\n \n-      return new InitialScan(sid, scanResult);\n-    }\n+  protected SecurityOperation getSecurity() {\n+    return security;\n+  }\n \n-    @Override\n-    public ScanResult continueScan(TInfo tinfo, long scanID)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-      SingleScanSession scanSession = (SingleScanSession) sessionManager.reserveSession(scanID);\n-      if (scanSession == null) {\n-        throw new NoSuchScanIDException();\n-      }\n+  protected SessionManager getSessionManager() {\n+    return sessionManager;\n+  }\n \n-      try {\n-        return continueScan(tinfo, scanID, scanSession);\n-      } finally {\n-        sessionManager.unreserveSession(scanSession);\n-      }\n-    }\n+  protected GarbageCollectionLogger getGcLogger() {\n+    return gcLogger;\n+  }\n \n-    private ScanResult continueScan(TInfo tinfo, long scanID, SingleScanSession scanSession)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n+  protected TabletStatsKeeper getStatsKeeper() {\n+    return statsKeeper;\n+  }\n \n-      if (scanSession.nextBatchTask == null) {\n-        scanSession.nextBatchTask =\n-            new NextBatchTask(TabletServer.this, scanID, scanSession.interruptFlag);\n-        resourceManager.executeReadAhead(scanSession.extent, getScanDispatcher(scanSession.extent),\n-            scanSession, scanSession.nextBatchTask);\n-      }\n+  protected void serverStopRequested() {\n+    serverStopRequested = true;\n+  }\n \n-      ScanBatch bresult;\n-      try {\n-        bresult = scanSession.nextBatchTask.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS,\n-            TimeUnit.MILLISECONDS);\n-        scanSession.nextBatchTask = null;\n-      } catch (ExecutionException e) {\n-        sessionManager.removeSession(scanID);\n-        if (e.getCause() instanceof NotServingTabletException) {\n-          throw (NotServingTabletException) e.getCause();\n-        } else if (e.getCause() instanceof TooManyFilesException) {\n-          throw new org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException(\n-              scanSession.extent.toThrift());\n-        } else if (e.getCause() instanceof SampleNotPresentException) {\n-          throw new TSampleNotPresentException(scanSession.extent.toThrift());\n-        } else if (e.getCause() instanceof IOException) {\n-          sleepUninterruptibly(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n-          List<KVEntry> empty = Collections.emptyList();\n-          bresult = new ScanBatch(empty, true);\n-          scanSession.nextBatchTask = null;\n-        } else {\n-          throw new RuntimeException(e);\n-        }\n-      } catch (CancellationException ce) {\n-        sessionManager.removeSession(scanID);\n-        Tablet tablet = getOnlineTablet(scanSession.extent);\n-        if (tablet == null || tablet.isClosed()) {\n-          throw new NotServingTabletException(scanSession.extent.toThrift());\n-        } else {\n-          throw new NoSuchScanIDException();\n-        }\n-      } catch (TimeoutException e) {\n-        List<TKeyValue> param = Collections.emptyList();\n-        long timeout =\n-            TabletServer.this.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n-        sessionManager.removeIfNotAccessed(scanID, timeout);\n-        return new ScanResult(param, true);\n-      } catch (Throwable t) {\n-        sessionManager.removeSession(scanID);\n-        log.warn(\"Failed to get next batch\", t);\n-        throw new RuntimeException(t);\n-      }\n+  protected ZooCache getMasterLockCache() {\n+    return masterLockCache;\n+  }", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1Mjk1NQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406552955", "bodyText": "\ud83d\udc4d  for bringing along those fields that weren't used outside this class.", "author": "ctubbsii", "createdAt": "2020-04-10T00:56:41Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/ThriftClientHandler.java", "diffHunk": "@@ -0,0 +1,1812 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.Durability;\n+import org.apache.accumulo.core.client.SampleNotPresentException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.clientImpl.CompressedIterators;\n+import org.apache.accumulo.core.clientImpl.DurabilityImpl;\n+import org.apache.accumulo.core.clientImpl.Tables;\n+import org.apache.accumulo.core.clientImpl.TabletType;\n+import org.apache.accumulo.core.clientImpl.Translator;\n+import org.apache.accumulo.core.clientImpl.Translator.TKeyExtentTranslator;\n+import org.apache.accumulo.core.clientImpl.Translator.TRangeTranslator;\n+import org.apache.accumulo.core.clientImpl.Translators;\n+import org.apache.accumulo.core.clientImpl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.data.Column;\n+import org.apache.accumulo.core.data.ConstraintViolationSummary;\n+import org.apache.accumulo.core.data.Key;\n+import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.NamespaceId;\n+import org.apache.accumulo.core.data.Range;\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialMultiScan;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialScan;\n+import org.apache.accumulo.core.dataImpl.thrift.IterInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MapFileInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MultiScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.ScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMStatus;\n+import org.apache.accumulo.core.dataImpl.thrift.TColumn;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalSession;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyValue;\n+import org.apache.accumulo.core.dataImpl.thrift.TMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TRowRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaries;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaryRequest;\n+import org.apache.accumulo.core.dataImpl.thrift.UpdateErrors;\n+import org.apache.accumulo.core.iterators.IterationInterruptedException;\n+import org.apache.accumulo.core.logging.TabletLogger;\n+import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n+import org.apache.accumulo.core.metadata.MetadataTable;\n+import org.apache.accumulo.core.metadata.RootTable;\n+import org.apache.accumulo.core.metadata.TabletFile;\n+import org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.securityImpl.thrift.TCredentials;\n+import org.apache.accumulo.core.spi.cache.BlockCache;\n+import org.apache.accumulo.core.spi.scan.ScanDispatcher;\n+import org.apache.accumulo.core.summary.Gatherer;\n+import org.apache.accumulo.core.summary.Gatherer.FileSystemResolver;\n+import org.apache.accumulo.core.summary.SummaryCollection;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveCompaction;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveScan;\n+import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;\n+import org.apache.accumulo.core.tabletserver.thrift.NoSuchScanIDException;\n+import org.apache.accumulo.core.tabletserver.thrift.NotServingTabletException;\n+import org.apache.accumulo.core.tabletserver.thrift.TDurability;\n+import org.apache.accumulo.core.tabletserver.thrift.TSampleNotPresentException;\n+import org.apache.accumulo.core.tabletserver.thrift.TSamplerConfiguration;\n+import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletClientService;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletStats;\n+import org.apache.accumulo.core.trace.thrift.TInfo;\n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.core.util.Pair;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.fate.zookeeper.ZooLock;\n+import org.apache.accumulo.fate.zookeeper.ZooUtil;\n+import org.apache.accumulo.server.client.ClientServiceHandler;\n+import org.apache.accumulo.server.conf.TableConfiguration;\n+import org.apache.accumulo.server.data.ServerMutation;\n+import org.apache.accumulo.server.fs.VolumeManager;\n+import org.apache.accumulo.server.master.tableOps.UserCompactionConfig;\n+import org.apache.accumulo.server.rpc.TServerUtils;\n+import org.apache.accumulo.server.security.SecurityOperation;\n+import org.apache.accumulo.server.util.Halt;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher;\n+import org.apache.accumulo.tserver.ConditionCheckerContext.ConditionChecker;\n+import org.apache.accumulo.tserver.RowLocks.RowLock;\n+import org.apache.accumulo.tserver.data.ServerConditionalMutation;\n+import org.apache.accumulo.tserver.log.TabletServerLogger;\n+import org.apache.accumulo.tserver.metrics.TabletServerScanMetrics;\n+import org.apache.accumulo.tserver.metrics.TabletServerUpdateMetrics;\n+import org.apache.accumulo.tserver.scan.LookupTask;\n+import org.apache.accumulo.tserver.scan.NextBatchTask;\n+import org.apache.accumulo.tserver.scan.ScanParameters;\n+import org.apache.accumulo.tserver.session.ConditionalSession;\n+import org.apache.accumulo.tserver.session.MultiScanSession;\n+import org.apache.accumulo.tserver.session.SessionManager;\n+import org.apache.accumulo.tserver.session.SingleScanSession;\n+import org.apache.accumulo.tserver.session.SummarySession;\n+import org.apache.accumulo.tserver.session.UpdateSession;\n+import org.apache.accumulo.tserver.tablet.CommitSession;\n+import org.apache.accumulo.tserver.tablet.CompactionInfo;\n+import org.apache.accumulo.tserver.tablet.Compactor;\n+import org.apache.accumulo.tserver.tablet.KVEntry;\n+import org.apache.accumulo.tserver.tablet.PreparedMutations;\n+import org.apache.accumulo.tserver.tablet.ScanBatch;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletClosedException;\n+import org.apache.hadoop.fs.FSError;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.io.Text;\n+import org.apache.htrace.Trace;\n+import org.apache.htrace.TraceScope;\n+import org.apache.thrift.TException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Collections2;\n+\n+public class ThriftClientHandler extends ClientServiceHandler implements TabletClientService.Iface {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ThriftClientHandler.class);\n+  private static final long MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS = 1000;\n+  private static final long RECENTLY_SPLIT_MILLIES = 60 * 1000;\n+  private final TabletServer server;\n+  private final WriteTracker writeTracker = new WriteTracker();\n+  private final RowLocks rowLocks = new RowLocks();", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMTU1Ng==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406811556", "bodyText": "Thanks! :-)", "author": "andrewglowacki", "createdAt": "2020-04-10T15:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1Mjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1Mzg1Mg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406553852", "bodyText": "You don't actually need to get the \"file system\" from the tserver. You can get it from the ServerContext:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.fs = server.getFileSystem();\n          \n          \n            \n                this.fs = server.getContext().getVolumeManager();", "author": "ctubbsii", "createdAt": "2020-04-10T01:00:31Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/ThriftClientHandler.java", "diffHunk": "@@ -0,0 +1,1812 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.Durability;\n+import org.apache.accumulo.core.client.SampleNotPresentException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.clientImpl.CompressedIterators;\n+import org.apache.accumulo.core.clientImpl.DurabilityImpl;\n+import org.apache.accumulo.core.clientImpl.Tables;\n+import org.apache.accumulo.core.clientImpl.TabletType;\n+import org.apache.accumulo.core.clientImpl.Translator;\n+import org.apache.accumulo.core.clientImpl.Translator.TKeyExtentTranslator;\n+import org.apache.accumulo.core.clientImpl.Translator.TRangeTranslator;\n+import org.apache.accumulo.core.clientImpl.Translators;\n+import org.apache.accumulo.core.clientImpl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.data.Column;\n+import org.apache.accumulo.core.data.ConstraintViolationSummary;\n+import org.apache.accumulo.core.data.Key;\n+import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.NamespaceId;\n+import org.apache.accumulo.core.data.Range;\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialMultiScan;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialScan;\n+import org.apache.accumulo.core.dataImpl.thrift.IterInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MapFileInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MultiScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.ScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMStatus;\n+import org.apache.accumulo.core.dataImpl.thrift.TColumn;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalSession;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyValue;\n+import org.apache.accumulo.core.dataImpl.thrift.TMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TRowRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaries;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaryRequest;\n+import org.apache.accumulo.core.dataImpl.thrift.UpdateErrors;\n+import org.apache.accumulo.core.iterators.IterationInterruptedException;\n+import org.apache.accumulo.core.logging.TabletLogger;\n+import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n+import org.apache.accumulo.core.metadata.MetadataTable;\n+import org.apache.accumulo.core.metadata.RootTable;\n+import org.apache.accumulo.core.metadata.TabletFile;\n+import org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.securityImpl.thrift.TCredentials;\n+import org.apache.accumulo.core.spi.cache.BlockCache;\n+import org.apache.accumulo.core.spi.scan.ScanDispatcher;\n+import org.apache.accumulo.core.summary.Gatherer;\n+import org.apache.accumulo.core.summary.Gatherer.FileSystemResolver;\n+import org.apache.accumulo.core.summary.SummaryCollection;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveCompaction;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveScan;\n+import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;\n+import org.apache.accumulo.core.tabletserver.thrift.NoSuchScanIDException;\n+import org.apache.accumulo.core.tabletserver.thrift.NotServingTabletException;\n+import org.apache.accumulo.core.tabletserver.thrift.TDurability;\n+import org.apache.accumulo.core.tabletserver.thrift.TSampleNotPresentException;\n+import org.apache.accumulo.core.tabletserver.thrift.TSamplerConfiguration;\n+import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletClientService;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletStats;\n+import org.apache.accumulo.core.trace.thrift.TInfo;\n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.core.util.Pair;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.fate.zookeeper.ZooLock;\n+import org.apache.accumulo.fate.zookeeper.ZooUtil;\n+import org.apache.accumulo.server.client.ClientServiceHandler;\n+import org.apache.accumulo.server.conf.TableConfiguration;\n+import org.apache.accumulo.server.data.ServerMutation;\n+import org.apache.accumulo.server.fs.VolumeManager;\n+import org.apache.accumulo.server.master.tableOps.UserCompactionConfig;\n+import org.apache.accumulo.server.rpc.TServerUtils;\n+import org.apache.accumulo.server.security.SecurityOperation;\n+import org.apache.accumulo.server.util.Halt;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher;\n+import org.apache.accumulo.tserver.ConditionCheckerContext.ConditionChecker;\n+import org.apache.accumulo.tserver.RowLocks.RowLock;\n+import org.apache.accumulo.tserver.data.ServerConditionalMutation;\n+import org.apache.accumulo.tserver.log.TabletServerLogger;\n+import org.apache.accumulo.tserver.metrics.TabletServerScanMetrics;\n+import org.apache.accumulo.tserver.metrics.TabletServerUpdateMetrics;\n+import org.apache.accumulo.tserver.scan.LookupTask;\n+import org.apache.accumulo.tserver.scan.NextBatchTask;\n+import org.apache.accumulo.tserver.scan.ScanParameters;\n+import org.apache.accumulo.tserver.session.ConditionalSession;\n+import org.apache.accumulo.tserver.session.MultiScanSession;\n+import org.apache.accumulo.tserver.session.SessionManager;\n+import org.apache.accumulo.tserver.session.SingleScanSession;\n+import org.apache.accumulo.tserver.session.SummarySession;\n+import org.apache.accumulo.tserver.session.UpdateSession;\n+import org.apache.accumulo.tserver.tablet.CommitSession;\n+import org.apache.accumulo.tserver.tablet.CompactionInfo;\n+import org.apache.accumulo.tserver.tablet.Compactor;\n+import org.apache.accumulo.tserver.tablet.KVEntry;\n+import org.apache.accumulo.tserver.tablet.PreparedMutations;\n+import org.apache.accumulo.tserver.tablet.ScanBatch;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletClosedException;\n+import org.apache.hadoop.fs.FSError;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.io.Text;\n+import org.apache.htrace.Trace;\n+import org.apache.htrace.TraceScope;\n+import org.apache.thrift.TException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Collections2;\n+\n+public class ThriftClientHandler extends ClientServiceHandler implements TabletClientService.Iface {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ThriftClientHandler.class);\n+  private static final long MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS = 1000;\n+  private static final long RECENTLY_SPLIT_MILLIES = 60 * 1000;\n+  private final TabletServer server;\n+  private final WriteTracker writeTracker = new WriteTracker();\n+  private final RowLocks rowLocks = new RowLocks();\n+  private final TransactionWatcher watcher;\n+  private final VolumeManager fs;\n+  private final SecurityOperation security;\n+  private final SessionManager sessionManager;\n+  private final TabletServerUpdateMetrics updateMetrics;\n+  private final TabletServerScanMetrics scanMetrics;\n+  private final TabletServerLogger logger;\n+\n+  public ThriftClientHandler(TabletServer server) {\n+    super(server.getContext(), server.getWatcher(), server.getFileSystem());\n+    this.server = server;\n+    this.watcher = server.getWatcher();\n+    this.fs = server.getFileSystem();", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NDE3NA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406554174", "bodyText": "I think I saw that there was already a .getSecurityOperation() method.", "author": "ctubbsii", "createdAt": "2020-04-10T01:02:03Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/ThriftClientHandler.java", "diffHunk": "@@ -0,0 +1,1812 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.Durability;\n+import org.apache.accumulo.core.client.SampleNotPresentException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.clientImpl.CompressedIterators;\n+import org.apache.accumulo.core.clientImpl.DurabilityImpl;\n+import org.apache.accumulo.core.clientImpl.Tables;\n+import org.apache.accumulo.core.clientImpl.TabletType;\n+import org.apache.accumulo.core.clientImpl.Translator;\n+import org.apache.accumulo.core.clientImpl.Translator.TKeyExtentTranslator;\n+import org.apache.accumulo.core.clientImpl.Translator.TRangeTranslator;\n+import org.apache.accumulo.core.clientImpl.Translators;\n+import org.apache.accumulo.core.clientImpl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.data.Column;\n+import org.apache.accumulo.core.data.ConstraintViolationSummary;\n+import org.apache.accumulo.core.data.Key;\n+import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.NamespaceId;\n+import org.apache.accumulo.core.data.Range;\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialMultiScan;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialScan;\n+import org.apache.accumulo.core.dataImpl.thrift.IterInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MapFileInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MultiScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.ScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMStatus;\n+import org.apache.accumulo.core.dataImpl.thrift.TColumn;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalSession;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyValue;\n+import org.apache.accumulo.core.dataImpl.thrift.TMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TRowRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaries;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaryRequest;\n+import org.apache.accumulo.core.dataImpl.thrift.UpdateErrors;\n+import org.apache.accumulo.core.iterators.IterationInterruptedException;\n+import org.apache.accumulo.core.logging.TabletLogger;\n+import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n+import org.apache.accumulo.core.metadata.MetadataTable;\n+import org.apache.accumulo.core.metadata.RootTable;\n+import org.apache.accumulo.core.metadata.TabletFile;\n+import org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.securityImpl.thrift.TCredentials;\n+import org.apache.accumulo.core.spi.cache.BlockCache;\n+import org.apache.accumulo.core.spi.scan.ScanDispatcher;\n+import org.apache.accumulo.core.summary.Gatherer;\n+import org.apache.accumulo.core.summary.Gatherer.FileSystemResolver;\n+import org.apache.accumulo.core.summary.SummaryCollection;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveCompaction;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveScan;\n+import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;\n+import org.apache.accumulo.core.tabletserver.thrift.NoSuchScanIDException;\n+import org.apache.accumulo.core.tabletserver.thrift.NotServingTabletException;\n+import org.apache.accumulo.core.tabletserver.thrift.TDurability;\n+import org.apache.accumulo.core.tabletserver.thrift.TSampleNotPresentException;\n+import org.apache.accumulo.core.tabletserver.thrift.TSamplerConfiguration;\n+import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletClientService;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletStats;\n+import org.apache.accumulo.core.trace.thrift.TInfo;\n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.core.util.Pair;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.fate.zookeeper.ZooLock;\n+import org.apache.accumulo.fate.zookeeper.ZooUtil;\n+import org.apache.accumulo.server.client.ClientServiceHandler;\n+import org.apache.accumulo.server.conf.TableConfiguration;\n+import org.apache.accumulo.server.data.ServerMutation;\n+import org.apache.accumulo.server.fs.VolumeManager;\n+import org.apache.accumulo.server.master.tableOps.UserCompactionConfig;\n+import org.apache.accumulo.server.rpc.TServerUtils;\n+import org.apache.accumulo.server.security.SecurityOperation;\n+import org.apache.accumulo.server.util.Halt;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher;\n+import org.apache.accumulo.tserver.ConditionCheckerContext.ConditionChecker;\n+import org.apache.accumulo.tserver.RowLocks.RowLock;\n+import org.apache.accumulo.tserver.data.ServerConditionalMutation;\n+import org.apache.accumulo.tserver.log.TabletServerLogger;\n+import org.apache.accumulo.tserver.metrics.TabletServerScanMetrics;\n+import org.apache.accumulo.tserver.metrics.TabletServerUpdateMetrics;\n+import org.apache.accumulo.tserver.scan.LookupTask;\n+import org.apache.accumulo.tserver.scan.NextBatchTask;\n+import org.apache.accumulo.tserver.scan.ScanParameters;\n+import org.apache.accumulo.tserver.session.ConditionalSession;\n+import org.apache.accumulo.tserver.session.MultiScanSession;\n+import org.apache.accumulo.tserver.session.SessionManager;\n+import org.apache.accumulo.tserver.session.SingleScanSession;\n+import org.apache.accumulo.tserver.session.SummarySession;\n+import org.apache.accumulo.tserver.session.UpdateSession;\n+import org.apache.accumulo.tserver.tablet.CommitSession;\n+import org.apache.accumulo.tserver.tablet.CompactionInfo;\n+import org.apache.accumulo.tserver.tablet.Compactor;\n+import org.apache.accumulo.tserver.tablet.KVEntry;\n+import org.apache.accumulo.tserver.tablet.PreparedMutations;\n+import org.apache.accumulo.tserver.tablet.ScanBatch;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletClosedException;\n+import org.apache.hadoop.fs.FSError;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.io.Text;\n+import org.apache.htrace.Trace;\n+import org.apache.htrace.TraceScope;\n+import org.apache.thrift.TException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Collections2;\n+\n+public class ThriftClientHandler extends ClientServiceHandler implements TabletClientService.Iface {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ThriftClientHandler.class);\n+  private static final long MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS = 1000;\n+  private static final long RECENTLY_SPLIT_MILLIES = 60 * 1000;\n+  private final TabletServer server;\n+  private final WriteTracker writeTracker = new WriteTracker();\n+  private final RowLocks rowLocks = new RowLocks();\n+  private final TransactionWatcher watcher;\n+  private final VolumeManager fs;\n+  private final SecurityOperation security;\n+  private final SessionManager sessionManager;\n+  private final TabletServerUpdateMetrics updateMetrics;\n+  private final TabletServerScanMetrics scanMetrics;\n+  private final TabletServerLogger logger;\n+\n+  public ThriftClientHandler(TabletServer server) {\n+    super(server.getContext(), server.getWatcher(), server.getFileSystem());\n+    this.server = server;\n+    this.watcher = server.getWatcher();\n+    this.fs = server.getFileSystem();\n+    this.security = server.getSecurity();", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NDgwMg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406554802", "bodyText": "As stated earlier, you can get the stuff from the context and the super class:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                super(server.getContext(), server.getWatcher(), server.getFileSystem());\n          \n          \n            \n                this.server = server;\n          \n          \n            \n                this.watcher = server.getWatcher();\n          \n          \n            \n                super(server.getContext(), new TransactionWatcher(server.getContext()), server.getContext().getVolumeManager());\n          \n          \n            \n                this.server = server;\n          \n          \n            \n                this.watcher = transactionWatcher;", "author": "ctubbsii", "createdAt": "2020-04-10T01:04:41Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/ThriftClientHandler.java", "diffHunk": "@@ -0,0 +1,1812 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.Durability;\n+import org.apache.accumulo.core.client.SampleNotPresentException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.clientImpl.CompressedIterators;\n+import org.apache.accumulo.core.clientImpl.DurabilityImpl;\n+import org.apache.accumulo.core.clientImpl.Tables;\n+import org.apache.accumulo.core.clientImpl.TabletType;\n+import org.apache.accumulo.core.clientImpl.Translator;\n+import org.apache.accumulo.core.clientImpl.Translator.TKeyExtentTranslator;\n+import org.apache.accumulo.core.clientImpl.Translator.TRangeTranslator;\n+import org.apache.accumulo.core.clientImpl.Translators;\n+import org.apache.accumulo.core.clientImpl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.data.Column;\n+import org.apache.accumulo.core.data.ConstraintViolationSummary;\n+import org.apache.accumulo.core.data.Key;\n+import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.NamespaceId;\n+import org.apache.accumulo.core.data.Range;\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialMultiScan;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialScan;\n+import org.apache.accumulo.core.dataImpl.thrift.IterInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MapFileInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MultiScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.ScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMStatus;\n+import org.apache.accumulo.core.dataImpl.thrift.TColumn;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalSession;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyValue;\n+import org.apache.accumulo.core.dataImpl.thrift.TMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TRowRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaries;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaryRequest;\n+import org.apache.accumulo.core.dataImpl.thrift.UpdateErrors;\n+import org.apache.accumulo.core.iterators.IterationInterruptedException;\n+import org.apache.accumulo.core.logging.TabletLogger;\n+import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n+import org.apache.accumulo.core.metadata.MetadataTable;\n+import org.apache.accumulo.core.metadata.RootTable;\n+import org.apache.accumulo.core.metadata.TabletFile;\n+import org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.securityImpl.thrift.TCredentials;\n+import org.apache.accumulo.core.spi.cache.BlockCache;\n+import org.apache.accumulo.core.spi.scan.ScanDispatcher;\n+import org.apache.accumulo.core.summary.Gatherer;\n+import org.apache.accumulo.core.summary.Gatherer.FileSystemResolver;\n+import org.apache.accumulo.core.summary.SummaryCollection;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveCompaction;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveScan;\n+import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;\n+import org.apache.accumulo.core.tabletserver.thrift.NoSuchScanIDException;\n+import org.apache.accumulo.core.tabletserver.thrift.NotServingTabletException;\n+import org.apache.accumulo.core.tabletserver.thrift.TDurability;\n+import org.apache.accumulo.core.tabletserver.thrift.TSampleNotPresentException;\n+import org.apache.accumulo.core.tabletserver.thrift.TSamplerConfiguration;\n+import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletClientService;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletStats;\n+import org.apache.accumulo.core.trace.thrift.TInfo;\n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.core.util.Pair;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.fate.zookeeper.ZooLock;\n+import org.apache.accumulo.fate.zookeeper.ZooUtil;\n+import org.apache.accumulo.server.client.ClientServiceHandler;\n+import org.apache.accumulo.server.conf.TableConfiguration;\n+import org.apache.accumulo.server.data.ServerMutation;\n+import org.apache.accumulo.server.fs.VolumeManager;\n+import org.apache.accumulo.server.master.tableOps.UserCompactionConfig;\n+import org.apache.accumulo.server.rpc.TServerUtils;\n+import org.apache.accumulo.server.security.SecurityOperation;\n+import org.apache.accumulo.server.util.Halt;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher;\n+import org.apache.accumulo.tserver.ConditionCheckerContext.ConditionChecker;\n+import org.apache.accumulo.tserver.RowLocks.RowLock;\n+import org.apache.accumulo.tserver.data.ServerConditionalMutation;\n+import org.apache.accumulo.tserver.log.TabletServerLogger;\n+import org.apache.accumulo.tserver.metrics.TabletServerScanMetrics;\n+import org.apache.accumulo.tserver.metrics.TabletServerUpdateMetrics;\n+import org.apache.accumulo.tserver.scan.LookupTask;\n+import org.apache.accumulo.tserver.scan.NextBatchTask;\n+import org.apache.accumulo.tserver.scan.ScanParameters;\n+import org.apache.accumulo.tserver.session.ConditionalSession;\n+import org.apache.accumulo.tserver.session.MultiScanSession;\n+import org.apache.accumulo.tserver.session.SessionManager;\n+import org.apache.accumulo.tserver.session.SingleScanSession;\n+import org.apache.accumulo.tserver.session.SummarySession;\n+import org.apache.accumulo.tserver.session.UpdateSession;\n+import org.apache.accumulo.tserver.tablet.CommitSession;\n+import org.apache.accumulo.tserver.tablet.CompactionInfo;\n+import org.apache.accumulo.tserver.tablet.Compactor;\n+import org.apache.accumulo.tserver.tablet.KVEntry;\n+import org.apache.accumulo.tserver.tablet.PreparedMutations;\n+import org.apache.accumulo.tserver.tablet.ScanBatch;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletClosedException;\n+import org.apache.hadoop.fs.FSError;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.io.Text;\n+import org.apache.htrace.Trace;\n+import org.apache.htrace.TraceScope;\n+import org.apache.thrift.TException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Collections2;\n+\n+public class ThriftClientHandler extends ClientServiceHandler implements TabletClientService.Iface {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ThriftClientHandler.class);\n+  private static final long MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS = 1000;\n+  private static final long RECENTLY_SPLIT_MILLIES = 60 * 1000;\n+  private final TabletServer server;\n+  private final WriteTracker writeTracker = new WriteTracker();\n+  private final RowLocks rowLocks = new RowLocks();\n+  private final TransactionWatcher watcher;\n+  private final VolumeManager fs;\n+  private final SecurityOperation security;\n+  private final SessionManager sessionManager;\n+  private final TabletServerUpdateMetrics updateMetrics;\n+  private final TabletServerScanMetrics scanMetrics;\n+  private final TabletServerLogger logger;\n+\n+  public ThriftClientHandler(TabletServer server) {\n+    super(server.getContext(), server.getWatcher(), server.getFileSystem());\n+    this.server = server;\n+    this.watcher = server.getWatcher();", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NTkwMQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406555901", "bodyText": "This is changing the synchronization. Previously, it synchronized on the snapshot factory. Now, it's synchronizing on the snapshot. This kind of error is why I think it'd probably be better to use package-private references to TabletServer's own fields, rather than use getters and assign to new variables.\nI saw you avoided this behavior change elsewhere by synchronizing on what is returned from your new method, getOnlineTabletsRaw(), but I think it's too easy to mistake these methods for one another.\nAnother reason to use the same reference is because it makes it easier to analyze the concurrency model by finding references the object in an IDE. If the same object is assigned to multiple references, trying to understand the concurrency model is more difficult, because you have to follow call stacks.", "author": "ctubbsii", "createdAt": "2020-04-10T01:09:52Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/ThriftClientHandler.java", "diffHunk": "@@ -0,0 +1,1812 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.tserver;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.Durability;\n+import org.apache.accumulo.core.client.SampleNotPresentException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.clientImpl.CompressedIterators;\n+import org.apache.accumulo.core.clientImpl.DurabilityImpl;\n+import org.apache.accumulo.core.clientImpl.Tables;\n+import org.apache.accumulo.core.clientImpl.TabletType;\n+import org.apache.accumulo.core.clientImpl.Translator;\n+import org.apache.accumulo.core.clientImpl.Translator.TKeyExtentTranslator;\n+import org.apache.accumulo.core.clientImpl.Translator.TRangeTranslator;\n+import org.apache.accumulo.core.clientImpl.Translators;\n+import org.apache.accumulo.core.clientImpl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException;\n+import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.data.Column;\n+import org.apache.accumulo.core.data.ConstraintViolationSummary;\n+import org.apache.accumulo.core.data.Key;\n+import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.NamespaceId;\n+import org.apache.accumulo.core.data.Range;\n+import org.apache.accumulo.core.data.TableId;\n+import org.apache.accumulo.core.dataImpl.KeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialMultiScan;\n+import org.apache.accumulo.core.dataImpl.thrift.InitialScan;\n+import org.apache.accumulo.core.dataImpl.thrift.IterInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MapFileInfo;\n+import org.apache.accumulo.core.dataImpl.thrift.MultiScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.ScanResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMResult;\n+import org.apache.accumulo.core.dataImpl.thrift.TCMStatus;\n+import org.apache.accumulo.core.dataImpl.thrift.TColumn;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TConditionalSession;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyExtent;\n+import org.apache.accumulo.core.dataImpl.thrift.TKeyValue;\n+import org.apache.accumulo.core.dataImpl.thrift.TMutation;\n+import org.apache.accumulo.core.dataImpl.thrift.TRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TRowRange;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaries;\n+import org.apache.accumulo.core.dataImpl.thrift.TSummaryRequest;\n+import org.apache.accumulo.core.dataImpl.thrift.UpdateErrors;\n+import org.apache.accumulo.core.iterators.IterationInterruptedException;\n+import org.apache.accumulo.core.logging.TabletLogger;\n+import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n+import org.apache.accumulo.core.metadata.MetadataTable;\n+import org.apache.accumulo.core.metadata.RootTable;\n+import org.apache.accumulo.core.metadata.TabletFile;\n+import org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.securityImpl.thrift.TCredentials;\n+import org.apache.accumulo.core.spi.cache.BlockCache;\n+import org.apache.accumulo.core.spi.scan.ScanDispatcher;\n+import org.apache.accumulo.core.summary.Gatherer;\n+import org.apache.accumulo.core.summary.Gatherer.FileSystemResolver;\n+import org.apache.accumulo.core.summary.SummaryCollection;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveCompaction;\n+import org.apache.accumulo.core.tabletserver.thrift.ActiveScan;\n+import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;\n+import org.apache.accumulo.core.tabletserver.thrift.NoSuchScanIDException;\n+import org.apache.accumulo.core.tabletserver.thrift.NotServingTabletException;\n+import org.apache.accumulo.core.tabletserver.thrift.TDurability;\n+import org.apache.accumulo.core.tabletserver.thrift.TSampleNotPresentException;\n+import org.apache.accumulo.core.tabletserver.thrift.TSamplerConfiguration;\n+import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletClientService;\n+import org.apache.accumulo.core.tabletserver.thrift.TabletStats;\n+import org.apache.accumulo.core.trace.thrift.TInfo;\n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+import org.apache.accumulo.core.util.Daemon;\n+import org.apache.accumulo.core.util.Pair;\n+import org.apache.accumulo.fate.util.LoggingRunnable;\n+import org.apache.accumulo.fate.zookeeper.ZooLock;\n+import org.apache.accumulo.fate.zookeeper.ZooUtil;\n+import org.apache.accumulo.server.client.ClientServiceHandler;\n+import org.apache.accumulo.server.conf.TableConfiguration;\n+import org.apache.accumulo.server.data.ServerMutation;\n+import org.apache.accumulo.server.fs.VolumeManager;\n+import org.apache.accumulo.server.master.tableOps.UserCompactionConfig;\n+import org.apache.accumulo.server.rpc.TServerUtils;\n+import org.apache.accumulo.server.security.SecurityOperation;\n+import org.apache.accumulo.server.util.Halt;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher;\n+import org.apache.accumulo.tserver.ConditionCheckerContext.ConditionChecker;\n+import org.apache.accumulo.tserver.RowLocks.RowLock;\n+import org.apache.accumulo.tserver.data.ServerConditionalMutation;\n+import org.apache.accumulo.tserver.log.TabletServerLogger;\n+import org.apache.accumulo.tserver.metrics.TabletServerScanMetrics;\n+import org.apache.accumulo.tserver.metrics.TabletServerUpdateMetrics;\n+import org.apache.accumulo.tserver.scan.LookupTask;\n+import org.apache.accumulo.tserver.scan.NextBatchTask;\n+import org.apache.accumulo.tserver.scan.ScanParameters;\n+import org.apache.accumulo.tserver.session.ConditionalSession;\n+import org.apache.accumulo.tserver.session.MultiScanSession;\n+import org.apache.accumulo.tserver.session.SessionManager;\n+import org.apache.accumulo.tserver.session.SingleScanSession;\n+import org.apache.accumulo.tserver.session.SummarySession;\n+import org.apache.accumulo.tserver.session.UpdateSession;\n+import org.apache.accumulo.tserver.tablet.CommitSession;\n+import org.apache.accumulo.tserver.tablet.CompactionInfo;\n+import org.apache.accumulo.tserver.tablet.Compactor;\n+import org.apache.accumulo.tserver.tablet.KVEntry;\n+import org.apache.accumulo.tserver.tablet.PreparedMutations;\n+import org.apache.accumulo.tserver.tablet.ScanBatch;\n+import org.apache.accumulo.tserver.tablet.Tablet;\n+import org.apache.accumulo.tserver.tablet.TabletClosedException;\n+import org.apache.hadoop.fs.FSError;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.io.Text;\n+import org.apache.htrace.Trace;\n+import org.apache.htrace.TraceScope;\n+import org.apache.thrift.TException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Collections2;\n+\n+public class ThriftClientHandler extends ClientServiceHandler implements TabletClientService.Iface {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ThriftClientHandler.class);\n+  private static final long MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS = 1000;\n+  private static final long RECENTLY_SPLIT_MILLIES = 60 * 1000;\n+  private final TabletServer server;\n+  private final WriteTracker writeTracker = new WriteTracker();\n+  private final RowLocks rowLocks = new RowLocks();\n+  private final TransactionWatcher watcher;\n+  private final VolumeManager fs;\n+  private final SecurityOperation security;\n+  private final SessionManager sessionManager;\n+  private final TabletServerUpdateMetrics updateMetrics;\n+  private final TabletServerScanMetrics scanMetrics;\n+  private final TabletServerLogger logger;\n+\n+  public ThriftClientHandler(TabletServer server) {\n+    super(server.getContext(), server.getWatcher(), server.getFileSystem());\n+    this.server = server;\n+    this.watcher = server.getWatcher();\n+    this.fs = server.getFileSystem();\n+    this.security = server.getSecurity();\n+    this.sessionManager = server.getSessionManager();\n+    this.updateMetrics = server.getUpdateMetrics();\n+    this.scanMetrics = server.getScanMetrics();\n+    this.logger = server.getLogger();\n+    log.debug(\"{} created\", ThriftClientHandler.class.getName());\n+  }\n+\n+  @Override\n+  public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n+      final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n+      throws ThriftSecurityException {\n+\n+    if (!security.canPerformSystemActions(credentials)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+\n+    try {\n+      return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n+        List<TKeyExtent> failures = new ArrayList<>();\n+\n+        for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n+          TKeyExtent tke = entry.getKey();\n+          Map<String,MapFileInfo> fileMap = entry.getValue();\n+          Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n+          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n+            Path path = new Path(mapping.getKey());\n+            FileSystem ns = fs.getFileSystemByPath(path);\n+            path = ns.makeQualified(path);\n+            fileRefMap.put(new TabletFile(path), mapping.getValue());\n+          }\n+\n+          Tablet importTablet = server.getOnlineTablet(new KeyExtent(tke));\n+\n+          if (importTablet == null) {\n+            failures.add(tke);\n+          } else {\n+            try {\n+              importTablet.importMapFiles(tid, fileRefMap, setTime);\n+            } catch (IOException ioe) {\n+              log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n+                  ioe.getMessage());\n+              failures.add(tke);\n+            }\n+          }\n+        }\n+        return failures;\n+      });\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n+      Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n+      throws ThriftSecurityException {\n+    if (!security.canPerformSystemActions(credentials)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+\n+    watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n+      tabletImports.forEach((tke, fileMap) -> {\n+        Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n+        for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n+          Path path = new Path(dir, mapping.getKey());\n+          FileSystem ns = fs.getFileSystemByPath(path);\n+          path = ns.makeQualified(path);\n+          newFileMap.put(new TabletFile(path), mapping.getValue());\n+        }\n+\n+        Tablet importTablet = server.getOnlineTablet(new KeyExtent(tke));\n+\n+        if (importTablet != null) {\n+          try {\n+            importTablet.importMapFiles(tid, newFileMap, setTime);\n+          } catch (IOException ioe) {\n+            log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n+                ioe.getMessage());\n+          }\n+        }\n+      });\n+    });\n+\n+  }\n+\n+  private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n+    if (extent.isRootTablet() || extent.isMeta()) {\n+      // dispatcher is only for user tables\n+      return null;\n+    }\n+\n+    return server.getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n+  }\n+\n+  @Override\n+  public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n+      TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n+      Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n+      boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n+      long batchTimeOut, String contextArg, Map<String,String> executionHints)\n+      throws NotServingTabletException, ThriftSecurityException,\n+      org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n+      TSampleNotPresentException {\n+\n+    TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n+    NamespaceId namespaceId;\n+    try {\n+      namespaceId = Tables.getNamespaceId(server.getContext(), tableId);\n+    } catch (TableNotFoundException e1) {\n+      throw new NotServingTabletException(textent);\n+    }\n+    if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n+        authorizations)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+\n+    if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.BAD_AUTHORIZATIONS);\n+    }\n+\n+    final KeyExtent extent = new KeyExtent(textent);\n+\n+    // wait for any writes that are in flight.. this done to ensure\n+    // consistency across client restarts... assume a client writes\n+    // to accumulo and dies while waiting for a confirmation from\n+    // accumulo... the client process restarts and tries to read\n+    // data from accumulo making the assumption that it will get\n+    // any writes previously made... however if the server side thread\n+    // processing the write from the dead client is still in progress,\n+    // the restarted client may not see the write unless we wait here.\n+    // this behavior is very important when the client is reading the\n+    // metadata\n+    if (waitForWrites) {\n+      writeTracker.waitForWrites(TabletType.type(extent));\n+    }\n+\n+    Tablet tablet = server.getOnlineTablet(extent);\n+    if (tablet == null) {\n+      throw new NotServingTabletException(textent);\n+    }\n+\n+    HashSet<Column> columnSet = new HashSet<>();\n+    for (TColumn tcolumn : columns) {\n+      columnSet.add(new Column(tcolumn));\n+    }\n+\n+    ScanParameters scanParams = new ScanParameters(batchSize, new Authorizations(authorizations),\n+        columnSet, ssiList, ssio, isolated, SamplerConfigurationImpl.fromThrift(tSamplerConfig),\n+        batchTimeOut, contextArg);\n+\n+    final SingleScanSession scanSession =\n+        new SingleScanSession(credentials, extent, scanParams, readaheadThreshold, executionHints);\n+    scanSession.scanner =\n+        tablet.createScanner(new Range(range), scanParams, scanSession.interruptFlag);\n+\n+    long sid = sessionManager.createSession(scanSession, true);\n+\n+    ScanResult scanResult;\n+    try {\n+      scanResult = continueScan(tinfo, sid, scanSession);\n+    } catch (NoSuchScanIDException e) {\n+      log.error(\"The impossible happened\", e);\n+      throw new RuntimeException();\n+    } finally {\n+      sessionManager.unreserveSession(sid);\n+    }\n+\n+    return new InitialScan(sid, scanResult);\n+  }\n+\n+  @Override\n+  public ScanResult continueScan(TInfo tinfo, long scanID) throws NoSuchScanIDException,\n+      NotServingTabletException, org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n+      TSampleNotPresentException {\n+    SingleScanSession scanSession = (SingleScanSession) sessionManager.reserveSession(scanID);\n+    if (scanSession == null) {\n+      throw new NoSuchScanIDException();\n+    }\n+\n+    try {\n+      return continueScan(tinfo, scanID, scanSession);\n+    } finally {\n+      sessionManager.unreserveSession(scanSession);\n+    }\n+  }\n+\n+  private ScanResult continueScan(TInfo tinfo, long scanID, SingleScanSession scanSession)\n+      throws NoSuchScanIDException, NotServingTabletException,\n+      org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n+      TSampleNotPresentException {\n+\n+    if (scanSession.nextBatchTask == null) {\n+      scanSession.nextBatchTask = new NextBatchTask(server, scanID, scanSession.interruptFlag);\n+      server.getResourceManager().executeReadAhead(scanSession.extent,\n+          getScanDispatcher(scanSession.extent), scanSession, scanSession.nextBatchTask);\n+    }\n+\n+    ScanBatch bresult;\n+    try {\n+      bresult = scanSession.nextBatchTask.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS,\n+          TimeUnit.MILLISECONDS);\n+      scanSession.nextBatchTask = null;\n+    } catch (ExecutionException e) {\n+      sessionManager.removeSession(scanID);\n+      if (e.getCause() instanceof NotServingTabletException) {\n+        throw (NotServingTabletException) e.getCause();\n+      } else if (e.getCause() instanceof TooManyFilesException) {\n+        throw new org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException(\n+            scanSession.extent.toThrift());\n+      } else if (e.getCause() instanceof SampleNotPresentException) {\n+        throw new TSampleNotPresentException(scanSession.extent.toThrift());\n+      } else if (e.getCause() instanceof IOException) {\n+        sleepUninterruptibly(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n+        List<KVEntry> empty = Collections.emptyList();\n+        bresult = new ScanBatch(empty, true);\n+        scanSession.nextBatchTask = null;\n+      } else {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (CancellationException ce) {\n+      sessionManager.removeSession(scanID);\n+      Tablet tablet = server.getOnlineTablet(scanSession.extent);\n+      if (tablet == null || tablet.isClosed()) {\n+        throw new NotServingTabletException(scanSession.extent.toThrift());\n+      } else {\n+        throw new NoSuchScanIDException();\n+      }\n+    } catch (TimeoutException e) {\n+      List<TKeyValue> param = Collections.emptyList();\n+      long timeout = server.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n+      sessionManager.removeIfNotAccessed(scanID, timeout);\n+      return new ScanResult(param, true);\n+    } catch (Throwable t) {\n+      sessionManager.removeSession(scanID);\n+      log.warn(\"Failed to get next batch\", t);\n+      throw new RuntimeException(t);\n+    }\n+\n+    ScanResult scanResult = new ScanResult(Key.compress(bresult.getResults()), bresult.isMore());\n+\n+    scanSession.entriesReturned += scanResult.results.size();\n+\n+    scanSession.batchCount++;\n+\n+    if (scanResult.more && scanSession.batchCount > scanSession.readaheadThreshold) {\n+      // start reading next batch while current batch is transmitted\n+      // to client\n+      scanSession.nextBatchTask = new NextBatchTask(server, scanID, scanSession.interruptFlag);\n+      server.getResourceManager().executeReadAhead(scanSession.extent,\n+          getScanDispatcher(scanSession.extent), scanSession, scanSession.nextBatchTask);\n+    }\n+\n+    if (!scanResult.more) {\n+      closeScan(tinfo, scanID);\n+    }\n+\n+    return scanResult;\n+  }\n+\n+  @Override\n+  public void closeScan(TInfo tinfo, long scanID) {\n+    final SingleScanSession ss = (SingleScanSession) sessionManager.removeSession(scanID);\n+    if (ss != null) {\n+      long t2 = System.currentTimeMillis();\n+\n+      if (log.isTraceEnabled()) {\n+        log.trace(String.format(\"ScanSess tid %s %s %,d entries in %.2f secs, nbTimes = [%s] \",\n+            TServerUtils.clientAddress.get(), ss.extent.getTableId(), ss.entriesReturned,\n+            (t2 - ss.startTime) / 1000.0, ss.runStats.toString()));\n+      }\n+\n+      scanMetrics.addScan(t2 - ss.startTime);\n+      scanMetrics.addResult(ss.entriesReturned);\n+    }\n+  }\n+\n+  @Override\n+  public InitialMultiScan startMultiScan(TInfo tinfo, TCredentials credentials,\n+      Map<TKeyExtent,List<TRange>> tbatch, List<TColumn> tcolumns, List<IterInfo> ssiList,\n+      Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n+      TSamplerConfiguration tSamplerConfig, long batchTimeOut, String contextArg,\n+      Map<String,String> executionHints)\n+      throws ThriftSecurityException, TSampleNotPresentException {\n+    // find all of the tables that need to be scanned\n+    final HashSet<TableId> tables = new HashSet<>();\n+    for (TKeyExtent keyExtent : tbatch.keySet()) {\n+      tables.add(TableId.of(new String(keyExtent.getTable(), UTF_8)));\n+    }\n+\n+    if (tables.size() != 1) {\n+      throw new IllegalArgumentException(\"Cannot batch scan over multiple tables\");\n+    }\n+\n+    // check if user has permission to the tables\n+    for (TableId tableId : tables) {\n+      NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n+      if (!security.canScan(credentials, tableId, namespaceId, tbatch, tcolumns, ssiList, ssio,\n+          authorizations)) {\n+        throw new ThriftSecurityException(credentials.getPrincipal(),\n+            SecurityErrorCode.PERMISSION_DENIED);\n+      }\n+    }\n+\n+    try {\n+      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n+        throw new ThriftSecurityException(credentials.getPrincipal(),\n+            SecurityErrorCode.BAD_AUTHORIZATIONS);\n+      }\n+    } catch (ThriftSecurityException tse) {\n+      log.error(\"{} is not authorized\", credentials.getPrincipal(), tse);\n+      throw tse;\n+    }\n+    Map<KeyExtent,List<Range>> batch = Translator.translate(tbatch, new TKeyExtentTranslator(),\n+        new Translator.ListTranslator<>(new TRangeTranslator()));\n+\n+    // This is used to determine which thread pool to use\n+    KeyExtent threadPoolExtent = batch.keySet().iterator().next();\n+\n+    if (waitForWrites) {\n+      writeTracker.waitForWrites(TabletType.type(batch.keySet()));\n+    }\n+\n+    Set<Column> columnSet = tcolumns.isEmpty() ? Collections.emptySet()\n+        : new HashSet<>(Collections2.transform(tcolumns, Column::new));\n+\n+    ScanParameters scanParams =\n+        new ScanParameters(-1, new Authorizations(authorizations), columnSet, ssiList, ssio, false,\n+            SamplerConfigurationImpl.fromThrift(tSamplerConfig), batchTimeOut, contextArg);\n+\n+    final MultiScanSession mss =\n+        new MultiScanSession(credentials, threadPoolExtent, batch, scanParams, executionHints);\n+\n+    mss.numTablets = batch.size();\n+    for (List<Range> ranges : batch.values()) {\n+      mss.numRanges += ranges.size();\n+    }\n+\n+    long sid = sessionManager.createSession(mss, true);\n+\n+    MultiScanResult result;\n+    try {\n+      result = continueMultiScan(sid, mss);\n+    } finally {\n+      sessionManager.unreserveSession(sid);\n+    }\n+\n+    return new InitialMultiScan(sid, result);\n+  }\n+\n+  @Override\n+  public MultiScanResult continueMultiScan(TInfo tinfo, long scanID)\n+      throws NoSuchScanIDException, TSampleNotPresentException {\n+\n+    MultiScanSession session = (MultiScanSession) sessionManager.reserveSession(scanID);\n+\n+    if (session == null) {\n+      throw new NoSuchScanIDException();\n+    }\n+\n+    try {\n+      return continueMultiScan(scanID, session);\n+    } finally {\n+      sessionManager.unreserveSession(session);\n+    }\n+  }\n+\n+  private MultiScanResult continueMultiScan(long scanID, MultiScanSession session)\n+      throws TSampleNotPresentException {\n+\n+    if (session.lookupTask == null) {\n+      session.lookupTask = new LookupTask(server, scanID);\n+      server.getResourceManager().executeReadAhead(session.threadPoolExtent,\n+          getScanDispatcher(session.threadPoolExtent), session, session.lookupTask);\n+    }\n+\n+    try {\n+      MultiScanResult scanResult =\n+          session.lookupTask.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n+      session.lookupTask = null;\n+      return scanResult;\n+    } catch (ExecutionException e) {\n+      sessionManager.removeSession(scanID);\n+      if (e.getCause() instanceof SampleNotPresentException) {\n+        throw new TSampleNotPresentException();\n+      } else {\n+        log.warn(\"Failed to get multiscan result\", e);\n+        throw new RuntimeException(e);\n+      }\n+    } catch (TimeoutException e1) {\n+      long timeout = server.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n+      sessionManager.removeIfNotAccessed(scanID, timeout);\n+      List<TKeyValue> results = Collections.emptyList();\n+      Map<TKeyExtent,List<TRange>> failures = Collections.emptyMap();\n+      List<TKeyExtent> fullScans = Collections.emptyList();\n+      return new MultiScanResult(results, failures, fullScans, null, null, false, true);\n+    } catch (Throwable t) {\n+      sessionManager.removeSession(scanID);\n+      log.warn(\"Failed to get multiscan result\", t);\n+      throw new RuntimeException(t);\n+    }\n+  }\n+\n+  @Override\n+  public void closeMultiScan(TInfo tinfo, long scanID) throws NoSuchScanIDException {\n+    MultiScanSession session = (MultiScanSession) sessionManager.removeSession(scanID);\n+    if (session == null) {\n+      throw new NoSuchScanIDException();\n+    }\n+\n+    long t2 = System.currentTimeMillis();\n+\n+    if (log.isTraceEnabled()) {\n+      log.trace(String.format(\n+          \"MultiScanSess %s %,d entries in %.2f secs\"\n+              + \" (lookup_time:%.2f secs tablets:%,d ranges:%,d) \",\n+          TServerUtils.clientAddress.get(), session.numEntries, (t2 - session.startTime) / 1000.0,\n+          session.totalLookupTime / 1000.0, session.numTablets, session.numRanges));\n+    }\n+  }\n+\n+  @Override\n+  public long startUpdate(TInfo tinfo, TCredentials credentials, TDurability tdurabilty)\n+      throws ThriftSecurityException {\n+    // Make sure user is real\n+    Durability durability = DurabilityImpl.fromThrift(tdurabilty);\n+    security.authenticateUser(credentials, credentials);\n+    updateMetrics.addPermissionErrors(0);\n+\n+    UpdateSession us =\n+        new UpdateSession(new TservConstraintEnv(server.getContext(), security, credentials),\n+            credentials, durability);\n+    return sessionManager.createSession(us, false);\n+  }\n+\n+  private void setUpdateTablet(UpdateSession us, KeyExtent keyExtent) {\n+    long t1 = System.currentTimeMillis();\n+    if (us.currentTablet != null && us.currentTablet.getExtent().equals(keyExtent)) {\n+      return;\n+    }\n+    if (us.currentTablet == null\n+        && (us.failures.containsKey(keyExtent) || us.authFailures.containsKey(keyExtent))) {\n+      // if there were previous failures, then do not accept additional writes\n+      return;\n+    }\n+\n+    TableId tableId = null;\n+    try {\n+      // if user has no permission to write to this table, add it to\n+      // the failures list\n+      boolean sameTable = us.currentTablet != null\n+          && (us.currentTablet.getExtent().getTableId().equals(keyExtent.getTableId()));\n+      tableId = keyExtent.getTableId();\n+      if (sameTable || security.canWrite(us.getCredentials(), tableId,\n+          Tables.getNamespaceId(server.getContext(), tableId))) {\n+        long t2 = System.currentTimeMillis();\n+        us.authTimes.addStat(t2 - t1);\n+        us.currentTablet = server.getOnlineTablet(keyExtent);\n+        if (us.currentTablet != null) {\n+          us.queuedMutations.put(us.currentTablet, new ArrayList<>());\n+        } else {\n+          // not serving tablet, so report all mutations as\n+          // failures\n+          us.failures.put(keyExtent, 0L);\n+          updateMetrics.addUnknownTabletErrors(0);\n+        }\n+      } else {\n+        log.warn(\"Denying access to table {} for user {}\", keyExtent.getTableId(), us.getUser());\n+        long t2 = System.currentTimeMillis();\n+        us.authTimes.addStat(t2 - t1);\n+        us.currentTablet = null;\n+        us.authFailures.put(keyExtent, SecurityErrorCode.PERMISSION_DENIED);\n+        updateMetrics.addPermissionErrors(0);\n+        return;\n+      }\n+    } catch (TableNotFoundException tnfe) {\n+      log.error(\"Table \" + tableId + \" not found \", tnfe);\n+      long t2 = System.currentTimeMillis();\n+      us.authTimes.addStat(t2 - t1);\n+      us.currentTablet = null;\n+      us.authFailures.put(keyExtent, SecurityErrorCode.TABLE_DOESNT_EXIST);\n+      updateMetrics.addUnknownTabletErrors(0);\n+      return;\n+    } catch (ThriftSecurityException e) {\n+      log.error(\"Denying permission to check user \" + us.getUser() + \" with user \" + e.getUser(),\n+          e);\n+      long t2 = System.currentTimeMillis();\n+      us.authTimes.addStat(t2 - t1);\n+      us.currentTablet = null;\n+      us.authFailures.put(keyExtent, e.getCode());\n+      updateMetrics.addPermissionErrors(0);\n+      return;\n+    }\n+  }\n+\n+  @Override\n+  public void applyUpdates(TInfo tinfo, long updateID, TKeyExtent tkeyExtent,\n+      List<TMutation> tmutations) {\n+    UpdateSession us = (UpdateSession) sessionManager.reserveSession(updateID);\n+    if (us == null) {\n+      return;\n+    }\n+\n+    boolean reserved = true;\n+    try {\n+      KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n+      setUpdateTablet(us, keyExtent);\n+\n+      if (us.currentTablet != null) {\n+        long additionalMutationSize = 0;\n+        List<Mutation> mutations = us.queuedMutations.get(us.currentTablet);\n+        for (TMutation tmutation : tmutations) {\n+          Mutation mutation = new ServerMutation(tmutation);\n+          mutations.add(mutation);\n+          additionalMutationSize += mutation.numBytes();\n+        }\n+        us.queuedMutationSize += additionalMutationSize;\n+        long totalQueued = server.updateTotalQueuedMutationSize(additionalMutationSize);\n+        long total = server.getConfiguration().getAsBytes(Property.TSERV_TOTAL_MUTATION_QUEUE_MAX);\n+        if (totalQueued > total) {\n+          try {\n+            flush(us);\n+          } catch (HoldTimeoutException hte) {\n+            // Assumption is that the client has timed out and is gone. If that's not the case,\n+            // then removing the session should cause the client to fail\n+            // in such a way that it retries.\n+            log.debug(\"HoldTimeoutException during applyUpdates, removing session\");\n+            sessionManager.removeSession(updateID, true);\n+            reserved = false;\n+          }\n+        }\n+      }\n+    } finally {\n+      if (reserved) {\n+        sessionManager.unreserveSession(us);\n+      }\n+    }\n+  }\n+\n+  private void flush(UpdateSession us) {\n+\n+    int mutationCount = 0;\n+    Map<CommitSession,List<Mutation>> sendables = new HashMap<>();\n+    Map<CommitSession,TabletMutations> loggables = new HashMap<>();\n+    Throwable error = null;\n+\n+    long pt1 = System.currentTimeMillis();\n+\n+    boolean containsMetadataTablet = false;\n+    for (Tablet tablet : us.queuedMutations.keySet()) {\n+      if (tablet.getExtent().isMeta()) {\n+        containsMetadataTablet = true;\n+      }\n+    }\n+\n+    if (!containsMetadataTablet && us.queuedMutations.size() > 0) {\n+      server.getResourceManager().waitUntilCommitsAreEnabled();\n+    }\n+\n+    try (TraceScope prep = Trace.startSpan(\"prep\")) {\n+      for (Entry<Tablet,? extends List<Mutation>> entry : us.queuedMutations.entrySet()) {\n+\n+        Tablet tablet = entry.getKey();\n+        Durability durability =\n+            DurabilityImpl.resolveDurabilty(us.durability, tablet.getDurability());\n+        List<Mutation> mutations = entry.getValue();\n+        if (mutations.size() > 0) {\n+          try {\n+            updateMetrics.addMutationArraySize(mutations.size());\n+\n+            PreparedMutations prepared = tablet.prepareMutationsForCommit(us.cenv, mutations);\n+\n+            if (prepared.tabletClosed()) {\n+              if (us.currentTablet == tablet) {\n+                us.currentTablet = null;\n+              }\n+              us.failures.put(tablet.getExtent(), us.successfulCommits.get(tablet));\n+            } else {\n+              if (!prepared.getNonViolators().isEmpty()) {\n+                List<Mutation> validMutations = prepared.getNonViolators();\n+                CommitSession session = prepared.getCommitSession();\n+                if (durability != Durability.NONE) {\n+                  loggables.put(session, new TabletMutations(session, validMutations, durability));\n+                }\n+                sendables.put(session, validMutations);\n+              }\n+\n+              if (!prepared.getViolations().isEmpty()) {\n+                us.violations.add(prepared.getViolations());\n+                updateMetrics.addConstraintViolations(0);\n+              }\n+              // Use the size of the original mutation list, regardless of how many mutations\n+              // did not violate constraints.\n+              mutationCount += mutations.size();\n+\n+            }\n+          } catch (Throwable t) {\n+            error = t;\n+            log.error(\"Unexpected error preparing for commit\", error);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+\n+    long pt2 = System.currentTimeMillis();\n+    us.prepareTimes.addStat(pt2 - pt1);\n+    updateAvgPrepTime(pt2 - pt1, us.queuedMutations.size());\n+\n+    if (error != null) {\n+      sendables.forEach((commitSession, value) -> commitSession.abortCommit());\n+      throw new RuntimeException(error);\n+    }\n+    try {\n+      try (TraceScope wal = Trace.startSpan(\"wal\")) {\n+        while (true) {\n+          try {\n+            long t1 = System.currentTimeMillis();\n+\n+            logger.logManyTablets(loggables);\n+\n+            long t2 = System.currentTimeMillis();\n+            us.walogTimes.addStat(t2 - t1);\n+            updateWalogWriteTime((t2 - t1));\n+            break;\n+          } catch (IOException | FSError ex) {\n+            log.warn(\"logging mutations failed, retrying\");\n+          } catch (Throwable t) {\n+            log.error(\"Unknown exception logging mutations, counts\"\n+                + \" for mutations in flight not decremented!\", t);\n+            throw new RuntimeException(t);\n+          }\n+        }\n+      }\n+\n+      try (TraceScope commit = Trace.startSpan(\"commit\")) {\n+        long t1 = System.currentTimeMillis();\n+        sendables.forEach((commitSession, mutations) -> {\n+          commitSession.commit(mutations);\n+          KeyExtent extent = commitSession.getExtent();\n+\n+          if (us.currentTablet != null && extent == us.currentTablet.getExtent()) {\n+            // because constraint violations may filter out some\n+            // mutations, for proper accounting with the client code,\n+            // need to increment the count based on the original\n+            // number of mutations from the client NOT the filtered number\n+            us.successfulCommits.increment(us.currentTablet,\n+                us.queuedMutations.get(us.currentTablet).size());\n+          }\n+        });\n+        long t2 = System.currentTimeMillis();\n+\n+        us.flushTime += (t2 - pt1);\n+        us.commitTimes.addStat(t2 - t1);\n+\n+        updateAvgCommitTime(t2 - t1, sendables.size());\n+      }\n+    } finally {\n+      us.queuedMutations.clear();\n+      if (us.currentTablet != null) {\n+        us.queuedMutations.put(us.currentTablet, new ArrayList<>());\n+      }\n+      server.updateTotalQueuedMutationSize(-us.queuedMutationSize);\n+      us.queuedMutationSize = 0;\n+    }\n+    us.totalUpdates += mutationCount;\n+  }\n+\n+  private void updateWalogWriteTime(long time) {\n+    updateMetrics.addWalogWriteTime(time);\n+  }\n+\n+  private void updateAvgCommitTime(long time, int size) {\n+    if (size > 0)\n+      updateMetrics.addCommitTime((long) (time / (double) size));\n+  }\n+\n+  private void updateAvgPrepTime(long time, int size) {\n+    if (size > 0)\n+      updateMetrics.addCommitPrep((long) (time / (double) size));\n+  }\n+\n+  @Override\n+  public UpdateErrors closeUpdate(TInfo tinfo, long updateID) throws NoSuchScanIDException {\n+    final UpdateSession us = (UpdateSession) sessionManager.removeSession(updateID);\n+    if (us == null) {\n+      throw new NoSuchScanIDException();\n+    }\n+\n+    // clients may or may not see data from an update session while\n+    // it is in progress, however when the update session is closed\n+    // want to ensure that reads wait for the write to finish\n+    long opid = writeTracker.startWrite(us.queuedMutations.keySet());\n+\n+    try {\n+      flush(us);\n+    } catch (HoldTimeoutException e) {\n+      // Assumption is that the client has timed out and is gone. If that's not the case throw an\n+      // exception that will cause it to retry.\n+      log.debug(\"HoldTimeoutException during closeUpdate, reporting no such session\");\n+      throw new NoSuchScanIDException();\n+    } finally {\n+      writeTracker.finishWrite(opid);\n+    }\n+\n+    if (log.isTraceEnabled()) {\n+      log.trace(\n+          String.format(\"UpSess %s %,d in %.3fs, at=[%s] ft=%.3fs(pt=%.3fs lt=%.3fs ct=%.3fs)\",\n+              TServerUtils.clientAddress.get(), us.totalUpdates,\n+              (System.currentTimeMillis() - us.startTime) / 1000.0, us.authTimes.toString(),\n+              us.flushTime / 1000.0, us.prepareTimes.sum() / 1000.0, us.walogTimes.sum() / 1000.0,\n+              us.commitTimes.sum() / 1000.0));\n+    }\n+    if (us.failures.size() > 0) {\n+      Entry<KeyExtent,Long> first = us.failures.entrySet().iterator().next();\n+      log.debug(String.format(\"Failures: %d, first extent %s successful commits: %d\",\n+          us.failures.size(), first.getKey().toString(), first.getValue()));\n+    }\n+    List<ConstraintViolationSummary> violations = us.violations.asList();\n+    if (violations.size() > 0) {\n+      ConstraintViolationSummary first = us.violations.asList().iterator().next();\n+      log.debug(String.format(\"Violations: %d, first %s occurs %d\", violations.size(),\n+          first.violationDescription, first.numberOfViolatingMutations));\n+    }\n+    if (us.authFailures.size() > 0) {\n+      KeyExtent first = us.authFailures.keySet().iterator().next();\n+      log.debug(String.format(\"Authentication Failures: %d, first %s\", us.authFailures.size(),\n+          first.toString()));\n+    }\n+\n+    return new UpdateErrors(Translator.translate(us.failures, Translators.KET),\n+        Translator.translate(violations, Translators.CVST),\n+        Translator.translate(us.authFailures, Translators.KET));\n+  }\n+\n+  @Override\n+  public void update(TInfo tinfo, TCredentials credentials, TKeyExtent tkeyExtent,\n+      TMutation tmutation, TDurability tdurability)\n+      throws NotServingTabletException, ConstraintViolationException, ThriftSecurityException {\n+\n+    final TableId tableId = TableId.of(new String(tkeyExtent.getTable(), UTF_8));\n+    NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n+    if (!security.canWrite(credentials, tableId, namespaceId)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+    final KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n+    final Tablet tablet = server.getOnlineTablet(new KeyExtent(keyExtent));\n+    if (tablet == null) {\n+      throw new NotServingTabletException(tkeyExtent);\n+    }\n+    Durability tabletDurability = tablet.getDurability();\n+\n+    if (!keyExtent.isMeta()) {\n+      try {\n+        server.getResourceManager().waitUntilCommitsAreEnabled();\n+      } catch (HoldTimeoutException hte) {\n+        // Major hack. Assumption is that the client has timed out and is gone. If that's not the\n+        // case, then throwing the following will let client know there\n+        // was a failure and it should retry.\n+        throw new NotServingTabletException(tkeyExtent);\n+      }\n+    }\n+\n+    final long opid = writeTracker.startWrite(TabletType.type(keyExtent));\n+\n+    try {\n+      final Mutation mutation = new ServerMutation(tmutation);\n+      final List<Mutation> mutations = Collections.singletonList(mutation);\n+\n+      PreparedMutations prepared;\n+      try (TraceScope prep = Trace.startSpan(\"prep\")) {\n+        prepared = tablet.prepareMutationsForCommit(\n+            new TservConstraintEnv(server.getContext(), security, credentials), mutations);\n+      }\n+\n+      if (prepared.tabletClosed()) {\n+        throw new NotServingTabletException(tkeyExtent);\n+      } else if (!prepared.getViolators().isEmpty()) {\n+        throw new ConstraintViolationException(\n+            Translator.translate(prepared.getViolations().asList(), Translators.CVST));\n+      } else {\n+        CommitSession session = prepared.getCommitSession();\n+        Durability durability = DurabilityImpl\n+            .resolveDurabilty(DurabilityImpl.fromThrift(tdurability), tabletDurability);\n+\n+        // Instead of always looping on true, skip completely when durability is NONE.\n+        while (durability != Durability.NONE) {\n+          try {\n+            try (TraceScope wal = Trace.startSpan(\"wal\")) {\n+              logger.log(session, mutation, durability);\n+            }\n+            break;\n+          } catch (IOException ex) {\n+            log.warn(\"Error writing mutations to log\", ex);\n+          }\n+        }\n+\n+        try (TraceScope commit = Trace.startSpan(\"commit\")) {\n+          session.commit(mutations);\n+        }\n+      }\n+    } finally {\n+      writeTracker.finishWrite(opid);\n+    }\n+  }\n+\n+  private NamespaceId getNamespaceId(TCredentials credentials, TableId tableId)\n+      throws ThriftSecurityException {\n+    try {\n+      return Tables.getNamespaceId(server.getContext(), tableId);\n+    } catch (TableNotFoundException e1) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.TABLE_DOESNT_EXIST);\n+    }\n+  }\n+\n+  private void checkConditions(Map<KeyExtent,List<ServerConditionalMutation>> updates,\n+      ArrayList<TCMResult> results, ConditionalSession cs, List<String> symbols)\n+      throws IOException {\n+    Iterator<Entry<KeyExtent,List<ServerConditionalMutation>>> iter = updates.entrySet().iterator();\n+\n+    final CompressedIterators compressedIters = new CompressedIterators(symbols);\n+    ConditionCheckerContext checkerContext = new ConditionCheckerContext(server.getContext(),\n+        compressedIters, server.getContext().getTableConfiguration(cs.tableId));\n+\n+    while (iter.hasNext()) {\n+      final Entry<KeyExtent,List<ServerConditionalMutation>> entry = iter.next();\n+      final Tablet tablet = server.getOnlineTablet(entry.getKey());\n+\n+      if (tablet == null || tablet.isClosed()) {\n+        for (ServerConditionalMutation scm : entry.getValue()) {\n+          results.add(new TCMResult(scm.getID(), TCMStatus.IGNORED));\n+        }\n+        iter.remove();\n+      } else {\n+        final List<ServerConditionalMutation> okMutations =\n+            new ArrayList<>(entry.getValue().size());\n+        final List<TCMResult> resultsSubList = results.subList(results.size(), results.size());\n+\n+        ConditionChecker checker =\n+            checkerContext.newChecker(entry.getValue(), okMutations, resultsSubList);\n+        try {\n+          tablet.checkConditions(checker, cs.auths, cs.interruptFlag);\n+\n+          if (okMutations.size() > 0) {\n+            entry.setValue(okMutations);\n+          } else {\n+            iter.remove();\n+          }\n+        } catch (TabletClosedException | IterationInterruptedException | TooManyFilesException e) {\n+          // clear anything added while checking conditions.\n+          resultsSubList.clear();\n+\n+          for (ServerConditionalMutation scm : entry.getValue()) {\n+            results.add(new TCMResult(scm.getID(), TCMStatus.IGNORED));\n+          }\n+          iter.remove();\n+        }\n+      }\n+    }\n+  }\n+\n+  private void writeConditionalMutations(Map<KeyExtent,List<ServerConditionalMutation>> updates,\n+      ArrayList<TCMResult> results, ConditionalSession sess) {\n+    Set<Entry<KeyExtent,List<ServerConditionalMutation>>> es = updates.entrySet();\n+\n+    Map<CommitSession,List<Mutation>> sendables = new HashMap<>();\n+    Map<CommitSession,TabletMutations> loggables = new HashMap<>();\n+\n+    boolean sessionCanceled = sess.interruptFlag.get();\n+\n+    try (TraceScope prepSpan = Trace.startSpan(\"prep\")) {\n+      long t1 = System.currentTimeMillis();\n+      for (Entry<KeyExtent,List<ServerConditionalMutation>> entry : es) {\n+        final Tablet tablet = server.getOnlineTablet(entry.getKey());\n+        if (tablet == null || tablet.isClosed() || sessionCanceled) {\n+          addMutationsAsTCMResults(results, entry.getValue(), TCMStatus.IGNORED);\n+        } else {\n+          final Durability durability =\n+              DurabilityImpl.resolveDurabilty(sess.durability, tablet.getDurability());\n+\n+          @SuppressWarnings(\"unchecked\")\n+          List<Mutation> mutations = (List<Mutation>) (List<? extends Mutation>) entry.getValue();\n+          if (!mutations.isEmpty()) {\n+\n+            PreparedMutations prepared = tablet.prepareMutationsForCommit(\n+                new TservConstraintEnv(server.getContext(), security, sess.credentials), mutations);\n+\n+            if (prepared.tabletClosed()) {\n+              addMutationsAsTCMResults(results, mutations, TCMStatus.IGNORED);\n+            } else {\n+              if (!prepared.getNonViolators().isEmpty()) {\n+                // Only log and commit mutations that did not violate constraints.\n+                List<Mutation> validMutations = prepared.getNonViolators();\n+                addMutationsAsTCMResults(results, validMutations, TCMStatus.ACCEPTED);\n+                CommitSession session = prepared.getCommitSession();\n+                if (durability != Durability.NONE) {\n+                  loggables.put(session, new TabletMutations(session, validMutations, durability));\n+                }\n+                sendables.put(session, validMutations);\n+              }\n+\n+              if (!prepared.getViolators().isEmpty()) {\n+                addMutationsAsTCMResults(results, prepared.getViolators(), TCMStatus.VIOLATED);\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      long t2 = System.currentTimeMillis();\n+      updateAvgPrepTime(t2 - t1, es.size());\n+    }\n+\n+    try (TraceScope walSpan = Trace.startSpan(\"wal\")) {\n+      while (loggables.size() > 0) {\n+        try {\n+          long t1 = System.currentTimeMillis();\n+          logger.logManyTablets(loggables);\n+          long t2 = System.currentTimeMillis();\n+          updateWalogWriteTime(t2 - t1);\n+          break;\n+        } catch (IOException | FSError ex) {\n+          log.warn(\"logging mutations failed, retrying\");\n+        } catch (Throwable t) {\n+          log.error(\"Unknown exception logging mutations, counts for\"\n+              + \" mutations in flight not decremented!\", t);\n+          throw new RuntimeException(t);\n+        }\n+      }\n+    }\n+\n+    try (TraceScope commitSpan = Trace.startSpan(\"commit\")) {\n+      long t1 = System.currentTimeMillis();\n+      sendables.forEach(CommitSession::commit);\n+      long t2 = System.currentTimeMillis();\n+      updateAvgCommitTime(t2 - t1, sendables.size());\n+    }\n+  }\n+\n+  /**\n+   * Transform and add each mutation as a {@link TCMResult} with the mutation's ID and the specified\n+   * status to the {@link TCMResult} list.\n+   */\n+  private void addMutationsAsTCMResults(final List<TCMResult> list,\n+      final Collection<? extends Mutation> mutations, final TCMStatus status) {\n+    mutations.stream()\n+        .map(mutation -> new TCMResult(((ServerConditionalMutation) mutation).getID(), status))\n+        .forEach(list::add);\n+  }\n+\n+  private Map<KeyExtent,List<ServerConditionalMutation>> conditionalUpdate(ConditionalSession cs,\n+      Map<KeyExtent,List<ServerConditionalMutation>> updates, ArrayList<TCMResult> results,\n+      List<String> symbols) throws IOException {\n+    // sort each list of mutations, this is done to avoid deadlock and doing seeks in order is\n+    // more efficient and detect duplicate rows.\n+    ConditionalMutationSet.sortConditionalMutations(updates);\n+\n+    Map<KeyExtent,List<ServerConditionalMutation>> deferred = new HashMap<>();\n+\n+    // can not process two mutations for the same row, because one will not see what the other\n+    // writes\n+    ConditionalMutationSet.deferDuplicatesRows(updates, deferred);\n+\n+    // get as many locks as possible w/o blocking... defer any rows that are locked\n+    List<RowLock> locks = rowLocks.acquireRowlocks(updates, deferred);\n+    try {\n+      try (TraceScope checkSpan = Trace.startSpan(\"Check conditions\")) {\n+        checkConditions(updates, results, cs, symbols);\n+      }\n+\n+      try (TraceScope updateSpan = Trace.startSpan(\"apply conditional mutations\")) {\n+        writeConditionalMutations(updates, results, cs);\n+      }\n+    } finally {\n+      rowLocks.releaseRowLocks(locks);\n+    }\n+    return deferred;\n+  }\n+\n+  @Override\n+  public TConditionalSession startConditionalUpdate(TInfo tinfo, TCredentials credentials,\n+      List<ByteBuffer> authorizations, String tableIdStr, TDurability tdurabilty,\n+      String classLoaderContext) throws ThriftSecurityException, TException {\n+\n+    TableId tableId = TableId.of(tableIdStr);\n+    Authorizations userauths = null;\n+    NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n+    if (!security.canConditionallyUpdate(credentials, tableId, namespaceId)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+\n+    userauths = security.getUserAuthorizations(credentials);\n+    for (ByteBuffer auth : authorizations) {\n+      if (!userauths.contains(ByteBufferUtil.toBytes(auth))) {\n+        throw new ThriftSecurityException(credentials.getPrincipal(),\n+            SecurityErrorCode.BAD_AUTHORIZATIONS);\n+      }\n+    }\n+\n+    ConditionalSession cs = new ConditionalSession(credentials, new Authorizations(authorizations),\n+        tableId, DurabilityImpl.fromThrift(tdurabilty));\n+\n+    long sid = sessionManager.createSession(cs, false);\n+    return new TConditionalSession(sid, server.getLockID(), sessionManager.getMaxIdleTime());\n+  }\n+\n+  @Override\n+  public List<TCMResult> conditionalUpdate(TInfo tinfo, long sessID,\n+      Map<TKeyExtent,List<TConditionalMutation>> mutations, List<String> symbols)\n+      throws NoSuchScanIDException, TException {\n+\n+    ConditionalSession cs = (ConditionalSession) sessionManager.reserveSession(sessID);\n+\n+    if (cs == null || cs.interruptFlag.get()) {\n+      throw new NoSuchScanIDException();\n+    }\n+\n+    if (!cs.tableId.equals(MetadataTable.ID) && !cs.tableId.equals(RootTable.ID)) {\n+      try {\n+        server.getResourceManager().waitUntilCommitsAreEnabled();\n+      } catch (HoldTimeoutException hte) {\n+        // Assumption is that the client has timed out and is gone. If that's not the case throw\n+        // an exception that will cause it to retry.\n+        log.debug(\"HoldTimeoutException during conditionalUpdate, reporting no such session\");\n+        throw new NoSuchScanIDException();\n+      }\n+    }\n+\n+    TableId tid = cs.tableId;\n+    long opid = writeTracker.startWrite(TabletType.type(new KeyExtent(tid, null, null)));\n+\n+    try {\n+      Map<KeyExtent,List<ServerConditionalMutation>> updates = Translator.translate(mutations,\n+          Translators.TKET, new Translator.ListTranslator<>(ServerConditionalMutation.TCMT));\n+\n+      for (KeyExtent ke : updates.keySet()) {\n+        if (!ke.getTableId().equals(tid)) {\n+          throw new IllegalArgumentException(\n+              \"Unexpected table id \" + tid + \" != \" + ke.getTableId());\n+        }\n+      }\n+\n+      ArrayList<TCMResult> results = new ArrayList<>();\n+\n+      Map<KeyExtent,List<ServerConditionalMutation>> deferred =\n+          conditionalUpdate(cs, updates, results, symbols);\n+\n+      while (deferred.size() > 0) {\n+        deferred = conditionalUpdate(cs, deferred, results, symbols);\n+      }\n+\n+      return results;\n+    } catch (IOException ioe) {\n+      throw new TException(ioe);\n+    } finally {\n+      writeTracker.finishWrite(opid);\n+      sessionManager.unreserveSession(sessID);\n+    }\n+  }\n+\n+  @Override\n+  public void invalidateConditionalUpdate(TInfo tinfo, long sessID) {\n+    // this method should wait for any running conditional update to complete\n+    // after this method returns a conditional update should not be able to start\n+\n+    ConditionalSession cs = (ConditionalSession) sessionManager.getSession(sessID);\n+    if (cs != null) {\n+      cs.interruptFlag.set(true);\n+    }\n+\n+    cs = (ConditionalSession) sessionManager.reserveSession(sessID, true);\n+    if (cs != null) {\n+      sessionManager.removeSession(sessID, true);\n+    }\n+  }\n+\n+  @Override\n+  public void closeConditionalUpdate(TInfo tinfo, long sessID) {\n+    sessionManager.removeSession(sessID, false);\n+  }\n+\n+  @Override\n+  public void splitTablet(TInfo tinfo, TCredentials credentials, TKeyExtent tkeyExtent,\n+      ByteBuffer splitPoint) throws NotServingTabletException, ThriftSecurityException {\n+\n+    TableId tableId = TableId.of(new String(ByteBufferUtil.toBytes(tkeyExtent.table)));\n+    NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n+\n+    if (!security.canSplitTablet(credentials, tableId, namespaceId)) {\n+      throw new ThriftSecurityException(credentials.getPrincipal(),\n+          SecurityErrorCode.PERMISSION_DENIED);\n+    }\n+\n+    KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n+\n+    Tablet tablet = server.getOnlineTablet(keyExtent);\n+    if (tablet == null) {\n+      throw new NotServingTabletException(tkeyExtent);\n+    }\n+\n+    if (keyExtent.getEndRow() == null\n+        || !keyExtent.getEndRow().equals(ByteBufferUtil.toText(splitPoint))) {\n+      try {\n+        if (server.splitTablet(tablet, ByteBufferUtil.toBytes(splitPoint)) == null) {\n+          throw new NotServingTabletException(tkeyExtent);\n+        }\n+      } catch (IOException e) {\n+        log.warn(\"Failed to split \" + keyExtent, e);\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TabletServerStatus getTabletServerStatus(TInfo tinfo, TCredentials credentials) {\n+    return server.getStats(sessionManager.getActiveScansPerTable());\n+  }\n+\n+  @Override\n+  public List<TabletStats> getTabletStats(TInfo tinfo, TCredentials credentials, String tableId) {\n+    List<TabletStats> result = new ArrayList<>();\n+    TableId text = TableId.of(tableId);\n+    KeyExtent start = new KeyExtent(text, new Text(), null);\n+    for (Entry<KeyExtent,Tablet> entry : server.getOnlineTablets().tailMap(start).entrySet()) {\n+      KeyExtent ke = entry.getKey();\n+      if (ke.getTableId().compareTo(text) == 0) {\n+        Tablet tablet = entry.getValue();\n+        TabletStats stats = tablet.getTabletStats();\n+        stats.extent = ke.toThrift();\n+        stats.ingestRate = tablet.ingestRate();\n+        stats.queryRate = tablet.queryRate();\n+        stats.splitCreationTime = tablet.getSplitCreationTime();\n+        stats.numEntries = tablet.getNumEntries();\n+        result.add(stats);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private void checkPermission(TCredentials credentials, String lock, final String request)\n+      throws ThriftSecurityException {\n+    try {\n+      log.trace(\"Got {} message from user: {}\", request, credentials.getPrincipal());\n+      if (!security.canPerformSystemActions(credentials)) {\n+        log.warn(\"Got {} message from user: {}\", request, credentials.getPrincipal());\n+        throw new ThriftSecurityException(credentials.getPrincipal(),\n+            SecurityErrorCode.PERMISSION_DENIED);\n+      }\n+    } catch (ThriftSecurityException e) {\n+      log.warn(\"Got {} message from unauthenticatable user: {}\", request, e.getUser());\n+      if (server.getContext().getCredentials().getToken().getClass().getName()\n+          .equals(credentials.getTokenClassName())) {\n+        log.error(\"Got message from a service with a mismatched configuration.\"\n+            + \" Please ensure a compatible configuration.\", e);\n+      }\n+      throw e;\n+    }\n+\n+    if (server.getLock() == null || !server.getLock().wasLockAcquired()) {\n+      log.debug(\"Got {} message before my lock was acquired, ignoring...\", request);\n+      throw new RuntimeException(\"Lock not acquired\");\n+    }\n+\n+    if (server.getLock() != null && server.getLock().wasLockAcquired()\n+        && !server.getLock().isLocked()) {\n+      Halt.halt(1, () -> {\n+        log.info(\"Tablet server no longer holds lock during checkPermission() : {}, exiting\",\n+            request);\n+        server.getGcLogger().logGCInfo(server.getConfiguration());\n+      });\n+    }\n+\n+    if (lock != null) {\n+      ZooUtil.LockID lid =\n+          new ZooUtil.LockID(server.getContext().getZooKeeperRoot() + Constants.ZMASTER_LOCK, lock);\n+\n+      try {\n+        if (!ZooLock.isLockHeld(server.getMasterLockCache(), lid)) {\n+          // maybe the cache is out of date and a new master holds the\n+          // lock?\n+          server.getMasterLockCache().clear();\n+          if (!ZooLock.isLockHeld(server.getMasterLockCache(), lid)) {\n+            log.warn(\"Got {} message from a master that does not hold the current lock {}\", request,\n+                lock);\n+            throw new RuntimeException(\"bad master lock\");\n+          }\n+        }\n+      } catch (Exception e) {\n+        throw new RuntimeException(\"bad master lock\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void loadTablet(TInfo tinfo, TCredentials credentials, String lock,\n+      final TKeyExtent textent) {\n+\n+    try {\n+      checkPermission(credentials, lock, \"loadTablet\");\n+    } catch (ThriftSecurityException e) {\n+      log.error(\"Caller doesn't have permission to load a tablet\", e);\n+      throw new RuntimeException(e);\n+    }\n+\n+    final KeyExtent extent = new KeyExtent(textent);\n+    SortedSet<KeyExtent> unopenedTablets = server.getUnopenedTablets();\n+    SortedSet<KeyExtent> openingTablets = server.getOpeningTablets();\n+\n+    synchronized (unopenedTablets) {\n+      synchronized (openingTablets) {\n+        SortedMap<KeyExtent,Tablet> onlineTablets = server.getOnlineTablets();\n+        synchronized (onlineTablets) {", "originalCommit": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMzcyOA==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406813728", "bodyText": "Whoops, yea, the synchronziation isn't actually necessary since it's operating on the snapshot. Yea, as I mentioned in slack, the use of synchronzied colletions makes this a bit confusing and would be more straight forward to refactor them as concurrent collections later.", "author": "andrewglowacki", "createdAt": "2020-04-10T15:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0MjU2MQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r406942561", "bodyText": "Perhaps... making them concurrent instead of having the explicit synchronization... might make it harder to understand the overall concurrency model, and the relationship between these objects. It might make more sense to put the objects into a single container that gives a consistent snapshot across all of the data structures at once. I'd have to think about it some more to have an informed opinion.", "author": "ctubbsii", "createdAt": "2020-04-10T21:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NTkwMQ=="}], "type": "inlineReview"}, {"oid": "8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "url": "https://github.com/apache/accumulo/commit/8d99cdc5c09a86939e24572f55d079e34cd3e1c9", "message": "Moved ThriftClientHandler, AssignmentHandler and UnloadTabletHandler into separate classes (#1581)", "committedDate": "2020-04-08T21:46:04Z", "type": "forcePushed"}, {"oid": "1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "url": "https://github.com/apache/accumulo/commit/1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "message": "Removed new protected getters and replaced them with direct use of package-private variables. (#1581)", "committedDate": "2020-04-10T18:00:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODU3NQ==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408128575", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected void acquireRecoveryMemory(KeyExtent extent) {\n          \n          \n            \n             void acquireRecoveryMemory(KeyExtent extent) {", "author": "keith-turner", "createdAt": "2020-04-14T13:18:29Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -2278,301 +529,13 @@ public void enqueueMasterMessage(MasterMessage m) {\n     masterMessages.addLast(m);\n   }\n \n-  private class UnloadTabletHandler implements Runnable {\n-    private final KeyExtent extent;\n-    private final TUnloadTabletGoal goalState;\n-    private final long requestTimeSkew;\n-\n-    public UnloadTabletHandler(KeyExtent extent, TUnloadTabletGoal goalState, long requestTime) {\n-      this.extent = extent;\n-      this.goalState = goalState;\n-      this.requestTimeSkew = requestTime - MILLISECONDS.convert(System.nanoTime(), NANOSECONDS);\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-      Tablet t = null;\n-\n-      synchronized (unopenedTablets) {\n-        if (unopenedTablets.contains(extent)) {\n-          unopenedTablets.remove(extent);\n-          // enqueueMasterMessage(new TabletUnloadedMessage(extent));\n-          return;\n-        }\n-      }\n-      synchronized (openingTablets) {\n-        while (openingTablets.contains(extent)) {\n-          try {\n-            openingTablets.wait();\n-          } catch (InterruptedException e) {}\n-        }\n-      }\n-      synchronized (onlineTablets) {\n-        if (onlineTablets.snapshot().containsKey(extent)) {\n-          t = onlineTablets.snapshot().get(extent);\n-        }\n-      }\n-\n-      if (t == null) {\n-        // Tablet has probably been recently unloaded: repeated master\n-        // unload request is crossing the successful unloaded message\n-        if (!recentlyUnloadedCache.containsKey(extent)) {\n-          log.info(\"told to unload tablet that was not being served {}\", extent);\n-          enqueueMasterMessage(\n-              new TabletStatusMessage(TabletLoadState.UNLOAD_FAILURE_NOT_SERVING, extent));\n-        }\n-        return;\n-      }\n-\n-      try {\n-        t.close(!goalState.equals(TUnloadTabletGoal.DELETED));\n-      } catch (Throwable e) {\n-\n-        if ((t.isClosing() || t.isClosed()) && e instanceof IllegalStateException) {\n-          log.debug(\"Failed to unload tablet {}... it was already closing or closed : {}\", extent,\n-              e.getMessage());\n-        } else {\n-          log.error(\"Failed to close tablet {}... Aborting migration\", extent, e);\n-          enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.UNLOAD_ERROR, extent));\n-        }\n-        return;\n-      }\n-\n-      // stop serving tablet - client will get not serving tablet\n-      // exceptions\n-      recentlyUnloadedCache.put(extent, System.currentTimeMillis());\n-      onlineTablets.remove(extent);\n-\n-      try {\n-        TServerInstance instance = new TServerInstance(clientAddress, getLock().getSessionId());\n-        TabletLocationState tls = null;\n-        try {\n-          tls = new TabletLocationState(extent, null, instance, null, null, null, false);\n-        } catch (BadLocationStateException e) {\n-          log.error(\"Unexpected error\", e);\n-        }\n-        if (!goalState.equals(TUnloadTabletGoal.SUSPENDED) || extent.isRootTablet()\n-            || (extent.isMeta()\n-                && !getConfiguration().getBoolean(Property.MASTER_METADATA_SUSPENDABLE))) {\n-          TabletStateStore.unassign(getContext(), tls, null);\n-        } else {\n-          TabletStateStore.suspend(getContext(), tls, null,\n-              requestTimeSkew + MILLISECONDS.convert(System.nanoTime(), NANOSECONDS));\n-        }\n-      } catch (DistributedStoreException ex) {\n-        log.warn(\"Unable to update storage\", ex);\n-      } catch (KeeperException e) {\n-        log.warn(\"Unable determine our zookeeper session information\", e);\n-      } catch (InterruptedException e) {\n-        log.warn(\"Interrupted while getting our zookeeper session information\", e);\n-      }\n-\n-      // tell the master how it went\n-      enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.UNLOADED, extent));\n-\n-      // roll tablet stats over into tablet server's statsKeeper object as\n-      // historical data\n-      statsKeeper.saveMajorMinorTimes(t.getTabletStats());\n-    }\n-  }\n-\n-  protected class AssignmentHandler implements Runnable {\n-    private final KeyExtent extent;\n-    private final int retryAttempt;\n-\n-    public AssignmentHandler(KeyExtent extent) {\n-      this(extent, 0);\n-    }\n-\n-    public AssignmentHandler(KeyExtent extent, int retryAttempt) {\n-      this.extent = extent;\n-      this.retryAttempt = retryAttempt;\n-    }\n-\n-    @Override\n-    public void run() {\n-      synchronized (unopenedTablets) {\n-        synchronized (openingTablets) {\n-          synchronized (onlineTablets) {\n-            // nothing should be moving between sets, do a sanity\n-            // check\n-            Set<KeyExtent> unopenedOverlapping = KeyExtent.findOverlapping(extent, unopenedTablets);\n-            Set<KeyExtent> openingOverlapping = KeyExtent.findOverlapping(extent, openingTablets);\n-            Set<KeyExtent> onlineOverlapping =\n-                KeyExtent.findOverlapping(extent, onlineTablets.snapshot());\n-\n-            if (openingOverlapping.contains(extent) || onlineOverlapping.contains(extent)) {\n-              return;\n-            }\n-\n-            if (!unopenedOverlapping.contains(extent)) {\n-              log.info(\"assignment {} no longer in the unopened set\", extent);\n-              return;\n-            }\n-\n-            if (unopenedOverlapping.size() != 1 || openingOverlapping.size() > 0\n-                || onlineOverlapping.size() > 0) {\n-              throw new IllegalStateException(\n-                  \"overlaps assigned \" + extent + \" \" + !unopenedTablets.contains(extent) + \" \"\n-                      + unopenedOverlapping + \" \" + openingOverlapping + \" \" + onlineOverlapping);\n-            }\n-          }\n-\n-          unopenedTablets.remove(extent);\n-          openingTablets.add(extent);\n-        }\n-      }\n-\n-      // check Metadata table before accepting assignment\n-      Text locationToOpen = null;\n-      TabletMetadata tabletMetadata = null;\n-      boolean canLoad = false;\n-      try {\n-        tabletMetadata = getContext().getAmple().readTablet(extent);\n-\n-        canLoad = checkTabletMetadata(extent, TabletServer.this.getTabletSession(), tabletMetadata);\n-\n-        if (canLoad && tabletMetadata.sawOldPrevEndRow()) {\n-          KeyExtent fixedExtent =\n-              MasterMetadataUtil.fixSplit(getContext(), tabletMetadata, getLock());\n-\n-          synchronized (openingTablets) {\n-            openingTablets.remove(extent);\n-            openingTablets.notifyAll();\n-            // it expected that the new extent will overlap the old one... if it does not, it\n-            // should not be added to unopenedTablets\n-            if (!KeyExtent.findOverlapping(extent, new TreeSet<>(Arrays.asList(fixedExtent)))\n-                .contains(fixedExtent)) {\n-              throw new IllegalStateException(\n-                  \"Fixed split does not overlap \" + extent + \" \" + fixedExtent);\n-            }\n-            unopenedTablets.add(fixedExtent);\n-          }\n-          // split was rolled back... try again\n-          new AssignmentHandler(fixedExtent).run();\n-          return;\n-\n-        }\n-      } catch (Exception e) {\n-        synchronized (openingTablets) {\n-          openingTablets.remove(extent);\n-          openingTablets.notifyAll();\n-        }\n-        log.warn(\"Failed to verify tablet \" + extent, e);\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        throw new RuntimeException(e);\n-      }\n-\n-      if (!canLoad) {\n-        log.debug(\"Reporting tablet {} assignment failure: unable to verify Tablet Information\",\n-            extent);\n-        synchronized (openingTablets) {\n-          openingTablets.remove(extent);\n-          openingTablets.notifyAll();\n-        }\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        return;\n-      }\n-\n-      Tablet tablet = null;\n-      boolean successful = false;\n-\n-      try {\n-        acquireRecoveryMemory(extent);\n-\n-        TabletResourceManager trm =\n-            resourceManager.createTabletResourceManager(extent, getTableConfiguration(extent));\n-        TabletData data = new TabletData(tabletMetadata);\n-\n-        tablet = new Tablet(TabletServer.this, extent, trm, data);\n-        // If a minor compaction starts after a tablet opens, this indicates a log recovery\n-        // occurred. This recovered data must be minor compacted.\n-        // There are three reasons to wait for this minor compaction to finish before placing the\n-        // tablet in online tablets.\n-        //\n-        // 1) The log recovery code does not handle data written to the tablet on multiple tablet\n-        // servers.\n-        // 2) The log recovery code does not block if memory is full. Therefore recovering lots of\n-        // tablets that use a lot of memory could run out of memory.\n-        // 3) The minor compaction finish event did not make it to the logs (the file will be in\n-        // metadata, preventing replay of compacted data)... but do not\n-        // want a majc to wipe the file out from metadata and then have another process failure...\n-        // this could cause duplicate data to replay.\n-        if (tablet.getNumEntriesInMemory() > 0\n-            && !tablet.minorCompactNow(MinorCompactionReason.RECOVERY)) {\n-          throw new RuntimeException(\"Minor compaction after recovery fails for \" + extent);\n-        }\n-        Assignment assignment = new Assignment(extent, getTabletSession());\n-        TabletStateStore.setLocation(getContext(), assignment);\n-\n-        synchronized (openingTablets) {\n-          synchronized (onlineTablets) {\n-            openingTablets.remove(extent);\n-            onlineTablets.put(extent, tablet);\n-            openingTablets.notifyAll();\n-            recentlyUnloadedCache.remove(tablet.getExtent());\n-          }\n-        }\n-        tablet = null; // release this reference\n-        successful = true;\n-      } catch (Throwable e) {\n-        log.warn(\"exception trying to assign tablet {} {}\", extent, locationToOpen, e);\n-\n-        if (e.getMessage() != null) {\n-          log.warn(\"{}\", e.getMessage());\n-        }\n-\n-        TableId tableId = extent.getTableId();\n-        ProblemReports.getInstance(getContext()).report(new ProblemReport(tableId, TABLET_LOAD,\n-            extent.getUUID().toString(), getClientAddressString(), e));\n-      } finally {\n-        releaseRecoveryMemory(extent);\n-      }\n-\n-      if (!successful) {\n-        synchronized (unopenedTablets) {\n-          synchronized (openingTablets) {\n-            openingTablets.remove(extent);\n-            unopenedTablets.add(extent);\n-            openingTablets.notifyAll();\n-          }\n-        }\n-        log.warn(\"failed to open tablet {} reporting failure to master\", extent);\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        long reschedule = Math.min((1L << Math.min(32, retryAttempt)) * 1000, 10 * 60 * 1000L);\n-        log.warn(String.format(\"rescheduling tablet load in %.2f seconds\", reschedule / 1000.));\n-        SimpleTimer.getInstance(getConfiguration()).schedule(new TimerTask() {\n-          @Override\n-          public void run() {\n-            log.info(\"adding tablet {} back to the assignment pool (retry {})\", extent,\n-                retryAttempt);\n-            AssignmentHandler handler = new AssignmentHandler(extent, retryAttempt + 1);\n-            if (extent.isMeta()) {\n-              if (extent.isRootTablet()) {\n-                new Daemon(new LoggingRunnable(log, handler), \"Root tablet assignment retry\")\n-                    .start();\n-              } else {\n-                resourceManager.addMetaDataAssignment(extent, log, handler);\n-              }\n-            } else {\n-              resourceManager.addAssignment(extent, log, handler);\n-            }\n-          }\n-        }, reschedule);\n-      } else {\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOADED, extent));\n-      }\n-    }\n-  }\n-\n-  private void acquireRecoveryMemory(KeyExtent extent) {\n+  protected void acquireRecoveryMemory(KeyExtent extent) {", "originalCommit": "1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODY5Ng==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408128696", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected void releaseRecoveryMemory(KeyExtent extent) {\n          \n          \n            \n             void releaseRecoveryMemory(KeyExtent extent) {", "author": "keith-turner", "createdAt": "2020-04-14T13:18:39Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -2278,301 +529,13 @@ public void enqueueMasterMessage(MasterMessage m) {\n     masterMessages.addLast(m);\n   }\n \n-  private class UnloadTabletHandler implements Runnable {\n-    private final KeyExtent extent;\n-    private final TUnloadTabletGoal goalState;\n-    private final long requestTimeSkew;\n-\n-    public UnloadTabletHandler(KeyExtent extent, TUnloadTabletGoal goalState, long requestTime) {\n-      this.extent = extent;\n-      this.goalState = goalState;\n-      this.requestTimeSkew = requestTime - MILLISECONDS.convert(System.nanoTime(), NANOSECONDS);\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-      Tablet t = null;\n-\n-      synchronized (unopenedTablets) {\n-        if (unopenedTablets.contains(extent)) {\n-          unopenedTablets.remove(extent);\n-          // enqueueMasterMessage(new TabletUnloadedMessage(extent));\n-          return;\n-        }\n-      }\n-      synchronized (openingTablets) {\n-        while (openingTablets.contains(extent)) {\n-          try {\n-            openingTablets.wait();\n-          } catch (InterruptedException e) {}\n-        }\n-      }\n-      synchronized (onlineTablets) {\n-        if (onlineTablets.snapshot().containsKey(extent)) {\n-          t = onlineTablets.snapshot().get(extent);\n-        }\n-      }\n-\n-      if (t == null) {\n-        // Tablet has probably been recently unloaded: repeated master\n-        // unload request is crossing the successful unloaded message\n-        if (!recentlyUnloadedCache.containsKey(extent)) {\n-          log.info(\"told to unload tablet that was not being served {}\", extent);\n-          enqueueMasterMessage(\n-              new TabletStatusMessage(TabletLoadState.UNLOAD_FAILURE_NOT_SERVING, extent));\n-        }\n-        return;\n-      }\n-\n-      try {\n-        t.close(!goalState.equals(TUnloadTabletGoal.DELETED));\n-      } catch (Throwable e) {\n-\n-        if ((t.isClosing() || t.isClosed()) && e instanceof IllegalStateException) {\n-          log.debug(\"Failed to unload tablet {}... it was already closing or closed : {}\", extent,\n-              e.getMessage());\n-        } else {\n-          log.error(\"Failed to close tablet {}... Aborting migration\", extent, e);\n-          enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.UNLOAD_ERROR, extent));\n-        }\n-        return;\n-      }\n-\n-      // stop serving tablet - client will get not serving tablet\n-      // exceptions\n-      recentlyUnloadedCache.put(extent, System.currentTimeMillis());\n-      onlineTablets.remove(extent);\n-\n-      try {\n-        TServerInstance instance = new TServerInstance(clientAddress, getLock().getSessionId());\n-        TabletLocationState tls = null;\n-        try {\n-          tls = new TabletLocationState(extent, null, instance, null, null, null, false);\n-        } catch (BadLocationStateException e) {\n-          log.error(\"Unexpected error\", e);\n-        }\n-        if (!goalState.equals(TUnloadTabletGoal.SUSPENDED) || extent.isRootTablet()\n-            || (extent.isMeta()\n-                && !getConfiguration().getBoolean(Property.MASTER_METADATA_SUSPENDABLE))) {\n-          TabletStateStore.unassign(getContext(), tls, null);\n-        } else {\n-          TabletStateStore.suspend(getContext(), tls, null,\n-              requestTimeSkew + MILLISECONDS.convert(System.nanoTime(), NANOSECONDS));\n-        }\n-      } catch (DistributedStoreException ex) {\n-        log.warn(\"Unable to update storage\", ex);\n-      } catch (KeeperException e) {\n-        log.warn(\"Unable determine our zookeeper session information\", e);\n-      } catch (InterruptedException e) {\n-        log.warn(\"Interrupted while getting our zookeeper session information\", e);\n-      }\n-\n-      // tell the master how it went\n-      enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.UNLOADED, extent));\n-\n-      // roll tablet stats over into tablet server's statsKeeper object as\n-      // historical data\n-      statsKeeper.saveMajorMinorTimes(t.getTabletStats());\n-    }\n-  }\n-\n-  protected class AssignmentHandler implements Runnable {\n-    private final KeyExtent extent;\n-    private final int retryAttempt;\n-\n-    public AssignmentHandler(KeyExtent extent) {\n-      this(extent, 0);\n-    }\n-\n-    public AssignmentHandler(KeyExtent extent, int retryAttempt) {\n-      this.extent = extent;\n-      this.retryAttempt = retryAttempt;\n-    }\n-\n-    @Override\n-    public void run() {\n-      synchronized (unopenedTablets) {\n-        synchronized (openingTablets) {\n-          synchronized (onlineTablets) {\n-            // nothing should be moving between sets, do a sanity\n-            // check\n-            Set<KeyExtent> unopenedOverlapping = KeyExtent.findOverlapping(extent, unopenedTablets);\n-            Set<KeyExtent> openingOverlapping = KeyExtent.findOverlapping(extent, openingTablets);\n-            Set<KeyExtent> onlineOverlapping =\n-                KeyExtent.findOverlapping(extent, onlineTablets.snapshot());\n-\n-            if (openingOverlapping.contains(extent) || onlineOverlapping.contains(extent)) {\n-              return;\n-            }\n-\n-            if (!unopenedOverlapping.contains(extent)) {\n-              log.info(\"assignment {} no longer in the unopened set\", extent);\n-              return;\n-            }\n-\n-            if (unopenedOverlapping.size() != 1 || openingOverlapping.size() > 0\n-                || onlineOverlapping.size() > 0) {\n-              throw new IllegalStateException(\n-                  \"overlaps assigned \" + extent + \" \" + !unopenedTablets.contains(extent) + \" \"\n-                      + unopenedOverlapping + \" \" + openingOverlapping + \" \" + onlineOverlapping);\n-            }\n-          }\n-\n-          unopenedTablets.remove(extent);\n-          openingTablets.add(extent);\n-        }\n-      }\n-\n-      // check Metadata table before accepting assignment\n-      Text locationToOpen = null;\n-      TabletMetadata tabletMetadata = null;\n-      boolean canLoad = false;\n-      try {\n-        tabletMetadata = getContext().getAmple().readTablet(extent);\n-\n-        canLoad = checkTabletMetadata(extent, TabletServer.this.getTabletSession(), tabletMetadata);\n-\n-        if (canLoad && tabletMetadata.sawOldPrevEndRow()) {\n-          KeyExtent fixedExtent =\n-              MasterMetadataUtil.fixSplit(getContext(), tabletMetadata, getLock());\n-\n-          synchronized (openingTablets) {\n-            openingTablets.remove(extent);\n-            openingTablets.notifyAll();\n-            // it expected that the new extent will overlap the old one... if it does not, it\n-            // should not be added to unopenedTablets\n-            if (!KeyExtent.findOverlapping(extent, new TreeSet<>(Arrays.asList(fixedExtent)))\n-                .contains(fixedExtent)) {\n-              throw new IllegalStateException(\n-                  \"Fixed split does not overlap \" + extent + \" \" + fixedExtent);\n-            }\n-            unopenedTablets.add(fixedExtent);\n-          }\n-          // split was rolled back... try again\n-          new AssignmentHandler(fixedExtent).run();\n-          return;\n-\n-        }\n-      } catch (Exception e) {\n-        synchronized (openingTablets) {\n-          openingTablets.remove(extent);\n-          openingTablets.notifyAll();\n-        }\n-        log.warn(\"Failed to verify tablet \" + extent, e);\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        throw new RuntimeException(e);\n-      }\n-\n-      if (!canLoad) {\n-        log.debug(\"Reporting tablet {} assignment failure: unable to verify Tablet Information\",\n-            extent);\n-        synchronized (openingTablets) {\n-          openingTablets.remove(extent);\n-          openingTablets.notifyAll();\n-        }\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        return;\n-      }\n-\n-      Tablet tablet = null;\n-      boolean successful = false;\n-\n-      try {\n-        acquireRecoveryMemory(extent);\n-\n-        TabletResourceManager trm =\n-            resourceManager.createTabletResourceManager(extent, getTableConfiguration(extent));\n-        TabletData data = new TabletData(tabletMetadata);\n-\n-        tablet = new Tablet(TabletServer.this, extent, trm, data);\n-        // If a minor compaction starts after a tablet opens, this indicates a log recovery\n-        // occurred. This recovered data must be minor compacted.\n-        // There are three reasons to wait for this minor compaction to finish before placing the\n-        // tablet in online tablets.\n-        //\n-        // 1) The log recovery code does not handle data written to the tablet on multiple tablet\n-        // servers.\n-        // 2) The log recovery code does not block if memory is full. Therefore recovering lots of\n-        // tablets that use a lot of memory could run out of memory.\n-        // 3) The minor compaction finish event did not make it to the logs (the file will be in\n-        // metadata, preventing replay of compacted data)... but do not\n-        // want a majc to wipe the file out from metadata and then have another process failure...\n-        // this could cause duplicate data to replay.\n-        if (tablet.getNumEntriesInMemory() > 0\n-            && !tablet.minorCompactNow(MinorCompactionReason.RECOVERY)) {\n-          throw new RuntimeException(\"Minor compaction after recovery fails for \" + extent);\n-        }\n-        Assignment assignment = new Assignment(extent, getTabletSession());\n-        TabletStateStore.setLocation(getContext(), assignment);\n-\n-        synchronized (openingTablets) {\n-          synchronized (onlineTablets) {\n-            openingTablets.remove(extent);\n-            onlineTablets.put(extent, tablet);\n-            openingTablets.notifyAll();\n-            recentlyUnloadedCache.remove(tablet.getExtent());\n-          }\n-        }\n-        tablet = null; // release this reference\n-        successful = true;\n-      } catch (Throwable e) {\n-        log.warn(\"exception trying to assign tablet {} {}\", extent, locationToOpen, e);\n-\n-        if (e.getMessage() != null) {\n-          log.warn(\"{}\", e.getMessage());\n-        }\n-\n-        TableId tableId = extent.getTableId();\n-        ProblemReports.getInstance(getContext()).report(new ProblemReport(tableId, TABLET_LOAD,\n-            extent.getUUID().toString(), getClientAddressString(), e));\n-      } finally {\n-        releaseRecoveryMemory(extent);\n-      }\n-\n-      if (!successful) {\n-        synchronized (unopenedTablets) {\n-          synchronized (openingTablets) {\n-            openingTablets.remove(extent);\n-            unopenedTablets.add(extent);\n-            openingTablets.notifyAll();\n-          }\n-        }\n-        log.warn(\"failed to open tablet {} reporting failure to master\", extent);\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOAD_FAILURE, extent));\n-        long reschedule = Math.min((1L << Math.min(32, retryAttempt)) * 1000, 10 * 60 * 1000L);\n-        log.warn(String.format(\"rescheduling tablet load in %.2f seconds\", reschedule / 1000.));\n-        SimpleTimer.getInstance(getConfiguration()).schedule(new TimerTask() {\n-          @Override\n-          public void run() {\n-            log.info(\"adding tablet {} back to the assignment pool (retry {})\", extent,\n-                retryAttempt);\n-            AssignmentHandler handler = new AssignmentHandler(extent, retryAttempt + 1);\n-            if (extent.isMeta()) {\n-              if (extent.isRootTablet()) {\n-                new Daemon(new LoggingRunnable(log, handler), \"Root tablet assignment retry\")\n-                    .start();\n-              } else {\n-                resourceManager.addMetaDataAssignment(extent, log, handler);\n-              }\n-            } else {\n-              resourceManager.addAssignment(extent, log, handler);\n-            }\n-          }\n-        }, reschedule);\n-      } else {\n-        enqueueMasterMessage(new TabletStatusMessage(TabletLoadState.LOADED, extent));\n-      }\n-    }\n-  }\n-\n-  private void acquireRecoveryMemory(KeyExtent extent) {\n+  protected void acquireRecoveryMemory(KeyExtent extent) {\n     if (!extent.isMeta()) {\n       recoveryLock.lock();\n     }\n   }\n \n-  private void releaseRecoveryMemory(KeyExtent extent) {\n+  protected void releaseRecoveryMemory(KeyExtent extent) {", "originalCommit": "1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODg2Nw==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408128867", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected TreeMap<KeyExtent,TabletData> splitTablet(Tablet tablet, byte[] splitPoint)\n          \n          \n            \n             TreeMap<KeyExtent,TabletData> splitTablet(Tablet tablet, byte[] splitPoint)", "author": "keith-turner", "createdAt": "2020-04-14T13:18:54Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -2228,7 +479,7 @@ private void splitTablet(Tablet tablet) {\n     }\n   }\n \n-  private TreeMap<KeyExtent,TabletData> splitTablet(Tablet tablet, byte[] splitPoint)\n+  protected TreeMap<KeyExtent,TabletData> splitTablet(Tablet tablet, byte[] splitPoint)", "originalCommit": "1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyOTAzMg==", "url": "https://github.com/apache/accumulo/pull/1584#discussion_r408129032", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected String getLockID() {\n          \n          \n            \n             String getLockID() {", "author": "keith-turner", "createdAt": "2020-04-14T13:19:07Z", "path": "server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java", "diffHunk": "@@ -493,1649 +374,19 @@ private static long jitter() {\n     return (long) ((1. + (r.nextDouble() / 10)) * TabletServer.TIME_BETWEEN_LOCATOR_CACHE_CLEARS);\n   }\n \n-  private final SessionManager sessionManager;\n+  final SessionManager sessionManager;\n \n-  private final WriteTracker writeTracker = new WriteTracker();\n-\n-  private final RowLocks rowLocks = new RowLocks();\n-\n-  private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n-  private final ReentrantLock recoveryLock = new ReentrantLock(true);\n-  private ThriftClientHandler clientHandler;\n-  private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n-\n-  private class ThriftClientHandler extends ClientServiceHandler\n-      implements TabletClientService.Iface {\n-\n-    ThriftClientHandler() {\n-      super(getContext(), watcher, fs);\n-      log.debug(\"{} created\", ThriftClientHandler.class.getName());\n-    }\n-\n-    @Override\n-    public List<TKeyExtent> bulkImport(TInfo tinfo, TCredentials credentials, final long tid,\n-        final Map<TKeyExtent,Map<String,MapFileInfo>> files, final boolean setTime)\n-        throws ThriftSecurityException {\n-\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      try {\n-        return watcher.run(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-          List<TKeyExtent> failures = new ArrayList<>();\n-\n-          for (Entry<TKeyExtent,Map<String,MapFileInfo>> entry : files.entrySet()) {\n-            TKeyExtent tke = entry.getKey();\n-            Map<String,MapFileInfo> fileMap = entry.getValue();\n-            Map<TabletFile,MapFileInfo> fileRefMap = new HashMap<>();\n-            for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-              Path path = new Path(mapping.getKey());\n-              FileSystem ns = fs.getFileSystemByPath(path);\n-              path = ns.makeQualified(path);\n-              fileRefMap.put(new TabletFile(path), mapping.getValue());\n-            }\n-\n-            Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-            if (importTablet == null) {\n-              failures.add(tke);\n-            } else {\n-              try {\n-                importTablet.importMapFiles(tid, fileRefMap, setTime);\n-              } catch (IOException ioe) {\n-                log.info(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                    ioe.getMessage());\n-                failures.add(tke);\n-              }\n-            }\n-          }\n-          return failures;\n-        });\n-      } catch (RuntimeException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    public void loadFiles(TInfo tinfo, TCredentials credentials, long tid, String dir,\n-        Map<TKeyExtent,Map<String,MapFileInfo>> tabletImports, boolean setTime)\n-        throws ThriftSecurityException {\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      watcher.runQuietly(Constants.BULK_ARBITRATOR_TYPE, tid, () -> {\n-        tabletImports.forEach((tke, fileMap) -> {\n-          Map<TabletFile,MapFileInfo> newFileMap = new HashMap<>();\n-          for (Entry<String,MapFileInfo> mapping : fileMap.entrySet()) {\n-            Path path = new Path(dir, mapping.getKey());\n-            FileSystem ns = fs.getFileSystemByPath(path);\n-            path = ns.makeQualified(path);\n-            newFileMap.put(new TabletFile(path), mapping.getValue());\n-          }\n-\n-          Tablet importTablet = getOnlineTablet(new KeyExtent(tke));\n-\n-          if (importTablet != null) {\n-            try {\n-              importTablet.importMapFiles(tid, newFileMap, setTime);\n-            } catch (IOException ioe) {\n-              log.debug(\"files {} not imported to {}: {}\", fileMap.keySet(), new KeyExtent(tke),\n-                  ioe.getMessage());\n-            }\n-          }\n-        });\n-      });\n-\n-    }\n-\n-    private ScanDispatcher getScanDispatcher(KeyExtent extent) {\n-      if (extent.isRootTablet() || extent.isMeta()) {\n-        // dispatcher is only for user tables\n-        return null;\n-      }\n-\n-      return getContext().getTableConfiguration(extent.getTableId()).getScanDispatcher();\n-    }\n-\n-    @Override\n-    public InitialScan startScan(TInfo tinfo, TCredentials credentials, TKeyExtent textent,\n-        TRange range, List<TColumn> columns, int batchSize, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        boolean isolated, long readaheadThreshold, TSamplerConfiguration tSamplerConfig,\n-        long batchTimeOut, String contextArg, Map<String,String> executionHints)\n-        throws NotServingTabletException, ThriftSecurityException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      TableId tableId = TableId.of(new String(textent.getTable(), UTF_8));\n-      NamespaceId namespaceId;\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new NotServingTabletException(textent);\n-      }\n-      if (!security.canScan(credentials, tableId, namespaceId, range, columns, ssiList, ssio,\n-          authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.BAD_AUTHORIZATIONS);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      // wait for any writes that are in flight.. this done to ensure\n-      // consistency across client restarts... assume a client writes\n-      // to accumulo and dies while waiting for a confirmation from\n-      // accumulo... the client process restarts and tries to read\n-      // data from accumulo making the assumption that it will get\n-      // any writes previously made... however if the server side thread\n-      // processing the write from the dead client is still in progress,\n-      // the restarted client may not see the write unless we wait here.\n-      // this behavior is very important when the client is reading the\n-      // metadata\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(extent));\n-      }\n-\n-      Tablet tablet = getOnlineTablet(extent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(textent);\n-      }\n-\n-      HashSet<Column> columnSet = new HashSet<>();\n-      for (TColumn tcolumn : columns) {\n-        columnSet.add(new Column(tcolumn));\n-      }\n-\n-      ScanParameters scanParams = new ScanParameters(batchSize, new Authorizations(authorizations),\n-          columnSet, ssiList, ssio, isolated, SamplerConfigurationImpl.fromThrift(tSamplerConfig),\n-          batchTimeOut, contextArg);\n-\n-      final SingleScanSession scanSession = new SingleScanSession(credentials, extent, scanParams,\n-          readaheadThreshold, executionHints);\n-      scanSession.scanner =\n-          tablet.createScanner(new Range(range), scanParams, scanSession.interruptFlag);\n-\n-      long sid = sessionManager.createSession(scanSession, true);\n-\n-      ScanResult scanResult;\n-      try {\n-        scanResult = continueScan(tinfo, sid, scanSession);\n-      } catch (NoSuchScanIDException e) {\n-        log.error(\"The impossible happened\", e);\n-        throw new RuntimeException();\n-      } finally {\n-        sessionManager.unreserveSession(sid);\n-      }\n-\n-      return new InitialScan(sid, scanResult);\n-    }\n-\n-    @Override\n-    public ScanResult continueScan(TInfo tinfo, long scanID)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-      SingleScanSession scanSession = (SingleScanSession) sessionManager.reserveSession(scanID);\n-      if (scanSession == null) {\n-        throw new NoSuchScanIDException();\n-      }\n-\n-      try {\n-        return continueScan(tinfo, scanID, scanSession);\n-      } finally {\n-        sessionManager.unreserveSession(scanSession);\n-      }\n-    }\n-\n-    private ScanResult continueScan(TInfo tinfo, long scanID, SingleScanSession scanSession)\n-        throws NoSuchScanIDException, NotServingTabletException,\n-        org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException,\n-        TSampleNotPresentException {\n-\n-      if (scanSession.nextBatchTask == null) {\n-        scanSession.nextBatchTask =\n-            new NextBatchTask(TabletServer.this, scanID, scanSession.interruptFlag);\n-        resourceManager.executeReadAhead(scanSession.extent, getScanDispatcher(scanSession.extent),\n-            scanSession, scanSession.nextBatchTask);\n-      }\n-\n-      ScanBatch bresult;\n-      try {\n-        bresult = scanSession.nextBatchTask.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS,\n-            TimeUnit.MILLISECONDS);\n-        scanSession.nextBatchTask = null;\n-      } catch (ExecutionException e) {\n-        sessionManager.removeSession(scanID);\n-        if (e.getCause() instanceof NotServingTabletException) {\n-          throw (NotServingTabletException) e.getCause();\n-        } else if (e.getCause() instanceof TooManyFilesException) {\n-          throw new org.apache.accumulo.core.tabletserver.thrift.TooManyFilesException(\n-              scanSession.extent.toThrift());\n-        } else if (e.getCause() instanceof SampleNotPresentException) {\n-          throw new TSampleNotPresentException(scanSession.extent.toThrift());\n-        } else if (e.getCause() instanceof IOException) {\n-          sleepUninterruptibly(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n-          List<KVEntry> empty = Collections.emptyList();\n-          bresult = new ScanBatch(empty, true);\n-          scanSession.nextBatchTask = null;\n-        } else {\n-          throw new RuntimeException(e);\n-        }\n-      } catch (CancellationException ce) {\n-        sessionManager.removeSession(scanID);\n-        Tablet tablet = getOnlineTablet(scanSession.extent);\n-        if (tablet == null || tablet.isClosed()) {\n-          throw new NotServingTabletException(scanSession.extent.toThrift());\n-        } else {\n-          throw new NoSuchScanIDException();\n-        }\n-      } catch (TimeoutException e) {\n-        List<TKeyValue> param = Collections.emptyList();\n-        long timeout =\n-            TabletServer.this.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n-        sessionManager.removeIfNotAccessed(scanID, timeout);\n-        return new ScanResult(param, true);\n-      } catch (Throwable t) {\n-        sessionManager.removeSession(scanID);\n-        log.warn(\"Failed to get next batch\", t);\n-        throw new RuntimeException(t);\n-      }\n-\n-      ScanResult scanResult = new ScanResult(Key.compress(bresult.getResults()), bresult.isMore());\n-\n-      scanSession.entriesReturned += scanResult.results.size();\n-\n-      scanSession.batchCount++;\n-\n-      if (scanResult.more && scanSession.batchCount > scanSession.readaheadThreshold) {\n-        // start reading next batch while current batch is transmitted\n-        // to client\n-        scanSession.nextBatchTask =\n-            new NextBatchTask(TabletServer.this, scanID, scanSession.interruptFlag);\n-        resourceManager.executeReadAhead(scanSession.extent, getScanDispatcher(scanSession.extent),\n-            scanSession, scanSession.nextBatchTask);\n-      }\n-\n-      if (!scanResult.more) {\n-        closeScan(tinfo, scanID);\n-      }\n-\n-      return scanResult;\n-    }\n-\n-    @Override\n-    public void closeScan(TInfo tinfo, long scanID) {\n-      final SingleScanSession ss = (SingleScanSession) sessionManager.removeSession(scanID);\n-      if (ss != null) {\n-        long t2 = System.currentTimeMillis();\n-\n-        if (log.isTraceEnabled()) {\n-          log.trace(String.format(\"ScanSess tid %s %s %,d entries in %.2f secs, nbTimes = [%s] \",\n-              TServerUtils.clientAddress.get(), ss.extent.getTableId(), ss.entriesReturned,\n-              (t2 - ss.startTime) / 1000.0, ss.runStats.toString()));\n-        }\n-\n-        scanMetrics.addScan(t2 - ss.startTime);\n-        scanMetrics.addResult(ss.entriesReturned);\n-      }\n-    }\n-\n-    @Override\n-    public InitialMultiScan startMultiScan(TInfo tinfo, TCredentials credentials,\n-        Map<TKeyExtent,List<TRange>> tbatch, List<TColumn> tcolumns, List<IterInfo> ssiList,\n-        Map<String,Map<String,String>> ssio, List<ByteBuffer> authorizations, boolean waitForWrites,\n-        TSamplerConfiguration tSamplerConfig, long batchTimeOut, String contextArg,\n-        Map<String,String> executionHints)\n-        throws ThriftSecurityException, TSampleNotPresentException {\n-      // find all of the tables that need to be scanned\n-      final HashSet<TableId> tables = new HashSet<>();\n-      for (TKeyExtent keyExtent : tbatch.keySet()) {\n-        tables.add(TableId.of(new String(keyExtent.getTable(), UTF_8)));\n-      }\n-\n-      if (tables.size() != 1) {\n-        throw new IllegalArgumentException(\"Cannot batch scan over multiple tables\");\n-      }\n-\n-      // check if user has permission to the tables\n-      for (TableId tableId : tables) {\n-        NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n-        if (!security.canScan(credentials, tableId, namespaceId, tbatch, tcolumns, ssiList, ssio,\n-            authorizations)) {\n-          throw new ThriftSecurityException(credentials.getPrincipal(),\n-              SecurityErrorCode.PERMISSION_DENIED);\n-        }\n-      }\n-\n-      try {\n-        if (!security.authenticatedUserHasAuthorizations(credentials, authorizations)) {\n-          throw new ThriftSecurityException(credentials.getPrincipal(),\n-              SecurityErrorCode.BAD_AUTHORIZATIONS);\n-        }\n-      } catch (ThriftSecurityException tse) {\n-        log.error(\"{} is not authorized\", credentials.getPrincipal(), tse);\n-        throw tse;\n-      }\n-      Map<KeyExtent,List<Range>> batch = Translator.translate(tbatch, new TKeyExtentTranslator(),\n-          new Translator.ListTranslator<>(new TRangeTranslator()));\n-\n-      // This is used to determine which thread pool to use\n-      KeyExtent threadPoolExtent = batch.keySet().iterator().next();\n-\n-      if (waitForWrites) {\n-        writeTracker.waitForWrites(TabletType.type(batch.keySet()));\n-      }\n-\n-      Set<Column> columnSet = tcolumns.isEmpty() ? Collections.emptySet()\n-          : new HashSet<>(Collections2.transform(tcolumns, Column::new));\n-\n-      ScanParameters scanParams =\n-          new ScanParameters(-1, new Authorizations(authorizations), columnSet, ssiList, ssio,\n-              false, SamplerConfigurationImpl.fromThrift(tSamplerConfig), batchTimeOut, contextArg);\n-\n-      final MultiScanSession mss =\n-          new MultiScanSession(credentials, threadPoolExtent, batch, scanParams, executionHints);\n-\n-      mss.numTablets = batch.size();\n-      for (List<Range> ranges : batch.values()) {\n-        mss.numRanges += ranges.size();\n-      }\n-\n-      long sid = sessionManager.createSession(mss, true);\n-\n-      MultiScanResult result;\n-      try {\n-        result = continueMultiScan(sid, mss);\n-      } finally {\n-        sessionManager.unreserveSession(sid);\n-      }\n-\n-      return new InitialMultiScan(sid, result);\n-    }\n-\n-    @Override\n-    public MultiScanResult continueMultiScan(TInfo tinfo, long scanID)\n-        throws NoSuchScanIDException, TSampleNotPresentException {\n-\n-      MultiScanSession session = (MultiScanSession) sessionManager.reserveSession(scanID);\n-\n-      if (session == null) {\n-        throw new NoSuchScanIDException();\n-      }\n-\n-      try {\n-        return continueMultiScan(scanID, session);\n-      } finally {\n-        sessionManager.unreserveSession(session);\n-      }\n-    }\n-\n-    private MultiScanResult continueMultiScan(long scanID, MultiScanSession session)\n-        throws TSampleNotPresentException {\n-\n-      if (session.lookupTask == null) {\n-        session.lookupTask = new LookupTask(TabletServer.this, scanID);\n-        resourceManager.executeReadAhead(session.threadPoolExtent,\n-            getScanDispatcher(session.threadPoolExtent), session, session.lookupTask);\n-      }\n-\n-      try {\n-        MultiScanResult scanResult =\n-            session.lookupTask.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n-        session.lookupTask = null;\n-        return scanResult;\n-      } catch (ExecutionException e) {\n-        sessionManager.removeSession(scanID);\n-        if (e.getCause() instanceof SampleNotPresentException) {\n-          throw new TSampleNotPresentException();\n-        } else {\n-          log.warn(\"Failed to get multiscan result\", e);\n-          throw new RuntimeException(e);\n-        }\n-      } catch (TimeoutException e1) {\n-        long timeout =\n-            TabletServer.this.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n-        sessionManager.removeIfNotAccessed(scanID, timeout);\n-        List<TKeyValue> results = Collections.emptyList();\n-        Map<TKeyExtent,List<TRange>> failures = Collections.emptyMap();\n-        List<TKeyExtent> fullScans = Collections.emptyList();\n-        return new MultiScanResult(results, failures, fullScans, null, null, false, true);\n-      } catch (Throwable t) {\n-        sessionManager.removeSession(scanID);\n-        log.warn(\"Failed to get multiscan result\", t);\n-        throw new RuntimeException(t);\n-      }\n-    }\n-\n-    @Override\n-    public void closeMultiScan(TInfo tinfo, long scanID) throws NoSuchScanIDException {\n-      MultiScanSession session = (MultiScanSession) sessionManager.removeSession(scanID);\n-      if (session == null) {\n-        throw new NoSuchScanIDException();\n-      }\n-\n-      long t2 = System.currentTimeMillis();\n-\n-      if (log.isTraceEnabled()) {\n-        log.trace(String.format(\n-            \"MultiScanSess %s %,d entries in %.2f secs\"\n-                + \" (lookup_time:%.2f secs tablets:%,d ranges:%,d) \",\n-            TServerUtils.clientAddress.get(), session.numEntries, (t2 - session.startTime) / 1000.0,\n-            session.totalLookupTime / 1000.0, session.numTablets, session.numRanges));\n-      }\n-    }\n-\n-    @Override\n-    public long startUpdate(TInfo tinfo, TCredentials credentials, TDurability tdurabilty)\n-        throws ThriftSecurityException {\n-      // Make sure user is real\n-      Durability durability = DurabilityImpl.fromThrift(tdurabilty);\n-      security.authenticateUser(credentials, credentials);\n-      updateMetrics.addPermissionErrors(0);\n-\n-      UpdateSession us = new UpdateSession(\n-          new TservConstraintEnv(getContext(), security, credentials), credentials, durability);\n-      return sessionManager.createSession(us, false);\n-    }\n-\n-    private void setUpdateTablet(UpdateSession us, KeyExtent keyExtent) {\n-      long t1 = System.currentTimeMillis();\n-      if (us.currentTablet != null && us.currentTablet.getExtent().equals(keyExtent)) {\n-        return;\n-      }\n-      if (us.currentTablet == null\n-          && (us.failures.containsKey(keyExtent) || us.authFailures.containsKey(keyExtent))) {\n-        // if there were previous failures, then do not accept additional writes\n-        return;\n-      }\n-\n-      TableId tableId = null;\n-      try {\n-        // if user has no permission to write to this table, add it to\n-        // the failures list\n-        boolean sameTable = us.currentTablet != null\n-            && (us.currentTablet.getExtent().getTableId().equals(keyExtent.getTableId()));\n-        tableId = keyExtent.getTableId();\n-        if (sameTable || security.canWrite(us.getCredentials(), tableId,\n-            Tables.getNamespaceId(getContext(), tableId))) {\n-          long t2 = System.currentTimeMillis();\n-          us.authTimes.addStat(t2 - t1);\n-          us.currentTablet = getOnlineTablet(keyExtent);\n-          if (us.currentTablet != null) {\n-            us.queuedMutations.put(us.currentTablet, new ArrayList<>());\n-          } else {\n-            // not serving tablet, so report all mutations as\n-            // failures\n-            us.failures.put(keyExtent, 0L);\n-            updateMetrics.addUnknownTabletErrors(0);\n-          }\n-        } else {\n-          log.warn(\"Denying access to table {} for user {}\", keyExtent.getTableId(), us.getUser());\n-          long t2 = System.currentTimeMillis();\n-          us.authTimes.addStat(t2 - t1);\n-          us.currentTablet = null;\n-          us.authFailures.put(keyExtent, SecurityErrorCode.PERMISSION_DENIED);\n-          updateMetrics.addPermissionErrors(0);\n-          return;\n-        }\n-      } catch (TableNotFoundException tnfe) {\n-        log.error(\"Table \" + tableId + \" not found \", tnfe);\n-        long t2 = System.currentTimeMillis();\n-        us.authTimes.addStat(t2 - t1);\n-        us.currentTablet = null;\n-        us.authFailures.put(keyExtent, SecurityErrorCode.TABLE_DOESNT_EXIST);\n-        updateMetrics.addUnknownTabletErrors(0);\n-        return;\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Denying permission to check user \" + us.getUser() + \" with user \" + e.getUser(),\n-            e);\n-        long t2 = System.currentTimeMillis();\n-        us.authTimes.addStat(t2 - t1);\n-        us.currentTablet = null;\n-        us.authFailures.put(keyExtent, e.getCode());\n-        updateMetrics.addPermissionErrors(0);\n-        return;\n-      }\n-    }\n-\n-    @Override\n-    public void applyUpdates(TInfo tinfo, long updateID, TKeyExtent tkeyExtent,\n-        List<TMutation> tmutations) {\n-      UpdateSession us = (UpdateSession) sessionManager.reserveSession(updateID);\n-      if (us == null) {\n-        return;\n-      }\n-\n-      boolean reserved = true;\n-      try {\n-        KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n-        setUpdateTablet(us, keyExtent);\n-\n-        if (us.currentTablet != null) {\n-          long additionalMutationSize = 0;\n-          List<Mutation> mutations = us.queuedMutations.get(us.currentTablet);\n-          for (TMutation tmutation : tmutations) {\n-            Mutation mutation = new ServerMutation(tmutation);\n-            mutations.add(mutation);\n-            additionalMutationSize += mutation.numBytes();\n-          }\n-          us.queuedMutationSize += additionalMutationSize;\n-          long totalQueued = updateTotalQueuedMutationSize(additionalMutationSize);\n-          long total = TabletServer.this.getConfiguration()\n-              .getAsBytes(Property.TSERV_TOTAL_MUTATION_QUEUE_MAX);\n-          if (totalQueued > total) {\n-            try {\n-              flush(us);\n-            } catch (HoldTimeoutException hte) {\n-              // Assumption is that the client has timed out and is gone. If that's not the case,\n-              // then removing the session should cause the client to fail\n-              // in such a way that it retries.\n-              log.debug(\"HoldTimeoutException during applyUpdates, removing session\");\n-              sessionManager.removeSession(updateID, true);\n-              reserved = false;\n-            }\n-          }\n-        }\n-      } finally {\n-        if (reserved) {\n-          sessionManager.unreserveSession(us);\n-        }\n-      }\n-    }\n-\n-    private void flush(UpdateSession us) {\n-\n-      int mutationCount = 0;\n-      Map<CommitSession,List<Mutation>> sendables = new HashMap<>();\n-      Map<CommitSession,TabletMutations> loggables = new HashMap<>();\n-      Throwable error = null;\n-\n-      long pt1 = System.currentTimeMillis();\n-\n-      boolean containsMetadataTablet = false;\n-      for (Tablet tablet : us.queuedMutations.keySet()) {\n-        if (tablet.getExtent().isMeta()) {\n-          containsMetadataTablet = true;\n-        }\n-      }\n-\n-      if (!containsMetadataTablet && us.queuedMutations.size() > 0) {\n-        TabletServer.this.resourceManager.waitUntilCommitsAreEnabled();\n-      }\n-\n-      try (TraceScope prep = Trace.startSpan(\"prep\")) {\n-        for (Entry<Tablet,? extends List<Mutation>> entry : us.queuedMutations.entrySet()) {\n-\n-          Tablet tablet = entry.getKey();\n-          Durability durability =\n-              DurabilityImpl.resolveDurabilty(us.durability, tablet.getDurability());\n-          List<Mutation> mutations = entry.getValue();\n-          if (mutations.size() > 0) {\n-            try {\n-              updateMetrics.addMutationArraySize(mutations.size());\n-\n-              PreparedMutations prepared = tablet.prepareMutationsForCommit(us.cenv, mutations);\n-\n-              if (prepared.tabletClosed()) {\n-                if (us.currentTablet == tablet) {\n-                  us.currentTablet = null;\n-                }\n-                us.failures.put(tablet.getExtent(), us.successfulCommits.get(tablet));\n-              } else {\n-                if (!prepared.getNonViolators().isEmpty()) {\n-                  List<Mutation> validMutations = prepared.getNonViolators();\n-                  CommitSession session = prepared.getCommitSession();\n-                  if (durability != Durability.NONE) {\n-                    loggables.put(session,\n-                        new TabletMutations(session, validMutations, durability));\n-                  }\n-                  sendables.put(session, validMutations);\n-                }\n-\n-                if (!prepared.getViolations().isEmpty()) {\n-                  us.violations.add(prepared.getViolations());\n-                  updateMetrics.addConstraintViolations(0);\n-                }\n-                // Use the size of the original mutation list, regardless of how many mutations\n-                // did not violate constraints.\n-                mutationCount += mutations.size();\n-\n-              }\n-            } catch (Throwable t) {\n-              error = t;\n-              log.error(\"Unexpected error preparing for commit\", error);\n-              break;\n-            }\n-          }\n-        }\n-      }\n-\n-      long pt2 = System.currentTimeMillis();\n-      us.prepareTimes.addStat(pt2 - pt1);\n-      updateAvgPrepTime(pt2 - pt1, us.queuedMutations.size());\n-\n-      if (error != null) {\n-        sendables.forEach((commitSession, value) -> commitSession.abortCommit());\n-        throw new RuntimeException(error);\n-      }\n-      try {\n-        try (TraceScope wal = Trace.startSpan(\"wal\")) {\n-          while (true) {\n-            try {\n-              long t1 = System.currentTimeMillis();\n-\n-              logger.logManyTablets(loggables);\n-\n-              long t2 = System.currentTimeMillis();\n-              us.walogTimes.addStat(t2 - t1);\n-              updateWalogWriteTime((t2 - t1));\n-              break;\n-            } catch (IOException | FSError ex) {\n-              log.warn(\"logging mutations failed, retrying\");\n-            } catch (Throwable t) {\n-              log.error(\"Unknown exception logging mutations, counts\"\n-                  + \" for mutations in flight not decremented!\", t);\n-              throw new RuntimeException(t);\n-            }\n-          }\n-        }\n-\n-        try (TraceScope commit = Trace.startSpan(\"commit\")) {\n-          long t1 = System.currentTimeMillis();\n-          sendables.forEach((commitSession, mutations) -> {\n-            commitSession.commit(mutations);\n-            KeyExtent extent = commitSession.getExtent();\n-\n-            if (us.currentTablet != null && extent == us.currentTablet.getExtent()) {\n-              // because constraint violations may filter out some\n-              // mutations, for proper accounting with the client code,\n-              // need to increment the count based on the original\n-              // number of mutations from the client NOT the filtered number\n-              us.successfulCommits.increment(us.currentTablet,\n-                  us.queuedMutations.get(us.currentTablet).size());\n-            }\n-          });\n-          long t2 = System.currentTimeMillis();\n-\n-          us.flushTime += (t2 - pt1);\n-          us.commitTimes.addStat(t2 - t1);\n-\n-          updateAvgCommitTime(t2 - t1, sendables.size());\n-        }\n-      } finally {\n-        us.queuedMutations.clear();\n-        if (us.currentTablet != null) {\n-          us.queuedMutations.put(us.currentTablet, new ArrayList<>());\n-        }\n-        updateTotalQueuedMutationSize(-us.queuedMutationSize);\n-        us.queuedMutationSize = 0;\n-      }\n-      us.totalUpdates += mutationCount;\n-    }\n-\n-    private void updateWalogWriteTime(long time) {\n-      updateMetrics.addWalogWriteTime(time);\n-    }\n-\n-    private void updateAvgCommitTime(long time, int size) {\n-      if (size > 0)\n-        updateMetrics.addCommitTime((long) (time / (double) size));\n-    }\n-\n-    private void updateAvgPrepTime(long time, int size) {\n-      if (size > 0)\n-        updateMetrics.addCommitPrep((long) (time / (double) size));\n-    }\n-\n-    @Override\n-    public UpdateErrors closeUpdate(TInfo tinfo, long updateID) throws NoSuchScanIDException {\n-      final UpdateSession us = (UpdateSession) sessionManager.removeSession(updateID);\n-      if (us == null) {\n-        throw new NoSuchScanIDException();\n-      }\n-\n-      // clients may or may not see data from an update session while\n-      // it is in progress, however when the update session is closed\n-      // want to ensure that reads wait for the write to finish\n-      long opid = writeTracker.startWrite(us.queuedMutations.keySet());\n-\n-      try {\n-        flush(us);\n-      } catch (HoldTimeoutException e) {\n-        // Assumption is that the client has timed out and is gone. If that's not the case throw an\n-        // exception that will cause it to retry.\n-        log.debug(\"HoldTimeoutException during closeUpdate, reporting no such session\");\n-        throw new NoSuchScanIDException();\n-      } finally {\n-        writeTracker.finishWrite(opid);\n-      }\n-\n-      if (log.isTraceEnabled()) {\n-        log.trace(\n-            String.format(\"UpSess %s %,d in %.3fs, at=[%s] ft=%.3fs(pt=%.3fs lt=%.3fs ct=%.3fs)\",\n-                TServerUtils.clientAddress.get(), us.totalUpdates,\n-                (System.currentTimeMillis() - us.startTime) / 1000.0, us.authTimes.toString(),\n-                us.flushTime / 1000.0, us.prepareTimes.sum() / 1000.0, us.walogTimes.sum() / 1000.0,\n-                us.commitTimes.sum() / 1000.0));\n-      }\n-      if (us.failures.size() > 0) {\n-        Entry<KeyExtent,Long> first = us.failures.entrySet().iterator().next();\n-        log.debug(String.format(\"Failures: %d, first extent %s successful commits: %d\",\n-            us.failures.size(), first.getKey().toString(), first.getValue()));\n-      }\n-      List<ConstraintViolationSummary> violations = us.violations.asList();\n-      if (violations.size() > 0) {\n-        ConstraintViolationSummary first = us.violations.asList().iterator().next();\n-        log.debug(String.format(\"Violations: %d, first %s occurs %d\", violations.size(),\n-            first.violationDescription, first.numberOfViolatingMutations));\n-      }\n-      if (us.authFailures.size() > 0) {\n-        KeyExtent first = us.authFailures.keySet().iterator().next();\n-        log.debug(String.format(\"Authentication Failures: %d, first %s\", us.authFailures.size(),\n-            first.toString()));\n-      }\n-\n-      return new UpdateErrors(Translator.translate(us.failures, Translators.KET),\n-          Translator.translate(violations, Translators.CVST),\n-          Translator.translate(us.authFailures, Translators.KET));\n-    }\n-\n-    @Override\n-    public void update(TInfo tinfo, TCredentials credentials, TKeyExtent tkeyExtent,\n-        TMutation tmutation, TDurability tdurability)\n-        throws NotServingTabletException, ConstraintViolationException, ThriftSecurityException {\n-\n-      final TableId tableId = TableId.of(new String(tkeyExtent.getTable(), UTF_8));\n-      NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n-      if (!security.canWrite(credentials, tableId, namespaceId)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-      final KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n-      final Tablet tablet = getOnlineTablet(new KeyExtent(keyExtent));\n-      if (tablet == null) {\n-        throw new NotServingTabletException(tkeyExtent);\n-      }\n-      Durability tabletDurability = tablet.getDurability();\n-\n-      if (!keyExtent.isMeta()) {\n-        try {\n-          TabletServer.this.resourceManager.waitUntilCommitsAreEnabled();\n-        } catch (HoldTimeoutException hte) {\n-          // Major hack. Assumption is that the client has timed out and is gone. If that's not the\n-          // case, then throwing the following will let client know there\n-          // was a failure and it should retry.\n-          throw new NotServingTabletException(tkeyExtent);\n-        }\n-      }\n-\n-      final long opid = writeTracker.startWrite(TabletType.type(keyExtent));\n-\n-      try {\n-        final Mutation mutation = new ServerMutation(tmutation);\n-        final List<Mutation> mutations = Collections.singletonList(mutation);\n-\n-        PreparedMutations prepared;\n-        try (TraceScope prep = Trace.startSpan(\"prep\")) {\n-          prepared = tablet.prepareMutationsForCommit(\n-              new TservConstraintEnv(getContext(), security, credentials), mutations);\n-        }\n-\n-        if (prepared.tabletClosed()) {\n-          throw new NotServingTabletException(tkeyExtent);\n-        } else if (!prepared.getViolators().isEmpty()) {\n-          throw new ConstraintViolationException(\n-              Translator.translate(prepared.getViolations().asList(), Translators.CVST));\n-        } else {\n-          CommitSession session = prepared.getCommitSession();\n-          Durability durability = DurabilityImpl\n-              .resolveDurabilty(DurabilityImpl.fromThrift(tdurability), tabletDurability);\n-\n-          // Instead of always looping on true, skip completely when durability is NONE.\n-          while (durability != Durability.NONE) {\n-            try {\n-              try (TraceScope wal = Trace.startSpan(\"wal\")) {\n-                logger.log(session, mutation, durability);\n-              }\n-              break;\n-            } catch (IOException ex) {\n-              log.warn(\"Error writing mutations to log\", ex);\n-            }\n-          }\n-\n-          try (TraceScope commit = Trace.startSpan(\"commit\")) {\n-            session.commit(mutations);\n-          }\n-        }\n-      } finally {\n-        writeTracker.finishWrite(opid);\n-      }\n-    }\n-\n-    private NamespaceId getNamespaceId(TCredentials credentials, TableId tableId)\n-        throws ThriftSecurityException {\n-      try {\n-        return Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.TABLE_DOESNT_EXIST);\n-      }\n-    }\n-\n-    private void checkConditions(Map<KeyExtent,List<ServerConditionalMutation>> updates,\n-        ArrayList<TCMResult> results, ConditionalSession cs, List<String> symbols)\n-        throws IOException {\n-      Iterator<Entry<KeyExtent,List<ServerConditionalMutation>>> iter =\n-          updates.entrySet().iterator();\n-\n-      final CompressedIterators compressedIters = new CompressedIterators(symbols);\n-      ConditionCheckerContext checkerContext = new ConditionCheckerContext(getContext(),\n-          compressedIters, getContext().getTableConfiguration(cs.tableId));\n-\n-      while (iter.hasNext()) {\n-        final Entry<KeyExtent,List<ServerConditionalMutation>> entry = iter.next();\n-        final Tablet tablet = getOnlineTablet(entry.getKey());\n-\n-        if (tablet == null || tablet.isClosed()) {\n-          for (ServerConditionalMutation scm : entry.getValue()) {\n-            results.add(new TCMResult(scm.getID(), TCMStatus.IGNORED));\n-          }\n-          iter.remove();\n-        } else {\n-          final List<ServerConditionalMutation> okMutations =\n-              new ArrayList<>(entry.getValue().size());\n-          final List<TCMResult> resultsSubList = results.subList(results.size(), results.size());\n-\n-          ConditionChecker checker =\n-              checkerContext.newChecker(entry.getValue(), okMutations, resultsSubList);\n-          try {\n-            tablet.checkConditions(checker, cs.auths, cs.interruptFlag);\n-\n-            if (okMutations.size() > 0) {\n-              entry.setValue(okMutations);\n-            } else {\n-              iter.remove();\n-            }\n-          } catch (TabletClosedException | IterationInterruptedException\n-              | TooManyFilesException e) {\n-            // clear anything added while checking conditions.\n-            resultsSubList.clear();\n-\n-            for (ServerConditionalMutation scm : entry.getValue()) {\n-              results.add(new TCMResult(scm.getID(), TCMStatus.IGNORED));\n-            }\n-            iter.remove();\n-          }\n-        }\n-      }\n-    }\n-\n-    private void writeConditionalMutations(Map<KeyExtent,List<ServerConditionalMutation>> updates,\n-        ArrayList<TCMResult> results, ConditionalSession sess) {\n-      Set<Entry<KeyExtent,List<ServerConditionalMutation>>> es = updates.entrySet();\n-\n-      Map<CommitSession,List<Mutation>> sendables = new HashMap<>();\n-      Map<CommitSession,TabletMutations> loggables = new HashMap<>();\n-\n-      boolean sessionCanceled = sess.interruptFlag.get();\n-\n-      try (TraceScope prepSpan = Trace.startSpan(\"prep\")) {\n-        long t1 = System.currentTimeMillis();\n-        for (Entry<KeyExtent,List<ServerConditionalMutation>> entry : es) {\n-          final Tablet tablet = getOnlineTablet(entry.getKey());\n-          if (tablet == null || tablet.isClosed() || sessionCanceled) {\n-            addMutationsAsTCMResults(results, entry.getValue(), TCMStatus.IGNORED);\n-          } else {\n-            final Durability durability =\n-                DurabilityImpl.resolveDurabilty(sess.durability, tablet.getDurability());\n-\n-            @SuppressWarnings(\"unchecked\")\n-            List<Mutation> mutations = (List<Mutation>) (List<? extends Mutation>) entry.getValue();\n-            if (!mutations.isEmpty()) {\n-\n-              PreparedMutations prepared = tablet.prepareMutationsForCommit(\n-                  new TservConstraintEnv(getContext(), security, sess.credentials), mutations);\n-\n-              if (prepared.tabletClosed()) {\n-                addMutationsAsTCMResults(results, mutations, TCMStatus.IGNORED);\n-              } else {\n-                if (!prepared.getNonViolators().isEmpty()) {\n-                  // Only log and commit mutations that did not violate constraints.\n-                  List<Mutation> validMutations = prepared.getNonViolators();\n-                  addMutationsAsTCMResults(results, validMutations, TCMStatus.ACCEPTED);\n-                  CommitSession session = prepared.getCommitSession();\n-                  if (durability != Durability.NONE) {\n-                    loggables.put(session,\n-                        new TabletMutations(session, validMutations, durability));\n-                  }\n-                  sendables.put(session, validMutations);\n-                }\n-\n-                if (!prepared.getViolators().isEmpty()) {\n-                  addMutationsAsTCMResults(results, prepared.getViolators(), TCMStatus.VIOLATED);\n-                }\n-              }\n-            }\n-          }\n-        }\n-\n-        long t2 = System.currentTimeMillis();\n-        updateAvgPrepTime(t2 - t1, es.size());\n-      }\n-\n-      try (TraceScope walSpan = Trace.startSpan(\"wal\")) {\n-        while (loggables.size() > 0) {\n-          try {\n-            long t1 = System.currentTimeMillis();\n-            logger.logManyTablets(loggables);\n-            long t2 = System.currentTimeMillis();\n-            updateWalogWriteTime(t2 - t1);\n-            break;\n-          } catch (IOException | FSError ex) {\n-            log.warn(\"logging mutations failed, retrying\");\n-          } catch (Throwable t) {\n-            log.error(\"Unknown exception logging mutations, counts for\"\n-                + \" mutations in flight not decremented!\", t);\n-            throw new RuntimeException(t);\n-          }\n-        }\n-      }\n-\n-      try (TraceScope commitSpan = Trace.startSpan(\"commit\")) {\n-        long t1 = System.currentTimeMillis();\n-        sendables.forEach(CommitSession::commit);\n-        long t2 = System.currentTimeMillis();\n-        updateAvgCommitTime(t2 - t1, sendables.size());\n-      }\n-    }\n-\n-    /**\n-     * Transform and add each mutation as a {@link TCMResult} with the mutation's ID and the\n-     * specified status to the {@link TCMResult} list.\n-     */\n-    private void addMutationsAsTCMResults(final List<TCMResult> list,\n-        final Collection<? extends Mutation> mutations, final TCMStatus status) {\n-      mutations.stream()\n-          .map(mutation -> new TCMResult(((ServerConditionalMutation) mutation).getID(), status))\n-          .forEach(list::add);\n-    }\n-\n-    private Map<KeyExtent,List<ServerConditionalMutation>> conditionalUpdate(ConditionalSession cs,\n-        Map<KeyExtent,List<ServerConditionalMutation>> updates, ArrayList<TCMResult> results,\n-        List<String> symbols) throws IOException {\n-      // sort each list of mutations, this is done to avoid deadlock and doing seeks in order is\n-      // more efficient and detect duplicate rows.\n-      ConditionalMutationSet.sortConditionalMutations(updates);\n-\n-      Map<KeyExtent,List<ServerConditionalMutation>> deferred = new HashMap<>();\n-\n-      // can not process two mutations for the same row, because one will not see what the other\n-      // writes\n-      ConditionalMutationSet.deferDuplicatesRows(updates, deferred);\n-\n-      // get as many locks as possible w/o blocking... defer any rows that are locked\n-      List<RowLock> locks = rowLocks.acquireRowlocks(updates, deferred);\n-      try {\n-        try (TraceScope checkSpan = Trace.startSpan(\"Check conditions\")) {\n-          checkConditions(updates, results, cs, symbols);\n-        }\n-\n-        try (TraceScope updateSpan = Trace.startSpan(\"apply conditional mutations\")) {\n-          writeConditionalMutations(updates, results, cs);\n-        }\n-      } finally {\n-        rowLocks.releaseRowLocks(locks);\n-      }\n-      return deferred;\n-    }\n-\n-    @Override\n-    public TConditionalSession startConditionalUpdate(TInfo tinfo, TCredentials credentials,\n-        List<ByteBuffer> authorizations, String tableIdStr, TDurability tdurabilty,\n-        String classLoaderContext) throws ThriftSecurityException, TException {\n-\n-      TableId tableId = TableId.of(tableIdStr);\n-      Authorizations userauths = null;\n-      NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n-      if (!security.canConditionallyUpdate(credentials, tableId, namespaceId)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      userauths = security.getUserAuthorizations(credentials);\n-      for (ByteBuffer auth : authorizations) {\n-        if (!userauths.contains(ByteBufferUtil.toBytes(auth))) {\n-          throw new ThriftSecurityException(credentials.getPrincipal(),\n-              SecurityErrorCode.BAD_AUTHORIZATIONS);\n-        }\n-      }\n-\n-      ConditionalSession cs = new ConditionalSession(credentials,\n-          new Authorizations(authorizations), tableId, DurabilityImpl.fromThrift(tdurabilty));\n-\n-      long sid = sessionManager.createSession(cs, false);\n-      return new TConditionalSession(sid, lockID, sessionManager.getMaxIdleTime());\n-    }\n-\n-    @Override\n-    public List<TCMResult> conditionalUpdate(TInfo tinfo, long sessID,\n-        Map<TKeyExtent,List<TConditionalMutation>> mutations, List<String> symbols)\n-        throws NoSuchScanIDException, TException {\n-\n-      ConditionalSession cs = (ConditionalSession) sessionManager.reserveSession(sessID);\n-\n-      if (cs == null || cs.interruptFlag.get()) {\n-        throw new NoSuchScanIDException();\n-      }\n-\n-      if (!cs.tableId.equals(MetadataTable.ID) && !cs.tableId.equals(RootTable.ID)) {\n-        try {\n-          TabletServer.this.resourceManager.waitUntilCommitsAreEnabled();\n-        } catch (HoldTimeoutException hte) {\n-          // Assumption is that the client has timed out and is gone. If that's not the case throw\n-          // an exception that will cause it to retry.\n-          log.debug(\"HoldTimeoutException during conditionalUpdate, reporting no such session\");\n-          throw new NoSuchScanIDException();\n-        }\n-      }\n-\n-      TableId tid = cs.tableId;\n-      long opid = writeTracker.startWrite(TabletType.type(new KeyExtent(tid, null, null)));\n-\n-      try {\n-        Map<KeyExtent,List<ServerConditionalMutation>> updates = Translator.translate(mutations,\n-            Translators.TKET, new Translator.ListTranslator<>(ServerConditionalMutation.TCMT));\n-\n-        for (KeyExtent ke : updates.keySet()) {\n-          if (!ke.getTableId().equals(tid)) {\n-            throw new IllegalArgumentException(\n-                \"Unexpected table id \" + tid + \" != \" + ke.getTableId());\n-          }\n-        }\n-\n-        ArrayList<TCMResult> results = new ArrayList<>();\n-\n-        Map<KeyExtent,List<ServerConditionalMutation>> deferred =\n-            conditionalUpdate(cs, updates, results, symbols);\n-\n-        while (deferred.size() > 0) {\n-          deferred = conditionalUpdate(cs, deferred, results, symbols);\n-        }\n-\n-        return results;\n-      } catch (IOException ioe) {\n-        throw new TException(ioe);\n-      } finally {\n-        writeTracker.finishWrite(opid);\n-        sessionManager.unreserveSession(sessID);\n-      }\n-    }\n-\n-    @Override\n-    public void invalidateConditionalUpdate(TInfo tinfo, long sessID) {\n-      // this method should wait for any running conditional update to complete\n-      // after this method returns a conditional update should not be able to start\n-\n-      ConditionalSession cs = (ConditionalSession) sessionManager.getSession(sessID);\n-      if (cs != null) {\n-        cs.interruptFlag.set(true);\n-      }\n-\n-      cs = (ConditionalSession) sessionManager.reserveSession(sessID, true);\n-      if (cs != null) {\n-        sessionManager.removeSession(sessID, true);\n-      }\n-    }\n-\n-    @Override\n-    public void closeConditionalUpdate(TInfo tinfo, long sessID) {\n-      sessionManager.removeSession(sessID, false);\n-    }\n-\n-    @Override\n-    public void splitTablet(TInfo tinfo, TCredentials credentials, TKeyExtent tkeyExtent,\n-        ByteBuffer splitPoint) throws NotServingTabletException, ThriftSecurityException {\n-\n-      TableId tableId = TableId.of(new String(ByteBufferUtil.toBytes(tkeyExtent.table)));\n-      NamespaceId namespaceId = getNamespaceId(credentials, tableId);\n-\n-      if (!security.canSplitTablet(credentials, tableId, namespaceId)) {\n-        throw new ThriftSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED);\n-      }\n-\n-      KeyExtent keyExtent = new KeyExtent(tkeyExtent);\n-\n-      Tablet tablet = getOnlineTablet(keyExtent);\n-      if (tablet == null) {\n-        throw new NotServingTabletException(tkeyExtent);\n-      }\n-\n-      if (keyExtent.getEndRow() == null\n-          || !keyExtent.getEndRow().equals(ByteBufferUtil.toText(splitPoint))) {\n-        try {\n-          if (TabletServer.this.splitTablet(tablet, ByteBufferUtil.toBytes(splitPoint)) == null) {\n-            throw new NotServingTabletException(tkeyExtent);\n-          }\n-        } catch (IOException e) {\n-          log.warn(\"Failed to split \" + keyExtent, e);\n-          throw new RuntimeException(e);\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public TabletServerStatus getTabletServerStatus(TInfo tinfo, TCredentials credentials) {\n-      return getStats(sessionManager.getActiveScansPerTable());\n-    }\n-\n-    @Override\n-    public List<TabletStats> getTabletStats(TInfo tinfo, TCredentials credentials, String tableId) {\n-      List<TabletStats> result = new ArrayList<>();\n-      TableId text = TableId.of(tableId);\n-      KeyExtent start = new KeyExtent(text, new Text(), null);\n-      for (Entry<KeyExtent,Tablet> entry : getOnlineTablets().tailMap(start).entrySet()) {\n-        KeyExtent ke = entry.getKey();\n-        if (ke.getTableId().compareTo(text) == 0) {\n-          Tablet tablet = entry.getValue();\n-          TabletStats stats = tablet.getTabletStats();\n-          stats.extent = ke.toThrift();\n-          stats.ingestRate = tablet.ingestRate();\n-          stats.queryRate = tablet.queryRate();\n-          stats.splitCreationTime = tablet.getSplitCreationTime();\n-          stats.numEntries = tablet.getNumEntries();\n-          result.add(stats);\n-        }\n-      }\n-      return result;\n-    }\n-\n-    private void checkPermission(TCredentials credentials, String lock, final String request)\n-        throws ThriftSecurityException {\n-      try {\n-        log.trace(\"Got {} message from user: {}\", request, credentials.getPrincipal());\n-        if (!security.canPerformSystemActions(credentials)) {\n-          log.warn(\"Got {} message from user: {}\", request, credentials.getPrincipal());\n-          throw new ThriftSecurityException(credentials.getPrincipal(),\n-              SecurityErrorCode.PERMISSION_DENIED);\n-        }\n-      } catch (ThriftSecurityException e) {\n-        log.warn(\"Got {} message from unauthenticatable user: {}\", request, e.getUser());\n-        if (getContext().getCredentials().getToken().getClass().getName()\n-            .equals(credentials.getTokenClassName())) {\n-          log.error(\"Got message from a service with a mismatched configuration.\"\n-              + \" Please ensure a compatible configuration.\", e);\n-        }\n-        throw e;\n-      }\n-\n-      if (tabletServerLock == null || !tabletServerLock.wasLockAcquired()) {\n-        log.debug(\"Got {} message before my lock was acquired, ignoring...\", request);\n-        throw new RuntimeException(\"Lock not acquired\");\n-      }\n-\n-      if (tabletServerLock != null && tabletServerLock.wasLockAcquired()\n-          && !tabletServerLock.isLocked()) {\n-        Halt.halt(1, () -> {\n-          log.info(\"Tablet server no longer holds lock during checkPermission() : {}, exiting\",\n-              request);\n-          gcLogger.logGCInfo(TabletServer.this.getConfiguration());\n-        });\n-      }\n-\n-      if (lock != null) {\n-        ZooUtil.LockID lid =\n-            new ZooUtil.LockID(getContext().getZooKeeperRoot() + Constants.ZMASTER_LOCK, lock);\n-\n-        try {\n-          if (!ZooLock.isLockHeld(masterLockCache, lid)) {\n-            // maybe the cache is out of date and a new master holds the\n-            // lock?\n-            masterLockCache.clear();\n-            if (!ZooLock.isLockHeld(masterLockCache, lid)) {\n-              log.warn(\"Got {} message from a master that does not hold the current lock {}\",\n-                  request, lock);\n-              throw new RuntimeException(\"bad master lock\");\n-            }\n-          }\n-        } catch (Exception e) {\n-          throw new RuntimeException(\"bad master lock\", e);\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void loadTablet(TInfo tinfo, TCredentials credentials, String lock,\n-        final TKeyExtent textent) {\n-\n-      try {\n-        checkPermission(credentials, lock, \"loadTablet\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to load a tablet\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      final KeyExtent extent = new KeyExtent(textent);\n-\n-      synchronized (unopenedTablets) {\n-        synchronized (openingTablets) {\n-          synchronized (onlineTablets) {\n-\n-            // checking if this exact tablet is in any of the sets\n-            // below is not a strong enough check\n-            // when splits and fix splits occurring\n-\n-            Set<KeyExtent> unopenedOverlapping = KeyExtent.findOverlapping(extent, unopenedTablets);\n-            Set<KeyExtent> openingOverlapping = KeyExtent.findOverlapping(extent, openingTablets);\n-            Set<KeyExtent> onlineOverlapping =\n-                KeyExtent.findOverlapping(extent, onlineTablets.snapshot());\n-\n-            Set<KeyExtent> all = new HashSet<>();\n-            all.addAll(unopenedOverlapping);\n-            all.addAll(openingOverlapping);\n-            all.addAll(onlineOverlapping);\n-\n-            if (!all.isEmpty()) {\n-\n-              // ignore any tablets that have recently split, for error logging\n-              for (KeyExtent e2 : onlineOverlapping) {\n-                Tablet tablet = getOnlineTablet(e2);\n-                if (System.currentTimeMillis() - tablet.getSplitCreationTime()\n-                    < RECENTLY_SPLIT_MILLIES) {\n-                  all.remove(e2);\n-                }\n-              }\n-\n-              // ignore self, for error logging\n-              all.remove(extent);\n-\n-              if (all.size() > 0) {\n-                log.error(\"Tablet {} overlaps previously assigned {} {} {}\", extent,\n-                    unopenedOverlapping, openingOverlapping, onlineOverlapping + \" \" + all);\n-              }\n-              return;\n-            }\n-\n-            unopenedTablets.add(extent);\n-          }\n-        }\n-      }\n-\n-      TabletLogger.loading(extent, TabletServer.this.getTabletSession());\n-\n-      final AssignmentHandler ah = new AssignmentHandler(extent);\n-      // final Runnable ah = new LoggingRunnable(log, );\n-      // Root tablet assignment must take place immediately\n-\n-      if (extent.isRootTablet()) {\n-        new Daemon(\"Root Tablet Assignment\") {\n-          @Override\n-          public void run() {\n-            ah.run();\n-            if (onlineTablets.snapshot().containsKey(extent)) {\n-              log.info(\"Root tablet loaded: {}\", extent);\n-            } else {\n-              log.info(\"Root tablet failed to load\");\n-            }\n-\n-          }\n-        }.start();\n-      } else {\n-        if (extent.isMeta()) {\n-          resourceManager.addMetaDataAssignment(extent, log, ah);\n-        } else {\n-          resourceManager.addAssignment(extent, log, ah);\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void unloadTablet(TInfo tinfo, TCredentials credentials, String lock, TKeyExtent textent,\n-        TUnloadTabletGoal goal, long requestTime) {\n-      try {\n-        checkPermission(credentials, lock, \"unloadTablet\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to unload a tablet\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      KeyExtent extent = new KeyExtent(textent);\n-\n-      resourceManager.addMigration(extent,\n-          new LoggingRunnable(log, new UnloadTabletHandler(extent, goal, requestTime)));\n-    }\n-\n-    @Override\n-    public void flush(TInfo tinfo, TCredentials credentials, String lock, String tableId,\n-        ByteBuffer startRow, ByteBuffer endRow) {\n-      try {\n-        checkPermission(credentials, lock, \"flush\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to flush a table\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      ArrayList<Tablet> tabletsToFlush = new ArrayList<>();\n-\n-      KeyExtent ke = new KeyExtent(TableId.of(tableId), ByteBufferUtil.toText(endRow),\n-          ByteBufferUtil.toText(startRow));\n-\n-      for (Tablet tablet : getOnlineTablets().values()) {\n-        if (ke.overlaps(tablet.getExtent())) {\n-          tabletsToFlush.add(tablet);\n-        }\n-      }\n-\n-      Long flushID = null;\n-\n-      for (Tablet tablet : tabletsToFlush) {\n-        if (flushID == null) {\n-          // read the flush id once from zookeeper instead of reading\n-          // it for each tablet\n-          try {\n-            flushID = tablet.getFlushID();\n-          } catch (NoNodeException e) {\n-            // table was probably deleted\n-            log.info(\"Asked to flush table that has no flush id {} {}\", ke, e.getMessage());\n-            return;\n-          }\n-        }\n-        tablet.flush(flushID);\n-      }\n-    }\n-\n-    @Override\n-    public void flushTablet(TInfo tinfo, TCredentials credentials, String lock,\n-        TKeyExtent textent) {\n-      try {\n-        checkPermission(credentials, lock, \"flushTablet\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to flush a tablet\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      Tablet tablet = getOnlineTablet(new KeyExtent(textent));\n-      if (tablet != null) {\n-        log.info(\"Flushing {}\", tablet.getExtent());\n-        try {\n-          tablet.flush(tablet.getFlushID());\n-        } catch (NoNodeException nne) {\n-          log.info(\"Asked to flush tablet that has no flush id {} {}\", new KeyExtent(textent),\n-              nne.getMessage());\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void halt(TInfo tinfo, TCredentials credentials, String lock)\n-        throws ThriftSecurityException {\n-\n-      checkPermission(credentials, lock, \"halt\");\n-\n-      Halt.halt(0, () -> {\n-        log.info(\"Master requested tablet server halt\");\n-        gcLogger.logGCInfo(TabletServer.this.getConfiguration());\n-        serverStopRequested = true;\n-        try {\n-          tabletServerLock.unlock();\n-        } catch (Exception e) {\n-          log.error(\"Caught exception unlocking TabletServer lock\", e);\n-        }\n-      });\n-    }\n-\n-    @Override\n-    public void fastHalt(TInfo info, TCredentials credentials, String lock) {\n-      try {\n-        halt(info, credentials, lock);\n-      } catch (Exception e) {\n-        log.warn(\"Error halting\", e);\n-      }\n-    }\n-\n-    @Override\n-    public TabletStats getHistoricalStats(TInfo tinfo, TCredentials credentials) {\n-      return statsKeeper.getTabletStats();\n-    }\n-\n-    @Override\n-    public List<ActiveScan> getActiveScans(TInfo tinfo, TCredentials credentials)\n-        throws ThriftSecurityException, TException {\n-      try {\n-        checkPermission(credentials, null, \"getScans\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to get active scans\", e);\n-        throw e;\n-      }\n-\n-      return sessionManager.getActiveScans();\n-    }\n-\n-    @Override\n-    public void chop(TInfo tinfo, TCredentials credentials, String lock, TKeyExtent textent) {\n-      try {\n-        checkPermission(credentials, lock, \"chop\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to chop extent\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      KeyExtent ke = new KeyExtent(textent);\n-\n-      Tablet tablet = getOnlineTablet(ke);\n-      if (tablet != null) {\n-        tablet.chopFiles();\n-      }\n-    }\n-\n-    @Override\n-    public void compact(TInfo tinfo, TCredentials credentials, String lock, String tableId,\n-        ByteBuffer startRow, ByteBuffer endRow) {\n-      try {\n-        checkPermission(credentials, lock, \"compact\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to compact a table\", e);\n-        throw new RuntimeException(e);\n-      }\n-\n-      KeyExtent ke = new KeyExtent(TableId.of(tableId), ByteBufferUtil.toText(endRow),\n-          ByteBufferUtil.toText(startRow));\n-\n-      ArrayList<Tablet> tabletsToCompact = new ArrayList<>();\n-\n-      for (Tablet tablet : getOnlineTablets().values()) {\n-        if (ke.overlaps(tablet.getExtent())) {\n-          tabletsToCompact.add(tablet);\n-        }\n-      }\n-\n-      Pair<Long,UserCompactionConfig> compactionInfo = null;\n-\n-      for (Tablet tablet : tabletsToCompact) {\n-        // all for the same table id, so only need to read\n-        // compaction id once\n-        if (compactionInfo == null) {\n-          try {\n-            compactionInfo = tablet.getCompactionID();\n-          } catch (NoNodeException e) {\n-            log.info(\"Asked to compact table with no compaction id {} {}\", ke, e.getMessage());\n-            return;\n-          }\n-        }\n-        tablet.compactAll(compactionInfo.getFirst(), compactionInfo.getSecond());\n-      }\n-\n-    }\n-\n-    @Override\n-    public List<ActiveCompaction> getActiveCompactions(TInfo tinfo, TCredentials credentials)\n-        throws ThriftSecurityException, TException {\n-      try {\n-        checkPermission(credentials, null, \"getActiveCompactions\");\n-      } catch (ThriftSecurityException e) {\n-        log.error(\"Caller doesn't have permission to get active compactions\", e);\n-        throw e;\n-      }\n-\n-      List<CompactionInfo> compactions = Compactor.getRunningCompactions();\n-      List<ActiveCompaction> ret = new ArrayList<>(compactions.size());\n-\n-      for (CompactionInfo compactionInfo : compactions) {\n-        ret.add(compactionInfo.toThrift());\n-      }\n-\n-      return ret;\n-    }\n-\n-    @Override\n-    public List<String> getActiveLogs(TInfo tinfo, TCredentials credentials) {\n-      String log = logger.getLogFile();\n-      // Might be null if there no active logger\n-      if (log == null) {\n-        return Collections.emptyList();\n-      }\n-      return Collections.singletonList(log);\n-    }\n-\n-    @Override\n-    public void removeLogs(TInfo tinfo, TCredentials credentials, List<String> filenames) {\n-      log.warn(\"Garbage collector is attempting to remove logs through the tablet server\");\n-      log.warn(\"This is probably because your file\"\n-          + \" Garbage Collector is an older version than your tablet servers.\\n\"\n-          + \"Restart your file Garbage Collector.\");\n-    }\n-\n-    private TSummaries getSummaries(Future<SummaryCollection> future) throws TimeoutException {\n-      try {\n-        SummaryCollection sc =\n-            future.get(MAX_TIME_TO_WAIT_FOR_SCAN_RESULT_MILLIS, TimeUnit.MILLISECONDS);\n-        return sc.toThrift();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (ExecutionException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    private TSummaries handleTimeout(long sessionId) {\n-      long timeout =\n-          TabletServer.this.getConfiguration().getTimeInMillis(Property.TSERV_CLIENT_TIMEOUT);\n-      sessionManager.removeIfNotAccessed(sessionId, timeout);\n-      return new TSummaries(false, sessionId, -1, -1, null);\n-    }\n-\n-    private TSummaries startSummaryOperation(TCredentials credentials,\n-        Future<SummaryCollection> future) {\n-      try {\n-        return getSummaries(future);\n-      } catch (TimeoutException e) {\n-        long sid = sessionManager.createSession(new SummarySession(credentials, future), false);\n-        while (sid == 0) {\n-          sessionManager.removeSession(sid);\n-          sid = sessionManager.createSession(new SummarySession(credentials, future), false);\n-        }\n-        return handleTimeout(sid);\n-      }\n-    }\n-\n-    @Override\n-    public TSummaries startGetSummaries(TInfo tinfo, TCredentials credentials,\n-        TSummaryRequest request)\n-        throws ThriftSecurityException, ThriftTableOperationException, TException {\n-      NamespaceId namespaceId;\n-      TableId tableId = TableId.of(request.getTableId());\n-      try {\n-        namespaceId = Tables.getNamespaceId(getContext(), tableId);\n-      } catch (TableNotFoundException e1) {\n-        throw new ThriftTableOperationException(tableId.canonical(), null, null,\n-            TableOperationExceptionType.NOTFOUND, null);\n-      }\n-\n-      if (!security.canGetSummaries(credentials, tableId, namespaceId)) {\n-        throw new AccumuloSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED).asThriftException();\n-      }\n-\n-      ExecutorService es = resourceManager.getSummaryPartitionExecutor();\n-      Future<SummaryCollection> future = new Gatherer(getContext(), request,\n-          getContext().getTableConfiguration(tableId), getContext().getCryptoService()).gather(es);\n-\n-      return startSummaryOperation(credentials, future);\n-    }\n-\n-    @Override\n-    public TSummaries startGetSummariesForPartition(TInfo tinfo, TCredentials credentials,\n-        TSummaryRequest request, int modulus, int remainder)\n-        throws ThriftSecurityException, TException {\n-      // do not expect users to call this directly, expect other tservers to call this method\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new AccumuloSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED).asThriftException();\n-      }\n-\n-      ExecutorService spe = resourceManager.getSummaryRemoteExecutor();\n-      TableConfiguration tableConfig =\n-          getContext().getTableConfiguration(TableId.of(request.getTableId()));\n-      Future<SummaryCollection> future =\n-          new Gatherer(getContext(), request, tableConfig, getContext().getCryptoService())\n-              .processPartition(spe, modulus, remainder);\n-\n-      return startSummaryOperation(credentials, future);\n-    }\n-\n-    @Override\n-    public TSummaries startGetSummariesFromFiles(TInfo tinfo, TCredentials credentials,\n-        TSummaryRequest request, Map<String,List<TRowRange>> files)\n-        throws ThriftSecurityException, TException {\n-      // do not expect users to call this directly, expect other tservers to call this method\n-      if (!security.canPerformSystemActions(credentials)) {\n-        throw new AccumuloSecurityException(credentials.getPrincipal(),\n-            SecurityErrorCode.PERMISSION_DENIED).asThriftException();\n-      }\n-\n-      ExecutorService srp = resourceManager.getSummaryRetrievalExecutor();\n-      TableConfiguration tableCfg =\n-          getContext().getTableConfiguration(TableId.of(request.getTableId()));\n-      BlockCache summaryCache = resourceManager.getSummaryCache();\n-      BlockCache indexCache = resourceManager.getIndexCache();\n-      Cache<String,Long> fileLenCache = resourceManager.getFileLenCache();\n-      FileSystemResolver volMgr = p -> fs.getFileSystemByPath(p);\n-      Future<SummaryCollection> future =\n-          new Gatherer(getContext(), request, tableCfg, getContext().getCryptoService())\n-              .processFiles(volMgr, files, summaryCache, indexCache, fileLenCache, srp);\n-\n-      return startSummaryOperation(credentials, future);\n-    }\n+  private final AtomicLong totalQueuedMutationSize = new AtomicLong(0);\n+  private final ReentrantLock recoveryLock = new ReentrantLock(true);\n+  private ThriftClientHandler clientHandler;\n+  private final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n \n-    @Override\n-    public TSummaries contiuneGetSummaries(TInfo tinfo, long sessionId)\n-        throws NoSuchScanIDException, TException {\n-      SummarySession session = (SummarySession) sessionManager.getSession(sessionId);\n-      if (session == null) {\n-        throw new NoSuchScanIDException();\n-      }\n+  protected String getLockID() {", "originalCommit": "1bf3ba5904362eb6940780f6b1a87ebab7c39cf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b4482a5500e0f2df5d57af4c0732c7302822104", "url": "https://github.com/apache/accumulo/commit/9b4482a5500e0f2df5d57af4c0732c7302822104", "message": "Changed shared protected methods to package-private in TabletServer (#1581)", "committedDate": "2020-04-14T14:56:13Z", "type": "commit"}, {"oid": "f52baeb9f265e5d64219fe3eae011f167b5a5c41", "url": "https://github.com/apache/accumulo/commit/f52baeb9f265e5d64219fe3eae011f167b5a5c41", "message": "Merge branch 'master' into accumulo-1581", "committedDate": "2020-04-15T06:24:32Z", "type": "commit"}, {"oid": "129244d7ef50852d3f929c8ceda32ba328790ede", "url": "https://github.com/apache/accumulo/commit/129244d7ef50852d3f929c8ceda32ba328790ede", "message": "PR feedback from ctubbsii as a commit", "committedDate": "2020-04-15T06:25:11Z", "type": "commit"}]}