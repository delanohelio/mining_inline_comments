{"pr_number": 1555, "pr_title": "Fix idempotency bug in importtable", "pr_createdAt": "2020-03-08T18:52:40Z", "pr_url": "https://github.com/apache/accumulo/pull/1555", "timeline": [{"oid": "b3dc5f629b59d51d0580a5df710f6743d518b308", "url": "https://github.com/apache/accumulo/commit/b3dc5f629b59d51d0580a5df710f6743d518b308", "message": "Fix idempotency bug in importtable\nThe previous implementation would fail when an interrupted importtable\noperation was retried by FATE, as it would not find (already moved)\nfiles in the exported directory. Additionally, this commit also removes\na chatty fs.exists() check.", "committedDate": "2020-03-08T18:50:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMTY1MQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r389421651", "bodyText": "Not sure if it's worth it, but I think you could maybe reuse the lambda used for the Predicate, as in the following.\nAlso, I think .noneMatch(p) is probably better than .filter(p).count() != 1, since it's not really possible to have multiple files in the same directory match on the same file name anyway... so the result is always binary (present or absent).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String oldFileName : fileNameMappings.keySet()) {\n          \n          \n            \n                    if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n          \n          \n            \n                      throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n          \n          \n            \n                          TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n          \n          \n            \n                          \"File referenced by exported table does not exists \" + oldFileName);\n          \n          \n            \n                    if (Arrays.stream(exportedFiles).filter(fstat ->\n          \n          \n            \n                        fstat.getPath().getName().equals(oldFileName)).count() != 1) {\n          \n          \n            \n                      if (Arrays.stream(importedFiles).filter(fstat ->\n          \n          \n            \n                          fstat.getPath().getName().equals(fileNameMappings.get(oldFileName))).count() != 1) {\n          \n          \n            \n                        throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n          \n          \n            \n                            TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n          \n          \n            \n                            \"File referenced by exported table does not exist \" + oldFileName);\n          \n          \n            \n                      }\n          \n          \n            \n                  // given a name, return a predicate that can check a FileStatus for a match against that name\n          \n          \n            \n                  Function<String,Predicate<FileStatus>> nameEq = name -> fstat -> fstat.getPath().getName().equals(name);\n          \n          \n            \n                  for (String oldFileName : fileNameMappings.keySet()) {\n          \n          \n            \n                    if (Arrays.stream(exportedFiles).noneMatch(nameEq.apply(oldFileName))) {\n          \n          \n            \n                      String newFileName = fileNameMappings.get(oldFileName);\n          \n          \n            \n                      if (Arrays.stream(importedFiles).noneMatch(nameEq.apply(newFileName))) {\n          \n          \n            \n                        throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n          \n          \n            \n                            TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n          \n          \n            \n                            \"File referenced by exported table does not exist \" + oldFileName);\n          \n          \n            \n                      }", "author": "ctubbsii", "createdAt": "2020-03-09T00:12:09Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,17 +49,22 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+\n       for (String oldFileName : fileNameMappings.keySet()) {\n-        if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n-          throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n-              TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n-              \"File referenced by exported table does not exists \" + oldFileName);\n+        if (Arrays.stream(exportedFiles).filter(fstat ->\n+            fstat.getPath().getName().equals(oldFileName)).count() != 1) {\n+          if (Arrays.stream(importedFiles).filter(fstat ->\n+              fstat.getPath().getName().equals(fileNameMappings.get(oldFileName))).count() != 1) {\n+            throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n+                TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n+                \"File referenced by exported table does not exist \" + oldFileName);\n+          }", "originalCommit": "b3dc5f629b59d51d0580a5df710f6743d518b308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1NDU5MA==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390054590", "bodyText": "Thank you Christopher! I did implement this and have it as a viable option - but I would like to evaluate Keith's suggestion as well before finalizing.", "author": "arvindshmicrosoft", "createdAt": "2020-03-10T01:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r389808195", "bodyText": "Could possibly avoid the linear search in each loop iteration with something like the following before the loop.\nSet<String> importing = Arrays.stream(exportedFiles).map(fstat ->\n            fstat.getPath().getName()).map(fileNameMapping::get).collect(Collectors.toSet());\nSet<String> imported = Arrays.stream(importedFiles).map(fstat ->\n            fstat.getPath().getName()).collect(Collectors.toSet());\n\n//ensure Sets.union(importing, imported) equals new HashSet<>(fileNameMappings.values())", "author": "keith-turner", "createdAt": "2020-03-09T16:30:05Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,17 +49,22 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+", "originalCommit": "b3dc5f629b59d51d0580a5df710f6743d518b308", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1NDg5Ng==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390054896", "bodyText": "This seems quite elegant, and I am working toward this. The only question I have at this stage is the usage of the Guava Sets class. I presume there are no concerns (both for this PR and from later porting this to 2.x) on using Sets here? I did try using CollectionUtils but it seems far easier to perform set operations with the Sets class.", "author": "arvindshmicrosoft", "createdAt": "2020-03-10T01:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA3MjAwMw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390072003", "bodyText": "Guava Sets is definitely better over commons-collections CollectionUtils. We still use Guava in 2.x, so that should be fine. If you want a pure-Java way to do it, you could use Streams:\nStream.concat(importing.stream(),imported.stream()).collect(Collectors.toSet()).equals(Set.copyOf(fileNameMappings.values()));\nGuava's Sets.union is cleaner.", "author": "ctubbsii", "createdAt": "2020-03-10T03:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1MTA1Mg==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390451052", "bodyText": "One potential problem with using Guava is the @Beta APIs.  Those should be avoided, but its so easy to use them.  I forget to check.  I am not sure if Sets or any of its methods are @Beta.", "author": "keith-turner", "createdAt": "2020-03-10T16:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MDYyNw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390540627", "bodyText": "Thanks for the tip! I used the guava-beta-checker plugin to quickly establish if there is any new impact introduced by the usage of Sets. Thankfully, there is none, but in the process, I noticed there are many other @beta APIs used by previously existing code which are flagged by the plugin. For example, the use of Stopwatch and RateLimiter classes (and others) is flagged. I think that is a separate cleanup project on its own!", "author": "arvindshmicrosoft", "createdAt": "2020-03-10T18:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2OTY1Mg==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390569652", "bodyText": "I can create a separate PR with the guava-beta-checker added and emitting WARN for such beta APIs.", "author": "arvindshmicrosoft", "createdAt": "2020-03-10T19:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4MzI0MA==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390583240", "bodyText": "I did check. Sets is okay.", "author": "ctubbsii", "createdAt": "2020-03-10T20:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5OTIxMw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390599213", "bodyText": "@arvindshmicrosoft  I found #298.", "author": "keith-turner", "createdAt": "2020-03-10T20:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwMTE2Mg==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390601162", "bodyText": "Actually #340 would be the one to look at.", "author": "keith-turner", "createdAt": "2020-03-10T20:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwMzAxMw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390603013", "bodyText": "Great, so looks like we are fine for the purposes of this PR?", "author": "arvindshmicrosoft", "createdAt": "2020-03-10T20:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTE0Ng==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390649146", "bodyText": "guava-beta-checker requires errorprone. I'm not sold on the idea of dictating the compiler in the build, especially not for the default build. The spotbugs plugin would be less invasive (not sure that's the right word I mean). In any case, that can be a separate issue, if it matters.\nI'm going to make one more pass with some comments.", "author": "ctubbsii", "createdAt": "2020-03-10T22:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzk3NQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r389827975", "bodyText": "This is a really nice change, avoiding all of the individual namenode RPCs", "author": "keith-turner", "createdAt": "2020-03-09T17:01:07Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,17 +49,22 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));", "originalCommit": "b3dc5f629b59d51d0580a5df710f6743d518b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "url": "https://github.com/apache/accumulo/commit/0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "message": "Use Set operations to streamline code\nThis code uses set operations to validate if there are missing files in\nthe exported (source) directory. In addition the usage of sets improves\nperf compared to the lambda scanning the file status arrays.", "committedDate": "2020-03-10T05:19:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4OTM1MQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390589351", "bodyText": "Would be nice to avoid creating the concatenated string unless needed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.debug(\"Files already present in imported (target) directory: {}\",\n          \n          \n            \n                    StringUtils.join(imported.toArray(), \",\"));\n          \n          \n            \n              if(log.isDebugEnabled()){\n          \n          \n            \n                  log.debug(\"Files already present in imported (target) directory: {}\",\n          \n          \n            \n                    StringUtils.join(imported.toArray(), \",\"));\n          \n          \n            \n               }", "author": "keith-turner", "createdAt": "2020-03-10T20:25:18Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,21 +55,35 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n-      for (String oldFileName : fileNameMappings.keySet()) {\n-        if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n-          throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n-              TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n-              \"File referenced by exported table does not exists \" + oldFileName);\n-        }\n-      }\n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+\n+      Set<String> importing = Arrays.stream(exportedFiles).map(fstat -> fstat.getPath().getName())\n+        .map(fileNameMappings::get).collect(Collectors.toSet());\n \n-      FileStatus[] files = fs.listStatus(new Path(tableInfo.exportDir));\n+      Set<String> imported = Arrays.stream(importedFiles).map(fstat -> fstat.getPath().getName())\n+        .collect(Collectors.toSet());\n+      log.debug(\"Files already present in imported (target) directory: {}\",\n+        StringUtils.join(imported.toArray(), \",\"));", "originalCommit": "0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc0NzU5MQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390747591", "bodyText": "Addressed in latest commit", "author": "arvindshmicrosoft", "createdAt": "2020-03-11T05:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4OTM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTk2Nw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390649967", "bodyText": "fstat -> fstat.getPath().getName() is used twice. The lines can be shortened (possibly to one line each) if that lambda was saved in a reusable Function<FileStatus,String> fileStatusName = fstat -> fstat.getPath().getName(); variable or similar.", "author": "ctubbsii", "createdAt": "2020-03-10T22:33:26Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,21 +55,35 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n-      for (String oldFileName : fileNameMappings.keySet()) {\n-        if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n-          throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n-              TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n-              \"File referenced by exported table does not exists \" + oldFileName);\n-        }\n-      }\n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+\n+      Set<String> importing = Arrays.stream(exportedFiles).map(fstat -> fstat.getPath().getName())\n+        .map(fileNameMappings::get).collect(Collectors.toSet());\n \n-      FileStatus[] files = fs.listStatus(new Path(tableInfo.exportDir));\n+      Set<String> imported = Arrays.stream(importedFiles).map(fstat -> fstat.getPath().getName())\n+        .collect(Collectors.toSet());", "originalCommit": "0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc0NzUyOA==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390747528", "bodyText": "Addressed in latest commit - however FYI the formatter still causes the lines to wrap.", "author": "arvindshmicrosoft", "createdAt": "2020-03-11T05:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MTQ4Nw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390651487", "bodyText": "In addition to Keith's suggestion, we'll need to be careful about the use of commons-lang here when we merge to the master branch, which now uses commons-lang3. If you wanted to avoid that, you could instead use the built-in Java Joiner, as in:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringUtils.join(imported.toArray(), \",\"));\n          \n          \n            \n                    imported.stream().collect(Collectors.joining(\",\")));\n          \n      \n    \n    \n  \n\nIt's only slightly longer, but removes an unneeded library dependency.", "author": "ctubbsii", "createdAt": "2020-03-10T22:37:40Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,21 +55,35 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n-      for (String oldFileName : fileNameMappings.keySet()) {\n-        if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n-          throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n-              TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n-              \"File referenced by exported table does not exists \" + oldFileName);\n-        }\n-      }\n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+\n+      Set<String> importing = Arrays.stream(exportedFiles).map(fstat -> fstat.getPath().getName())\n+        .map(fileNameMappings::get).collect(Collectors.toSet());\n \n-      FileStatus[] files = fs.listStatus(new Path(tableInfo.exportDir));\n+      Set<String> imported = Arrays.stream(importedFiles).map(fstat -> fstat.getPath().getName())\n+        .collect(Collectors.toSet());\n+      log.debug(\"Files already present in imported (target) directory: {}\",\n+        StringUtils.join(imported.toArray(), \",\"));", "originalCommit": "0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc0NzMyNg==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390747326", "bodyText": "Addressed in latest commit", "author": "arvindshmicrosoft", "createdAt": "2020-03-11T05:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MTQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MjQ1OQ==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390652459", "bodyText": "This doesn't match our formatter style. Before we merge this, make sure the code is formatted and the basic QA checks pass (mvn clean verify -DskipTests).", "author": "ctubbsii", "createdAt": "2020-03-10T22:40:09Z", "path": "server/master/src/main/java/org/apache/accumulo/master/tableOps/MoveExportedFiles.java", "diffHunk": "@@ -48,21 +55,35 @@\n \n       Map<String,String> fileNameMappings = PopulateMetadataTable.readMappingFile(fs, tableInfo);\n \n-      for (String oldFileName : fileNameMappings.keySet()) {\n-        if (!fs.exists(new Path(tableInfo.exportDir, oldFileName))) {\n-          throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName,\n-              TableOperation.IMPORT, TableOperationExceptionType.OTHER,\n-              \"File referenced by exported table does not exists \" + oldFileName);\n-        }\n-      }\n+      FileStatus[] exportedFiles = fs.listStatus(new Path(tableInfo.exportDir));\n+      FileStatus[] importedFiles = fs.listStatus(new Path(tableInfo.importDir));\n+\n+      Set<String> importing = Arrays.stream(exportedFiles).map(fstat -> fstat.getPath().getName())\n+        .map(fileNameMappings::get).collect(Collectors.toSet());\n \n-      FileStatus[] files = fs.listStatus(new Path(tableInfo.exportDir));\n+      Set<String> imported = Arrays.stream(importedFiles).map(fstat -> fstat.getPath().getName())\n+        .collect(Collectors.toSet());\n+      log.debug(\"Files already present in imported (target) directory: {}\",\n+        StringUtils.join(imported.toArray(), \",\"));\n \n-      for (FileStatus fileStatus : files) {\n+      Set<String> missingFiles = Sets.difference(new HashSet<String>(fileNameMappings.values()),\n+        new HashSet<String>(Sets.union(importing, imported)));\n+\n+      if (!missingFiles.isEmpty())\n+      {", "originalCommit": "0e5f5c407f4c8ed9a188470be255b7833d1e2ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3Mjg2Nw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390672867", "bodyText": "For small changes I only run mvn compile to format the code and let Travis CI do the basic quality checks.", "author": "keith-turner", "createdAt": "2020-03-10T23:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTE5MA==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390715190", "bodyText": "That's fine, too. I typically do it locally, since it doesn't take that long, and it results in fewer round trips to resolve all the issues. Also, we have limited executors on Travis that we share with the rest of the ASF, so it can take awhile before it runs in Travis.", "author": "ctubbsii", "createdAt": "2020-03-11T02:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNjQ0Mw==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390736443", "bodyText": "Sorry for the overlook. I will ensure the QA checks pass before the next commit.", "author": "arvindshmicrosoft", "createdAt": "2020-03-11T04:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc0NzMwMg==", "url": "https://github.com/apache/accumulo/pull/1555#discussion_r390747302", "bodyText": "Addressed in latest commit", "author": "arvindshmicrosoft", "createdAt": "2020-03-11T05:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MjQ1OQ=="}], "type": "inlineReview"}, {"oid": "4cf2aa4785ad1ddee9b6d35364fa328c321f49cd", "url": "https://github.com/apache/accumulo/commit/4cf2aa4785ad1ddee9b6d35364fa328c321f49cd", "message": "Fix formatting and use inbuilt Java joiner", "committedDate": "2020-03-11T05:00:36Z", "type": "commit"}]}