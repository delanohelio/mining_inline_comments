{"pr_number": 7924, "pr_title": "MINOR: Remove updatePartitionReplicaAssignment from ControllerContext", "pr_createdAt": "2020-01-09T23:21:40Z", "pr_url": "https://github.com/apache/kafka/pull/7924", "timeline": [{"oid": "137563e19e1c116edc0818e57b7c1b4f7c97d115", "url": "https://github.com/apache/kafka/commit/137563e19e1c116edc0818e57b7c1b4f7c97d115", "message": "MINOR: Remove updatePartitionReplicaAssignment from ControllerContext\n\nThe method updatePartitionReplicaAssignment allows the user to direcly\nmodify the replicas assigned to a partition without also modifying the\naddingReplicas and removingReplicas fields. This is not a safe operation\nfor all inputs.\n\nClients should instead use updatePartitionFullReplicaAssignment.", "committedDate": "2020-01-09T23:17:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwODMwNQ==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365008305", "bodyText": "This method was not used by the controller after we introduced reassignTo. This functionality was moved to reassignTo.", "author": "jsancio", "createdAt": "2020-01-09T23:22:45Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -23,18 +23,11 @@ import org.apache.kafka.common.TopicPartition\n import scala.collection.{Map, Seq, Set, mutable}\n \n object ReplicaAssignment {\n-  def fromOldAndNewReplicas(oldReplicas: Seq[Int], newReplicas: Seq[Int]): ReplicaAssignment = {\n-    val fullReplicaSet = (newReplicas ++ oldReplicas).distinct\n-    ReplicaAssignment(\n-      fullReplicaSet,\n-      fullReplicaSet.diff(oldReplicas),\n-      fullReplicaSet.diff(newReplicas)\n-    )\n-  }", "originalCommit": "137563e19e1c116edc0818e57b7c1b4f7c97d115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwODYwNw==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365008607", "bodyText": "The bulk of this change is the removal of this method and the changes related to this removal.", "author": "jsancio", "createdAt": "2020-01-09T23:23:43Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -126,29 +132,8 @@ class ControllerContext {\n   }\n \n   def partitionFullReplicaAssignment(topicPartition: TopicPartition): ReplicaAssignment = {\n-    partitionAssignments.getOrElse(topicPartition.topic, mutable.Map.empty).get(topicPartition.partition) match {\n-      case Some(partitionAssignment) => partitionAssignment\n-      case None => ReplicaAssignment(Seq(), Seq(), Seq())\n-    }\n-  }\n-\n-  def updatePartitionReplicaAssignment(topicPartition: TopicPartition, newReplicas: Seq[Int]): Unit = {", "originalCommit": "137563e19e1c116edc0818e57b7c1b4f7c97d115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NDA1Ng==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365444056", "bodyText": "nit: is this conventional? I don't think we use this ordering anywhere else in the code?", "author": "hachikuji", "createdAt": "2020-01-10T21:49:10Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -44,9 +37,9 @@ object ReplicaAssignment {\n  * @param addingReplicas the replicas that are being added if there is a pending reassignment\n  * @param removingReplicas the replicas that are being removed if there is a pending reassignment\n  */\n-case class ReplicaAssignment(replicas: Seq[Int],\n-                             addingReplicas: Seq[Int],\n-                             removingReplicas: Seq[Int]) {\n+case class ReplicaAssignment private (replicas: Seq[Int],", "originalCommit": "137563e19e1c116edc0818e57b7c1b4f7c97d115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ1MDc4OA==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365450788", "bodyText": "Are you referring to the private keyword after ReplicaAssignment? This is how to declare the \"default\" constructor private in Scala. This is the best reference I could find: https://www.scala-lang.org/download/changelog.html#access-modifiers-for-primary-constructors\nNicely we never create this class directly (outside of JSON to ReplicaAssignment decoding). We either use some of the other apply methods or the reassignTo method. I don't think in the future we will want to create the value directly so I thought might as well make it private.", "author": "jsancio", "createdAt": "2020-01-10T22:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MzUzNg==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365473536", "bodyText": "Ah, ok. First time I have seen this.", "author": "hachikuji", "createdAt": "2020-01-10T23:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NDA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NjM4OQ==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365446389", "bodyText": "This code smells a bit (not from this PR). Feels like we need to refetch the assignment state in order to confirm whether the replicaId should be there or not. I guess after zk removal, the controller context will be guaranteed to be up to date and we can improve this.", "author": "hachikuji", "createdAt": "2020-01-10T21:56:43Z", "path": "core/src/main/scala/kafka/controller/ReplicaStateMachine.scala", "diffHunk": "@@ -192,9 +192,11 @@ class ZkReplicaStateMachine(config: KafkaConfig,\n \n           currentState match {\n             case NewReplica =>\n-              val assignment = controllerContext.partitionReplicaAssignment(partition)\n-              if (!assignment.contains(replicaId)) {\n-                controllerContext.updatePartitionReplicaAssignment(partition, assignment :+ replicaId)\n+              val assignment = controllerContext.partitionFullReplicaAssignment(partition)\n+              if (!assignment.replicas.contains(replicaId)) {\n+                error(s\"Adding replica ($replicaId) that is not part of the assignment $assignment\")\n+                val newAssignment = assignment.copy(replicas = assignment.replicas :+ replicaId)", "originalCommit": "137563e19e1c116edc0818e57b7c1b4f7c97d115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ1Mzg1Nw==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365453857", "bodyText": "Yeah. This state machine is a little strange. I convinced myself that this condition is not possible. The controllers needs to find out that replicaId is assigned to partition to be able to call doHandleStateChanges with those values and this is only possible if controllerContext has this information.\nAnother insight to why this code path is not possible is that this condition would magically change the ordering of the assignment.\nI made the conservative change and simply logged an error message. If we are interested, I can revisit this code to remove this code path.", "author": "jsancio", "createdAt": "2020-01-10T22:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NjM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NDA1OA==", "url": "https://github.com/apache/kafka/pull/7924#discussion_r365474058", "bodyText": "Yeah, we don't need to do it here, but if you think the state is not reachable, I'd suggest filing a separate PR. I'd rather raise an error instead of trying to fix up some state inconsistency. It's a bit arbitrary to assume the state change is probably right.", "author": "hachikuji", "createdAt": "2020-01-10T23:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0NjM4OQ=="}], "type": "inlineReview"}]}