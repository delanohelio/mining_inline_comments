{"pr_number": 7963, "pr_title": "KAFKA-9235; Ensure transaction coordinator resigns after replica deletion", "pr_createdAt": "2020-01-15T01:19:50Z", "pr_url": "https://github.com/apache/kafka/pull/7963", "timeline": [{"oid": "66e378c273f89b0918156f01908638443f2f6172", "url": "https://github.com/apache/kafka/commit/66e378c273f89b0918156f01908638443f2f6172", "message": "KAFKA-9235; Ensure transaction coordinator is stopped after replica deletion", "committedDate": "2020-01-15T01:16:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1NzMwNw==", "url": "https://github.com/apache/kafka/pull/7963#discussion_r366657307", "bodyText": "Note I got rid of this because there didn't seem to be a strong reason to do transaction state unloading asynchronously (all we do is remove a key from a map).", "author": "hachikuji", "createdAt": "2020-01-15T01:27:39Z", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala", "diffHunk": "@@ -90,9 +90,6 @@ class TransactionStateManager(brokerId: Int,\n   /** partitions of transaction topic that are being loaded, state lock should be called BEFORE accessing this set */\n   private[transaction] val loadingPartitions: mutable.Set[TransactionPartitionAndLeaderEpoch] = mutable.Set()\n \n-  /** partitions of transaction topic that are being removed, state lock should be called BEFORE accessing this set */\n-  private[transaction] val leavingPartitions: mutable.Set[TransactionPartitionAndLeaderEpoch] = mutable.Set()", "originalCommit": "66e378c273f89b0918156f01908638443f2f6172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1OTQyMQ==", "url": "https://github.com/apache/kafka/pull/7963#discussion_r366659421", "bodyText": "Minor test bug fix here.", "author": "hachikuji", "createdAt": "2020-01-15T01:37:18Z", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala", "diffHunk": "@@ -106,11 +107,103 @@ class TransactionStateManagerTest {\n \n     assertEquals(Right(None), transactionManager.getTransactionState(transactionalId1))\n     assertEquals(Right(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1)),\n-      transactionManager.putTransactionStateIfNotExists(transactionalId1, txnMetadata1))\n+      transactionManager.putTransactionStateIfNotExists(txnMetadata1))\n     assertEquals(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1))),\n       transactionManager.getTransactionState(transactionalId1))\n-    assertEquals(Right(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1)),\n-      transactionManager.putTransactionStateIfNotExists(transactionalId1, txnMetadata2))", "originalCommit": "66e378c273f89b0918156f01908638443f2f6172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}