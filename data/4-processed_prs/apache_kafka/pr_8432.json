{"pr_number": 8432, "pr_title": "MINOR: Fix KafkaApis.filterAuthorized", "pr_createdAt": "2020-04-06T14:38:29Z", "pr_url": "https://github.com/apache/kafka/pull/8432", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404150502", "bodyText": "The ordering is relevant (see the zip call below) and we lose it with this change. Did the tests pass with this change? If so, maybe we need to add more tests as they should not.\nSeems like the easiest fix may be to call resourceNames.distinct before using it anywhere else.", "author": "ijuma", "createdAt": "2020-04-06T14:47:37Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,35 +2876,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n-          val count = groupedResourceNames(resourceName).size\n+        val actions = groupedResourceNames.map { case (resourceName, groupedNames) =>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE2MjEwMw==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404162103", "bodyText": "Oh, right. Let me fix that.", "author": "dajac", "createdAt": "2020-04-06T15:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE3MTMxOA==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404171318", "bodyText": "I have extended the unit test to cover this case and updated the implementation as well.", "author": "dajac", "createdAt": "2020-04-06T15:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMDgxNQ==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404210815", "bodyText": "To verify, the test case failed without the second fix?", "author": "ijuma", "createdAt": "2020-04-06T16:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}], "type": "inlineReview"}, {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0", "url": "https://github.com/apache/kafka/commit/8b16a898db41a015717079bec0aacc4dedb14df0", "message": "MINOR: Fix KafkaApis.filterAuthorized\n\nhttps://github.com/apache/kafka/commit/90bbeedf52f4b6a411e9630dd132583afa4cd428 introduced a regression resulting in passing an action per ressournce name to the Authorizer instead of passing one per unique resource name. This PR refactors the signatures of both `filterAuthorized` and `authorize` to make them easier to test and adds a test for each.", "committedDate": "2020-04-06T15:11:57Z", "type": "commit"}, {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0", "url": "https://github.com/apache/kafka/commit/8b16a898db41a015717079bec0aacc4dedb14df0", "message": "MINOR: Fix KafkaApis.filterAuthorized\n\nhttps://github.com/apache/kafka/commit/90bbeedf52f4b6a411e9630dd132583afa4cd428 introduced a regression resulting in passing an action per ressournce name to the Authorizer instead of passing one per unique resource name. This PR refactors the signatures of both `filterAuthorized` and `authorize` to make them easier to test and adds a test for each.", "committedDate": "2020-04-06T15:11:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMjUxOQ==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404212519", "bodyText": "Nit: I would move this to the next line, it's a bit hard to read with if/else misaligned.", "author": "ijuma", "createdAt": "2020-04-06T16:09:11Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1673,11 +1678,13 @@ class KafkaApis(val requestChannel: RequestChannel,\n       createTopicsRequest.data.topics.asScala.foreach { topic =>\n         results.add(new CreatableTopicResult().setName(topic.name))\n       }\n-      val hasClusterAuthorization = authorize(request, CREATE, CLUSTER, CLUSTER_NAME, logIfDenied = false)\n+      val hasClusterAuthorization = authorize(request.context, CREATE, CLUSTER, CLUSTER_NAME,\n+        logIfDenied = false)\n       val topics = createTopicsRequest.data.topics.asScala.map(_.name)\n-      val authorizedTopics = if (hasClusterAuthorization) topics.toSet else filterAuthorized(request, CREATE, TOPIC, topics.toSeq)\n-      val authorizedForDescribeConfigs = filterAuthorized(request, DESCRIBE_CONFIGS, TOPIC, topics.toSeq, logIfDenied = false)\n-        .map(name => name -> results.find(name)).toMap\n+      val authorizedTopics = if (hasClusterAuthorization) topics.toSet", "originalCommit": "8b16a898db41a015717079bec0aacc4dedb14df0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzY2MA==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237660", "bodyText": "Ack.", "author": "dajac", "createdAt": "2020-04-06T16:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNDM5MA==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404214390", "bodyText": "We can replace the next line by uniqueResourceNames.toSet? Doesn't change the behavior, but slightly better performance if there were indeed duplicates.", "author": "ijuma", "createdAt": "2020-04-06T16:11:51Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,36 +2876,39 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n+        val uniqueResourceNames = resourceNames.distinct\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n+        val actions = uniqueResourceNames.map { resourceName =>\n           val count = groupedResourceNames(resourceName).size\n           val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n           new Action(operation, resource, count, logIfAllowed, logIfDenied)\n         }\n-        authZ.authorize(request.context, actions.asJava).asScala\n-          .zip(resourceNames)\n+        authZ.authorize(requestContext, actions.asJava).asScala\n+          .zip(uniqueResourceNames)\n           .filter { case (authzResult, _) => authzResult == AuthorizationResult.ALLOWED }\n           .map { case (_, resourceName) => resourceName }.toSet\n       case None =>", "originalCommit": "8b16a898db41a015717079bec0aacc4dedb14df0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzU5Nw==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237597", "bodyText": "Yes.", "author": "dajac", "createdAt": "2020-04-06T16:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTAyMw==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404215023", "bodyText": "Do we need to specify the val type here? Since we are passing it to niceMock, doesn't it figure it out by itself? Same question for the next test.", "author": "ijuma", "createdAt": "2020-04-06T16:12:42Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])", "originalCommit": "8b16a898db41a015717079bec0aacc4dedb14df0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzM5OQ==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237399", "bodyText": "It does not compile without the type: value authorize is not a member of Nothing at L153.", "author": "dajac", "createdAt": "2020-04-06T16:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTIwNg==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404215206", "bodyText": "Nit: is the () needed here? Same question in the next test.", "author": "ijuma", "createdAt": "2020-04-06T16:12:57Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])\n+\n+    val operation = AclOperation.WRITE\n+    val resourceType = ResourceType.TOPIC\n+    val resourceName = \"topic-1\"\n+    val requestHeader = new RequestHeader(ApiKeys.PRODUCE, ApiKeys.PRODUCE.latestVersion(),", "originalCommit": "8b16a898db41a015717079bec0aacc4dedb14df0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzUyMg==", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237522", "bodyText": "Right, it is not.", "author": "dajac", "createdAt": "2020-04-06T16:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTIwNg=="}], "type": "inlineReview"}, {"oid": "a46f012eddf8fda39071387eb802c6f50bb9de55", "url": "https://github.com/apache/kafka/commit/a46f012eddf8fda39071387eb802c6f50bb9de55", "message": "Address comments", "committedDate": "2020-04-06T16:46:39Z", "type": "commit"}, {"oid": "1f71ff568868ce87a89590d7b903b9f30e280c3e", "url": "https://github.com/apache/kafka/commit/1f71ff568868ce87a89590d7b903b9f30e280c3e", "message": "Remove unnecessary braces in if/else", "committedDate": "2020-04-06T16:52:12Z", "type": "commit"}]}