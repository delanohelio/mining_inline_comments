{"pr_number": 8902, "pr_title": "KAFKA-10179: Pass correct changelog topic to state serdes", "pr_createdAt": "2020-06-19T15:04:12Z", "pr_url": "https://github.com/apache/kafka/pull/8902", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MzkxMg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r443053912", "bodyText": "It seems this is a slight change in behavior? Before, we would only get a topic name returned in register was called, as we build up a local map. Now, we only rely on stateManager that might contain a topic name for a store, even if register was never called (even if the call to super.register call stateManager.register -- hence, I am wondering if we loose a guard?", "author": "mjsax", "createdAt": "2020-06-19T21:40:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -120,7 +118,7 @@ public void logChange(final String storeName,\n         throwUnsupportedOperationExceptionIfStandby(\"logChange\");\n         // Sending null headers to changelog topics (KIP-244)\n         collector.send(\n-            storeToChangelogTopic.get(storeName),\n+            stateManager.changelogFor(storeName),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyNTMyOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444325329", "bodyText": "I added an exception to make sure we do not changelog not registered state stores.\nI also used the registered metadata for the stores in the send() call. I felt that it would be cleaner.", "author": "cadonna", "createdAt": "2020-06-23T15:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDAwOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r443054009", "bodyText": "If we only pass through, we can remove the overwrite of the method completely.", "author": "mjsax", "createdAt": "2020-06-19T21:40:37Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -103,7 +102,6 @@ public ProcessorStateManager stateManager() {\n     @Override\n     public void register(final StateStore store,\n                          final StateRestoreCallback stateRestoreCallback) {\n-        storeToChangelogTopic.put(store.name(), ProcessorStateManager.storeChangelogTopic(applicationId(), store.name()));\n         super.register(store, stateRestoreCallback);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyMTY2Nw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444321667", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-23T15:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDQzMQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r443054431", "bodyText": "For which case would it be null?", "author": "mjsax", "createdAt": "2020-06-19T21:42:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStore.java", "diffHunk": "@@ -103,8 +104,12 @@ public void init(final ProcessorContext context,\n \n     @SuppressWarnings(\"unchecked\")\n     void initStoreSerde(final ProcessorContext context) {\n+        final InternalProcessorContext internalProcessorContext = (InternalProcessorContext) context;\n+        final String storeName = name();\n+        final String changelogTopic = internalProcessorContext.changelogFor(storeName);\n         serdes = new StateSerdes<>(\n-            ProcessorStateManager.storeChangelogTopic(context.applicationId(), name()),\n+            changelogTopic != null", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxOTYyMw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444319623", "bodyText": "It would be null for the case where logging is disabled. In this case we would still need the store serdes to read records from the store. We just pass in the default changelog name, so that one can still use a changelog name in the serde, e.g., as subject name for Confluent's schema registry.", "author": "cadonna", "createdAt": "2020-06-23T15:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDg5Mg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r443054892", "bodyText": "nit: move ? to the line above and move ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName), to its own line.\nPreferred formatting (makes it easy to read):\ncondition ?\n  then :\n  else", "author": "mjsax", "createdAt": "2020-06-19T21:43:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStore.java", "diffHunk": "@@ -103,8 +104,12 @@ public void init(final ProcessorContext context,\n \n     @SuppressWarnings(\"unchecked\")\n     void initStoreSerde(final ProcessorContext context) {\n+        final InternalProcessorContext internalProcessorContext = (InternalProcessorContext) context;\n+        final String storeName = name();\n+        final String changelogTopic = internalProcessorContext.changelogFor(storeName);\n         serdes = new StateSerdes<>(\n-            ProcessorStateManager.storeChangelogTopic(context.applicationId(), name()),\n+            changelogTopic != null\n+                ? changelogTopic : ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyMTA3OQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444321079", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-23T15:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NDg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NTM2Mw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r443055363", "bodyText": "Can we add a test for the other (non-optimized) case, too?", "author": "mjsax", "createdAt": "2020-06-19T21:45:41Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/graph/TableSourceNodeTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals.graph;\n+\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.internals.ConsumedInternal;\n+import org.apache.kafka.streams.kstream.internals.KTableSource;\n+import org.apache.kafka.streams.kstream.internals.MaterializedInternal;\n+import org.apache.kafka.streams.kstream.internals.graph.TableSourceNode.TableSourceNodeBuilder;\n+import org.apache.kafka.streams.processor.internals.InternalTopologyBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({InternalTopologyBuilder.class})\n+public class TableSourceNodeTest {\n+\n+    @Test\n+    public void shouldConnectStateStoreToInputTopicIfInputTopicIsUsedAsChangelog() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNDgzNQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444334835", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-23T15:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1NTM2Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTAzMw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444541033", "bodyText": "Should we better throw an exception as this method should never be called for global state stores?", "author": "mjsax", "createdAt": "2020-06-23T22:21:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java", "diffHunk": "@@ -402,4 +402,9 @@ public TaskType taskType() {\n     public Map<TopicPartition, Long> changelogOffsets() {\n         return Collections.unmodifiableMap(checkpointFileCache);\n     }\n+\n+    @Override\n+    public TopicPartition changelogTopicPartitionFor(final String storeName) {\n+        return null;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyOTQ1Mw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444729453", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-24T08:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTU1Mg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444541552", "bodyText": "I thinks the store could still be registered, but just does not have a changelog topic? Wondering if the error message might be miss leading?", "author": "mjsax", "createdAt": "2020-06-23T22:23:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -118,16 +111,24 @@ public void logChange(final String storeName,\n                           final byte[] value,\n                           final long timestamp) {\n         throwUnsupportedOperationExceptionIfStandby(\"logChange\");\n+\n+        final TopicPartition changelogPartition = stateManager().changelogTopicPartitionFor(storeName);\n+        if (changelogPartition == null) {\n+            throw new IllegalStateException(\"Sending records to state store \" + storeName +\n+                \" which has not been registered.\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDczOTA1Mw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444739053", "bodyText": "Good catch! I will add the logging disabled case to the message.", "author": "cadonna", "createdAt": "2020-06-24T08:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTgwOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444541809", "bodyText": "Cf. my comment from above: we could raise the exception if storeMetadata == null", "author": "mjsax", "createdAt": "2020-06-23T22:23:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java", "diffHunk": "@@ -578,4 +577,10 @@ private StateStoreMetadata findStore(final TopicPartition changelogPartition) {\n \n         return found.isEmpty() ? null : found.get(0);\n     }\n+\n+    @Override\n+    public TopicPartition changelogTopicPartitionFor(final String storeName) {\n+        final StateStoreMetadata storeMetadata = stores.get(storeName);\n+        return storeMetadata == null ? null : storeMetadata.changelogPartition;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0NDQzNg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444744436", "bodyText": "IMO, it is fine to return null here and mention both possible reason for the null result in logChange(). What exception would you throw here? Retrieving a changelog partition of a not registered state store is not exceptional. However, retrieving a changelog partition of a not registered state store in a method that writes to that changelog partition -- i.e. logChange() -- is exceptional.", "author": "cadonna", "createdAt": "2020-06-24T08:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3OTQxMQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445179411", "bodyText": "From my understanding storeMetadata should only be null if the store was not registered? Thus it seems to indicate a bug?", "author": "mjsax", "createdAt": "2020-06-24T21:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NzcwNg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445457706", "bodyText": "I would say it indicates a bug, if the state store should be changelogged. My point is that retrieving a changelog partition for a state store does not necessarily mean that the state store needs to be registered. However, since registeredChangelogPartitionFor() is currently only called for changelogging, I will add two IllegalStateExceptions to this method: one for non registered stores and one for stores with logging disabled.", "author": "cadonna", "createdAt": "2020-06-25T10:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzE4NQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444543185", "bodyText": "As above: should we throw here?", "author": "mjsax", "createdAt": "2020-06-23T22:28:02Z", "path": "streams/src/test/java/org/apache/kafka/test/GlobalStateManagerStub.java", "diffHunk": "@@ -88,4 +88,14 @@ public StateStore getGlobalStore(final String name) {\n     public TaskType taskType() {\n         return TaskType.GLOBAL;\n     }\n+\n+    @Override\n+    public String changelogFor(final String storeName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public TopicPartition changelogTopicPartitionFor(final String storeName) {\n+        return null;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0NjIzNQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444746235", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-24T08:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mjg5Nw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444552897", "bodyText": "Do we really need this? It seems like overkill to add this abstract class just for one trivial shared method. I'm also wondering if we really need changelogFor at all -- can't we just use changelogTopicPartitionFor and get the topic name from that?", "author": "ableegoldman", "createdAt": "2020-06-23T22:57:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractProcessorStateManager.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import java.util.Map;\n+\n+public abstract class AbstractProcessorStateManager implements StateManager {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNDAwNA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r444724004", "bodyText": "I do not consider the abstract class as overkill but rather as cleaner. I definitely would like to keep it.\nRegarding using changelogTopicPartitionFor() instead of changelogFor() I have the following thoughts:\n\n\nchangelogTopicPartitionFor() only returns changelogs for registered state stores whereas changelogFor() returns the changelogs as specified in the topology builder. That means if a store has logging enabled changelogFor() will return a non-null result (global tables and optimized source tables are an exception because they have a changelog topic but the logging is disabled internally) independently whether the store has been registered or not. We need changelogFor() at least internally during the registration of state stores. I introduced changelogTopicPartitionFor() to have a guard in logChange() to only write to changelogs for registered state store.\n\n\nWe could use changelogTopicPartitionFor() in the initialization of the state store serdes but this would mean we need to move the initialization of the state store serdes after the initialisation of the underlying state stores in Metered*Store. That would actually not be an issue, but IMO making a call to a method dependent on the order of calls to other methods is error-prone and if it could be avoided we should avoid it. Since we need changelogFor() anyways in ProcessorStateManager I would like to keep both. Additionally, initializing the state serde is somehow independent of registering a state store whose main goal is configuring changelogging.\n\n\nI think I can improve on the naming. I will rename changelogTopicPartitionFor() to registeredChangelogPartitionFor()", "author": "cadonna", "createdAt": "2020-06-24T08:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mjg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwNzgwMA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445107800", "bodyText": "Ok. Maybe I'm just biased because we only got rid of a pretty ugly AbstractStateManager class a few releases ago. Hopefully this one won't get out of hand \ud83d\ude42.\nThanks for explaining the difference between the two and renaming them to highlight this", "author": "ableegoldman", "createdAt": "2020-06-24T19:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mjg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MTYzOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445951639", "bodyText": "I know you've already had a conversation about this in the last cycle of reviews and defended the idea. So, I'm sorry to say that I also disagree with adding this class.\nWe've recently spent several months in an extremely costly refactoring effort clearing up a bunch of unmaintainable code in this exact module. There were many flaws that we had to correct, but one of them was excessive abstraction. There's nothing excessive about this class right now, but experience says it will become so over time. I'd avoid adding abstract classes unless there's an extremely compelling reason to do it. Right now, it just looks like we're saving the concrete classes from storing one field, which doesn't seem too compelling.\nI really want to emphasize that your choice to add this class is very normal, and in some codebases, it would be required style. But, given my experience with maintaining this codebase, I'd really like to inline this and keep the class hierarchy absolutely as flat as possible.", "author": "vvcephei", "createdAt": "2020-06-26T03:42:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractStateManager.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import java.util.Map;\n+\n+public abstract class AbstractStateManager implements StateManager {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2NzM0Ng==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446067346", "bodyText": "Since two people now criticized this, I will remove this abstract class. However, I strongly disagree that we should not abstract (and reduce code duplications) because maybe sometime in the future the abstraction might become excessive and hence unmaintainable. It is our responsibility to avoid the latter while keeping a clean design.", "author": "cadonna", "createdAt": "2020-06-26T09:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MjEzMA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446472130", "bodyText": "Thanks! This seems like the kind of debate that will continue for a while :)\nJust to share the thought, adding abstraction isn't the only way to de-duplicate code. In fact composition is generally less costly to maintain, for example adding utility methods.", "author": "vvcephei", "createdAt": "2020-06-27T02:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzAzNw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445953037", "bodyText": "We discussed this offline. When you revise this to branch based on the context type, you might want to follow the same Util strategy as I proposed here: #8927", "author": "vvcephei", "createdAt": "2020-06-26T03:49:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStore.java", "diffHunk": "@@ -103,8 +104,13 @@ public void init(final ProcessorContext context,\n \n     @SuppressWarnings(\"unchecked\")\n     void initStoreSerde(final ProcessorContext context) {\n+        final InternalProcessorContext internalProcessorContext = (InternalProcessorContext) context;\n+        final String storeName = name();\n+        final String changelogTopic = internalProcessorContext.changelogFor(storeName);\n         serdes = new StateSerdes<>(\n-            ProcessorStateManager.storeChangelogTopic(context.applicationId(), name()),\n+            changelogTopic != null ?\n+                changelogTopic :\n+                ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjcyNw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446056727", "bodyText": "Ack.\nThat means, this PR is now blocked on #8927", "author": "cadonna", "createdAt": "2020-06-26T08:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MDIzOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446080239", "bodyText": "Nevermind. I copied over ProcessorContextUtils from #8927 and extended it. There should not be any conflict.", "author": "cadonna", "createdAt": "2020-06-26T09:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NDc2OA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446084768", "bodyText": "BTW very helpful utils and a great idea. Thank you @vvcephei !", "author": "cadonna", "createdAt": "2020-06-26T09:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTgzOQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446471839", "bodyText": "No problem! I'm glad it proved useful.", "author": "vvcephei", "createdAt": "2020-06-27T02:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1MzAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445954292", "bodyText": "Unless we're actually verifying these interactions, we should probably use the MockInternalProcessorContext instead, and save ourselves from having to tweak these expectations every time we change the implementation details.", "author": "vvcephei", "createdAt": "2020-06-26T03:55:54Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStoreTest.java", "diffHunk": "@@ -124,18 +141,19 @@ public void before() {\n             Serdes.String()\n         );\n         metrics.config().recordLevel(Sensor.RecordingLevel.DEBUG);\n-        expect(context.metrics())\n-            .andReturn(new StreamsMetricsImpl(metrics, \"test\", builtInMetricsVersion)).anyTimes();\n-        expect(context.taskId()).andReturn(taskId).anyTimes();\n-        expect(inner.name()).andReturn(\"metered\").anyTimes();\n+        expect(context.applicationId()).andStubReturn(APPLICATION_ID);\n+        expect(context.metrics()).andStubReturn(new StreamsMetricsImpl(metrics, \"test\", builtInMetricsVersion));\n+        expect(context.taskId()).andStubReturn(taskId);\n+        expect(context.changelogFor(STORE_NAME)).andStubReturn(CHANGELOG_TOPIC);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MDAyNQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446050025", "bodyText": "I guess there is a misunderstanding. You cannot verify an expectation that is specified with andStubReturn(). That is the reason why I changed andReturn().anyTimes() with andStubReturn(). This also means that these expectations do not depend on the implementation details (i.e. how often the methods are called). Method andStubReturn() has similar effect as using MockInternalProcessorContext. Refactoring the tests would unreasonably increase the size of this PR. Hence, I would like not to do it.", "author": "cadonna", "createdAt": "2020-06-26T08:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxNjU4OA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446316588", "bodyText": "I think Bruno needs to give us all a short lesson on the correct usage of EasyMock. He explained the StubReturn thing to me on another PR a while back and I've been (slowly) trying to help migrate all the .andReturn.anyTimes usages over to this where appropriate (which is most places). It's definitely helped reduce the large number of EasyMock'ed tests that have to be fixed after every minor implementation change.\nThat said, there does seem to be one critical difference between using .andStubReturn and the actual MockInternalProcessorContext. If we add a new method to the InternalProcessorContext interface, for example, we then have to add this expectation to every test that calls it with an EasyMock context. Having had to do this a number of times, it's definitely a huge timesuck.\nBut I also agree that it doesn't need to be done as part of this PR. Maybe once the MockInternal and InternalMock processor contexts are finally merged we can do some reasonable cleanup of the tests", "author": "ableegoldman", "createdAt": "2020-06-26T17:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTczNg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446471736", "bodyText": "Thanks, all. What Sophie mentioned is more in line with what I had in mind. The advantage of something like \"MIPC\" is that it just generally satisfies the API contract while not really doing stuff like writing to the brokers, etc. Because it's a contract-valid implementation of InternalProcessorContext, we can use it transparently to support any use case where we really don't care exactly what calls the unit under test makes into the context.\nEasyMock is very powerful, but it can't magically implement a complex interface contract, so it can never fill this gap. On the other hand, if there's really only going to be one or two calls, then it's fine. And, of course, if we need to verify interactions, exceptions, etc., then EasyMock gives us a very powerful set of utilities for it.\nAnyway, we don't have to change this right now, but I've certainly spent many hours fiddling around with easymock expectations just like this, and it provides no value if you just want the thing to behave the way that MIPC already behaves. Which is why I pointed it out.", "author": "vvcephei", "createdAt": "2020-06-27T02:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2NzQ2MA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r447567460", "bodyText": "I agree that EasyMock is not able to magically implement a complex interface contract. However, as I said earlier it would significantly increase the size of this PR to swap to InternalMockProcessorContext or one of its siblings right now.", "author": "cadonna", "createdAt": "2020-06-30T10:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjE4MA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r447846180", "bodyText": "Ok, no need to change it now, then. Thanks for the discussion.", "author": "vvcephei", "createdAt": "2020-06-30T17:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDQzNA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r445954434", "bodyText": "It looks like these are only used in one method. Can we define them inline instead?\nThis feedback also applies to the other tests.", "author": "vvcephei", "createdAt": "2020-06-26T03:56:33Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStoreTest.java", "diffHunk": "@@ -91,13 +103,18 @@\n     private KeyValueStore<Bytes, byte[]> inner;\n     @Mock(type = MockType.NICE)\n     private InternalProcessorContext context;\n+    @Mock(type = MockType.NICE)\n+    private Serde<String> keySerde;\n+    @Mock(type = MockType.DEFAULT)\n+    private Serializer<String> keySerializer;\n+    @Mock(type = MockType.NICE)\n+    private Serde<String> valueSerde;\n+    @Mock(type = MockType.DEFAULT)\n+    private Deserializer<String> valueDeserializer;\n+    @Mock(type = MockType.DEFAULT)\n+    private Serializer<String> valueSerializer;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MTg0Mg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r446051842", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-06-26T08:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NDQzNA=="}], "type": "inlineReview"}, {"oid": "8e7ef6a57f836920be219dd360241319e03b0417", "url": "https://github.com/apache/kafka/commit/8e7ef6a57f836920be219dd360241319e03b0417", "message": "KAFKA-10179: Pass correct changelog topic to state serdes\n\nUntil now we always passed the default changelog topic name\nto the state serdes. However, for optimized source tables\nand global tables the changelog topic is the source topic.\n\nMost serdes do not use the topic name passed to them.\nHowever, if the serdes actually use the topic name for\n(de)serialization, e.g., when Kafka Streams is used with\nConfluent's Schema Registry, a\norg.apache.kafka.common.errors.SerializationException is thrown.\n\nThis commits passed the correct changelog topic to the state\nserdes of the metered state stores.", "committedDate": "2020-07-07T09:29:27Z", "type": "commit"}, {"oid": "e068389cabf31cc9cf7c30b36841fa9717b01733", "url": "https://github.com/apache/kafka/commit/e068389cabf31cc9cf7c30b36841fa9717b01733", "message": "Added exception for changelogging of not registered stores", "committedDate": "2020-07-07T09:31:57Z", "type": "commit"}, {"oid": "ccf3abc7ecae74658a9b6c963a812518499bba94", "url": "https://github.com/apache/kafka/commit/ccf3abc7ecae74658a9b6c963a812518499bba94", "message": "Add unit test for non-optimized case", "committedDate": "2020-07-07T09:31:57Z", "type": "commit"}, {"oid": "33eadcbc781df36839f1017b00f60899b62b7eeb", "url": "https://github.com/apache/kafka/commit/33eadcbc781df36839f1017b00f60899b62b7eeb", "message": "Include feedback", "committedDate": "2020-07-07T09:32:07Z", "type": "commit"}, {"oid": "dbc23fa59e993949198bf2271d8eef0f0c047bdc", "url": "https://github.com/apache/kafka/commit/dbc23fa59e993949198bf2271d8eef0f0c047bdc", "message": "Add exceptions to registeredChangelogPartitionFor()", "committedDate": "2020-07-07T09:32:07Z", "type": "commit"}, {"oid": "1302e2577eee582b143ae0adad74a9f7e09d989e", "url": "https://github.com/apache/kafka/commit/1302e2577eee582b143ae0adad74a9f7e09d989e", "message": "Include feedback", "committedDate": "2020-07-07T09:33:39Z", "type": "commit"}, {"oid": "1302e2577eee582b143ae0adad74a9f7e09d989e", "url": "https://github.com/apache/kafka/commit/1302e2577eee582b143ae0adad74a9f7e09d989e", "message": "Include feedback", "committedDate": "2020-07-07T09:33:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3OTg3NQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r450979875", "bodyText": "Should this be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected StateManagerStub stateManager() {\n          \n          \n            \n                protected StateManager stateManager() {\n          \n      \n    \n    \n  \n\n?", "author": "vvcephei", "createdAt": "2020-07-07T16:08:34Z", "path": "streams/src/test/java/org/apache/kafka/test/InternalMockProcessorContext.java", "diffHunk": "@@ -193,6 +194,11 @@ public InternalMockProcessorContext(final File stateDir,\n         this.metrics().setRocksDBMetricsRecordingTrigger(new RocksDBMetricsRecordingTrigger(new SystemTime()));\n     }\n \n+    @Override\n+    protected StateManagerStub stateManager() {", "originalCommit": "1302e2577eee582b143ae0adad74a9f7e09d989e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4MDM1Nw==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r450980357", "bodyText": "and here?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected StateManagerStub stateManager() {\n          \n          \n            \n                protected StateManager stateManager() {", "author": "vvcephei", "createdAt": "2020-07-07T16:09:16Z", "path": "streams/src/test/java/org/apache/kafka/test/NoOpProcessorContext.java", "diffHunk": "@@ -55,6 +58,11 @@ private static StreamsConfig streamsConfig() {\n         return new StreamsConfig(props);\n     }\n \n+    @Override\n+    protected StateManagerStub stateManager() {", "originalCommit": "1302e2577eee582b143ae0adad74a9f7e09d989e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b34c1750c216f252e7e18d01a657f61f224de18", "url": "https://github.com/apache/kafka/commit/6b34c1750c216f252e7e18d01a657f61f224de18", "message": "Apply suggestions from code review\n\nCo-authored-by: John Roesler <vvcephei@users.noreply.github.com>", "committedDate": "2020-07-07T16:20:26Z", "type": "commit"}, {"oid": "c741f2f88c5f619259ad8e5a2a3b5a32567c07da", "url": "https://github.com/apache/kafka/commit/c741f2f88c5f619259ad8e5a2a3b5a32567c07da", "message": "Revert last change", "committedDate": "2020-07-07T19:32:42Z", "type": "commit"}, {"oid": "948b13d7c105cc8bc8c2dcadf8e1e6d2785247f4", "url": "https://github.com/apache/kafka/commit/948b13d7c105cc8bc8c2dcadf8e1e6d2785247f4", "message": "Re-apply suggestion from code review", "committedDate": "2020-07-08T10:15:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMzEyNg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r451903126", "bodyText": "Not sure why we need to move this from the abstract class into the child classes?", "author": "mjsax", "createdAt": "2020-07-09T00:52:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractProcessorContext.java", "diffHunk": "@@ -45,24 +45,23 @@\n     protected ProcessorNode<?, ?> currentNode;\n     private long currentSystemTimeMs;\n \n-    final StateManager stateManager;", "originalCommit": "948b13d7c105cc8bc8c2dcadf8e1e6d2785247f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExOTk5OA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452119998", "bodyText": "This is basically to avoid the explicit cast from StateManager to ProcessorStateManager in ProcessorContextImpl. ProcessorStateManager has method registeredChangelogPartitionFor() that does only exist in the ProessorStateManager, because it is only used in ProcessorContextImpl. Hence, I moved the state manager field to the respective children and introduced the abstract method stateManager() in AbstractProcessorContext. Method stateManager() returns a ProcessorStateManager in ProcessorContextImpl but a StateManager in all other places.", "author": "cadonna", "createdAt": "2020-07-09T10:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMzEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTk0MQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452391941", "bodyText": "I see. Would it not be sufficient to just keep a (\"duplicate\") reference of ProcessorStateManager within ProcessorContextImpl?\nJust to clarify: I am ok with the proposed changes. Just wondering if it's really the best structure.", "author": "mjsax", "createdAt": "2020-07-09T17:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMzEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNTQ3Mg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452425472", "bodyText": "If I understand you correctly, you propose to have a processor state manager reference in the AbstractProcessorContext and in ProcessorContextImpl instead of in the GlobalProcessorContextImpl and in ProcessorContextImpl. Moreover, you want to have a method stateManager() in AbstractProcessorContext that is overridden only in ProcessorContextImpl.\nFWIW, I think it is cleaner to have the references in each child and an abstract method stateManager() in AbstractProcessorContext that is overridden in both children. My reasoning  is that both children have a state manager that is used in AbstractProcessorContext (i.e., both should provide a method stateManager()) but each child uses a different type of state manager internally.", "author": "cadonna", "createdAt": "2020-07-09T18:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDExNA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r451904114", "bodyText": "It seems we don't need this if-then-else any longer as it's already taken care of within ProcessorContextUtils.changelogFor? (Similar for other classes.)", "author": "mjsax", "createdAt": "2020-07-09T00:56:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStore.java", "diffHunk": "@@ -103,8 +104,12 @@ public void init(final ProcessorContext context,\n \n     @SuppressWarnings(\"unchecked\")\n     void initStoreSerde(final ProcessorContext context) {\n+        final String storeName = name();\n+        final String changelogTopic = ProcessorContextUtils.changelogFor(context, storeName);\n         serdes = new StateSerdes<>(\n-            ProcessorStateManager.storeChangelogTopic(context.applicationId(), name()),\n+             changelogTopic != null ?\n+                changelogTopic :\n+                ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName),", "originalCommit": "948b13d7c105cc8bc8c2dcadf8e1e6d2785247f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE0ODg3NA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452148874", "bodyText": "I think we still need the if-then-else. ProcessorContextUtils.changelogFor() checks that the processor context is of type InternalProcessorContext to be able to call changelogFor() on it. It does not consider the case where no changelog exists (i.e., changelogFor() returns null). The null check is done here. Fallback is in both cases ProcessorStateManager.storeChangelogTopic().", "author": "cadonna", "createdAt": "2020-07-09T11:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NDUxMA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452394510", "bodyText": "Ah thanks. I missed this case.\nHowever, should we move both null checks into ProcessorContextUtils.changelogFor() for this case? It seem, we do the same \"outer\" null-check each time we call the method, so why not do it at a single place in the code?", "author": "mjsax", "createdAt": "2020-07-09T17:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNTg1MA==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452415850", "bodyText": "I would not put any code that is not related to casts of ProcessorContext into ProessorContextUtils. I think the goal of ProessorContextUtils is to contain all code of which we want to get rid of in the future once the casts are fixed.\nWe could move the null check into the constructor of StateSerde since we do also there a null check.", "author": "cadonna", "createdAt": "2020-07-09T18:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNTExMg==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r451905112", "bodyText": "Wondering if we should pass storeToChangelogTopic() and .globalStateStores() into the constructor instead of ProcessorTopology ?", "author": "mjsax", "createdAt": "2020-07-09T01:00:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java", "diffHunk": "@@ -73,22 +73,23 @@\n     private final Set<String> globalNonPersistentStoresTopics = new HashSet<>();\n     private final OffsetCheckpoint checkpointFile;\n     private final Map<TopicPartition, Long> checkpointFileCache;\n+    private final Map<String, String> storeToChangelogTopic;\n \n     public GlobalStateManagerImpl(final LogContext logContext,\n                                   final ProcessorTopology topology,\n                                   final Consumer<byte[], byte[]> globalConsumer,\n                                   final StateDirectory stateDirectory,\n                                   final StateRestoreListener stateRestoreListener,\n                                   final StreamsConfig config) {\n+        storeToChangelogTopic = topology.storeToChangelogTopic();", "originalCommit": "948b13d7c105cc8bc8c2dcadf8e1e6d2785247f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2NTA2MQ==", "url": "https://github.com/apache/kafka/pull/8902#discussion_r452165061", "bodyText": "I would still pass ProcessorTopology into the constructor because it might make the signature of the constructor more stable. I removed the field for the topology and now we store only globalStateStores and storeChangelogTopics in GlobalStateManagerImpl.", "author": "cadonna", "createdAt": "2020-07-09T12:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNTExMg=="}], "type": "inlineReview"}, {"oid": "bfacb69b8895b4c72874942d37faa9a36ca357e9", "url": "https://github.com/apache/kafka/commit/bfacb69b8895b4c72874942d37faa9a36ca357e9", "message": "Include feedback", "committedDate": "2020-07-09T12:00:18Z", "type": "commit"}]}