{"pr_number": 8509, "pr_title": "KAFKA-9839: Broker should accept control requests with newer broker epoch", "pr_createdAt": "2020-04-18T02:23:17Z", "pr_url": "https://github.com/apache/kafka/pull/8509", "timeline": [{"oid": "0c9d015f3313f8d725134e48111e6f9378dcb920", "url": "https://github.com/apache/kafka/commit/0c9d015f3313f8d725134e48111e6f9378dcb920", "message": "KAFKA-9839: Broker should accept control requests with newer broker epoch", "committedDate": "2020-04-18T01:54:12Z", "type": "commit"}, {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "url": "https://github.com/apache/kafka/commit/d8604ede27d47a3a4bd016d70d7a1c7438445a00", "message": "added KafkaApisTest unit tests", "committedDate": "2020-04-22T03:19:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM3Nw==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412807377", "bodyText": "This and the two above should use testStopReplicaRequest instead of testUpdateMetadataRequest.", "author": "dajac", "createdAt": "2020-04-22T09:06:11Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)", "originalCommit": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzk3Mg==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413337972", "bodyText": "thanks for catching this and others below!", "author": "apovzner", "createdAt": "2020-04-22T21:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTAxOQ==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809019", "bodyText": "brokerEpoch is not necessary, I suppose.", "author": "dajac", "createdAt": "2020-04-22T09:08:33Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L", "originalCommit": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTQ1Ng==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809456", "bodyText": "This should rely on brokerEpochInRequest.", "author": "dajac", "createdAt": "2020-04-22T09:09:09Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val fooPartition = new TopicPartition(\"foo\", 0)\n+    val topicStates = Seq(\n+      new StopReplicaTopicState()\n+        .setTopicName(fooPartition.topic())\n+        .setPartitionStates(Seq(new StopReplicaPartitionState()\n+          .setPartitionIndex(fooPartition.partition())\n+          .setLeaderEpoch(1)\n+          .setDeletePartition(false)).asJava)\n+    ).asJava\n+    val stopReplicaRequest = new StopReplicaRequest.Builder(\n+      ApiKeys.STOP_REPLICA.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      false,\n+      topicStates\n+    ).build()\n+    val request = buildRequest(stopReplicaRequest)\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.stopReplicas(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.eq(controllerId),\n+      EasyMock.eq(controllerEpoch),\n+      EasyMock.eq(brokerEpoch + 1),", "originalCommit": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTAzNw==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413091037", "bodyText": "Short comment here may be helpful about the case where the controller sees the epoch bump first.", "author": "hachikuji", "createdAt": "2020-04-22T15:37:30Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+    else brokerEpochInRequest < controller.brokerEpoch", "originalCommit": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20", "url": "https://github.com/apache/kafka/commit/062c787a6a34246ac25026ebb6d3cfeec3515d20", "message": "fixed testStopReplicaRequestXXX unit tests and added a comment", "committedDate": "2020-04-22T21:13:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTE3Nw==", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413541177", "bodyText": "nit: Alignment of the comment looks a bit weird. I would align it with the if/else.", "author": "dajac", "createdAt": "2020-04-23T06:24:16Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+      // brokerEpochInRequest > controller.brokerEpoch is possible in rare scenarios where the controller gets notified\n+      // about the new broker epoch and sends a control request with this epoch before the broker learns about it", "originalCommit": "062c787a6a34246ac25026ebb6d3cfeec3515d20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d952854018b2862f48d23dcce9db682a16923ab0", "url": "https://github.com/apache/kafka/commit/d952854018b2862f48d23dcce9db682a16923ab0", "message": "adjusted comment alignment", "committedDate": "2020-04-23T21:15:33Z", "type": "commit"}]}