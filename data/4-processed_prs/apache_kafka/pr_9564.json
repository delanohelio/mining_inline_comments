{"pr_number": 9564, "pr_title": "KAFKA-10667: add timeout for forwarding requests", "pr_createdAt": "2020-11-05T07:53:51Z", "pr_url": "https://github.com/apache/kafka/pull/9564", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2ODUwNA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r517868504", "bodyText": "(The following question is not related to this PR. just curious)\nIs it possible to encounter authentication error when forwarding? If so, is it necessary to avoid retrying such (error) request?", "author": "chia7712", "createdAt": "2020-11-05T08:27:28Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(response)) {\n+      debug(s\"The request failed to send to the controller after timeout ${clientRequestTimeout} ms: $response\")\n+    } else if (response.wasDisconnected()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwODAxMQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r518208011", "bodyText": "Thanks, for authorization related exception, we could add the logic to stop retry as well.", "author": "abbccdda", "createdAt": "2020-11-05T16:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2ODUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NjY3NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537786674", "bodyText": "Note that we handle authentication exceptions in InterBrokerSendThread. We log a message and mark the response as \"disconnected.\" I think it is reasonable to keep retrying in case the broker's configuration changes and so that the error messages will remain persistent in the logs.", "author": "hachikuji", "createdAt": "2020-12-07T19:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2ODUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwMjk4NQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523102985", "bodyText": "So before, if the request timed out, it would be marked as \"disconnected\"?", "author": "mumrah", "createdAt": "2020-11-13T17:20:59Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE4MzQzMw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523183433", "bodyText": "I think so", "author": "abbccdda", "createdAt": "2020-11-13T19:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwMjk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMTgxNg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523111816", "bodyText": "Do we need to call the request callback here so we can propagate the error up to the client?", "author": "mumrah", "createdAt": "2020-11-13T17:31:23Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(response)) {\n+      debug(s\"The request failed to send to the controller after timeout ${clientRequestTimeout} ms: $response\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE4NDkxNg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523184916", "bodyText": "Yea, I think we could actually fire the callback here.", "author": "abbccdda", "createdAt": "2020-11-13T19:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMTgxNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODIxNA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525428214", "bodyText": "I am not so sure about adding this to RequestCompletionHandler. This interface is mainly serving NetworkClient, but there are no changes to NetworkClient here.", "author": "hachikuji", "createdAt": "2020-11-17T19:25:39Z", "path": "clients/src/main/java/org/apache/kafka/clients/RequestCompletionHandler.java", "diffHunk": "@@ -24,4 +24,11 @@\n \n     void onComplete(ClientResponse response);\n \n+    /**\n+     * Fire when the request transmission hits a fatal exception.\n+     *\n+     * @param exception the thrown exception\n+     */\n+    default void onFailure(RuntimeException exception) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNzIzMg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525507232", "bodyText": "We do have a case in ConsumerNetworkClient which adds an onFailure callback. To me it makes sense to include it as part of the RequestCompletionHandler interface.", "author": "abbccdda", "createdAt": "2020-11-17T20:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5ODYyMA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525598620", "bodyText": "Here is the interface for KafkaClient:\n ClientRequest newClientRequest(String nodeId,\n                                   AbstractRequest.Builder<?> requestBuilder,\n                                   long createdTimeMs,\n                                   boolean expectResponse,\n                                   int requestTimeoutMs,\n                                   RequestCompletionHandler callback);\n\nIt is misleading to add an onFailure callback to RequestCompletionHandler if it is not going to be used by KafkaClient implementations such as NetworkClient. The usage in ConsumerNetworkClient is different because it is internal. In general, we should avoid leaking implementation details up to the interfaces.", "author": "hachikuji", "createdAt": "2020-11-17T23:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTc2MzEyMQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525763121", "bodyText": "I see, if this is the case, we need a customized completion handler for both forwarding and AlterISR IMHO.", "author": "abbccdda", "createdAt": "2020-11-18T04:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMTI5OA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525431298", "bodyText": "The time we need to track should begin when the request is submitted to the manager. This looks like it is just checking how long an individual request is taking, which the request timeout in NetworkClient already takes care of.", "author": "hachikuji", "createdAt": "2020-11-17T19:30:36Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +183,11 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(response: ClientResponse): Boolean = {\n+    val requestCreatedTime = response.receivedTimeMs() - response.requestLatencyMs()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTc2NDIyOA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525764228", "bodyText": "Is it legitimate to compare with requestTimeout here since we actually measure the request buffered time on the broker-to-controller channel queue? Should we introduce a new timeout config here somehow?", "author": "abbccdda", "createdAt": "2020-11-18T04:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNDYyMA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527324620", "bodyText": "There may be requests that never had a chance to be sent?", "author": "hachikuji", "createdAt": "2020-11-20T00:54:48Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onFailure(exception: RuntimeException): Unit = {\n+        error(s\"Encountered $exception when sending AlterIsr to the controller, clearing all pending states\")\n+        unsentIsrUpdates.clear()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM1OTE3NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527359174", "bodyText": "Yea, I'm not sure whether we should clear all the pending updates here or not, just saw the comment as Regardless of callback outcome, we need to clear from the unsent updates map to unblock further updates, so thinking maybe we could just remove all pending updates here.", "author": "abbccdda", "createdAt": "2020-11-20T02:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNDYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNTY4Mg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527325682", "bodyText": "Don't we need to invoke the callbacks?", "author": "hachikuji", "createdAt": "2020-11-20T00:55:57Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onFailure(exception: RuntimeException): Unit = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM1OTQ0NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527359444", "bodyText": "You mean handleAlterIsrResponse?", "author": "abbccdda", "createdAt": "2020-11-20T02:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNjIzMQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527326231", "bodyText": "We do not want to timeout requests from the broker such as AlterIsr. We only want this for client requests.", "author": "hachikuji", "createdAt": "2020-11-20T00:57:37Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +194,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {\n+    (time.milliseconds() - request.firstEnqueuedTimeMs) > clientRequestTimeout", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c55f143e43a710db07d0f43211508692c4d46beb", "url": "https://github.com/apache/kafka/commit/c55f143e43a710db07d0f43211508692c4d46beb", "message": "add request timeout for forwarding", "committedDate": "2020-11-23T18:24:53Z", "type": "commit"}, {"oid": "c55f143e43a710db07d0f43211508692c4d46beb", "url": "https://github.com/apache/kafka/commit/c55f143e43a710db07d0f43211508692c4d46beb", "message": "add request timeout for forwarding", "committedDate": "2020-11-23T18:24:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDE5NQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024195", "bodyText": "We check for timeouts only after receiving a response. I guess this means that in the worst case, the total timeout would be request.timeout*2. This is probably not a big deal, but maybe worth documenting in a comment somewhere.", "author": "hachikuji", "createdAt": "2020-12-01T02:03:15Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -165,7 +176,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(request)) {", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDI3Ng==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024276", "bodyText": "Perhaps we could use a name like retryTimeout to distinguish this from the request timeout which only applies to individual requests. Alternatively we could let the caller provide the retry deadline explicitly. This would save the need for the extra time.milliseconds call.", "author": "hachikuji", "createdAt": "2020-12-01T02:03:38Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -35,7 +35,8 @@ import scala.jdk.CollectionConverters._\n \n trait BrokerToControllerChannelManager {\n   def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                  callback: RequestCompletionHandler): Unit\n+                  callback: BrokerToControllerRequestCompletionHandler,\n+                  requestTimeout: Long): Unit", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDU3OQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024579", "bodyText": "nit: hasTimedOut?", "author": "hachikuji", "createdAt": "2020-12-01T02:04:38Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +191,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDY4OQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024689", "bodyText": "This comment needs to be updated.", "author": "hachikuji", "createdAt": "2020-12-01T02:05:03Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           requestTimeout: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, time.milliseconds() + requestTimeout))\n     requestThread.wakeup()\n   }\n \n }\n \n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {\n+\n+  /**\n+   * Fire when the request transmission hits a fatal exception.", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNTg4NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533025884", "bodyText": "Won't this overflow with requestTimeout set to Long.MaxValue. Do we have any test cases?", "author": "hachikuji", "createdAt": "2020-12-01T02:09:02Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           requestTimeout: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, time.milliseconds() + requestTimeout))", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5MTc2Ng==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533091766", "bodyText": "Good catch!", "author": "abbccdda", "createdAt": "2020-12-01T06:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjA5MA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533026090", "bodyText": "If we don't expect this, maybe we should just raise an exception. Alternatively if we are not going to fail, perhaps we should go ahead and invoke the callbacks.", "author": "hachikuji", "createdAt": "2020-12-01T02:09:42Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        warn(s\"Encountered request when sending AlterIsr to the controller\")", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5MTIyOQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533091229", "bodyText": "Not sure we could do the callback here, since the request failed already. Maybe just do nothing here?", "author": "abbccdda", "createdAt": "2020-12-01T06:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNzU0Mw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533627543", "bodyText": "Why not raise an exception?", "author": "hachikuji", "createdAt": "2020-12-01T18:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNDEzNw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533814137", "bodyText": "That's what I decide to do eventually.", "author": "abbccdda", "createdAt": "2020-12-02T00:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjQ3NQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533026475", "bodyText": "Maybe we can avoid this call to time.milliseconds and use ClientResponse.receivedTimeMs?", "author": "hachikuji", "createdAt": "2020-12-01T02:10:54Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +191,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {\n+    time.milliseconds() > request.deadlineMs", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNzk0Nw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533027947", "bodyText": "I think this should be debug. Users will already have visibility into the error through the request log and the error metrics. There's probably a stronger case to increase the level for the unknown error case in onComplete above, but I'm fine letting them both be debug.", "author": "hachikuji", "createdAt": "2020-12-01T02:15:22Z", "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -44,26 +46,34 @@ class ForwardingManager(channelManager: BrokerToControllerChannelManager) extend\n       request.context.clientAddress.getAddress\n     )\n \n-    def onClientResponse(clientResponse: ClientResponse): Unit = {\n-      val envelopeResponse = clientResponse.responseBody.asInstanceOf[EnvelopeResponse]\n-      val envelopeError = envelopeResponse.error()\n-      val requestBody = request.body[AbstractRequest]\n+    class ForwardingResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(clientResponse: ClientResponse): Unit = {\n+        val envelopeResponse = clientResponse.responseBody.asInstanceOf[EnvelopeResponse]\n+        val envelopeError = envelopeResponse.error()\n+        val requestBody = request.body[AbstractRequest]\n \n-      val response = if (envelopeError != Errors.NONE) {\n-        // An envelope error indicates broker misconfiguration (e.g. the principal serde\n-        // might not be defined on the receiving broker). In this case, we do not return\n-        // the error directly to the client since it would not be expected. Instead we\n-        // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n-        // on the broker.\n-        debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n-        requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n-      } else {\n-        parseResponse(envelopeResponse.responseData, requestBody, request.header)\n+        val response = if (envelopeError != Errors.NONE) {\n+          // An envelope error indicates broker misconfiguration (e.g. the principal serde\n+          // might not be defined on the receiving broker). In this case, we do not return\n+          // the error directly to the client since it would not be expected. Instead we\n+          // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n+          // on the broker.\n+          debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n+          requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n+        } else {\n+          parseResponse(envelopeResponse.responseData, requestBody, request.header)\n+        }\n+        responseCallback(response)\n+      }\n+\n+      override def onTimeout(): Unit = {\n+        error(s\"Forwarding of the request $request failed due to timeout exception\")", "originalCommit": "c55f143e43a710db07d0f43211508692c4d46beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564", "url": "https://github.com/apache/kafka/commit/d1ce40e8c0141dedc016c638186c473ccbd52564", "message": "address comments", "committedDate": "2020-12-01T17:22:33Z", "type": "commit"}, {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564", "url": "https://github.com/apache/kafka/commit/d1ce40e8c0141dedc016c638186c473ccbd52564", "message": "address comments", "committedDate": "2020-12-01T17:22:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r534274917", "bodyText": "Where will this exception get raised? I'm guessing the BrokerToControllerChannelManager thread?\nIf we timeout and give up on reading a response, I think we should still clear the inflightRequest flag. Otherwise AlterIsrManager will be stuck in-flight and be unable to send any more requests.", "author": "mumrah", "createdAt": "2020-12-02T15:50:20Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4MTA1NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r534281054", "bodyText": "We also might want to iterate through the in-flight ISR (inflightAlterIsrItems) and complete their callbacks with an error. Otherwise, these partitions will not know to retry their ISR changes. They will eventually get new metadata via LeaderAndIsr, but it would be good to prevent them from getting into a bad state.\nSomething like\ninflightAlterIsrItems.foreach { item => item.callback.apply(Left(Errors.REQUEST_TIMED_OUT)) }\nI don't think we need this in the finally block at L104 since handleAlterIsrResponse should be pretty robust against raising an exception", "author": "mumrah", "createdAt": "2020-12-02T15:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MjUzMg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r534352532", "bodyText": "We set the timeout of AlterIsrManager to infinity, so it should never happen. See comment from Jason: #9564 (comment)", "author": "abbccdda", "createdAt": "2020-12-02T17:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0MDE0NQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537940145", "bodyText": "Thanks, makes sense.", "author": "mumrah", "createdAt": "2020-12-08T00:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwOTg2OA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537709868", "bodyText": "nit: drop parenthesis after brokerEpoch", "author": "hachikuji", "createdAt": "2020-12-07T17:56:35Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMTgwMg==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537711802", "bodyText": "Perhaps add some more detail: \"... letting it retry indefinitely until a response is received or the request is cancelled after receiving new LeaderAndIsr state\".", "author": "hachikuji", "createdAt": "2020-12-07T17:59:15Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")\n+      }\n     }\n \n     debug(s\"Sending AlterIsr to controller $message\")\n-    controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message), responseHandler)\n+    // We will not timeout AlterISR request, instead letting it retry indefinitely.", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMjM1NA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537712354", "bodyText": "How about ControllerRequestCompletionHandler?", "author": "hachikuji", "createdAt": "2020-12-07T17:59:56Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,24 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzIxMw==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537713213", "bodyText": "Can we document the difference between this and the request timeout?", "author": "hachikuji", "createdAt": "2020-12-07T18:01:11Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,24 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {\n \n+  /**\n+   * Fire when the request transmission hits timeout.", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzk1MQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537713951", "bodyText": "Can we move this comment to the doc for sendRequest?", "author": "hachikuji", "createdAt": "2020-12-07T18:02:13Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +190,12 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  // The timeout will only be checked after receiving a response. This means that in the worst case,", "originalCommit": "d1ce40e8c0141dedc016c638186c473ccbd52564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "url": "https://github.com/apache/kafka/commit/1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "message": "review comments", "committedDate": "2020-12-07T18:39:04Z", "type": "commit"}, {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "url": "https://github.com/apache/kafka/commit/1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "message": "review comments", "committedDate": "2020-12-07T18:39:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODUzOA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537788538", "bodyText": "nit: turn into scaladoc", "author": "hachikuji", "createdAt": "2020-12-07T19:54:13Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -34,8 +34,12 @@ import scala.collection.mutable\n import scala.jdk.CollectionConverters._\n \n trait BrokerToControllerChannelManager {\n+\n+  // The retry deadline will only be checked after receiving a response. This means that in the worst case,", "originalCommit": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTE2OA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537789168", "bodyText": "Can we explain how it is different? We want to emphasize that it covers the total time including retries which might be the result of request timeouts.", "author": "hachikuji", "createdAt": "2020-12-07T19:55:10Z", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +129,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: ControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class ControllerRequestCompletionHandler extends RequestCompletionHandler {\n \n+  /**\n+   * Fire when the request transmission time passes the caller defined deadline on the channel queue.\n+   * This is different from the original request's timeout.", "originalCommit": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c146b1398b0df9118d3f0d94745d6db72f653c0e", "url": "https://github.com/apache/kafka/commit/c146b1398b0df9118d3f0d94745d6db72f653c0e", "message": "additional comments", "committedDate": "2020-12-08T00:42:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0NTY4MQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537945681", "bodyText": "nit: could we inline this as an anonymous class down below rather than defining it here? Just seems a little odd to define it like this and then calling in to the containing class for inflightRequest.", "author": "mumrah", "createdAt": "2020-12-08T00:46:18Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,34 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends ControllerRequestCompletionHandler {", "originalCommit": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0ODE0MQ==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537948141", "bodyText": "I don't think we actually have the ability to cancel in-flight requests. The problem is that many partitions can have ISR changes batched together in a single request. So we couldn't cancel one without cancelling them all.\nA new LeaderAndIsr arriving will just overwrite the existing isrState in Partition which will effectively cause any in-flight AlterIsr response to be ignored (for that partition)", "author": "mumrah", "createdAt": "2020-12-08T00:52:34Z", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,34 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends ControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")\n+      }\n     }\n \n     debug(s\"Sending AlterIsr to controller $message\")\n-    controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message), responseHandler)\n+    // We will not timeout AlterISR request, instead letting it retry indefinitely\n+    // until a response is received or the request is cancelled after receiving new LeaderAndIsr state.", "originalCommit": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1ODI3OA==", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537958278", "bodyText": "Updated the comment", "author": "abbccdda", "createdAt": "2020-12-08T01:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0ODE0MQ=="}], "type": "inlineReview"}, {"oid": "8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a", "url": "https://github.com/apache/kafka/commit/8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a", "message": "address David comments", "committedDate": "2020-12-08T01:19:40Z", "type": "commit"}]}