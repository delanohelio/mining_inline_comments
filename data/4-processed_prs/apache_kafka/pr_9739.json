{"pr_number": 9739, "pr_title": "KAFKA-10636 Bypass log validation for writes to raft log", "pr_createdAt": "2020-12-13T07:15:12Z", "pr_url": "https://github.com/apache/kafka/pull/9739", "timeline": [{"oid": "ed2fc564ea5431a208cbb7e534996ee1843bb2a6", "url": "https://github.com/apache/kafka/commit/ed2fc564ea5431a208cbb7e534996ee1843bb2a6", "message": "initial commit", "committedDate": "2020-12-13T07:04:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NDg0Mw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r541864843", "bodyText": "I intended to add a new AppendOrigin called Leader for this case, but then think it implies the same as the Replication, so just reuses it.", "author": "feyman2016", "createdAt": "2020-12-13T07:17:20Z", "path": "core/src/main/scala/kafka/raft/KafkaMetadataLog.scala", "diffHunk": "@@ -68,7 +68,7 @@ class KafkaMetadataLog(\n \n     val appendInfo = log.appendAsLeader(records.asInstanceOf[MemoryRecords],\n       leaderEpoch = epoch,\n-      origin = AppendOrigin.Coordinator)\n+      origin = AppendOrigin.Replication)", "originalCommit": "ed2fc564ea5431a208cbb7e534996ee1843bb2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NDI5MA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r553664290", "bodyText": "I was going to ask about adding a new AppendOrigin. I agree that the behavior should be the same as for Replication, but it seems like it could lead to confusion. Maybe we could add an AppendOrigin.RaftLeader. Then we can add a simple comment which emphasizes that the Raft leader is responsible for assigning offsets. That would also allow us to revert the changes in LogCleanerTest.", "author": "hachikuji", "createdAt": "2021-01-08T00:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NDg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA4MjA2Mw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r559082063", "bodyText": "Added a AppendOrigin.RaftLeader and also reverted the changes in LogCleanerTest", "author": "feyman2016", "createdAt": "2021-01-17T05:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NDg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NTk3Nw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r541865977", "bodyText": "This is necessary for the sanity check in Log.scala append()\n         if (batch.magic >= RecordBatch.MAGIC_VALUE_V2) {\n              maybeAssignEpochStartOffset(batch.partitionLeaderEpoch, batch.baseOffset)", "author": "feyman2016", "createdAt": "2020-12-13T07:24:51Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1477,6 +1477,7 @@ private void appendBatch(\n     ) {\n         try {\n             int epoch = state.epoch();\n+            batch.data.batches().forEach(recordBatch -> recordBatch.setPartitionLeaderEpoch(epoch));", "originalCommit": "ed2fc564ea5431a208cbb7e534996ee1843bb2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTQ4MQ==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r553665481", "bodyText": "Hmm.. Do we need this? I thought we already set leader epoch here: https://github.com/apache/kafka/blob/trunk/raft/src/main/java/org/apache/kafka/raft/internals/BatchBuilder.java#L256.", "author": "hachikuji", "createdAt": "2021-01-08T00:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA4MjU5OQ==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r559082599", "bodyText": "@hachikuji I thought the same as you, re-check the code, the PARTITION_LEADER_EPOCH_OFFSET has been set in DefaultRecordBatch#writeHeader, but the problem is that the BatchBuilder is always constructed with the epoch=RecordBatch.NO_PARTITION_LEADER_EPOCH, so I updated it and reverted the L1480.", "author": "feyman2016", "createdAt": "2021-01-17T05:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg2NTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r541885151", "bodyText": "This can be replaced by val assignOffsets = if (origin != AppendOrigin.Replication)", "author": "dengziming", "createdAt": "2020-12-13T09:24:50Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -1050,7 +1050,8 @@ class Log(@volatile private var _dir: File,\n                      leaderEpoch: Int,\n                      origin: AppendOrigin = AppendOrigin.Client,\n                      interBrokerProtocolVersion: ApiVersion = ApiVersion.latestVersion): LogAppendInfo = {\n-    append(records, origin, interBrokerProtocolVersion, assignOffsets = true, leaderEpoch, ignoreRecordSize = false)\n+    val assignOffsets = if (origin == AppendOrigin.Replication) false else true", "originalCommit": "ed2fc564ea5431a208cbb7e534996ee1843bb2a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0MTg5NA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r541941894", "bodyText": "@dengziming Thanks, but it needs else for a complete if expression", "author": "feyman2016", "createdAt": "2020-12-13T14:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4NjU5Mg==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r542086592", "bodyText": "o, I mean val assignOffsets = origin != AppendOrigin.Replication", "author": "dengziming", "createdAt": "2020-12-14T03:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2MjM3Mg==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r542362372", "bodyText": "Got it, will let @hachikuji review and fix it in one shot, thanks", "author": "feyman2016", "createdAt": "2020-12-14T12:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NjczOA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r553666738", "bodyText": "By the way, it seems we might want to rename assignOffsets since we also rely on this flag for record validation. It's a bit on the verbose side, but maybe validateAndAssignOffsets to go along with the similarly named method in LogValidator?", "author": "hachikuji", "createdAt": "2021-01-08T00:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA4MjYxNg==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r559082616", "bodyText": "Make sense, updated", "author": "feyman2016", "createdAt": "2021-01-17T05:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4NTE1MQ=="}], "type": "inlineReview"}, {"oid": "621bbb2fdb63b3a72e80e0bdefb33e2b0bb3d033", "url": "https://github.com/apache/kafka/commit/621bbb2fdb63b3a72e80e0bdefb33e2b0bb3d033", "message": "fix tests", "committedDate": "2020-12-13T14:47:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0NDEwNA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r541944104", "bodyText": "Since now for AppendOrigin.Replication, the LogValidator is bypassed when Log.appendAsLeader is called, which has an assumption that the records to be appended should have leader epoch ready in its underlying batches. And moreover, the transaction/group coordinator are supposed to be calling the Log.appendAsLeader with origin = AppendOrigin.Coordinator.", "author": "feyman2016", "createdAt": "2020-12-13T15:11:59Z", "path": "core/src/test/scala/unit/kafka/log/LogCleanerTest.scala", "diffHunk": "@@ -599,12 +599,12 @@ class LogCleanerTest {\n     val log = makeLog(config = LogConfig.fromProps(logConfig.originals, logProps))\n \n     val appendFirstTransaction = appendTransactionalAsLeader(log, producerId, producerEpoch,\n-      origin = AppendOrigin.Replication)\n+      origin = AppendOrigin.Coordinator)", "originalCommit": "621bbb2fdb63b3a72e80e0bdefb33e2b0bb3d033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA4MjY1NA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r559082654", "bodyText": "Reverted since we have a newly added AppendOrigin.RaftLeader", "author": "feyman2016", "createdAt": "2021-01-17T05:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0NDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NjkzOA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r553666938", "bodyText": "It would be helpful to have a test case which verifies appendAsLeader with the new append origin.", "author": "hachikuji", "createdAt": "2021-01-08T00:14:21Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -1050,7 +1050,8 @@ class Log(@volatile private var _dir: File,\n                      leaderEpoch: Int,\n                      origin: AppendOrigin = AppendOrigin.Client,", "originalCommit": "621bbb2fdb63b3a72e80e0bdefb33e2b0bb3d033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkzNTY2OQ==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r558935669", "bodyText": "fixed", "author": "feyman2016", "createdAt": "2021-01-16T15:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NjkzOA=="}], "type": "inlineReview"}, {"oid": "56b1c6cc9c0df3b2eee222677b22fe66c3afb604", "url": "https://github.com/apache/kafka/commit/56b1c6cc9c0df3b2eee222677b22fe66c3afb604", "message": "update based on comments", "committedDate": "2021-01-16T15:23:24Z", "type": "commit"}, {"oid": "56228d5ff88333645517248264011da860f559fb", "url": "https://github.com/apache/kafka/commit/56228d5ff88333645517248264011da860f559fb", "message": "update", "committedDate": "2021-01-16T15:44:50Z", "type": "commit"}, {"oid": "30952cb2e7bd8eb913d011e6c9f6dde87d14a2e7", "url": "https://github.com/apache/kafka/commit/30952cb2e7bd8eb913d011e6c9f6dde87d14a2e7", "message": "merge trunk", "committedDate": "2021-01-17T08:26:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA5Njg0Mw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r559096843", "bodyText": "Fx checkstyle error", "author": "feyman2016", "createdAt": "2021-01-17T08:28:02Z", "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -19,7 +19,6 @@\n import org.apache.kafka.common.memory.MemoryPool;\n import org.apache.kafka.common.record.CompressionType;\n import org.apache.kafka.common.record.MemoryRecords;\n-import org.apache.kafka.common.record.RecordBatch;", "originalCommit": "30952cb2e7bd8eb913d011e6c9f6dde87d14a2e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aa1049a848c06b99c2fbf73fbf04d8e52ff50f6a", "url": "https://github.com/apache/kafka/commit/aa1049a848c06b99c2fbf73fbf04d8e52ff50f6a", "message": "fix naming", "committedDate": "2021-01-17T08:29:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMTMzNQ==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r560601335", "bodyText": "Good catch. Do we have any test cases in BatchAccumulatorTest which can be modified to catch this case?", "author": "hachikuji", "createdAt": "2021-01-20T00:57:12Z", "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -180,7 +179,7 @@ private void startNewBatch() {\n                 nextOffset,\n                 time.milliseconds(),\n                 false,\n-                RecordBatch.NO_PARTITION_LEADER_EPOCH,\n+                epoch,", "originalCommit": "aa1049a848c06b99c2fbf73fbf04d8e52ff50f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTU4NzU1MA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r561587550", "bodyText": "Let me check", "author": "feyman2016", "createdAt": "2021-01-21T03:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjgzMw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r560602833", "bodyText": "It is a little odd here is that we have to pass through leaderEpoch even though we expect the Raft leader to have set it already. Perhaps we should be validating it in analyzeAndValidateRecords. We can verify for each batch that the leader epoch matches when the append origin is RaftLeader. Does that make sense?", "author": "hachikuji", "createdAt": "2021-01-20T01:01:01Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -1057,7 +1057,8 @@ class Log(@volatile private var _dir: File,\n                      leaderEpoch: Int,\n                      origin: AppendOrigin = AppendOrigin.Client,\n                      interBrokerProtocolVersion: ApiVersion = ApiVersion.latestVersion): LogAppendInfo = {\n-    append(records, origin, interBrokerProtocolVersion, assignOffsets = true, leaderEpoch, ignoreRecordSize = false)\n+    val validateAndAssignOffsets = origin != AppendOrigin.RaftLeader\n+    append(records, origin, interBrokerProtocolVersion, validateAndAssignOffsets, leaderEpoch, ignoreRecordSize = false)", "originalCommit": "aa1049a848c06b99c2fbf73fbf04d8e52ff50f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTU4OTg2Nw==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r561589867", "bodyText": "Make sense to me, it is also a little bit odd to me, but I put it here because I think assignOffsets==true for appendAsLeader and ==false for appendAsFollower, which means normally assignOffsets is determined by the caller, the RaftLeader is just a special case for appendAsLeader, if we move the logic in analyzeAndValidateRecords, that means it need to determine whether to assignOffsets without caller info, does that doable?", "author": "feyman2016", "createdAt": "2021-01-21T04:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk0MTg0OA==", "url": "https://github.com/apache/kafka/pull/9739#discussion_r563941848", "bodyText": "The call to analyzeAndValidateRecords is done both for leader as well as follower appends. Basically we do a shallow iteration over the batches in order to collect some information and validate the CRC. My thought was to pass leaderEpoch into analyzeAndValidateRecords and add a basic check like this:\nrecords.batches.forEach { batch =>\n  ...\n  if (origin === RaftLeader && batch.partitionLeaderEpoch != leaderEpoch) {\n    throw new InvalidRecordException(\"Append from Raft leader did not set the batch epoch correctly\")\n  }\n}", "author": "hachikuji", "createdAt": "2021-01-25T18:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjgzMw=="}], "type": "inlineReview"}, {"oid": "7ae4903a1ddf109892465d24dd1b935886c45b11", "url": "https://github.com/apache/kafka/commit/7ae4903a1ddf109892465d24dd1b935886c45b11", "message": "merge origin/trunk and fix based on comments", "committedDate": "2021-02-01T00:40:24Z", "type": "commit"}, {"oid": "89afaf3d8f72af4b5770bef9ae27989ad1a29860", "url": "https://github.com/apache/kafka/commit/89afaf3d8f72af4b5770bef9ae27989ad1a29860", "message": "Fix KafkaMetadataLogTest", "committedDate": "2021-02-01T15:17:00Z", "type": "commit"}]}