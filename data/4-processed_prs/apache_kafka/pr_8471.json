{"pr_number": 8471, "pr_title": "KAFKA-9854 Re-authenticating causes mismatched parse of response", "pr_createdAt": "2020-04-12T16:53:00Z", "pr_url": "https://github.com/apache/kafka/pull/8471", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyNDg2Mw==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r407224863", "bodyText": "the side effect is that the mismatched error about correlation id is added back to Selector so I'm digging in it for better approach.", "author": "chia7712", "createdAt": "2020-04-12T16:57:54Z", "path": "clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java", "diffHunk": "@@ -524,10 +524,14 @@ private AbstractResponse receiveKafkaResponse() throws IOException {\n                 currentRequestHeader = null;\n                 return response;\n             }\n-        } catch (SchemaException | IllegalArgumentException e) {\n+        } catch (SchemaException | IllegalStateException | IllegalArgumentException e) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMjMzMw==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r407332333", "bodyText": "a case of parsing buffer of ListOffsetResponse to SaslHandshakeResponse", "author": "chia7712", "createdAt": "2020-04-13T06:01:29Z", "path": "clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java", "diffHunk": "@@ -1718,6 +1721,24 @@ public void testInsufficientScopeSaslOauthBearerMechanism() throws Exception {\n                 \"{\\\"status\\\":\\\"insufficient_scope\\\", \\\"scope\\\":\\\"[LOGIN_TO_KAFKA]\\\"}\");\n     }\n \n+    @Test\n+    public void testConvertListOffsetResponseToSaslHandshakeResponse() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NTc2NA==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408395764", "bodyText": "@rajinisivaram I change the reserved range from [0, 6] to [1017. 1024] to avoid changing the correlation id in mocked response of other test cases.", "author": "chia7712", "createdAt": "2020-04-14T19:53:55Z", "path": "clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java", "diffHunk": "@@ -105,6 +105,38 @@\n     private static final short DISABLE_KAFKA_SASL_AUTHENTICATE_HEADER = -1;\n     private static final Random RNG = new Random();\n \n+    /**\n+     * the reserved range of correlation id for Sasl requests.\n+     *\n+     * Noted: there is a story about reserved range. The response of LIST_OFFSET is compatible to response of SASL_HANDSHAKE.\n+     * Hence, we could miss the schema error when using schema of SASL_HANDSHAKE to parse response of LIST_OFFSET.\n+     * For example: the IllegalStateException caused by mismatched correlation id is thrown if following steps happens.\n+     * 1) sent LIST_OFFSET\n+     * 2) sent SASL_HANDSHAKE\n+     * 3) receive response of LIST_OFFSET\n+     * 4) succeed to use schema of SASL_HANDSHAKE to parse response of LIST_OFFSET\n+     * 5) throw IllegalStateException due to mismatched correlation id\n+     * As a simple approach, we force Sasl requests to use a reserved correlation id which is separated from those\n+     * used in NetworkClient for Kafka requests. Hence, we can guarantee that every SASL request will throw\n+     * SchemaException due to correlation id mismatch during reauthentication\n+     */\n+    public static final int MAX_RESERVED_CORRELATION_ID = 1024;\n+\n+    /**\n+     * We only expect one request in-flight a time during authentication so the small range is fine.\n+     *\n+     * Noted: the min id is not 0 since there are many tests mocking response with correlation id \"0\" and we don't want\n+     * to make a large commit.\n+     */\n+    public static final int MIN_RESERVED_CORRELATION_ID = MAX_RESERVED_CORRELATION_ID - 7;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NDY0OQ==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408454649", "bodyText": "We could perhaps reserve the top numbers with MAX_RESERVED_CORRELATION_ID=Integer.MAX_VALUE? Then we don't need the comment explaining why.", "author": "rajinisivaram", "createdAt": "2020-04-14T21:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MzE4Nw==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408453187", "bodyText": "make it if-then-else since we dont't need the increment in the line below? Also split this line since we don't include the statement in the same line as if.", "author": "rajinisivaram", "createdAt": "2020-04-14T21:41:33Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -1155,14 +1162,19 @@ public ClientRequest newClientRequest(String nodeId,\n         return newClientRequest(nodeId, requestBuilder, createdTimeMs, expectResponse, defaultRequestTimeoutMs, null);\n     }\n \n+    private int nextCorrelationId() {\n+        if (SaslClientAuthenticator.isReserved(correlation)) correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzODE0NQ==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408538145", "bodyText": "make it if-then-else since we dont't need the increment in the line below?\n\nThe increment make the variable has next available correlation id after evaluating the return value.\n\nAlso split this line since we don't include the statement in the same line as if.\n\nGot it", "author": "chia7712", "createdAt": "2020-04-15T02:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MzI5MQ==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408453291", "bodyText": "Revert?", "author": "rajinisivaram", "createdAt": "2020-04-14T21:41:46Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -941,7 +941,7 @@ public void onFailure(RuntimeException e) {\n                 .forConsumer(requireTimestamp, isolationLevel)\n                 .setTargetTimes(timestampsToSearch);\n \n-        log.debug(\"Sending ListOffsetRequest {} to broker {}\", builder, node);\n+        log.error(\"[CHIA] Sending ListOffsetRequest {} to broker {}\", builder, node);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NTE5Mg==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408455192", "bodyText": "as before, this could be if-then-else without the increment below for the if case.", "author": "rajinisivaram", "createdAt": "2020-04-14T21:45:55Z", "path": "clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java", "diffHunk": "@@ -326,6 +358,11 @@ public Long reauthenticationLatencyMs() {\n         return reauthInfo.reauthenticationLatencyMs();\n     }\n \n+    private int nextCorrelationId() {\n+        if (!isReserved(correlationId)) correlationId = MIN_RESERVED_CORRELATION_ID;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NzIwMA==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408457200", "bodyText": "Does this test hit the issue? If it doesn't reliably test the issue, it may be better to add a unit test since this is expensive and one of the other tests occasionally runs into this issue anyway. If it does reliably test the issue, we should keep this.", "author": "rajinisivaram", "createdAt": "2020-04-14T21:50:07Z", "path": "core/src/test/scala/integration/kafka/api/EndToEndAuthorizationTest.scala", "diffHunk": "@@ -379,6 +380,27 @@ abstract class EndToEndAuthorizationTest extends IntegrationTestHarness with Sas\n     assertEquals(1, describeResults2.get(topic2).get().partitions().size())\n   }\n \n+  @Test\n+  def testSendListOffsetBeforeReauthentication(): Unit = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU0MzY0MQ==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408543641", "bodyText": "It fails consistently on my local but you are right that it is too expensive. Will update the test case.", "author": "chia7712", "createdAt": "2020-04-15T02:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1Nzc0OA==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r408457748", "bodyText": "do we expect authorization exception here?", "author": "rajinisivaram", "createdAt": "2020-04-14T21:51:23Z", "path": "core/src/test/scala/integration/kafka/api/EndToEndAuthorizationTest.scala", "diffHunk": "@@ -379,6 +380,27 @@ abstract class EndToEndAuthorizationTest extends IntegrationTestHarness with Sas\n     assertEquals(1, describeResults2.get(topic2).get().partitions().size())\n   }\n \n+  @Test\n+  def testSendListOffsetBeforeReauthentication(): Unit = {\n+    setConsumerGroupAcls()\n+    val producer = createProducer()\n+    val consumer = createConsumer()\n+    val partitions = mutable.ArrayBuffer[TopicPartition]()\n+    (0 to 10).map(index => new TopicPartition(s\"topic-$index\", 0))\n+      .foreach {\n+        tp =>\n+          setReadAndWriteAcls(tp)\n+          partitions += tp\n+          // increase the assigned partitions to produce following requests.\n+          // 1. send LIST_OFFSET for new partition\n+          // 2. send SASL_AUTHENTICATE for existent partition\n+          // If they are on same broker, the response of LIST_OFFSET is processed by schema of SASL_AUTHENTICATE\n+          consumer.assign(partitions.asJava)\n+          sendRecords(producer, numRecords, tp)\n+          consumeRecordsIgnoreOneAuthorizationException(consumer, numRecords, startingOffset = 0, tp.topic())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM4OTAwMg==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r409389002", "bodyText": "I think we were using negative values as well before. Perhaps we should use correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1 to avoid assuming here that zero is not reserved?", "author": "rajinisivaram", "createdAt": "2020-04-16T08:49:50Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -1155,14 +1162,21 @@ public ClientRequest newClientRequest(String nodeId,\n         return newClientRequest(nodeId, requestBuilder, createdTimeMs, expectResponse, defaultRequestTimeoutMs, null);\n     }\n \n+    // visible for testing\n+    int nextCorrelationId() {\n+        if (SaslClientAuthenticator.isReserved(correlation))\n+            correlation = 0;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5OTkzMw==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r409399933", "bodyText": "you are totally right! I will roger that!", "author": "chia7712", "createdAt": "2020-04-16T09:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM4OTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5MTk2MA==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r409391960", "bodyText": "We can use assertThrows here.", "author": "rajinisivaram", "createdAt": "2020-04-16T08:54:21Z", "path": "clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java", "diffHunk": "@@ -1537,6 +1546,58 @@ public void testCannotReauthenticateWithDifferentPrincipal() throws Exception {\n             server.verifyReauthenticationMetrics(0, 1);\n         }\n     }\n+\n+    @Test\n+    public void testCorrelationId() {\n+        SaslClientAuthenticator authenticator = new SaslClientAuthenticator(\n+              Collections.emptyMap(),\n+              null,\n+              \"node\",\n+              null,\n+              null,\n+              null,\n+              \"plain\",\n+              false,\n+              null,\n+              null,\n+            new LogContext()\n+        ) {\n+            @Override\n+            SaslClient createSaslClient() {\n+                return null;\n+            }\n+        };\n+        int count = (SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID - SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID) * 2;\n+        Set<Integer> ids = IntStream.range(0, count)\n+            .mapToObj(i -> authenticator.nextCorrelationId())\n+            .collect(Collectors.toSet());\n+        assertEquals(SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID - SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID + 1, ids.size());\n+        ids.forEach(id -> {\n+            assertTrue(id >= SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID);\n+            assertTrue(SaslClientAuthenticator.isReserved(id));\n+        });\n+    }\n+\n+    @Test\n+    public void testConvertListOffsetResponseToSaslHandshakeResponse() {\n+        ListOffsetResponse response = new ListOffsetResponse(0, Collections.singletonMap(new TopicPartition(\"topic\", 0),\n+            new ListOffsetResponse.PartitionData(Errors.NONE, 0, 0, Optional.empty())));\n+        ByteBuffer buffer = response.serialize(ApiKeys.LIST_OFFSETS, LIST_OFFSETS.latestVersion(), 0);\n+        RequestHeader header = new RequestHeader(LIST_OFFSETS, LIST_OFFSETS.latestVersion(), \"id\", SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID);\n+        try {\n+            NetworkClient.parseResponse(buffer.duplicate(), header);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5MjE2MQ==", "url": "https://github.com/apache/kafka/pull/8471#discussion_r409392161", "bodyText": "As before, we can use assertThrows.", "author": "rajinisivaram", "createdAt": "2020-04-16T08:54:40Z", "path": "clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java", "diffHunk": "@@ -1537,6 +1546,58 @@ public void testCannotReauthenticateWithDifferentPrincipal() throws Exception {\n             server.verifyReauthenticationMetrics(0, 1);\n         }\n     }\n+\n+    @Test\n+    public void testCorrelationId() {\n+        SaslClientAuthenticator authenticator = new SaslClientAuthenticator(\n+              Collections.emptyMap(),\n+              null,\n+              \"node\",\n+              null,\n+              null,\n+              null,\n+              \"plain\",\n+              false,\n+              null,\n+              null,\n+            new LogContext()\n+        ) {\n+            @Override\n+            SaslClient createSaslClient() {\n+                return null;\n+            }\n+        };\n+        int count = (SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID - SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID) * 2;\n+        Set<Integer> ids = IntStream.range(0, count)\n+            .mapToObj(i -> authenticator.nextCorrelationId())\n+            .collect(Collectors.toSet());\n+        assertEquals(SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID - SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID + 1, ids.size());\n+        ids.forEach(id -> {\n+            assertTrue(id >= SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID);\n+            assertTrue(SaslClientAuthenticator.isReserved(id));\n+        });\n+    }\n+\n+    @Test\n+    public void testConvertListOffsetResponseToSaslHandshakeResponse() {\n+        ListOffsetResponse response = new ListOffsetResponse(0, Collections.singletonMap(new TopicPartition(\"topic\", 0),\n+            new ListOffsetResponse.PartitionData(Errors.NONE, 0, 0, Optional.empty())));\n+        ByteBuffer buffer = response.serialize(ApiKeys.LIST_OFFSETS, LIST_OFFSETS.latestVersion(), 0);\n+        RequestHeader header = new RequestHeader(LIST_OFFSETS, LIST_OFFSETS.latestVersion(), \"id\", SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID);\n+        try {\n+            NetworkClient.parseResponse(buffer.duplicate(), header);\n+            fail(\"parsing non-Sasl response should produce SchemaException\");\n+        } catch (SchemaException e) {\n+            // pass\n+        }\n+        header = new RequestHeader(LIST_OFFSETS, LIST_OFFSETS.latestVersion(), \"id\", 1);\n+        try {\n+            NetworkClient.parseResponse(buffer.duplicate(), header);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b2c03cf6227a236dd1b929501bb3fa2430c0dbd", "url": "https://github.com/apache/kafka/commit/3b2c03cf6227a236dd1b929501bb3fa2430c0dbd", "message": "KAFKA-9854 Re-authenticating causes mismatched parse of response", "committedDate": "2020-04-16T09:58:27Z", "type": "commit"}, {"oid": "3b2c03cf6227a236dd1b929501bb3fa2430c0dbd", "url": "https://github.com/apache/kafka/commit/3b2c03cf6227a236dd1b929501bb3fa2430c0dbd", "message": "KAFKA-9854 Re-authenticating causes mismatched parse of response", "committedDate": "2020-04-16T09:58:27Z", "type": "forcePushed"}]}