{"pr_number": 9485, "pr_title": "KAKFA-10619: Idempotent producer will get authorized once it has a WRITE access to at least one topic", "pr_createdAt": "2020-10-23T05:23:25Z", "pr_url": "https://github.com/apache/kafka/pull/9485", "timeline": [{"oid": "2c3065f2ead155ab488df38e0a7dd254120f7f30", "url": "https://github.com/apache/kafka/commit/2c3065f2ead155ab488df38e0a7dd254120f7f30", "message": "initial", "committedDate": "2020-10-23T05:22:15Z", "type": "commit"}, {"oid": "a91a5bc32f614b09c65cb416df4e23f73aa9dbe8", "url": "https://github.com/apache/kafka/commit/a91a5bc32f614b09c65cb416df4e23f73aa9dbe8", "message": "Added tests", "committedDate": "2020-10-27T01:53:44Z", "type": "commit"}, {"oid": "f85601011c482e32d103462734a4af358e2560b1", "url": "https://github.com/apache/kafka/commit/f85601011c482e32d103462734a4af358e2560b1", "message": "implement the interface default", "committedDate": "2020-10-28T06:17:28Z", "type": "commit"}, {"oid": "dc9fa33dea8d5764a1bdb20d62d9e160ce9f64ae", "url": "https://github.com/apache/kafka/commit/dc9fa33dea8d5764a1bdb20d62d9e160ce9f64ae", "message": "handle wildcard ace", "committedDate": "2020-10-28T08:45:19Z", "type": "commit"}, {"oid": "bcfe3532800108b8f33822432a01b45e2ceaec33", "url": "https://github.com/apache/kafka/commit/bcfe3532800108b8f33822432a01b45e2ceaec33", "message": "Fix authorizeAny deny on cluster", "committedDate": "2020-10-28T17:34:36Z", "type": "commit"}, {"oid": "05da2bd3eb0d7bd37fccf977a5215513c6974b29", "url": "https://github.com/apache/kafka/commit/05da2bd3eb0d7bd37fccf977a5215513c6974b29", "message": "Add more tests", "committedDate": "2020-10-29T00:58:29Z", "type": "commit"}, {"oid": "45dc8a212d6f71d22536c5d1e14f8a57d2b03014", "url": "https://github.com/apache/kafka/commit/45dc8a212d6f71d22536c5d1e14f8a57d2b03014", "message": "bug fix", "committedDate": "2020-10-29T01:00:18Z", "type": "commit"}, {"oid": "68dc6bf1713f62977f2b2cf0f47d50f1a720c00f", "url": "https://github.com/apache/kafka/commit/68dc6bf1713f62977f2b2cf0f47d50f1a720c00f", "message": "added tests for wildcard principle, host, and operation", "committedDate": "2020-10-29T05:06:20Z", "type": "commit"}, {"oid": "a886be27f7cb7488e899fa1c54477c83aa0fdef1", "url": "https://github.com/apache/kafka/commit/a886be27f7cb7488e899fa1c54477c83aa0fdef1", "message": "Support Wildcard ACES by default", "committedDate": "2020-11-03T01:18:55Z", "type": "commit"}, {"oid": "955c78d9331c0fa6ca752bc5f9e2b199b123ed2f", "url": "https://github.com/apache/kafka/commit/955c78d9331c0fa6ca752bc5f9e2b199b123ed2f", "message": "move the acl removal logic from @before to @after, in order to pass all the tests", "committedDate": "2020-11-03T01:28:12Z", "type": "commit"}, {"oid": "5c9feff96744804c543ecec370e60c4bd07708b0", "url": "https://github.com/apache/kafka/commit/5c9feff96744804c543ecec370e60c4bd07708b0", "message": "Implement the new API for AuthorizerWrapper", "committedDate": "2020-11-03T20:40:38Z", "type": "commit"}, {"oid": "ec900c3ed2e66bdbe17679fe8451d0badc439e8c", "url": "https://github.com/apache/kafka/commit/ec900c3ed2e66bdbe17679fe8451d0badc439e8c", "message": "refactor the test", "committedDate": "2020-11-03T20:42:04Z", "type": "commit"}, {"oid": "163f6cf54dde86679dab18cc4e003f879585d590", "url": "https://github.com/apache/kafka/commit/163f6cf54dde86679dab18cc4e003f879585d590", "message": "remove a) cluster special handling b) empty prefix check", "committedDate": "2020-11-03T23:46:28Z", "type": "commit"}, {"oid": "7b99fdce1987c0248353fa053b2d00254cf5827f", "url": "https://github.com/apache/kafka/commit/7b99fdce1987c0248353fa053b2d00254cf5827f", "message": "optimize the interface default, checking literals in the default instead of calling authorize", "committedDate": "2020-11-04T00:30:39Z", "type": "commit"}, {"oid": "b7f63fe1a2cfc122af5cd0d678ada4ed0fd0ff04", "url": "https://github.com/apache/kafka/commit/b7f63fe1a2cfc122af5cd0d678ada4ed0fd0ff04", "message": "rename the authorizeAny to authorizeByResourceType", "committedDate": "2020-11-04T20:09:02Z", "type": "commit"}, {"oid": "b28637e57c7c3779795cae48ffc851f7c7f99080", "url": "https://github.com/apache/kafka/commit/b28637e57c7c3779795cae48ffc851f7c7f99080", "message": "clean up AclAuthorizer", "committedDate": "2020-11-04T22:07:16Z", "type": "commit"}, {"oid": "594e35099c6af000503f99d1028375a3f2da0014", "url": "https://github.com/apache/kafka/commit/594e35099c6af000503f99d1028375a3f2da0014", "message": "added integration tests", "committedDate": "2020-11-07T10:08:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526479473", "bodyText": "We should document what this default implementation does and why a custom implementation may want to override this default.", "author": "rajinisivaram", "createdAt": "2020-11-18T22:58:26Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0NjIxMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532346213", "bodyText": "Yes. Let's document this after we finally settle down all the implementations.", "author": "ctan888", "createdAt": "2020-11-30T04:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMwNTIxOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r536305219", "bodyText": "commit 7af4a7f", "author": "ctan888", "createdAt": "2020-12-04T18:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526479478", "bodyText": "We should document what this default implementation does and why a custom implementation may want to override this default.", "author": "rajinisivaram", "createdAt": "2020-11-18T22:58:26Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MTU3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526481573", "bodyText": "nit: indentation", "author": "rajinisivaram", "createdAt": "2020-11-18T23:03:40Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                            denyLiterals.add(binding.pattern().name());", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Mjg5OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526482899", "bodyText": "This looks identical to the code block above for prefix, we could just run the same code in a loop that checks both allow literals and prefixes.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:07:07Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                            denyLiterals.add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        denyPrefixes.add(binding.pattern().name());\n+                        break;\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allowLiterals.add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allowPrefixes.add(binding.pattern().name());\n+                    break;\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (String allowPrefix : allowPrefixes) {\n+            StringBuilder sb = new StringBuilder();\n+            boolean hasDominatedDeny = false;\n+            for (char ch : allowPrefix.toCharArray()) {\n+                sb.append(ch);\n+                if (denyPrefixes.contains(sb.toString())) {\n+                    hasDominatedDeny = true;\n+                    break;\n+                }\n+            }\n+            if (!hasDominatedDeny)\n+                return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (String allowLiteral : allowLiterals) {\n+            if (denyLiterals.contains(allowLiteral))\n+                continue;\n+            StringBuilder sb = new StringBuilder();\n+            boolean hasDominatedDeny = false;\n+            for (char ch : allowLiteral.toCharArray()) {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMTA0Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529031043", "bodyText": "Yes. Using an ArrayList to group allow-literals & allow-prefixes in order to deduplicate the logic using a loop\ncommit 188536a", "author": "ctan888", "createdAt": "2020-11-23T22:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Mjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MzQ3Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526483476", "bodyText": "We should have exactly one call to logAuditMessage that says whether access was allowed or denied.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:08:45Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzNjYyNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532336627", "bodyText": "Yes. commit 254af37", "author": "ctan888", "createdAt": "2020-11-30T04:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NjAyOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526486028", "bodyText": "request.principal can be a custom extension of KafkaPrincipal, we cannot use toString for comparison", "author": "rajinisivaram", "createdAt": "2020-11-18T23:15:24Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwODMwNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529008307", "bodyText": "Yeah, that's right. Construct a KafkaPrinciple instance with params referred from principal.getType() and getName()\ncommit 89df4d7", "author": "ctan888", "createdAt": "2020-11-23T21:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzE3Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526487176", "bodyText": "Not sure it is worth making a whole copy of this structure for a method that is not used frequently. It will be good to add microbenchmarks to AclAuthorizerBenchmark to understand how the new method performs.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:18:26Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -130,6 +130,11 @@ class AclAuthorizer extends Authorizer with Logging {\n \n   @volatile\n   private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n+\n+  @volatile\n+  private var resourceCache = new scala.collection.immutable.HashMap[AccessControlEntry,\n+    scala.collection.mutable.HashSet[ResourcePattern]]()", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMyNzU2MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532327560", "bodyText": "commit 230ee36\nAdded the authorizeByResourceType() API to the benchmark and simulate the worst case: every allow ACL on the same resource has a dominant deny ACL.\nAdjust the resourceCount parameter to \"10000\", \"40000\", \"80000\" since each cluster is unlikely to have more than 10k resources. Also, since we are testing against the worst case mentioned above, I think the \"10000\" cases are adequate for us.\nPerformance result here: https://paste.ubuntu.com/p/k8kV3w6fvF/", "author": "ctan888", "createdAt": "2020-11-30T03:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDU4OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533644589", "bodyText": "I wasn't sure what the result shows (not that familiar with the output format, sorry) The useful comparisons would be:\n\nFor authorizeByResourceType, what is the performance advantage we get by using this duplicate cache versus just using aclCache.\nWhat is the impact on updates which hold a lock for maintaining two caches (without the PR vs with this PR)\nDoes this PR impact regular authorize() calls? I think the answer is no.\n\nIn any case, it seems unnecessary to maintain a second cache with all ACLs. We never use authorizeByResourceType for anything other than topics, so it seems a waste to store ACLs for other resource types here. We could just use super.authorizeByResourceType for other types.", "author": "rajinisivaram", "createdAt": "2020-12-01T18:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Nzc2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526487761", "bodyText": "Same as in the Authorizer default method, we cannot use request.principal().toString()", "author": "rajinisivaram", "createdAt": "2020-11-18T23:19:56Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val allowPatterns = matchingPatterns(\n+      requestContext.principal().toString,", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwODgxOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529008818", "bodyText": "Yeah, that's right. Construct a KafkaPrinciple instance with params referred from principal.getType() and getName()\ncommit 89df4d7", "author": "ctan888", "createdAt": "2020-11-23T21:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Nzc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTE1Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526489152", "bodyText": "We should optimize for the case where there are no DENY acls. There is no point in finding all matching ALLOW entries in that case, we would just need to check for one ALLOW.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:23:54Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val allowPatterns = matchingPatterns(\n+      requestContext.principal().toString,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.ALLOW\n+    )\n+\n+    val denyPatterns = matchingPatterns(\n+      requestContext.principal().toString,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTY2Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529089666", "bodyText": "Good point. Deferred the collection generation until we need it.\ncommit 3906f97", "author": "ctan888", "createdAt": "2020-11-24T00:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDAxNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526494014", "bodyText": "make this all the methods below private", "author": "rajinisivaram", "createdAt": "2020-11-18T23:37:05Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,69 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  def denyAllResource(requestContext: AuthorizableRequestContext,", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTgyMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529089823", "bodyText": "Good catch.\ncommit 3906f97", "author": "ctan888", "createdAt": "2020-11-24T00:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDI5OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526494298", "bodyText": "We coul just inline all the methods below instead of separate methods for host etc.?", "author": "rajinisivaram", "createdAt": "2020-11-18T23:37:54Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,69 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA5MDE1Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r529090156", "bodyText": "Yeah. But I'd guess that the compiler will optimize for us.\ncommit 3906f97", "author": "ctan888", "createdAt": "2020-11-24T00:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTkyOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526495928", "bodyText": "Hmm, Produce s authorized for topic anyway. Why would we use a very expensive authorizeByResourceType here?", "author": "rajinisivaram", "createdAt": "2020-11-18T23:42:06Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -517,7 +517,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n       // Note that authorization to a transactionalId implies ProducerId authorization\n \n-    } else if (produceRequest.hasIdempotentRecords && !authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (produceRequest.hasIdempotentRecords\n+        && !authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)\n+        && !authorizeByResourceType(request.context, WRITE, TOPIC)) {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzNzM1OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532337358", "bodyText": "Right. Deleted the else branch. commit 254af37", "author": "ctan888", "createdAt": "2020-11-30T04:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NjIyNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526496224", "bodyText": "First authorize should use logIfAllowed=true, logIfDenied=false", "author": "rajinisivaram", "createdAt": "2020-11-18T23:42:56Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2034,7 +2036,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n         sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n         return\n       }\n-    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzNzQ0NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532337445", "bodyText": "commit 254af37", "author": "ctan888", "createdAt": "2020-11-30T04:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NjIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5Njk5OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526496998", "bodyText": "Durability?", "author": "rajinisivaram", "createdAt": "2020-11-18T23:44:48Z", "path": "core/src/test/scala/integration/kafka/api/AuthorizerIntegrationTest.scala", "diffHunk": "@@ -1775,6 +1782,87 @@ class AuthorizerIntegrationTest extends BaseRequestTest {\n     assertFalse(\"Cluster id not returned\", response.clusterId.isEmpty)\n   }\n \n+  @Test\n+  def testAuthorizeAnyDurability(): Unit = {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzNzc2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532337761", "bodyText": "I was trying to prove that the new API can work properly with multiple add / remove operations. Changed to testAuthorizerAnyMultipleAddAndRemove for now. Any naming suggestion?\ncommit b0aa305", "author": "ctan888", "createdAt": "2020-11-30T04:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5Njk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTE1OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526499159", "bodyText": "It may be better to put the mock tests into another test class. That wouldn't request ZooKeeper for example.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:50:40Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -82,16 +86,17 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   override def setUp(): Unit = {\n     super.setUp()\n \n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2, MockAuthorizer.authorizer)", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzODI0MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532338240", "bodyText": "The MockAuthorizer is an AclAuthorizer using the interface default to do authorizeByResourceType. I was trying to prevent the duplicated code and ease the test implementation. Do you think we can keep it here?", "author": "ctan888", "createdAt": "2020-11-30T04:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTUwNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526499504", "bodyText": "As before, references to Durability in authorizer tests are confusing.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:51:38Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +1000,369 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeAnyDurability(): Unit = {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0MzYzNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532343635", "bodyText": "I was trying to prove that the new API can work properly with multiple add / remove operations. Changed to testAuthorizerAnyMultipleAddAndRemove for now. Any naming suggestion?\ncommit b0aa305", "author": "ctan888", "createdAt": "2020-11-30T04:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDY4OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526500688", "bodyText": "Are we going to add tests here?", "author": "rajinisivaram", "createdAt": "2020-11-18T23:54:50Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package unit.kafka.security.authorizer;\n+\n+public class AuthorizerInterfaceDefaultTest {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0Mzc1NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532343754", "bodyText": "No. I was going to but that would add tons of duplicated codes. So I added the interface default test logic into AclAuthorizerTest. File deleted.", "author": "ctan888", "createdAt": "2020-11-30T04:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526502000", "bodyText": "We should run the microbenchmarks in AclAuthorizerBenchmark to make sure we don't add too much overhead here.", "author": "rajinisivaram", "createdAt": "2020-11-18T23:58:19Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -550,6 +660,31 @@ class AclAuthorizer extends Authorizer with Logging {\n   }\n \n   private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMyNzc3NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532327775", "bodyText": "commit 230ee36\nAdded the authorizeByResourceType() API to the benchmark and simulate the worst case: every allow ACL on the same resource has a dominant deny ACL.\nAdjust the resourceCount parameter to \"10000\", \"40000\", \"80000\" since each cluster is unlikely to have more than 10k resources. Also, since we are testing against the worst case mentioned above, I think the \"10000\" cases are adequate for us.\nPerformance result here: https://paste.ubuntu.com/p/k8kV3w6fvF/", "author": "ctan888", "createdAt": "2020-11-30T03:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjEyNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533622127", "bodyText": "Do we have a benchmark for updates (not authorize)?", "author": "rajinisivaram", "createdAt": "2020-12-01T18:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2Nzc1NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r537667755", "bodyText": "Please see below", "author": "ctan888", "createdAt": "2020-12-07T16:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMzk3NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526503975", "bodyText": "Don't we reuse this in multiple tests? How do we guarantee that no state is preserved between tests?", "author": "rajinisivaram", "createdAt": "2020-11-19T00:03:44Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0MTgxNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532341814", "bodyText": "Right. Didn't realize that staitc variables in the permgen area will stay there during the whole unit test process. Turn the class variable into the instance variable.", "author": "ctan888", "createdAt": "2020-11-30T04:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526504244", "bodyText": "We could mock this fully instead of using AclAuthorizer?", "author": "rajinisivaram", "createdAt": "2020-11-19T00:04:32Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer\n+}\n+\n+/**\n+ * A mock authorizer for testing the interface default\n+ */\n+class MockAuthorizer extends Authorizer {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0MjI1Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r532342253", "bodyText": "If we are mocking this fully, we'd probably need tests on the authorize API which the interface default authorizeByResourceType is based on. Also, we'll have much more duplicated code in order to implement all the interfaces.", "author": "ctan888", "createdAt": "2020-11-30T04:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDQyNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533720425", "bodyText": "This should perhaps be called DelegatingAuthorizer rather than MockAuthorizer since it is not a mock and requires ZK.", "author": "rajinisivaram", "createdAt": "2020-12-01T21:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNzIyMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533737220", "bodyText": "Right. DelegatingAuthorizer is more reasonable as a design pattern naming here.", "author": "ctan888", "createdAt": "2020-12-01T21:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI1MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526504251", "bodyText": "We could mock this fully instead of using AclAuthorizer?", "author": "rajinisivaram", "createdAt": "2020-11-19T00:04:33Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer\n+}\n+\n+/**\n+ * A mock authorizer for testing the interface default\n+ */\n+class MockAuthorizer extends Authorizer {", "originalCommit": "594e35099c6af000503f99d1028375a3f2da0014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89df4d7600cad4e3785d0d95624d0918efce1f44", "url": "https://github.com/apache/kafka/commit/89df4d7600cad4e3785d0d95624d0918efce1f44", "message": "convert session principle to Kafka principle in case that the subclass override the toString() method", "committedDate": "2020-11-23T21:27:51Z", "type": "commit"}, {"oid": "188536ad8df13fc327008e59c9787ad2230a7186", "url": "https://github.com/apache/kafka/commit/188536ad8df13fc327008e59c9787ad2230a7186", "message": "Deduplicate allow literal & prefix's prefix checking logic in interface default", "committedDate": "2020-11-23T22:13:39Z", "type": "commit"}, {"oid": "3906f978e62255ff266f081bf646a4b3c6b896ad", "url": "https://github.com/apache/kafka/commit/3906f978e62255ff266f081bf646a4b3c6b896ad", "message": "enhance performance", "committedDate": "2020-11-24T00:43:26Z", "type": "commit"}, {"oid": "230ee36b9147a11d7ce299aa9fcbb590324faf68", "url": "https://github.com/apache/kafka/commit/230ee36b9147a11d7ce299aa9fcbb590324faf68", "message": "add the API to aclBenchmark", "committedDate": "2020-11-30T01:02:21Z", "type": "commit"}, {"oid": "230ee36b9147a11d7ce299aa9fcbb590324faf68", "url": "https://github.com/apache/kafka/commit/230ee36b9147a11d7ce299aa9fcbb590324faf68", "message": "add the API to aclBenchmark", "committedDate": "2020-11-30T01:02:21Z", "type": "forcePushed"}, {"oid": "254af37df5e2d6ec462e7b70497ceb655edea596", "url": "https://github.com/apache/kafka/commit/254af37df5e2d6ec462e7b70497ceb655edea596", "message": "optimize the API performance, add the audit log", "committedDate": "2020-11-30T04:02:17Z", "type": "commit"}, {"oid": "b0aa305d8c043075ef0bb7b41d2c37e0072284c5", "url": "https://github.com/apache/kafka/commit/b0aa305d8c043075ef0bb7b41d2c37e0072284c5", "message": "test changes", "committedDate": "2020-11-30T04:32:26Z", "type": "commit"}, {"oid": "4504b181bba4675fa8b8967e59860c6817c6e709", "url": "https://github.com/apache/kafka/commit/4504b181bba4675fa8b8967e59860c6817c6e709", "message": "resolve conflicts", "committedDate": "2020-11-30T04:46:11Z", "type": "commit"}, {"oid": "eb8acb6b0e6a62b3ea29ed22a112b7ee0b07a749", "url": "https://github.com/apache/kafka/commit/eb8acb6b0e6a62b3ea29ed22a112b7ee0b07a749", "message": "fix checkstyle", "committedDate": "2020-11-30T20:39:52Z", "type": "commit"}, {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5", "url": "https://github.com/apache/kafka/commit/f9979f3681e1c6374cb693b17f8440d874169ef5", "message": "fix syntax err", "committedDate": "2020-12-01T17:07:30Z", "type": "commit"}, {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5", "url": "https://github.com/apache/kafka/commit/f9979f3681e1c6374cb693b17f8440d874169ef5", "message": "fix syntax err", "committedDate": "2020-12-01T17:07:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMTk2Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533501963", "bodyText": "This looks odd, do we really need these to index into arrays?", "author": "rajinisivaram", "createdAt": "2020-12-01T15:29:01Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNTI3NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533915275", "bodyText": "EnumMap make sense. commit 1a139ce", "author": "ctan888", "createdAt": "2020-12-02T05:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMTk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMjQxNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533502417", "bodyText": "Why do we create ArrayList(Arrays.asList)?", "author": "rajinisivaram", "createdAt": "2020-12-01T15:29:33Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNTI2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533915261", "bodyText": "EnumMap make sense. commit 1a139ce", "author": "ctan888", "createdAt": "2020-12-02T05:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzExOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533503119", "bodyText": "We could get host address and store in a variable outside the loop.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:30:24Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNjg4OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533916889", "bodyText": "Right. Just as what we've done to Principle. commit 29ac862", "author": "ctan888", "createdAt": "2020-12-02T06:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzE2Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533503166", "bodyText": "Why is this inside the for loop? We could just create one principal and use it inside the loop.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:30:27Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            KafkaPrincipal principal = new KafkaPrincipal(\n+                requestContext.principal().getPrincipalType(),\n+                requestContext.principal().getName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNTE0Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533915142", "bodyText": "Yeah. Took out. commit 1a139ce", "author": "ctan888", "createdAt": "2020-12-02T05:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwNTU2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533505561", "bodyText": "An EnumMap may be neater.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:33:34Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            KafkaPrincipal principal = new KafkaPrincipal(\n+                requestContext.principal().getPrincipalType(),\n+                requestContext.principal().getName());\n+\n+            if (!SecurityUtils.parseKafkaPrincipal(binding.entry().principal()).equals(principal)\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                        deny.get(typeLiteral).add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        deny.get(typePrefix).add(binding.pattern().name());\n+                        break;\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allow.get(typeLiteral).add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allow.get(typePrefix).add(binding.pattern().name());\n+                    break;\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (int allowType : Arrays.asList(typePrefix, typeLiteral)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNTAzNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533915036", "bodyText": "EnumMap make sense. commit 1a139ce", "author": "ctan888", "createdAt": "2020-12-02T05:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwNTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMDQ2Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533510467", "bodyText": "We should probably move this common code to SecurityUtils and use it both here and in the default implementation.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:39:45Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxOTQyNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533919425", "bodyText": "commit f6d2a39", "author": "ctan888", "createdAt": "2020-12-02T06:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMDQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMDQ3Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533510477", "bodyText": "We should probably move this common code to SecurityUtils and use it both here and in the default implementation.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:39:46Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMzAyMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533513021", "bodyText": "We have lost the resource type for auditing, we should include a resource pattern with empty name or something.", "author": "rajinisivaram", "createdAt": "2020-12-01T15:42:54Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+\n+    val denyPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY\n+    )\n+\n+    if (denyAll(denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op, null,0, true, true), false, false)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0Nzc3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534447773", "bodyText": "Use \"NONE\" for the pattern name and \"UNKNOWN` for the pattern type\ncommit cebbbd4", "author": "ctan888", "createdAt": "2020-12-02T20:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NDkwOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533564908", "bodyText": "ok, I seem to have forgotten this. Why is this code different from the one in the default implementation?", "author": "rajinisivaram", "createdAt": "2020-12-01T16:49:59Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+\n+    val denyPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY\n+    )\n+\n+    if (denyAll(denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op, null,0, true, true), false, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, new Action(op, null, 0, true, true), true, false)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.ALLOW\n+    )\n+\n+    if (allowAny(allowPatterns, denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op,null, 0, true, true), true, false)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, new Action(op, null, 0, true, true), false, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingPatterns(principal: String, host: String, op: AclOperation,\n+                       resourceType: ResourceType,\n+                       permission: AclPermissionType): Set[ResourcePattern] = {\n+    var resources = Set[ResourcePattern]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          resourceCache.get(ace) match {\n+            case Some(r) => resources ++= r.filter(r => r.resourceType() == resourceType)\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    resources\n+  }\n+\n+  private def denyAll(denyResources: Set[ResourcePattern]): Boolean =\n+    denyResources.exists(rp => denyAll(rp))\n+\n+  private def denyAll(rp: ResourcePattern): Boolean =\n+    rp.patternType() == PatternType.LITERAL && rp.name() == ResourcePattern.WILDCARD_RESOURCE\n+\n+  private def allowAny(allowPatterns: Set[ResourcePattern], denyPatterns: Set[ResourcePattern]): Boolean =\n+    allowPatterns.exists(pattern => allow(pattern, denyPatterns))\n+\n+  private def allow(pattern: ResourcePattern, denyPatterns: Set[ResourcePattern]): Boolean = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1NTE2Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534755163", "bodyText": "Now the only difference is that the AclAuthorizer is indexing on ACE, so the number of ACE won't impact the query efficiency.", "author": "ctan888", "createdAt": "2020-12-03T06:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NzMxMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533567312", "bodyText": "We should try to preserve the format for this for compatibility with scripts that parse these logs.", "author": "rajinisivaram", "createdAt": "2020-12-01T16:53:18Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -456,8 +576,12 @@ class AclAuthorizer extends Authorizer with Logging {\n       val apiKey = if (ApiKeys.hasId(requestContext.requestType)) ApiKeys.forId(requestContext.requestType).name else requestContext.requestType\n       val refCount = action.resourceReferenceCount\n \n-      s\"Principal = $principal is $authResult Operation = $operation \" +\n-        s\"from host = $host on resource = $resource for request = $apiKey with resourceRefCount = $refCount\"\n+      if (byResourceType)\n+        s\"Principal = $principal is $authResult Operation = $operation \" +\n+          s\"from host = $host on at least one resource of type $resourceType for request = $apiKey\"", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0Nzg5NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534447894", "bodyText": "leave the message as it is now.\ncommit cebbbd4", "author": "ctan888", "createdAt": "2020-12-02T20:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NzMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMzcxNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533623715", "bodyText": "if denyAllResource is true, we can just return DENIED?", "author": "rajinisivaram", "createdAt": "2020-12-01T18:17:41Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4OTkyMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534589923", "bodyText": "right. Just as what AclAuthorizer does. commit 18c5c04", "author": "ctan888", "createdAt": "2020-12-03T01:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMzcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNjQ2MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533626460", "bodyText": "Looks like a lot of duplicate code here. We should see how to share code for all this. Can we move the default implementation into SecurityUtils and share some of the matching implementation across the classes?", "author": "rajinisivaram", "createdAt": "2020-12-01T18:21:58Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  @inline\n+  private def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)\n+      && operationMatched(op, binding))\n+  }\n+\n+  @inline\n+  private def hostMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().host().equals(requestContext.clientAddress().getHostAddress)\n+      || binding.entry().host().equals(AclEntry.WildcardHost))\n+\n+  @inline\n+  private def principleMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().principal().equals(requestContext.principal().toString)\n+      || binding.entry().principal().equals(AclEntry.WildcardPrincipal.toString))\n+\n+  @inline\n+  private def operationMatched(op: AclOperation,\n+                       binding: AclBinding): Boolean =\n+    (binding.entry().operation() == op\n+      || binding.entry().operation() == AclOperation.ALL)\n+\n+  @inline\n+  private def canDenyAll(pattern: ResourcePattern): Boolean =\n+    pattern.patternType() == PatternType.LITERAL && pattern.name().equals(ResourcePattern.WILDCARD_RESOURCE)\n+", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1MTU5NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534751595", "bodyText": "Yeah, moved to SecurityUtils. commit 30899c4", "author": "ctan888", "createdAt": "2020-12-03T06:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDIxMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533630212", "bodyText": "Should this be && since we we only need one?", "author": "rajinisivaram", "createdAt": "2020-12-01T18:27:59Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2109,7 +2104,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n         sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n         return\n       }\n-    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME, true, false)\n+        || !authorizeByResourceType(request.context, AclOperation.WRITE, ResourceType.TOPIC)) {", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY1NzU1Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r537657552", "bodyText": "Good catch commit 031c2f4", "author": "ctan888", "createdAt": "2020-12-07T16:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDk3MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533720971", "bodyText": "I am not sure why we would make this change. If we need the change because we have become slower, we need to understand why.", "author": "rajinisivaram", "createdAt": "2020-12-01T21:05:42Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +70,39 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"10000\", \"40000\", \"80000\"})", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2NTkwOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533765909", "bodyText": "The underlying algorithm of AuthorizeByResourceType() implementation in AclAuthorizer has several characteristics:\n\nIf any \"allow resource\" of the given ACE does not have a dominant \"deny resource\", the API will return immediately\nThe complexity is O(n*m) where n is the number of \"allow resources\" of the given ACE, 'm' is the number of \"deny resources\" of the given ACE, but not related to the number of \"ACE\" in the cluster.\n\n$1 means that, given an ACE,  suppose p% of its \"allow resource\" does not have a dominant \"deny resource\", if resourceCount is r, on average, after checking r * p * 0.01 \"allow resources\", the API will return.\na) if we are let the \"dominant deny resource\" distribute evenly, like use the (loop index % something) to determine which \"allow resource\" should have a dominant \"deny resource\", we end up iterating the same amount of the \"allow resource\" and returning from the API call every time, which is r*p*0.01\nb) if we are determine which \"allow resource\" should have a dominant \"deny resource\", the result will be too noisy. We may iterate only 1 resource or iterate all resources based on the randomize algorithm and seed.\n$2 means that, the API time cost is not related to the number of \"ACE\" but is hyperbolically increasing when resourceCount is increasing. Under the assumption in (1), the actual complexity would be (r * r * p * 0.01)\nAs a result, we should get an insight into how long does the worst case takes, as t.  Then we can estimate some reasonable values of p and then estimate the API cost by t * p.\nSo I was directly testing the worst case, where p = 1, which means 100% of the \"allow resource\" will have a dominant \"deny resource. The complexity hence would be (r^2). It's rare that a cluster can have 200k \"allow resources\" and 200k corresponding \"dominant deny resources\" for each user, and it's not fair to have a relatively smaller aclCount and huger resourceCount, as the API is optimizing the performance by indexing on ACE.", "author": "ctan888", "createdAt": "2020-12-01T22:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDk3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ3NzYzMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534477631", "bodyText": "I just realized that, in order to check the dominant denies, my AclAuthorizer implementation is calling String::startWith which also has an O(d) complexity where d is the length of the \"deny pattern\" string of the given ACL. So the complexity would be O(n * m * d).\nSo given all \"allow pattern\" and \"deny pattern\" of a given ACE, we have 2 algorithms now\n\nIterate through all the prefixes of the allow pattern string and check if any prefix is contained in the set of deny pattern, which has a complexity of O(n * a), where a is the length of the \"allow pattern\" string. My interface default is using this approach.\nIterate through all the \"deny patterns\", which has a complexity of O(n * m * d), where d is the length of the deny pattern string. My AclAuthorizer is using this approach.\n\nComparasion: Since the average of the allow pattern string length should be close to that of the deny pattern, we can say a = d. So O(n * a) = O(n * d) > O(n * m * d), which means approach 1 is much better.\nConclusion: I'll change AclAuthorizer to use approach 1.", "author": "ctan888", "createdAt": "2020-12-02T20:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMjM0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533722349", "bodyText": "spelling: principal", "author": "rajinisivaram", "createdAt": "2020-12-01T21:08:29Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -115,45 +122,62 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n \n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n-            for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+            for (int aclId = 0; aclId < aclCount / 2; aclId++) {\n+                String acePrinciple = principal.toString() + (aclId == 0 ? \"\" : aclId);\n+                AccessControlEntry allowAce = new AccessControlEntry(\n+                    acePrinciple,", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMjUyNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533922526", "bodyText": "commit 6ab95d3", "author": "ctan888", "createdAt": "2020-12-02T06:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMjM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMzgzNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533723836", "bodyText": "We probably want to retain the old benchmark as-is and add a different one for authorizeByResourceType. We were testing a common pattern before, but now we seem to be testing a very unlikely scenario. While this may be useful for testing authorizeByResourceType, it is not what we want for regression testing the authorizer.", "author": "rajinisivaram", "createdAt": "2020-12-01T21:11:24Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -115,45 +122,62 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n \n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n-            for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+            for (int aclId = 0; aclId < aclCount / 2; aclId++) {\n+                String acePrinciple = principal.toString() + (aclId == 0 ? \"\" : aclId);\n+                AccessControlEntry allowAce = new AccessControlEntry(\n+                    acePrinciple,\n+                    \"*\", AclOperation.WRITE, AclPermissionType.ALLOW);\n+                AccessControlEntry denyAce = new AccessControlEntry(\n+                    acePrinciple,\n+                    \"*\", AclOperation.WRITE, AclPermissionType.DENY);", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc2MzgxNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534763817", "bodyText": "I think adding some dominant denies won't change the performance pattern of AclAuthorizer::acls and AclAuthorizer::authorize.\n\nAclAuthorizer::acls just return all the matching acls by the filter rule.  The portion btw \"allow\" and \"deny\" resources doesn't matter.\nAclAuthorizer::authorize will iterate the and filter out the allow and deny ACEs respectively. Since it's using ResourcePattern as its indexing method, the portion btw \"allow\" and \"deny\" resources doesn't matter as well.", "author": "ctan888", "createdAt": "2020-12-03T06:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNDM3OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533724379", "bodyText": "spelling: principal (multiple places)", "author": "rajinisivaram", "createdAt": "2020-12-01T21:12:21Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  @inline\n+  private def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)\n+      && operationMatched(op, binding))\n+  }\n+\n+  @inline\n+  private def hostMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().host().equals(requestContext.clientAddress().getHostAddress)\n+      || binding.entry().host().equals(AclEntry.WildcardHost))\n+\n+  @inline\n+  private def principleMatched(requestContext: AuthorizableRequestContext,", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMjU4MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533922580", "bodyText": "commit 6ab95d3", "author": "ctan888", "createdAt": "2020-12-02T06:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNDM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNzA4MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533727081", "bodyText": "Can we move testing of interfaceDefaultAuthorizer.authorizer into another class? This is AclAuthorizerTest and testing of interfaceDefaultAuthorizer seems unrelated to this test.", "author": "rajinisivaram", "createdAt": "2020-12-01T21:17:34Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -82,16 +86,17 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   override def setUp(): Unit = {\n     super.setUp()\n \n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2, interfaceDefaultAuthorizer.authorizer)", "originalCommit": "f9979f3681e1c6374cb693b17f8440d874169ef5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4MzYxNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r534983615", "bodyText": "Move the interface default test to a new class. Also, created a util class for code sharing.\ncommit 6c550fd", "author": "ctan888", "createdAt": "2020-12-03T09:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNzA4MQ=="}], "type": "inlineReview"}, {"oid": "1a139ce744a279e4424188008ee5158186b0fcbe", "url": "https://github.com/apache/kafka/commit/1a139ce744a279e4424188008ee5158186b0fcbe", "message": "Use EnumMap for looping in interface default", "committedDate": "2020-12-02T05:56:34Z", "type": "commit"}, {"oid": "29ac8628089ddf1210072bbf52e01a41e123a718", "url": "https://github.com/apache/kafka/commit/29ac8628089ddf1210072bbf52e01a41e123a718", "message": "interface default NIT", "committedDate": "2020-12-02T06:02:58Z", "type": "commit"}, {"oid": "f6d2a39706998160ebe77a854b8bf64268eec68a", "url": "https://github.com/apache/kafka/commit/f6d2a39706998160ebe77a854b8bf64268eec68a", "message": "move checkArgs to SecurityUtils", "committedDate": "2020-12-02T06:09:40Z", "type": "commit"}, {"oid": "f6d2a39706998160ebe77a854b8bf64268eec68a", "url": "https://github.com/apache/kafka/commit/f6d2a39706998160ebe77a854b8bf64268eec68a", "message": "move checkArgs to SecurityUtils", "committedDate": "2020-12-02T06:09:40Z", "type": "forcePushed"}, {"oid": "6ab95d3668b3de27a7f6f58fc171a1e2e8925f69", "url": "https://github.com/apache/kafka/commit/6ab95d3668b3de27a7f6f58fc171a1e2e8925f69", "message": "Change typo principle to principal", "committedDate": "2020-12-02T06:19:20Z", "type": "commit"}, {"oid": "cebbbd47a8e7d318e327e3a279072c718b535abd", "url": "https://github.com/apache/kafka/commit/cebbbd47a8e7d318e327e3a279072c718b535abd", "message": "preserve the audit log format", "committedDate": "2020-12-02T20:04:41Z", "type": "commit"}, {"oid": "18c5c04ad4d8c98dc3cdaa6d15bf70b9991a6b88", "url": "https://github.com/apache/kafka/commit/18c5c04ad4d8c98dc3cdaa6d15bf70b9991a6b88", "message": "return directly if denyAll in AuthorizerWrapper", "committedDate": "2020-12-03T01:05:31Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "30899c45ac50b70625baa2e5f12f58cfe9d79404", "url": "https://github.com/apache/kafka/commit/30899c45ac50b70625baa2e5f12f58cfe9d79404", "message": "Optimize the AuthorizerWrapper", "committedDate": "2020-12-03T03:17:50Z", "type": "commit"}, {"oid": "30899c45ac50b70625baa2e5f12f58cfe9d79404", "url": "https://github.com/apache/kafka/commit/30899c45ac50b70625baa2e5f12f58cfe9d79404", "message": "Optimize the AuthorizerWrapper", "committedDate": "2020-12-03T03:17:50Z", "type": "forcePushed"}, {"oid": "6c550fd04a0c1912e669bf18d60dee27dd03e53c", "url": "https://github.com/apache/kafka/commit/6c550fd04a0c1912e669bf18d60dee27dd03e53c", "message": "seperate the interfac default tests", "committedDate": "2020-12-03T09:11:14Z", "type": "commit"}, {"oid": "dcdc415dce0bfe98754a887d635e4e4681df2c71", "url": "https://github.com/apache/kafka/commit/dcdc415dce0bfe98754a887d635e4e4681df2c71", "message": "Add resourceIndex to further optimize the perf", "committedDate": "2020-12-04T03:24:29Z", "type": "commit"}, {"oid": "dcdc415dce0bfe98754a887d635e4e4681df2c71", "url": "https://github.com/apache/kafka/commit/dcdc415dce0bfe98754a887d635e4e4681df2c71", "message": "Add resourceIndex to further optimize the perf", "committedDate": "2020-12-04T03:24:29Z", "type": "forcePushed"}, {"oid": "7af4a7ff7ed2dddc06cf11ab7ff2d4b9fee5fb56", "url": "https://github.com/apache/kafka/commit/7af4a7ff7ed2dddc06cf11ab7ff2d4b9fee5fb56", "message": "add description in interface default, and rename the MockAuthorizer to DelegateAuthorizer", "committedDate": "2020-12-04T18:46:31Z", "type": "commit"}, {"oid": "331cd13887dd1238211c48c13ccc734d0a05483b", "url": "https://github.com/apache/kafka/commit/331cd13887dd1238211c48c13ccc734d0a05483b", "message": "fix checkstyle", "committedDate": "2020-12-04T19:17:53Z", "type": "commit"}, {"oid": "957f3b212f8471ef208490d7ed9e996f5b94eed5", "url": "https://github.com/apache/kafka/commit/957f3b212f8471ef208490d7ed9e996f5b94eed5", "message": "add benchmark for updateCache", "committedDate": "2020-12-04T23:29:15Z", "type": "forcePushed"}, {"oid": "5c79a1a075ec008a640f71513adf29eddfd46f12", "url": "https://github.com/apache/kafka/commit/5c79a1a075ec008a640f71513adf29eddfd46f12", "message": "add benchmark for updateCache", "committedDate": "2020-12-07T16:27:09Z", "type": "commit"}, {"oid": "5c79a1a075ec008a640f71513adf29eddfd46f12", "url": "https://github.com/apache/kafka/commit/5c79a1a075ec008a640f71513adf29eddfd46f12", "message": "add benchmark for updateCache", "committedDate": "2020-12-07T16:27:09Z", "type": "forcePushed"}, {"oid": "031c2f41e6611df3d18ef9b709c7d98c91b93326", "url": "https://github.com/apache/kafka/commit/031c2f41e6611df3d18ef9b709c7d98c91b93326", "message": "fix Api issue", "committedDate": "2020-12-07T16:45:43Z", "type": "commit"}, {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "url": "https://github.com/apache/kafka/commit/a591ef42912d5ce59eb18ec45ed8b95901b72a88", "message": "add deny percentage to jmh-benchmark", "committedDate": "2020-12-08T09:39:19Z", "type": "commit"}, {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "url": "https://github.com/apache/kafka/commit/a591ef42912d5ce59eb18ec45ed8b95901b72a88", "message": "add deny percentage to jmh-benchmark", "committedDate": "2020-12-08T09:39:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyMjE3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538522173", "bodyText": "nit, unnecessary whitespace in i++.", "author": "lbradstreet", "createdAt": "2020-12-08T15:49:08Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {\n+        AclAuthorizer aclAuthorizer = new AclAuthorizer();\n+        scala.collection.mutable.Set<AclEntry> entries = new scala.collection.mutable.HashSet<>();\n+        for (int i = 0; i < resourceCount; i ++){", "originalCommit": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODU1NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538768554", "bodyText": "Thanks. Fixed.", "author": "ctan888", "createdAt": "2020-12-08T20:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyMjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538524117", "bodyText": "I think it's useful to understand how the cache performs at smaller sizes as well as larger sizes. Is there a reason we went with a fixed size and fixed number of resources now?", "author": "lbradstreet", "createdAt": "2020-12-08T15:50:45Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})", "originalCommit": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxMzc2OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538613769", "bodyText": "Oh, I'm just demonstrating the chart 3 I uploaded. I'll change them back.", "author": "ctan888", "createdAt": "2020-12-08T17:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjQyNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539632426", "bodyText": "looks like this hasn't been reverted?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNjY0OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r541206648", "bodyText": "Yes", "author": "ctan888", "createdAt": "2020-12-11T19:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538528015", "bodyText": "It might be better for the purpose of this microbenchmark to setup the cache with the desired size ahead of the time and then measure the time to update the cache with one entry. Otherwise you risk measuring a lot of the setup costs rather than the cost of the typical usage.", "author": "lbradstreet", "createdAt": "2020-12-08T15:54:15Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {\n+        AclAuthorizer aclAuthorizer = new AclAuthorizer();\n+        scala.collection.mutable.Set<AclEntry> entries = new scala.collection.mutable.HashSet<>();\n+        for (int i = 0; i < resourceCount; i ++){\n+            scala.collection.immutable.Set<AclEntry> immutable = new scala.collection.immutable.HashSet<>();\n+            for (int j = 0; j < aclCount; j++) {\n+                entries.add(new AclEntry(new AccessControlEntry(\n+                    principal.toString(), \"127.0.0\" + j, AclOperation.WRITE, AclPermissionType.ALLOW)));\n+                immutable = entries.toSet();\n+            }\n+            aclAuthorizer.updateCache(", "originalCommit": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxODE0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538618149", "bodyText": "@rajinisivaram Do you think we'll keep this testUpdateCache and merge it into trunk? If so, let's setup the cache ahead of time. But I think this benchmark is mainly for comparing the trunk with my branch, which means that we probably won't merge this testUpdateCache into master, which also means the same procedure constructing some memory records are acceptable since we are taking the time cost difference.", "author": "ctan888", "createdAt": "2020-12-08T17:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzODg3Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539638872", "bodyText": "It makes sense to merge the benchmarks to trunk. Let's make sure it measures just updateCache.", "author": "rajinisivaram", "createdAt": "2020-12-09T20:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNzI4Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539737287", "bodyText": "Sure", "author": "ctan888", "createdAt": "2020-12-09T23:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1Mzg1MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538553851", "bodyText": "If you take an async profile of this benchmark method you end up spending most of the time in building the entries and immutable set, and barely any time on AclAuthorizer#updateCache.", "author": "lbradstreet", "createdAt": "2020-12-08T16:16:33Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {", "originalCommit": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxODgxNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538618817", "bodyText": "Yeah. Agree. Let's see what @rajinisivaram think about the above discussion", "author": "ctan888", "createdAt": "2020-12-08T17:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1Mzg1MQ=="}], "type": "inlineReview"}, {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "url": "https://github.com/apache/kafka/commit/40c0cad01590e137eac4ad1bb859f3d97b62a245", "message": "checkstyle & NIT", "committedDate": "2020-12-08T20:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539594382", "bodyText": "This package is part of the public API, but the class looks like it should be internal?", "author": "rajinisivaram", "createdAt": "2020-12-09T19:42:17Z", "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDg4NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539730884", "bodyText": "Shall we make the class constructor package-private or make this class an inner class of AclAuthorizer?", "author": "ctan888", "createdAt": "2020-12-09T23:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MDUxMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542790510", "bodyText": "We have to move the class outside of the public package, so putting it alongside AclAuthorizer makes sense.", "author": "rajinisivaram", "createdAt": "2020-12-14T21:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxNDU2Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543814563", "bodyText": "Make ResourceTypeKey an inner class of AclAuthorizer\ncommit 7fe92c6", "author": "ctan888", "createdAt": "2020-12-16T01:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539595584", "bodyText": "Perhaps ResourceAclEntry or something along those lines would be better than ResourceIndex since this class has no notion of index.", "author": "rajinisivaram", "createdAt": "2020-12-09T19:44:19Z", "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;\n+\n+import org.apache.kafka.common.resource.PatternType;\n+import org.apache.kafka.common.resource.ResourceType;\n+\n+import java.util.Objects;\n+\n+public class ResourceIndex {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDMxNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539734315", "bodyText": "I used index as it's used as the index of the hashmap. What about something like ResourceNameFilter?", "author": "ctan888", "createdAt": "2020-12-09T23:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwNjAwOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542906008", "bodyText": "For Map, you would say key rather than index. But this is not a resource or resourceName - it has no resource name, it is not a filter, but it includes AccessControlEntry. Maybe just ResourceTypeKey is sufficient, but you could also include something to indicate it includes the AccessControlEntry if you want. Either way, putting it along with AclAuthorizer would make naming less critical.", "author": "rajinisivaram", "createdAt": "2020-12-14T23:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxNDI5NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543814295", "bodyText": "ResourceTypeKey sounds good:\ncommit 7fe92c6", "author": "ctan888", "createdAt": "2020-12-16T01:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5OTQzMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539599430", "bodyText": "Can we remove the TODO comments?", "author": "rajinisivaram", "createdAt": "2020-12-09T19:50:25Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDk4Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539734983", "bodyText": "Yeah. Removed.", "author": "ctan888", "createdAt": "2020-12-09T23:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5OTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMjgwOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539602809", "bodyText": "In the typical case, we have a large number of allowLiterals and allowPrefixes, no denyLiterals or denPrefixes. I think it would make sense to special case denyLiterals.isEmpty && denyPrefixes.isEmpty. In this case, we don't need to find all matching resources, we just need to check that there is at least one matching resource.", "author": "rajinisivaram", "createdAt": "2020-12-09T19:55:39Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTI1OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539751258", "bodyText": "Yes. commit 1dc143f\nif (noDeny) {\n..if (hasAllow) {\n....return Authorize.ALLOWED\n..} else {\n....return Authorize.DENIED // since no allow exists\n..}\n}", "author": "ctan888", "createdAt": "2020-12-10T00:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDM2MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539604360", "bodyText": "Why can't this be a Set instead of List of Sets?", "author": "rajinisivaram", "createdAt": "2020-12-09T19:58:05Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4MjA5Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539782093", "bodyText": "Because we don't wanna reconstruct a new large set containing all the matching resources. We are constructing a List of  ~ 3 * 3 * 3 elements which refer to existing HashSets maintained by updateCache.", "author": "ctan888", "createdAt": "2020-12-10T01:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2MDk2OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542860969", "bodyText": "ok, makes sense", "author": "rajinisivaram", "createdAt": "2020-12-14T22:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDg0NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539604845", "bodyText": "AclEntry.WildcardPrincipalString", "author": "rajinisivaram", "createdAt": "2020-12-09T19:58:51Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNzExMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539737110", "bodyText": "commit 2fd4bab", "author": "ctan888", "createdAt": "2020-12-09T23:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzIyMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539607223", "bodyText": "This method can be in SecurityUtils and shared with the default authorizer?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:02:33Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          val resourceIndex = new ResourceIndex(ace, resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def denyAll(denyLiterals: List[mutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[mutable.Set[String]], allowPrefixes: List[mutable.Set[String]],\n+                       denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String,\n+                           denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    literalName match{\n+      case ResourcePattern.WILDCARD_RESOURCE => true\n+      case _ => (denyLiterals.forall(denyLiterals => !denyLiterals.contains(literalName))\n+                    && !hasDominantPrefixedDeny(literalName, denyPrefixes))\n+    }\n+  }\n+\n+  private def allowPrefix(prefixName: String,\n+                          denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    !hasDominantPrefixedDeny(prefixName, denyPrefixes)\n+  }\n+\n+  private def hasDominantPrefixedDeny(resourceName: String, denyPrefixes: List[mutable.Set[String]]): Boolean = {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4NzU0Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539787542", "bodyText": "I was trying to share it but it seems like the different collection type btw java and scala is a headache. We'll then need some java converters or instantiate a java collection in the scala code. Do you think it deserves this?", "author": "ctan888", "createdAt": "2020-12-10T02:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2MTgzOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542861839", "bodyText": "ok, let's leave as is.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzU2Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539607563", "bodyText": "private def?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:03:07Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          val resourceIndex = new ResourceIndex(ace, resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def denyAll(denyLiterals: List[mutable.HashSet[String]]): Boolean =", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNjgyOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539736828", "bodyText": "Yes. commit 2fd4bab", "author": "ctan888", "createdAt": "2020-12-09T23:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMjUzNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539612536", "bodyText": "We cannot do this here. AuthorizerWrapper is used to wrap any custom authorizer using the old Authorizer API. AllowEveryoneIfNoAclIsFoundProp is a custom config of SimpleAclAuthorizer and AclAuthorizer, we cannot use that with any custom authorizer. We should find a way to support the config for SimpleAclAuthorizer that doesn't impact other custom authorizers.", "author": "rajinisivaram", "createdAt": "2020-12-09T20:11:00Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -71,15 +73,19 @@ object AuthorizerWrapper {\n   }\n \n   def convertToResource(resourcePattern: ResourcePattern): Resource = {\n-    Resource(ResourceType.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n+    Resource(ResourceTypeLegacy.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n   }\n }\n \n @deprecated(\"Use kafka.security.authorizer.AclAuthorizer\", \"Since 2.5\")\n class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.Authorizer) extends Authorizer {\n \n+  var shouldAllowEveryoneIfNoAclIsFound = false\n+\n   override def configure(configs: util.Map[String, _]): Unit = {\n     baseAuthorizer.configure(configs)\n+    shouldAllowEveryoneIfNoAclIsFound = configs.asScala.get(\n+      AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp).exists(_.toString.toBoolean)", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxODM4Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r540418386", "bodyText": "Given that we probably don't want to change the deprecated Authorizer interface, I can only think of one way to achieve this:\nBesides checking if the AllowEveryoneIfNoAclIsFoundProp exists and if it equals to true, I added another check to authorize on a hardcoded session, operation, and resource.\nSince configure() will be called immediately after the authorizer instantiation, it's guaranteed that no ACLs would exist when we do this check.\noverride def configure(configs: util.Map[String, ]): Unit = {\n..baseAuthorizer.configure(configs)\n....shouldAllowEveryoneIfNoAclIsFound = (configs.asScala.get(\n......AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp).exists(.toString.toBoolean)\n........&& baseAuthorizer.authorize(\n..........new Session(KafkaPrincipal.ANONYMOUS, InetAddress.getByName(\"1.2.3.4\")),\n............Read, new Resource(Topic, \"hi\", PatternType.LITERAL)))\n}\ncommit 2ed79a0", "author": "ctan888", "createdAt": "2020-12-10T18:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMjUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNDcxOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539614719", "bodyText": "Does this work with an ACL with wildcard host?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:14:37Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      principal.toString, requestContext.clientAddress().getHostAddress, op, AclPermissionType.DENY)", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1NTY1MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r540655651", "bodyText": "Good catch. commit 8263bd3\nSince it's a bit hard to test AllowAnyoneIfNoAclFound and many other logics in the integration test, I added a new test class AuthorizerWrapperTest.", "author": "ctan888", "createdAt": "2020-12-11T03:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNDczOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539614739", "bodyText": "Does this work with an ACL with wildcard host?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:14:38Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      principal.toString, requestContext.clientAddress().getHostAddress, op, AclPermissionType.DENY)", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNTE4OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539615189", "bodyText": "The main logic of this could potentially be moved to SecurityUtils since the default Authorizer implementation, AclAuthorizer and the wrapper all do this.", "author": "rajinisivaram", "createdAt": "2020-12-09T20:15:25Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1ODY5Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r540658692", "bodyText": "commit 8263bd3 changed the AuthorizerWrapper logic and optimized the performance a bit.\nNow AuthorizerWrapper#denyAllResource will\n\nonly use Authorizer#acls() to filter out the WildcardResource with the pattern type LITERAL.\ncheck if any of the filtered out bindings match the request principle and request host.\n\nSo it's behavior diverges more from the interface default now.", "author": "ctan888", "createdAt": "2020-12-11T03:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNTE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539630084", "bodyText": "Why do we need this in tearDown?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:37:40Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -100,8 +106,15 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n \n   @After\n   override def tearDown(): Unit = {\n-    aclAuthorizer.close()\n-    aclAuthorizer2.close()\n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2)\n+    authorizers.foreach(a => {\n+      a.acls(AclBindingFilter.ANY).forEach(bd => {\n+        removeAcls(aclAuthorizer, Set(bd.entry), bd.pattern())", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcwNTAyMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r540705023", "bodyText": "Otherwise \"deny all\" will remain in ZK during the whole test process since ZK won't be restarted or re-instantiated.", "author": "ctan888", "createdAt": "2020-12-11T05:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NDUxNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542884517", "bodyText": "ZK is reinstantiated for every test.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxMzQ4Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543813486", "bodyText": "Removed.", "author": "ctan888", "createdAt": "2020-12-16T01:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMTQyNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539631425", "bodyText": "a lot of these changes look unnecessary", "author": "rajinisivaram", "createdAt": "2020-12-09T20:40:04Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1117,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n     val bindings = aces.map { ace => new AclBinding(resourcePattern, ace) }\n     authorizer.createAcls(requestContext, bindings.toList.asJava).asScala\n       .map(_.toCompletableFuture.get)\n       .foreach { result => result.exception.ifPresent { e => throw e } }\n+    aclAdded += Tuple3(authorizer, aces, resourcePattern)\n   }\n \n-  private def removeAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Boolean = {\n+  private def removeAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Boolean = {", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcwNjExNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r540706117", "bodyText": "Since AuthorizerInterfaceDefaultTest, AclAuthorizerTest, and AuthorizerWrapperTest are sharing some test utils, we need to make this method signature abstract a bit, in order to make it usable by AuthorizerTestFactory.", "author": "ctan888", "createdAt": "2020-12-11T05:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMTQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTk3NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r541779975", "bodyText": "Reverted other test changes\ncommit 4f9b79a", "author": "ctan888", "createdAt": "2020-12-12T21:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjY1Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539632653", "bodyText": "revert?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:42:14Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})\n     private int resourceCount;\n     //no. of. rules per resource\n-    @Param({\"10\", \"50\"})\n+    @Param({\"50\"})", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNjA0OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r541206048", "bodyText": "Yes.", "author": "ctan888", "createdAt": "2020-12-11T19:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNDc4OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539634789", "bodyText": "why? This no longer reflects the comment above. Can we revert?", "author": "rajinisivaram", "createdAt": "2020-12-09T20:45:38Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})\n     private int resourceCount;\n     //no. of. rules per resource\n-    @Param({\"10\", \"50\"})\n+    @Param({\"50\"})\n     private int aclCount;\n \n+    @Param({\"0\", \"20\", \"50\", \"90\", \"99\", \"99.9\", \"99.99\", \"100\"})\n+    private double denyPercentage;\n+\n     private final int hostPreCount = 1000;\n     private final String resourceNamePrefix = \"foo-bar35_resource-\";\n+    private final String resourceName = resourceNamePrefix + 95;\n \n     private final AclAuthorizer aclAuthorizer = new AclAuthorizer();\n     private final KafkaPrincipal principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"test-user\");\n     private List<Action> actions = new ArrayList<>();\n     private RequestContext context;\n \n+    private TreeMap<ResourcePattern, VersionedAcls> aclCache = new TreeMap<>(new AclAuthorizer.ResourceOrdering());\n+    private scala.collection.mutable.HashMap<ResourceIndex, scala.collection.mutable.HashSet<String>> resourceCache =\n+        new scala.collection.mutable.HashMap<>();\n+    Random rand = new Random(System.currentTimeMillis());\n+    double eps = 1e-9;\n+\n     @Setup(Level.Trial)\n     public void setup() throws Exception {\n-        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"aclCache\").getName(),\n-            prepareAclCache());\n+        prepareAclCache();\n+        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"aclCache\").getName(), aclCache);\n+        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"resourceCache\").getName(), resourceCache);\n         // By adding `-95` to the resource name prefix, we cause the `TreeMap.from/to` call to return\n         // most map entries. In such cases, we rely on the filtering based on `String.startsWith`\n         // to return the matching ACLs. Using a more efficient data structure (e.g. a prefix\n         // tree) should improve performance significantly).\n         actions = Collections.singletonList(new Action(AclOperation.WRITE,\n-            new ResourcePattern(ResourceType.TOPIC, resourceNamePrefix + 95, PatternType.LITERAL),\n+            new ResourcePattern(ResourceType.TOPIC, resourceName, PatternType.LITERAL),", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMjU3Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r541202572", "bodyText": "Yeah. I was doing resourceName = resourceName + 95 to re-use this variable. We can revert it.", "author": "ctan888", "createdAt": "2020-12-11T19:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNDc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTQyNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539635426", "bodyText": "We should revert changes to existing benchmark because it hard to tell why these changes were made and what impact it has on the original benchmark.", "author": "rajinisivaram", "createdAt": "2020-12-09T20:46:42Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -105,49 +120,76 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n         field.set(obj, value);\n     }\n \n-    private TreeMap<ResourcePattern, VersionedAcls> prepareAclCache() {\n+    private void prepareAclCache() throws UnknownHostException {\n         Map<ResourcePattern, Set<AclEntry>> aclEntries = new HashMap<>();\n         for (int resourceId = 0; resourceId < resourceCount; resourceId++) {\n             ResourcePattern resource = new ResourcePattern(\n                 (resourceId % 10 == 0) ? ResourceType.GROUP : ResourceType.TOPIC,\n-                resourceNamePrefix + resourceId,\n+                resourceName(resourceNamePrefix),", "originalCommit": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMjE5MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r541212190", "bodyText": "The existing benchmark does not have any DENY resource in it. Adding some DENY bindings whose percentage is controlled by parameters will be an improvement to the existing benchmark and help us understand the performance better.\nI've reverted all changes other than adding some DENY bindings. Also, I moved those memory intense operations into the @setup phase so now the benchmark just measures updateCache(). Does the benchmark look good to you now?\ncommit 6536cea\n@rajinisivaram", "author": "ctan888", "createdAt": "2020-12-11T19:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAzOTMyMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542039322", "bodyText": "Benchmark result: https://paste.ubuntu.com/p/zvjZC4QkMM/\nPerformance pattern doesn't change, except testUpdateCache runs much faster now.", "author": "ctan888", "createdAt": "2020-12-14T00:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTQyNg=="}], "type": "inlineReview"}, {"oid": "2fd4babe2c27ee0723fa1cd720ca35d2bbefe57b", "url": "https://github.com/apache/kafka/commit/2fd4babe2c27ee0723fa1cd720ca35d2bbefe57b", "message": "NIT", "committedDate": "2020-12-09T23:52:34Z", "type": "commit"}, {"oid": "1dc143fc78a3b9927189751255346ef0b6cafd90", "url": "https://github.com/apache/kafka/commit/1dc143fc78a3b9927189751255346ef0b6cafd90", "message": "handle the special case where no deny resources exists, improve the performance", "committedDate": "2020-12-10T00:24:56Z", "type": "commit"}, {"oid": "1e139df0ba64cb86507d9ec742214054791a45fe", "url": "https://github.com/apache/kafka/commit/1e139df0ba64cb86507d9ec742214054791a45fe", "message": "improve the allowEveryoneIfNoAclFound checking logic", "committedDate": "2020-12-10T18:57:09Z", "type": "commit"}, {"oid": "1e139df0ba64cb86507d9ec742214054791a45fe", "url": "https://github.com/apache/kafka/commit/1e139df0ba64cb86507d9ec742214054791a45fe", "message": "improve the allowEveryoneIfNoAclFound checking logic", "committedDate": "2020-12-10T18:57:09Z", "type": "forcePushed"}, {"oid": "67b3163bbf6562bdad1ba054b813a454f9be2363", "url": "https://github.com/apache/kafka/commit/67b3163bbf6562bdad1ba054b813a454f9be2363", "message": "rename authorizeAny to authorizeByResourcetype in tests", "committedDate": "2020-12-10T21:20:49Z", "type": "commit"}, {"oid": "8263bd319f63d39808f90129db55427b98385dd4", "url": "https://github.com/apache/kafka/commit/8263bd319f63d39808f90129db55427b98385dd4", "message": "Fix the issue that the wildcard host and principle didn't work in AuthorizerWrapper", "committedDate": "2020-12-11T03:05:23Z", "type": "commit"}, {"oid": "8263bd319f63d39808f90129db55427b98385dd4", "url": "https://github.com/apache/kafka/commit/8263bd319f63d39808f90129db55427b98385dd4", "message": "Fix the issue that the wildcard host and principle didn't work in AuthorizerWrapper", "committedDate": "2020-12-11T03:05:23Z", "type": "forcePushed"}, {"oid": "b90763947d4d7d6a3f42e12a7a440a7a212a73de", "url": "https://github.com/apache/kafka/commit/b90763947d4d7d6a3f42e12a7a440a7a212a73de", "message": "Revert benchmark changes", "committedDate": "2020-12-11T19:51:51Z", "type": "forcePushed"}, {"oid": "dea46b04516382285dc42f088f3f896b7c10cc64", "url": "https://github.com/apache/kafka/commit/dea46b04516382285dc42f088f3f896b7c10cc64", "message": "Revert benchmark changes", "committedDate": "2020-12-12T06:29:25Z", "type": "forcePushed"}, {"oid": "6536cea788210860a764f3f0a6901244e8d974fe", "url": "https://github.com/apache/kafka/commit/6536cea788210860a764f3f0a6901244e8d974fe", "message": "Revert benchmark changes", "committedDate": "2020-12-12T20:01:42Z", "type": "commit"}, {"oid": "6536cea788210860a764f3f0a6901244e8d974fe", "url": "https://github.com/apache/kafka/commit/6536cea788210860a764f3f0a6901244e8d974fe", "message": "Revert benchmark changes", "committedDate": "2020-12-12T20:01:42Z", "type": "forcePushed"}, {"oid": "4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "url": "https://github.com/apache/kafka/commit/4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "message": "revert unnecessary test re-writes", "committedDate": "2020-12-12T21:01:46Z", "type": "commit"}, {"oid": "4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "url": "https://github.com/apache/kafka/commit/4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "message": "revert unnecessary test re-writes", "committedDate": "2020-12-12T21:01:46Z", "type": "forcePushed"}, {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "url": "https://github.com/apache/kafka/commit/dd48b22aff2802c191fd555fa894a5d1081f68ca", "message": "fix checkstyle", "committedDate": "2020-12-14T04:40:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzMDA5OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542830098", "bodyText": "Since this is the javadoc of a public API, we should move the details on how the default implementation works outside of the javadoc. We can move this list of comments inside the method.", "author": "rajinisivaram", "createdAt": "2020-12-14T21:47:04Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +151,126 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * 1. Filter out all the resource pattern corresponding to the requestContext, AclOperation,\n+     *    and ResourceType\n+     * 2. If wildcard deny exists, return deny directly\n+     * 3. For any literal allowed resource, if there's no dominant literal denied resource, and\n+     *    no dominant prefixed denied resource, return allow\n+     * 4. For any prefixed allowed resource, if there's no dominant denied resource, return allow\n+     * 5. For any other cases, return deny", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA4MDYxMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543080612", "bodyText": "Sure. commit 25e0bfc", "author": "ctan888", "createdAt": "2020-12-15T06:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzMDA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1MTU1MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542851551", "bodyText": "We don't currently have anything in the default implementation to support super.users right? Unlike allow.everyone.if.no.acl.found which is not particularly suitable for production use, super.users is a commonly used config that is likely to be in use in a lot of deployments. The simplest fix may be to authorize() with a hard-coded name and return ALLOWED if authorize() returns ALLOWED before any of the logic below is executed.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:07:06Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +151,126 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * 1. Filter out all the resource pattern corresponding to the requestContext, AclOperation,\n+     *    and ResourceType\n+     * 2. If wildcard deny exists, return deny directly\n+     * 3. For any literal allowed resource, if there's no dominant literal denied resource, and\n+     *    no dominant prefixed denied resource, return allow\n+     * 4. For any prefixed allowed resource, if there's no dominant denied resource, return allow\n+     * 5. For any other cases, return deny\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxNDY4MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543814681", "bodyText": "Good catch. This is super important.\ncommit dae1a78", "author": "ctan888", "createdAt": "2020-12-16T01:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1MTU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542854629", "bodyText": "This needs to be an immutable map or a ConcurrentHashMap since we read this without lock.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:09:57Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -130,6 +130,10 @@ class AclAuthorizer extends Authorizer with Logging {\n \n   @volatile\n   private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n+\n+  private val resourceCache = new scala.collection.mutable.HashMap[ResourceIndex,\n+    scala.collection.mutable.HashSet[String]]()", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDc3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543134773", "bodyText": "Would scala \"foreach\" throw any exception when READ operation races with WRITE in HashMap / HashSet? If not, I think we can tolerate some READ inconsistency as ZK is also broadcasting the ACL changes asynchronously to brokers.", "author": "ctan888", "createdAt": "2020-12-15T08:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3NDEzOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543174139", "bodyText": "I tested a bit, using 1 bg thread adding and removing elements to a mutable.HashSet while the main thread constantly iterating the HashSet using \"foreach\". The \"foreach\" call doesn't throw any exception. But I'm a bit unsure what would happen if the iteration hits a bucket where some elements are being added to or deleted from.\nLet me test what's the overhead using the immutable map. I'd prefer this approach as we're expecting much more READ than WRITE to the hashset.", "author": "ctan888", "createdAt": "2020-12-15T09:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgwNTg1OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543805858", "bodyText": "Use Immutable collections:\nBenchmark                                           (aclCount)  (denyPercentage)  (resourceCount)  Mode  Cnt     Score      Error  Units\nAclAuthorizerBenchmark.testAclsIterator                     50               100           200000  avgt    5  4132.824 \u00b1 2967.122  ms/op\nAclAuthorizerBenchmark.testAuthorizeByResourceType          50               100           200000  avgt    5    46.733 \u00b1    5.397  ms/op\nAclAuthorizerBenchmark.testAuthorizer                       50               100           200000  avgt    5     6.844 \u00b1    0.915  ms/op\nAclAuthorizerBenchmark.testUpdateCache                      50               100           200000  avgt    5  7219.696 \u00b1 4018.189  ms/op\nJMH benchmarks done\nUse Mutable collections:\nAclAuthorizerBenchmark.testUpdateCache                      50               100           200000  avgt    5  4927.832 \u00b1 2570.786  ms/op\nWhen aclCount = 50, denyPercentage = 100, resourceCount = 200000, the time cost is 2.3 seconds more with immutable collections. But since adding 50 * 20000 ACL bindings only takes ~7 seconds, I think the performance should be acceptable.", "author": "ctan888", "createdAt": "2020-12-16T01:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxNzk0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543817949", "bodyText": "commit 62c44ad", "author": "ctan888", "createdAt": "2020-12-16T01:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NTMxNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542855316", "bodyText": "We need to check if the principal is a super.user and return ALLOWED for super users before executing any of the logic below.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:10:36Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,131 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0NDA4Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543744087", "bodyText": "Good catch. This is super important.\ncommit dae1a78", "author": "ctan888", "createdAt": "2020-12-15T22:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MTU3OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542871579", "bodyText": "This is too hacky. And it breaks if ANONYMOUS has all access (e.g. because inter-broker listener alone uses PLAINTEXT). We could check baseAuthorizer.isInstanceOf[SimpleAclAuthorizer] perhaps. It is not perfect since it would break if there was a custom authorizer that extended SimpleAclAuthorizer, but doesn't support AllowEveryoneIfNoAclIsFoundProp and the prop was set to true. But that seems like an unlikely scenario.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:26:24Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -71,15 +74,22 @@ object AuthorizerWrapper {\n   }\n \n   def convertToResource(resourcePattern: ResourcePattern): Resource = {\n-    Resource(ResourceType.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n+    Resource(ResourceTypeLegacy.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n   }\n }\n \n @deprecated(\"Use kafka.security.authorizer.AclAuthorizer\", \"Since 2.5\")\n class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.Authorizer) extends Authorizer {\n \n+  var shouldAllowEveryoneIfNoAclIsFound = false\n+\n   override def configure(configs: util.Map[String, _]): Unit = {\n     baseAuthorizer.configure(configs)\n+    shouldAllowEveryoneIfNoAclIsFound = (configs.asScala.get(\n+        AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp).exists(_.toString.toBoolean)\n+      && baseAuthorizer.authorize(\n+        new Session(KafkaPrincipal.ANONYMOUS, InetAddress.getByName(\"1.2.3.4\")),\n+        Read, new Resource(Topic, \"hi\", PatternType.LITERAL)))", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MzM5Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543093393", "bodyText": "So we have three approaches here:\n\nuse .getClass\nuse .isInstanceOf\nonly configure the property with the key \"AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp\" in the AuthorizerWrapper instance construction so no other property will get in.\n\nNeither of them is perfect but approach 2 also seems better to me.\ncommit 1217394", "author": "ctan888", "createdAt": "2020-12-15T07:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTE0Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542879143", "bodyText": "This sequence doesn't work with super.users. We probably should do something like:\nif (super.authorizeByResourceType(requestContext, op, resourceType) == AuthorizationResult.ALLOWED)\n  AuthorizationResult.ALLOWED\nelse if (denyAllResource(requestContext, op, resourceType) || !shouldAllowEveryoneIfNoAclIsFound)\n  AuthorizationResult.DENIED\nelse\n  AuthorizationResult.ALLOWED", "author": "rajinisivaram", "createdAt": "2020-12-14T22:33:41Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +185,39 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0NDE4Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543744182", "bodyText": "Good catch. This is super important.\ncommit dae1a78", "author": "ctan888", "createdAt": "2020-12-15T22:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MTc3MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542881770", "bodyText": "We could have done principal.toString() once in the caller rather than convert everytime.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:36:27Z", "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +185,39 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                              op: AclOperation,\n+                              resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, Resource.WildCardResource, PatternType.LITERAL)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val host = requestContext.clientAddress().getHostAddress\n+    val accessControlEntry = new AccessControlEntryFilter(null, null, op, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    acls(aclFilter).asScala.exists(b => principalHostMatch(b.entry(), principal, host))\n+  }\n+\n+  private def principalHostMatch(ace: AccessControlEntry,\n+                                 principal: KafkaPrincipal,\n+                                 host: String): Boolean = {\n+    ((ace.host() == AclEntry.WildcardHost || ace.host() == host)\n+      && (ace.principal() == AclEntry.WildcardPrincipalString || ace.principal() == principal.toString))", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5OTkzNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543099934", "bodyText": "Yeah. I was trying to restrict the type in order to remind people to construct a KafkaPrinciple first. But toString() is an expensive operation.\ncommit 16576f8", "author": "ctan888", "createdAt": "2020-12-15T07:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NzQwOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542887409", "bodyText": "As in the other class, we don't need this in tearDown", "author": "rajinisivaram", "createdAt": "2020-12-14T22:41:58Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before, Test}\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+  private val superUsers = \"User:superuser1; User:superuser2\"\n+  private val username = \"alice\"\n+  private val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, username)\n+  private val requestContext = newRequestContext(principal, InetAddress.getByName(\"192.168.0.1\"))\n+  private var config: KafkaConfig = _\n+  private var zooKeeperClient: ZooKeeperClient = _\n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()\n+  private val authorizerTestFactory = new AuthorizerTestFactory(\n+    newRequestContext, addAcls, authorizeByResourceType, removeAcls)\n+\n+  class CustomPrincipal(principalType: String, name: String) extends KafkaPrincipal(principalType, name) {\n+    override def equals(o: scala.Any): Boolean = false\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AclAuthorizerTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(interfaceDefaultAuthorizer)\n+    authorizers.foreach(a => {\n+      a.acls(AclBindingFilter.ANY).forEach(bd => {\n+        removeAcls(interfaceDefaultAuthorizer, Set(bd.entry), bd.pattern())", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNzk1NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543117954", "bodyText": "commit 825a8ba", "author": "ctan888", "createdAt": "2020-12-15T07:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4ODYxNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542888614", "bodyText": "We should add tests for super users.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:43:13Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before, Test}\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+  private val superUsers = \"User:superuser1; User:superuser2\"", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0NTM1Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543745352", "bodyText": "Test added for AuthorizerInterfaceDefaultTest, AclAuthorizerTest, AuthorizerWrapperTest.\ncommit dae1a78", "author": "ctan888", "createdAt": "2020-12-15T22:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4ODYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MDQ2NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542890465", "bodyText": "why are we storing these?", "author": "rajinisivaram", "createdAt": "2020-12-14T22:45:10Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -74,6 +75,10 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   private var config: KafkaConfig = _\n   private var zooKeeperClient: ZooKeeperClient = _\n \n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNzg3NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543117875", "bodyText": "Removed as we are not removing ACLs in teadDown() anymore.\ncommit 825a8ba", "author": "ctan888", "createdAt": "2020-12-15T07:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MDQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5Mjk0Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542892942", "bodyText": "Why?", "author": "rajinisivaram", "createdAt": "2020-12-14T22:47:34Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNjA4NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543116084", "bodyText": "For this method, I changed the signature back to AclAuthorzier as the AuthorizerTestFactory is not depending on it.", "author": "ctan888", "createdAt": "2020-12-15T07:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5Mjk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNzkwOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543117908", "bodyText": "commit 825a8ba", "author": "ctan888", "createdAt": "2020-12-15T07:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5Mjk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzM5Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542893393", "bodyText": "why was this changed from AclAuthorizer to Authorizer?", "author": "rajinisivaram", "createdAt": "2020-12-14T22:48:00Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNDA5MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543114091", "bodyText": "I replied here. Maybe I shouldn't have resolved it. #9485 (comment)\nSince AuthorizerInterfaceDefaultTest, AclAuthorizerTest, and AuthorizerWrapperTest are sharing some test cases, we need to make this method signature abstract a bit, in order to pass the method reference to AuthorizerTestFactory.", "author": "ctan888", "createdAt": "2020-12-15T07:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzY2NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542893665", "bodyText": "why are we storing this?", "author": "rajinisivaram", "createdAt": "2020-12-14T22:48:15Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n     val bindings = aces.map { ace => new AclBinding(resourcePattern, ace) }\n     authorizer.createAcls(requestContext, bindings.toList.asJava).asScala\n       .map(_.toCompletableFuture.get)\n       .foreach { result => result.exception.ifPresent { e => throw e } }\n+    aclAdded += Tuple3(authorizer, aces, resourcePattern)", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExODYxNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543118616", "bodyText": "Removed as we are not removing ACLs in teadDown() anymore.\ncommit 825a8ba", "author": "ctan888", "createdAt": "2020-12-15T07:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwMDIxMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542900213", "bodyText": "It would be better to move this inside AuthorizerInterfaceDefaultTest since it is specific to that test.", "author": "rajinisivaram", "createdAt": "2020-12-14T22:54:40Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/DelegateAuthorizer.scala", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+/**\n+ * For testing the interface default\n+ */\n+class DelegateAuthorizer extends Authorizer {", "originalCommit": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyMDgwOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r543120808", "bodyText": "Make sense. commit e31f157", "author": "ctan888", "createdAt": "2020-12-15T07:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwMDIxMw=="}], "type": "inlineReview"}, {"oid": "25e0bfcc97f956ceb4254ab8c457fe5d8d250e82", "url": "https://github.com/apache/kafka/commit/25e0bfcc97f956ceb4254ab8c457fe5d8d250e82", "message": "move the step by step comments into the method", "committedDate": "2020-12-15T06:28:49Z", "type": "commit"}, {"oid": "1217394c0c3767ac11df958c02a681c8cbc8382b", "url": "https://github.com/apache/kafka/commit/1217394c0c3767ac11df958c02a681c8cbc8382b", "message": "change the no acl found logic in AuthorizerWrapper", "committedDate": "2020-12-15T06:59:47Z", "type": "commit"}, {"oid": "cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "url": "https://github.com/apache/kafka/commit/cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "message": "optimize principle.toString", "committedDate": "2020-12-15T07:18:44Z", "type": "commit"}, {"oid": "cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "url": "https://github.com/apache/kafka/commit/cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "message": "optimize principle.toString", "committedDate": "2020-12-15T07:18:44Z", "type": "forcePushed"}, {"oid": "825a8ba77ad1766f998a71a9a15f21e73daad84a", "url": "https://github.com/apache/kafka/commit/825a8ba77ad1766f998a71a9a15f21e73daad84a", "message": "remove the removeAcl related logic since ZK will re-instantiate before every test case", "committedDate": "2020-12-15T07:37:25Z", "type": "commit"}, {"oid": "184944c78ec1a0f3061dabba9b1c638a4f86d99a", "url": "https://github.com/apache/kafka/commit/184944c78ec1a0f3061dabba9b1c638a4f86d99a", "message": "rename the ZK client metricType name", "committedDate": "2020-12-15T07:43:49Z", "type": "commit"}, {"oid": "e31f157eaac1213445dd284fd2209a29f4fa18fd", "url": "https://github.com/apache/kafka/commit/e31f157eaac1213445dd284fd2209a29f4fa18fd", "message": "move the DelegateAuthorizer into AuthorizerInterfaceDefaultTest", "committedDate": "2020-12-15T07:53:26Z", "type": "commit"}, {"oid": "dae1a788b70ebc03eab265b1027a4b43ad8e773b", "url": "https://github.com/apache/kafka/commit/dae1a788b70ebc03eab265b1027a4b43ad8e773b", "message": "added super user case and tests", "committedDate": "2020-12-15T22:48:27Z", "type": "commit"}, {"oid": "7fe92c6436432760adf9465c3f0bcf3c91104b10", "url": "https://github.com/apache/kafka/commit/7fe92c6436432760adf9465c3f0bcf3c91104b10", "message": "Maket ResourceIndex an Inner class of AclAuthorizer, and decouple the jmh benchmark with it", "committedDate": "2020-12-16T01:40:44Z", "type": "commit"}, {"oid": "62c44ade550a90671ff41bfb847e2bc28adc7baa", "url": "https://github.com/apache/kafka/commit/62c44ade550a90671ff41bfb847e2bc28adc7baa", "message": "change the mutable map to volatile immutable map for thread safety", "committedDate": "2020-12-16T01:50:47Z", "type": "commit"}, {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "url": "https://github.com/apache/kafka/commit/b22ecd69c0001046d62e6236e768422cbf1df0a0", "message": "NIT", "committedDate": "2020-12-16T04:36:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzEyNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544223127", "bodyText": "Use op rather than READ since that fits with why we are allowing access. We also need a test that verifies that permission to READ everything doesn't imply authorizeByResourceType for WRITE.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:29:11Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,134 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                AclOperation.READ,", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NTkzOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544545938", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzYzMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544223630", "bodyText": "Use logIfAllowed=true since we are granting access in that case.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:29:58Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,134 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                AclOperation.READ,\n+                new ResourcePattern(resourceType, \"hardcode\", PatternType.LITERAL),\n+                0, false, false)))", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NTk0OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544545948", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyOTY3Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544229673", "bodyText": "Can we used named arguments for the booleans: authorized = false - we should update all usages of logAuditMessage below.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:40:14Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +310,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NTk3MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544545971", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyOTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzMjU1OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544232558", "bodyText": "We should make this a case class. We can then remove all the methods (equals, hashCode and toString) since we get those for free.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:44:53Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -582,4 +749,21 @@ class AclAuthorizer extends Authorizer with Logging {\n       processAclChangeNotification(resource)\n     }\n   }\n+\n+  private class ResourceTypeKey(val ace: AccessControlEntry,", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NjAwMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544546002", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzMjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544239742", "bodyText": "not a custom principal, just a principal.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:56:47Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NjEwMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544546101", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544239749", "bodyText": "not a custom principal, just a principal.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:56:48Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NjE3Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544546172", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0MDE1Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544240156", "bodyText": "All these tests are using READ which happens to work for the default implementation since we used READ there.", "author": "rajinisivaram", "createdAt": "2020-12-16T11:57:27Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",\n+      authorizeByResourceType(authorizer, superUserContext, READ, ResourceType.TOPIC))", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0Njk0Ng==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544546946", "bodyText": "Yeah. Since I've changed READ to op, this has been resolved.", "author": "ctan888", "createdAt": "2020-12-16T18:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0MDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NDgxMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544244813", "bodyText": "Can we check how much work it would be to convert authorizerTestFactory into an  abstract BaseAuthorizerTest class that the three xxxAuthorizerTest classes extend? Having to repeat these tests in all three places makes it too easy to miss one in the future.", "author": "rajinisivaram", "createdAt": "2020-12-16T12:05:14Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerWrapperTest.scala", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.auth.SimpleAclAuthorizer\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl.AclOperation._\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.PatternType.LITERAL\n+import org.apache.kafka.common.resource.ResourceType._\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.Assert._\n+import org.junit.{After, Before, Test}\n+\n+import scala.annotation.nowarn\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerWrapperTest extends ZooKeeperTestHarness {\n+  @nowarn(\"cat=deprecation\")\n+  private val wrappedSimpleAuthorizer = new AuthorizerWrapper(new SimpleAclAuthorizer)\n+  @nowarn(\"cat=deprecation\")\n+  private val wrappedSimpleAuthorizerAllowEveryone = new AuthorizerWrapper(new SimpleAclAuthorizer)\n+  private var resource: ResourcePattern = _\n+  private val superUsers = \"User:superuser1; User:superuser2\"\n+  private val username = \"alice\"\n+  private val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, username)\n+  private val requestContext = newRequestContext(principal, InetAddress.getByName(\"192.168.0.1\"))\n+  private var config: KafkaConfig = _\n+  private var zooKeeperClient: ZooKeeperClient = _\n+\n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()\n+  private val authorizerTestFactory = new AuthorizerTestFactory(\n+    newRequestContext, addAcls, authorizeByResourceType, removeAcls)\n+\n+  class CustomPrincipal(principalType: String, name: String) extends KafkaPrincipal(principalType, name) {\n+    override def equals(o: scala.Any): Boolean = false\n+  }\n+\n+  @Before\n+  @nowarn(\"cat=deprecation\")\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+    config = KafkaConfig.fromProps(props)\n+    wrappedSimpleAuthorizer.configure(config.originals)\n+\n+    props.put(SimpleAclAuthorizer.AllowEveryoneIfNoAclIsFoundProp, \"true\")\n+    config = KafkaConfig.fromProps(props)\n+    wrappedSimpleAuthorizerAllowEveryone.configure(config.originals)\n+\n+    resource = new ResourcePattern(TOPIC, \"foo-\" + UUID.randomUUID(), LITERAL)\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AuthorizerWrapperTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(wrappedSimpleAuthorizer, wrappedSimpleAuthorizerAllowEveryone)\n+    authorizers.foreach(a => {\n+      a.close()\n+    })\n+    zooKeeperClient.close()\n+    super.tearDown()\n+  }\n+\n+  @Test\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(): Unit = {\n+    authorizerTestFactory.testAuthorizeByResourceTypeMultipleAddAndRemove(wrappedSimpleAuthorizer)\n+  }", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzY3MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544713670", "bodyText": "commit 092fec7\ncommit e5e3d18\nThese two commits are condensing the class methods and members into the BaseAuthorizerTest.\nIn BaseAuthorizerTest, the only abstract method is an authorizer provider. After overriding the provider, those test cases in it are sufficient to run.\nNow the test code looks much cleaner. If the changes look too much to you, we can revert 092fec7 and move the head to e5e3d18", "author": "ctan888", "createdAt": "2020-12-17T00:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NDgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NjI1Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544246252", "bodyText": "nit: principle => principal", "author": "rajinisivaram", "createdAt": "2020-12-16T12:07:37Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -116,38 +122,88 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n             for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+                // The principle in the request context we are using", "originalCommit": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0NzA4MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544547081", "bodyText": "commit ec80dc4", "author": "ctan888", "createdAt": "2020-12-16T18:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NjI1Mg=="}], "type": "inlineReview"}, {"oid": "ec80dc4e55758d83835f3ecde381a988d6dd4779", "url": "https://github.com/apache/kafka/commit/ec80dc4e55758d83835f3ecde381a988d6dd4779", "message": "NIT", "committedDate": "2020-12-16T18:57:33Z", "type": "commit"}, {"oid": "e5e3d18f57ab22df20133f9841905af384d9b641", "url": "https://github.com/apache/kafka/commit/e5e3d18f57ab22df20133f9841905af384d9b641", "message": "Make a base authorizer class for code sharing", "committedDate": "2020-12-16T23:18:46Z", "type": "commit"}, {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275", "url": "https://github.com/apache/kafka/commit/092fec70a9547ec07cba999e77be1c0cf79fa275", "message": "condense methods and class members for sharing", "committedDate": "2020-12-16T23:54:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NjQyOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545246428", "bodyText": "resourceIndex => resourceTypeKey and omit new.", "author": "rajinisivaram", "createdAt": "2020-12-17T16:56:46Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyOTEzMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545529131", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T02:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NjQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NzM5Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545247397", "bodyText": "Couldn't we just check:resourceCache.contains(resourceKey) ?", "author": "rajinisivaram", "createdAt": "2020-12-17T16:58:03Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyOTQzNg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545529436", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T02:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NzM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTEyOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545261128", "bodyText": "resourceIndex => resourceTypeKey, Also we can omit new for ResourceTypeKey since it is a case class.", "author": "rajinisivaram", "createdAt": "2020-12-17T17:17:49Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyOTUzNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545529534", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T02:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDc5NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545264795", "bodyText": "private def", "author": "rajinisivaram", "createdAt": "2020-12-17T17:23:02Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUzMTA0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545531049", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T02:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDg5OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545264898", "bodyText": "private def", "author": "rajinisivaram", "createdAt": "2020-12-17T17:23:10Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUzMTA3OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545531079", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T02:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NzczNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545267737", "bodyText": "We can use map instead of match:\naclCache.get(resource).map(_.acls.map(_.ace)).getOrElse(Set.empty)", "author": "rajinisivaram", "createdAt": "2020-12-17T17:27:13Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NjE2Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545576162", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NzczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDIyMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545270222", "bodyText": "resourceIndex => resourceTypeKey, Omit new", "author": "rajinisivaram", "createdAt": "2020-12-17T17:30:45Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty\n+    }\n+    val newAces: Set[AccessControlEntry] = versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+    val acesToAdd = newAces.diff(currentAces)\n+    val acesToRemove = currentAces.diff(newAces)\n+\n+    acesToAdd.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NjM5NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545576394", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDI5Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545270292", "bodyText": "resourceIndex => resourceTypeKey, Omit new", "author": "rajinisivaram", "createdAt": "2020-12-17T17:30:53Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty\n+    }\n+    val newAces: Set[AccessControlEntry] = versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+    val acesToAdd = newAces.diff(currentAces)\n+    val acesToRemove = currentAces.diff(newAces)\n+\n+    acesToAdd.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())\n+      resourceCache.get(resourceIndex) match {\n+        case Some(resources) => resourceCache += (resourceIndex -> (resources + resource.name()))\n+        case None => resourceCache += (resourceIndex -> immutable.HashSet(resource.name()))\n+      }\n+    })\n+    acesToRemove.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NjU3OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545576579", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MzU2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545273561", "bodyText": "canDenyAll => denyAll since can doesn't fit with deny", "author": "rajinisivaram", "createdAt": "2020-12-17T17:35:05Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/SecurityUtils.java", "diffHunk": "@@ -146,4 +148,32 @@ else if (capitalizeNext) {\n         }\n         return builder.toString();\n     }\n+\n+    public static void authorizeByResourceTypeCheckArgs(AclOperation op,\n+                                                        ResourceType type) {\n+        if (type == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (type == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+    }\n+\n+    public static boolean canDenyAll(ResourcePattern pattern) {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NjcwMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545576700", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MDY1NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545280654", "bodyText": "Suggestions to improve this (feel free to ignore/update):\nCustom authorizer implementations should consider overriding this default implementation because:\n1) The default implementation iterates all AclBindings multiple times, without any caching for resource types. More efficient implementations may be added in custom authorizers that directly access cached entries.\n2) The default implementation cannot integrate with any audit logging included in the authorizer implementation.\n3) The default implementation does not support any custom authorizer configs or other access rules apart from ACLs.", "author": "rajinisivaram", "createdAt": "2020-12-17T17:45:19Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NjgwOA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545576808", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MDY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MjM3NA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545282374", "bodyText": "Add a comment to say that we check for one hard-coded name to ensure that super users are granted access regardless of DENY acls.", "author": "rajinisivaram", "createdAt": "2020-12-17T17:47:45Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3Nzc3Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545577772", "bodyText": "// Check a hard-coded name to ensure that super users are granted\n    // access regardless of DENY ACLs.", "author": "ctan888", "createdAt": "2020-12-18T05:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MjM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NzgzMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545577832", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4NzQxOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545287419", "bodyText": "Can we make this comment two lines instead of 4 since each sentence seems short enough to fit into a line?", "author": "rajinisivaram", "createdAt": "2020-12-17T17:55:22Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                op, new ResourcePattern(resourceType, \"hardcode\", PatternType.LITERAL),\n+                0, true, false)))\n+                .get(0) == AuthorizationResult.ALLOWED) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        // Filter out all the resource pattern corresponding to the RequestContext,\n+        // AclOperation, and ResourceType\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        EnumMap<PatternType, Set<String>> denyPatterns =\n+            new EnumMap<PatternType, Set<String>>(PatternType.class) {{\n+                put(PatternType.LITERAL, new HashSet<>());\n+                put(PatternType.PREFIXED, new HashSet<>());\n+            }};\n+        EnumMap<PatternType, Set<String>> allowPatterns =\n+            new EnumMap<PatternType, Set<String>>(PatternType.class) {{\n+                put(PatternType.LITERAL, new HashSet<>());\n+                put(PatternType.PREFIXED, new HashSet<>());\n+            }};\n+\n+        boolean hasWildCardAllow = false;\n+\n+        KafkaPrincipal principal = new KafkaPrincipal(\n+            requestContext.principal().getPrincipalType(),\n+            requestContext.principal().getName());\n+        String hostAddr = requestContext.clientAddress().getHostAddress();\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(hostAddr) && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!SecurityUtils.parseKafkaPrincipal(binding.entry().principal()).equals(principal)\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        // If wildcard deny exists, return deny directly\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                        denyPatterns.get(PatternType.LITERAL).add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        denyPatterns.get(PatternType.PREFIXED).add(binding.pattern().name());\n+                        break;\n+                    default:\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allowPatterns.get(PatternType.LITERAL).add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allowPatterns.get(PatternType.PREFIXED).add(binding.pattern().name());\n+                    break;\n+                default:\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        // For any literal allowed, if there's no dominant literal\n+        // and prefix denied, return allow.\n+        // For any prefix allowed, if there's no dominant prefix\n+        // denied, return allow.", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3Nzg2NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545577865", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4NzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMyNTkwOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545325909", "bodyText": "PatternType.UNKNOWN looks odd in audit logs, ANY may be better.", "author": "rajinisivaram", "createdAt": "2020-12-17T18:53:16Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3MTc0OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545471749", "bodyText": "public ResourcePattern(ResourceType resourceType, String name, PatternType patternType) {\n        this.resourceType = Objects.requireNonNull(resourceType, \"resourceType\");\n        this.name = Objects.requireNonNull(name, \"name\");\n        this.patternType = Objects.requireNonNull(patternType, \"patternType\");\n\n        if (resourceType == ResourceType.ANY) {\n            throw new IllegalArgumentException(\"resourceType must not be ANY\");\n        }\n\n        if (patternType == PatternType.MATCH || patternType == PatternType.ANY) {\n            throw new IllegalArgumentException(\"patternType must not be \" + patternType);\n        }\n    }\n\nI think the ResourcePattern constructor is preventing us passing PatternType.ANY. It's only usable with Filter.", "author": "ctan888", "createdAt": "2020-12-17T23:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMyNTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MzkzMw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545363933", "bodyText": "The nested for loop can be replaced with:\nfor (p <- Set(principal, AclEntry.WildcardPrincipalString); h <- Set(host, AclEntry.WildcardHost); o <- Set(op, AclOperation.ALL))", "author": "rajinisivaram", "createdAt": "2020-12-17T19:55:50Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3Nzk1Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545577952", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NTg1NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545365855", "bodyText": "We can make this a val by using an ArrayBuffer instead of List that we keep recreating", "author": "rajinisivaram", "createdAt": "2020-12-17T19:58:45Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3ODA3MA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545578070", "bodyText": "Right, though it's only a list of 8.\ncommit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NjEwMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545366101", "bodyText": "As before, we can use a single for loop instead of nested loop", "author": "rajinisivaram", "createdAt": "2020-12-17T19:59:08Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3ODU1OQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545578559", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NjEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NzQ5Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545367497", "bodyText": "Can use denyLiterals.exists(_.contains(ResourcePattern.WILDCARD_RESOURCE))", "author": "rajinisivaram", "createdAt": "2020-12-17T20:01:27Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3ODczNA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545578734", "bodyText": "Yes. Didn't realize the existence of this syntax be4. Thanks.\ncommit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NzQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODA0NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545368045", "bodyText": "Can use allowPrefixes.exists(_.exists, similarly for allowLiterals.", "author": "rajinisivaram", "createdAt": "2020-12-17T20:02:13Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3OTgzNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545579837", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODE5OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545368198", "bodyText": "nit: space before {", "author": "rajinisivaram", "createdAt": "2020-12-17T20:02:31Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String, denyLiterals: List[immutable.Set[String]],\n+                           denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    literalName match{", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4MTE3MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545581171", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2OTU3MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545369571", "bodyText": "Can be !denyLiterals.exists(_.contains(literalName))?", "author": "rajinisivaram", "createdAt": "2020-12-17T20:04:55Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String, denyLiterals: List[immutable.Set[String]],\n+                           denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    literalName match{\n+      case ResourcePattern.WILDCARD_RESOURCE => true\n+      case _ => (denyLiterals.forall(denyLiterals => !denyLiterals.contains(literalName))", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NDQ2OA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545584468", "bodyText": "Right. We can bring the ! to the front.\ncommit 9407b16", "author": "ctan888", "createdAt": "2020-12-18T05:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2OTU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTEwMQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545399101", "bodyText": "We should use the same pattern as the usage of aclCache where we get a aclCacheSnapshot at the start of the method and then use the same snapshot throughout the method rather than use a changing value of resourceCache within the loop.", "author": "rajinisivaram", "createdAt": "2020-12-17T20:57:59Z", "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyNTE2Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545525163", "bodyText": "Right. To prevent the phantom problem.", "author": "ctan888", "createdAt": "2020-12-18T02:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NDc4Mw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545584783", "bodyText": "commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMDMyMg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545410322", "bodyText": "Could just close interfaceDefaultAuthorizer instead of creating an authorizers collection?", "author": "rajinisivaram", "createdAt": "2020-12-17T21:19:25Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AuthorizerInterfaceDefaultTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(interfaceDefaultAuthorizer)\n+    authorizers.foreach(a => {\n+      a.close()\n+    })", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NDgyNQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545584825", "bodyText": "Yes. commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMDMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTM2MQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545411361", "bodyText": "The authorizer parameter is not used. Can't we just move this into the test method testAuthorizeByResourceTypeNoAclFoundOverride above?", "author": "rajinisivaram", "createdAt": "2020-12-17T21:21:34Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +980,30 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeByResourceTypeNoAclFoundOverride(): Unit = {\n+    testAuthorizeByResourceTypeNoAclFoundOverride(aclAuthorizer)\n+  }\n+\n+  private def testAuthorizeByResourceTypeNoAclFoundOverride(authorizer: Authorizer): Unit = {", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NDg3Mg==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545584872", "bodyText": "Yes. commit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTgyOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545411829", "bodyText": "can't this be aclAuthorizer?", "author": "rajinisivaram", "createdAt": "2020-12-17T21:22:24Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +980,30 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeByResourceTypeNoAclFoundOverride(): Unit = {\n+    testAuthorizeByResourceTypeNoAclFoundOverride(aclAuthorizer)\n+  }\n+\n+  private def testAuthorizeByResourceTypeNoAclFoundOverride(authorizer: Authorizer): Unit = {\n+    val props = TestUtils.createBrokerConfig(1, zkConnect)\n+    props.put(AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp, \"true\")\n+\n+    val cfg = KafkaConfig.fromProps(props)\n+    val testAuthorizer = new AclAuthorizer", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NTAzNw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545585037", "bodyText": "Yes. Renamed to aclAuthorizer.\ncommit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMjYzOQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545412639", "bodyText": "There is only one authorizer, we could just use it directly instead of creating a Seq", "author": "rajinisivaram", "createdAt": "2020-12-17T21:24:09Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU4NTM1NQ==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545585355", "bodyText": "Yes. Remove the Seq construction and make a single class member call.\ncommit b6a766b", "author": "ctan888", "createdAt": "2020-12-18T05:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMzgwMA==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545413800", "bodyText": "Looks like there is opportunity to move some of this stuff into BaseAuthorizerTest, but we can do that in a follow-up later.", "author": "rajinisivaram", "createdAt": "2020-12-17T21:26:29Z", "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,", "originalCommit": "092fec70a9547ec07cba999e77be1c0cf79fa275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyNzE4Nw==", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545527187", "bodyText": "I think that the ZookeeperClient has a different metric group name. I'm not sure how the name will be used though. And yes, we can do that in a follow-up PR later.", "author": "ctan888", "createdAt": "2020-12-18T02:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMzgwMA=="}], "type": "inlineReview"}, {"oid": "b6a766b228034a442e3a6e8b71ecee78eefdbfd3", "url": "https://github.com/apache/kafka/commit/b6a766b228034a442e3a6e8b71ecee78eefdbfd3", "message": "Another NIT", "committedDate": "2020-12-18T02:15:31Z", "type": "commit"}, {"oid": "9407b1697d976fc6cff90703573a64f7a3c9f348", "url": "https://github.com/apache/kafka/commit/9407b1697d976fc6cff90703573a64f7a3c9f348", "message": "address the missing comments", "committedDate": "2020-12-18T05:31:12Z", "type": "commit"}, {"oid": "9407b1697d976fc6cff90703573a64f7a3c9f348", "url": "https://github.com/apache/kafka/commit/9407b1697d976fc6cff90703573a64f7a3c9f348", "message": "address the missing comments", "committedDate": "2020-12-18T05:31:12Z", "type": "forcePushed"}, {"oid": "85231ec69bdf59be7853424dbe3c946addc8ec2b", "url": "https://github.com/apache/kafka/commit/85231ec69bdf59be7853424dbe3c946addc8ec2b", "message": "A few minor updates", "committedDate": "2020-12-18T10:03:59Z", "type": "commit"}, {"oid": "dd620f4cc70d09def9304904e7fcf020fd1c406e", "url": "https://github.com/apache/kafka/commit/dd620f4cc70d09def9304904e7fcf020fd1c406e", "message": "Fix Scala 2.12 build", "committedDate": "2020-12-18T13:57:02Z", "type": "commit"}]}