{"pr_number": 9156, "pr_title": "KAFKA-10077: Filter downstream of state-store results in spurious tombstones", "pr_createdAt": "2020-08-10T17:48:47Z", "pr_url": "https://github.com/apache/kafka/pull/9156", "timeline": [{"oid": "b90718719a3bc294f758303f8797ca74294f4651", "url": "https://github.com/apache/kafka/commit/b90718719a3bc294f758303f8797ca74294f4651", "message": "KAFKA-10077: Filter downstream of state-store results in spurious tombstones\n\nEnable sending old values on `KTable.filter` call to avoid the filter sending tombstones for rows that do not exist in the output.", "committedDate": "2020-08-10T17:46:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1MzUwNA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r474353504", "bodyText": "Don't we need to call this.enableSendingOldValues() as \"this\" is the upstream KTable the filter is applied to? Why do we need to enable sending old values on the result of the filter() ?", "author": "mjsax", "createdAt": "2020-08-21T01:12:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -203,6 +203,10 @@ public String queryableStoreName() {\n             processorSupplier,\n             tableNode,\n             builder);\n+\n+        kTable.enableSendingOldValues();", "originalCommit": "b90718719a3bc294f758303f8797ca74294f4651", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk5NzQ0Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r480997443", "bodyText": "Switching to enabling via the filter.", "author": "big-andy-coates", "createdAt": "2020-09-01T09:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1MzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r474353890", "bodyText": "This is surprising to me -- need to dig into the code I guess, but I though enabling to send old values would not trigger any upstream materialization but only take effect if the store is materializes already (but would be ignored otherwise). Seems my assumption is wrong though.", "author": "mjsax", "createdAt": "2020-08-21T01:13:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java", "diffHunk": "@@ -123,7 +123,7 @@ public void shouldAllowJoinMaterializedFilteredKTable() {\n \n         assertThat(\n             topology.stateStores().size(),\n-            equalTo(1));\n+            equalTo(2));", "originalCommit": "b90718719a3bc294f758303f8797ca74294f4651", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2MTU4Ng==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r474361586", "bodyText": "The issue seems to be this line: https://github.com/apache/kafka/blob/trunk/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java#L67\nIn a source-KTable, if we enable sending old values we force an materialization. I guess, we should have this materialization optional?\nI would recommend to rename enableSendingOldValues() to maybeEnableSendingOldValues(final boolean forceMaterialization) or similar?\n\\cc @guozhangwang WDYT?", "author": "mjsax", "createdAt": "2020-08-21T01:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MjY3MQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r475792671", "bodyText": "enableSendingOldValues is indicated for sending a pair of <new, old> values, and if it is not set the old value would always be null. If we want to enableSendingOldValues then we'd have to materialize the source node still?\nMaybe I'm not fully understanding the context here. Could you bring me up to date?", "author": "guozhangwang", "createdAt": "2020-08-24T17:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMjQ3Ng==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r477622476", "bodyText": "@guozhangwang Atm, when enableSendingOldValues is set and the upstream store is not materialized already we enforce a materialization. Thus, enabling enableSendingOldValues in KTable#filter() would be a breaking change as we would start to materialize state that did not exist before if one upgrades a topology.\nInstead, we want to say, iff the upstream store exist, please send me the old value, but if the upstream store does not exist, it's ok to just send old=null but don't force a materialization.", "author": "mjsax", "createdAt": "2020-08-26T22:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwNTgzNQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r478605835", "bodyText": "Ah I see.. what about changing the function as enableSendingOldValues(boolean enforced) in that case? And then only ktable aggregations which would definitely need this would set it to true.", "author": "guozhangwang", "createdAt": "2020-08-27T18:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk5ODUxNA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r480998514", "bodyText": "Sounds good.", "author": "big-andy-coates", "createdAt": "2020-09-01T09:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1Mzg5MA=="}], "type": "inlineReview"}, {"oid": "e49ebb7a041f35979239f340bc6455e464ad3692", "url": "https://github.com/apache/kafka/commit/e49ebb7a041f35979239f340bc6455e464ad3692", "message": "Added boolean to enableSendingOldValues", "committedDate": "2020-09-01T12:23:17Z", "type": "commit"}, {"oid": "f164529973bafed27d5c6752b1676d4cc8fd8931", "url": "https://github.com/apache/kafka/commit/f164529973bafed27d5c6752b1676d4cc8fd8931", "message": "merge from trunk", "committedDate": "2020-09-07T15:38:43Z", "type": "commit"}, {"oid": "cfa92350ea01fd7fcf9c52ce4981eb1429db4140", "url": "https://github.com/apache/kafka/commit/cfa92350ea01fd7fcf9c52ce4981eb1429db4140", "message": "fix scala test", "committedDate": "2020-09-08T10:02:01Z", "type": "commit"}, {"oid": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "url": "https://github.com/apache/kafka/commit/417e2ab7b27185bd6035a3e8422536a38e712b7b", "message": "Merge branch 'trunk' into kafka_10077_table_filter_send_old_values", "committedDate": "2020-09-09T10:15:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjczNg==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485846736", "bodyText": "Unrelated change: can we revert this?", "author": "mjsax", "createdAt": "2020-09-09T19:04:23Z", "path": "clients/src/main/java/org/apache/kafka/server/authorizer/AuthorizableRequestContext.java", "diffHunk": "@@ -17,11 +17,12 @@\n \n package org.apache.kafka.server.authorizer;\n \n-import java.net.InetAddress;\n import org.apache.kafka.common.annotation.InterfaceStability;\n import org.apache.kafka.common.security.auth.KafkaPrincipal;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n \n+import java.net.InetAddress;", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0OTQ0Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487049443", "bodyText": "Done. (Must sort out Kafka code style settings at some point)", "author": "big-andy-coates", "createdAt": "2020-09-11T13:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTk1Ng==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485851956", "bodyText": "Can we flip the logic of the boolean flag ? -- It makes a knob in my mind to say, onlyIfMaterailized=false implies that we need to (ie, enforce to) materialize...  I would prefer the suggest from Guozhang to use a flag like enforceMaterialization (or maybe better materializeIfNeeded).\nAlso, the method may or may not enable sending old values and thus, we might want to rename it to maybeEnableSendOldValues (or enableSendOldValuesIfPossible or similar).", "author": "mjsax", "createdAt": "2020-09-09T19:13:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableAggregate.java", "diffHunk": "@@ -47,8 +47,10 @@\n     }\n \n     @Override\n-    public void enableSendingOldValues() {\n+    public boolean enableSendingOldValues(final boolean onlyIfMaterialized) {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NzE4Ng==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487057186", "bodyText": "I did initially go with this. However, it seems really unintuitive.\nGiven a param such as forceMaterialization then it's clear that enableSendingOldValues(true) will force materialization, but what does enabledSendingOldValues(false) mean? OK, we're not forcing materialization, but actually the method won't enable sending old values if the param is false and its not already materialized.\nEven if we go with maybeEnableSendingOldValues(enforceMaterialization) I still would argue the semantics are not intuitive from the names alone.  (Though of course JavaDocs would help).\nHowever, given enableSendingOldValues(onlyIfMaterialized) is, IMHO, very intuitive. enableSendingOldValues(true) will only enable sending old values if already materialized, whereas enableSendingOldValues(false) will always enable sending old values, materializing as necessary, must like the previous enableSendingOldValues() method did.\nLikewise, if we stick with enableSendingOldValues(onlyIfMaterialized) then I don't think we need to include a maybe or IfPossible in the name as this is implied already by the onlyIf.\nThat said, this is not code I have to look at every day. If there's a consensus we should flip, then happy enough to do it.", "author": "big-andy-coates", "createdAt": "2020-09-11T13:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjE2NA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487166164", "bodyText": "I guess it's subjective. Personally, I would prefer to flip it.", "author": "mjsax", "createdAt": "2020-09-11T16:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NzUxNw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r490147517", "bodyText": "OK, will flip.", "author": "big-andy-coates", "createdAt": "2020-09-17T10:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjQ3NA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485852474", "bodyText": "Why does the filter need to send old values? I though the filter needs to receive old values, and thus we should call this. enableSendingOldValues(true) to enable sending old values on the filter's input?", "author": "mjsax", "createdAt": "2020-09-09T19:14:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -182,6 +182,8 @@ public String queryableStoreName() {\n         final KTableProcessorSupplier<K, V, V> processorSupplier =\n             new KTableFilter<>(this, predicate, filterNot, queryableStoreName);\n \n+        processorSupplier.enableSendingOldValues(true);", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NzgwNQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487057805", "bodyText": "KTableFilter has a boolean flag internally that also needs to be set if it is to correctly handle old values, (existing code).  So if we don't call enableSendingOldValues on it, it won't swallow the output when things haven't changed.\nto put it another way, the sendOldValues field of KTableFilter is used to both signify that the upstream is sending old values, and to control if the filter should forward old values. I'll split these into two variables.", "author": "big-andy-coates", "createdAt": "2020-09-11T13:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2Nzc4OQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487167789", "bodyText": "SGTM.\nIMHO, sendOldValues in KTableFilter should have only one meaning: do send old values downstream. If the filter result is materialized, we don't care if he upstream is sending old values or not. However, if the filter is stateless, as a side effect, we also need to tell upstream to send old values.", "author": "mjsax", "createdAt": "2020-09-11T16:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzODE5NQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489538195", "bodyText": "If the filter result is materialized, we don't care if he upstream is sending old values or not. However, if the filter is stateless, as a side effect, we also need to tell upstream to send old values.\n\nThat's not how the code was working. It always asked the parent to send old values:\n    @Override\n    public void enableSendingOldValues() {\n        parent.enableSendingOldValues();\n        sendOldValues = true;\n    }\nDo we want to change this as part of this PR to only call parent.enableSendingOldValues is the filter is not materialized?", "author": "big-andy-coates", "createdAt": "2020-09-16T15:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MjI2Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r490152263", "bodyText": "As discussed offline - change the behaviour of enableSendingOldValues such that a node that is already materialized will not ask upstream nodes to also send old values, is deemed out of scope of this PR.\n@mjsax has requested a ticket to track this work: https://issues.apache.org/jira/browse/KAFKA-10494", "author": "big-andy-coates", "createdAt": "2020-09-17T10:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzI5MA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485853290", "bodyText": "Seems the boolean input parameter is missing?", "author": "mjsax", "createdAt": "2020-09-09T19:16:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -832,18 +834,25 @@ public String queryableStoreName() {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public void enableSendingOldValues() {\n+    public boolean enableSendingOldValues(final boolean onlyIfMaterialized) {\n         if (!sendOldValues) {\n             if (processorSupplier instanceof KTableSource) {\n                 final KTableSource<K, ?> source = (KTableSource<K, V>) processorSupplier;\n+                if (onlyIfMaterialized && !source.materialized()) {\n+                    return false;\n+                }\n                 source.enableSendingOldValues();", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1ODU0OA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487058548", "bodyText": "Nope.  The if above is handling the boolean, there is no need for the source to be aware of this.", "author": "big-andy-coates", "createdAt": "2020-09-11T13:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MjQwMg==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487172402", "bodyText": "Ah. I though you changes ProcessorSuppler#enableSendOldValues but that was incorrect. You change KTableProcessorSuppler#enableSendOldValues.", "author": "mjsax", "createdAt": "2020-09-11T16:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTAzMw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485855033", "bodyText": "Instead of the check, should we pass in false to enforce a materialization if necessary?", "author": "mjsax", "createdAt": "2020-09-09T19:19:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableKTableAbstractJoin.java", "diffHunk": "@@ -39,9 +39,15 @@\n     }\n \n     @Override\n-    public final void enableSendingOldValues() {\n-        table1.enableSendingOldValues();\n-        table2.enableSendingOldValues();\n+    public final boolean enableSendingOldValues(final boolean onlyIfMaterialized) {\n+        if (!table1.enableSendingOldValues(onlyIfMaterialized)) {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1OTE1NA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487059154", "bodyText": "My view, as outlined above, is to stick with the pattern that's here.", "author": "big-andy-coates", "createdAt": "2020-09-11T13:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2OTMyMA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487169320", "bodyText": "My comment was about your pattern... (if we flip the logic, we would need to pass in true to force a materialization). My point is, shouldn't we pass in a constant? For KTableKTableAbstractJoin we always want that the upstream is sending us old values.", "author": "mjsax", "createdAt": "2020-09-11T16:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzOTkwNA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489539904", "bodyText": "Feels a little off to me to ignore what the caller is asking.  If they pass true for onlyIfMaterialized, then we shouldn't silently ignore them IMHO.", "author": "big-andy-coates", "createdAt": "2020-09-16T15:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NDM0MQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r490154341", "bodyText": "Anyway, done...", "author": "big-andy-coates", "createdAt": "2020-09-17T10:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTA4Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485855083", "bodyText": "as above.", "author": "mjsax", "createdAt": "2020-09-09T19:19:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableKTableAbstractJoin.java", "diffHunk": "@@ -39,9 +39,15 @@\n     }\n \n     @Override\n-    public final void enableSendingOldValues() {\n-        table1.enableSendingOldValues();\n-        table2.enableSendingOldValues();\n+    public final boolean enableSendingOldValues(final boolean onlyIfMaterialized) {\n+        if (!table1.enableSendingOldValues(onlyIfMaterialized)) {\n+            throw new IllegalStateException(\"Table-table joins should always be materialized\");\n+        }\n+\n+        if (!table2.enableSendingOldValues(onlyIfMaterialized)) {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2MDA3OA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487060078", "bodyText": "as above :)", "author": "big-andy-coates", "createdAt": "2020-09-11T13:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTIyMw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485855223", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-09-09T19:20:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableKTableJoinMerger.java", "diffHunk": "@@ -77,10 +77,16 @@ public String getQueryableName() {\n     }\n \n     @Override\n-    public void enableSendingOldValues() {\n-        parent1.enableSendingOldValues();\n-        parent2.enableSendingOldValues();\n+    public boolean enableSendingOldValues(final boolean onlyIfMaterialized) {\n+        if (!parent1.enableSendingOldValues(onlyIfMaterialized)) {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2MDE3MQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487060171", "bodyText": "as above :)", "author": "big-andy-coates", "createdAt": "2020-09-11T13:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTI3NQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485855275", "bodyText": "as above?", "author": "mjsax", "createdAt": "2020-09-09T19:20:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableKTableJoinMerger.java", "diffHunk": "@@ -77,10 +77,16 @@ public String getQueryableName() {\n     }\n \n     @Override\n-    public void enableSendingOldValues() {\n-        parent1.enableSendingOldValues();\n-        parent2.enableSendingOldValues();\n+    public boolean enableSendingOldValues(final boolean onlyIfMaterialized) {\n+        if (!parent1.enableSendingOldValues(onlyIfMaterialized)) {\n+            throw new IllegalStateException(\"Table-table joins should always be materialized\");\n+        }\n+\n+        if (!parent2.enableSendingOldValues(onlyIfMaterialized)) {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2MDI0MA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487060240", "bodyText": "as above. :p", "author": "big-andy-coates", "createdAt": "2020-09-11T13:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1ODQ1Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485858453", "bodyText": "Why do we need to call this (ie, why do we want the result of the filter to send old values)?", "author": "mjsax", "createdAt": "2020-09-09T19:25:29Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableFilterTest.java", "diffHunk": "@@ -295,12 +295,39 @@ public void shouldNotSendOldValuesOnMaterialization() {\n         doTestNotSendingOldValue(builder, table1, table2, topic1);\n     }\n \n+    @Test\n+    public void shouldNotSendOldValuesWithoutMaterializationIfOptionallyRequested() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String topic1 = \"topic1\";\n+\n+        final KTableImpl<String, Integer, Integer> table1 =\n+            (KTableImpl<String, Integer, Integer>) builder.table(topic1, consumed);\n+        final KTableImpl<String, Integer, Integer> table2 = (KTableImpl<String, Integer, Integer>) table1.filter(predicate);\n+\n+        table2.enableSendingOldValues(true);", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2MDUyNA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r487060524", "bodyText": "See my comment above", "author": "big-andy-coates", "createdAt": "2020-09-11T13:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1ODkyMw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485858923", "bodyText": "As we enable this on the result KTable, and we enforce a materialization of the result, I would expect that we actually do get old-values sent?", "author": "mjsax", "createdAt": "2020-09-09T19:26:09Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableFilterTest.java", "diffHunk": "@@ -295,12 +295,39 @@ public void shouldNotSendOldValuesOnMaterialization() {\n         doTestNotSendingOldValue(builder, table1, table2, topic1);\n     }\n \n+    @Test\n+    public void shouldNotSendOldValuesWithoutMaterializationIfOptionallyRequested() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String topic1 = \"topic1\";\n+\n+        final KTableImpl<String, Integer, Integer> table1 =\n+            (KTableImpl<String, Integer, Integer>) builder.table(topic1, consumed);\n+        final KTableImpl<String, Integer, Integer> table2 = (KTableImpl<String, Integer, Integer>) table1.filter(predicate);\n+\n+        table2.enableSendingOldValues(true);\n+\n+        doTestNotSendingOldValue(builder, table1, table2, topic1);\n+    }\n+\n+    @Test\n+    public void shouldNotSendOldValuesOnMaterializationIfOptionallyRequested() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String topic1 = \"topic1\";\n+\n+        final KTableImpl<String, Integer, Integer> table1 =\n+            (KTableImpl<String, Integer, Integer>) builder.table(topic1, consumed);\n+        final KTableImpl<String, Integer, Integer> table2 =\n+            (KTableImpl<String, Integer, Integer>) table1.filter(predicate, Materialized.as(\"store2\"));\n+\n+        table2.enableSendingOldValues(true);", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MDQ1Mg==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485860452", "bodyText": "Should we actually keep this call within this method and pass in the boolean flag as parameter to doTestSendingOldValue ?", "author": "mjsax", "createdAt": "2020-09-09T19:28:20Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableFilterTest.java", "diffHunk": "@@ -295,12 +295,39 @@ public void shouldNotSendOldValuesOnMaterialization() {\n         doTestNotSendingOldValue(builder, table1, table2, topic1);\n     }\n \n+    @Test\n+    public void shouldNotSendOldValuesWithoutMaterializationIfOptionallyRequested() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String topic1 = \"topic1\";\n+\n+        final KTableImpl<String, Integer, Integer> table1 =\n+            (KTableImpl<String, Integer, Integer>) builder.table(topic1, consumed);\n+        final KTableImpl<String, Integer, Integer> table2 = (KTableImpl<String, Integer, Integer>) table1.filter(predicate);\n+\n+        table2.enableSendingOldValues(true);\n+\n+        doTestNotSendingOldValue(builder, table1, table2, topic1);\n+    }\n+\n+    @Test\n+    public void shouldNotSendOldValuesOnMaterializationIfOptionallyRequested() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String topic1 = \"topic1\";\n+\n+        final KTableImpl<String, Integer, Integer> table1 =\n+            (KTableImpl<String, Integer, Integer>) builder.table(topic1, consumed);\n+        final KTableImpl<String, Integer, Integer> table2 =\n+            (KTableImpl<String, Integer, Integer>) table1.filter(predicate, Materialized.as(\"store2\"));\n+\n+        table2.enableSendingOldValues(true);\n+\n+        doTestNotSendingOldValue(builder, table1, table2, topic1);\n+    }\n+\n     private void doTestSendingOldValue(final StreamsBuilder builder,\n                                        final KTableImpl<String, Integer, Integer> table1,\n                                        final KTableImpl<String, Integer, Integer> table2,\n                                        final String topic1) {\n-        table2.enableSendingOldValues();", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NzE5NA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485867194", "bodyText": "shouldNotSetSendingOldValuesIfNotMaterialized", "author": "mjsax", "createdAt": "2020-09-09T19:37:13Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableImplTest.java", "diffHunk": "@@ -304,6 +363,30 @@ public void testStateStore() {\n         }\n     }\n \n+    @Test\n+    public void testSendingOldValuesNotSetIfNotMaterialized() {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU0MjAyMg==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489542022", "bodyText": "I prefer should too, but a lot of the code users test.  Happy to switch. Can I use should everywhere?", "author": "big-andy-coates", "createdAt": "2020-09-16T15:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2Nzc5MA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485867790", "bodyText": "shouldSetSendingOldValuesIfMaterializationForced", "author": "mjsax", "createdAt": "2020-09-09T19:37:54Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableImplTest.java", "diffHunk": "@@ -304,6 +363,30 @@ public void testStateStore() {\n         }\n     }\n \n+    @Test\n+    public void testSendingOldValuesNotSetIfNotMaterialized() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final KTableImpl<String, String, String> table =\n+            (KTableImpl<String, String, String>) builder.table(\"topic1\", consumed);\n+\n+        table.enableSendingOldValues(true);\n+\n+        assertThat(table.sendingOldValueEnabled(), is(false));\n+    }\n+\n+    @Test\n+    public void testSendingOldValuesSetIfMaterializedForced() {", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2ODQ1Mw==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485868453", "bodyText": "Seems the Matererialized.as(\"fred\") parameter is missing?", "author": "mjsax", "createdAt": "2020-09-09T19:38:38Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KTableImplTest.java", "diffHunk": "@@ -304,6 +363,30 @@ public void testStateStore() {\n         }\n     }\n \n+    @Test\n+    public void testSendingOldValuesNotSetIfNotMaterialized() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final KTableImpl<String, String, String> table =\n+            (KTableImpl<String, String, String>) builder.table(\"topic1\", consumed);\n+\n+        table.enableSendingOldValues(true);\n+\n+        assertThat(table.sendingOldValueEnabled(), is(false));\n+    }\n+\n+    @Test\n+    public void testSendingOldValuesSetIfMaterializedForced() {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final KTableImpl<String, String, String> table =\n+            (KTableImpl<String, String, String>) builder.table(\"topic1\", consumed);", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU0MzQ3Mg==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489543472", "bodyText": "Why? This test is about forced materialization. If we pass that parameter, then it would work even if not forced, right?", "author": "big-andy-coates", "createdAt": "2020-09-16T15:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2ODQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4ODcwNQ==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489588705", "bodyText": "Rename test to make it clear its force materialized due to sending old values,\nshouldSetSendingOldValuesIfMaterializationForcedInternally", "author": "big-andy-coates", "createdAt": "2020-09-16T17:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MTMyMA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r485871320", "bodyText": "Why do we need to change the filter condition?", "author": "mjsax", "createdAt": "2020-09-09T19:41:55Z", "path": "streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/kstream/KTableTest.scala", "diffHunk": "@@ -39,29 +39,27 @@ class KTableTest extends FlatSpec with Matchers with TestDriver {\n     val sinkTopic = \"sink\"\n \n     val table = builder.stream[String, String](sourceTopic).groupBy((key, _) => key).count()\n-    table.filter((_, value) => value > 1).toStream.to(sinkTopic)\n+    table.filter((key, value) => key.equals(\"a\") && value == 1).toStream.to(sinkTopic)", "originalCommit": "417e2ab7b27185bd6035a3e8422536a38e712b7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU0NDAxNA==", "url": "https://github.com/apache/kafka/pull/9156#discussion_r489544014", "bodyText": "So that we can test an existing row being removed.", "author": "big-andy-coates", "createdAt": "2020-09-16T15:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MTMyMA=="}], "type": "inlineReview"}, {"oid": "03fe316707c62aa01ca57178898665554898beb5", "url": "https://github.com/apache/kafka/commit/03fe316707c62aa01ca57178898665554898beb5", "message": "merge from trunk", "committedDate": "2020-09-16T20:16:49Z", "type": "commit"}, {"oid": "c008ae0361f8c9c4648bedd034b6c706b2510121", "url": "https://github.com/apache/kafka/commit/c008ae0361f8c9c4648bedd034b6c706b2510121", "message": "requested changes", "committedDate": "2020-09-17T12:12:42Z", "type": "commit"}, {"oid": "540466141c8a132b751ea37a3f5eead02185078e", "url": "https://github.com/apache/kafka/commit/540466141c8a132b751ea37a3f5eead02185078e", "message": "remove test testing bad behaviour", "committedDate": "2020-09-17T12:26:54Z", "type": "commit"}, {"oid": "9a8d7f36b7e70de9442cab0be4b91d9a068c3d95", "url": "https://github.com/apache/kafka/commit/9a8d7f36b7e70de9442cab0be4b91d9a068c3d95", "message": "Merge branch 'trunk' into kafka_10077_table_filter_send_old_values", "committedDate": "2020-09-25T12:04:21Z", "type": "commit"}]}