{"pr_number": 8724, "pr_title": "KAFKA-10040; Make computing the PreferredReplicaImbalanceCount metric more efficient", "pr_createdAt": "2020-05-25T15:26:33Z", "pr_url": "https://github.com/apache/kafka/pull/8724", "timeline": [{"oid": "c2fb87a9ab370fe38ad7ae2949204e8641dcfe36", "url": "https://github.com/apache/kafka/commit/c2fb87a9ab370fe38ad7ae2949204e8641dcfe36", "message": "KAFKA-10040; Make computing the PreferredReplicaImbalanceCount metric more efficient", "committedDate": "2020-05-25T15:10:15Z", "type": "commit"}, {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464", "url": "https://github.com/apache/kafka/commit/f2c9df960726243528b91c1a4aa8de1af713e464", "message": "refactoring", "committedDate": "2020-05-26T07:02:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NjI3NQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r432986275", "bodyText": "nit: I think this exact argument doesn't need to be an Option", "author": "stanislavkozlovski", "createdAt": "2020-05-31T21:32:28Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],", "originalCommit": "f2c9df960726243528b91c1a4aa8de1af713e464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2MDY2MQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434360661", "bodyText": "Actually, in updatePartitionFullReplicaAssignment, partitionLeadershipInfo.get(topicPartition) returns an Option so it is more convenient to keep it as an Option. Ok for you?", "author": "dajac", "createdAt": "2020-06-03T07:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1OTYyNw==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434259627", "bodyText": "What about hasPreferredLeader?", "author": "hachikuji", "createdAt": "2020-06-03T01:26:03Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],\n+                                                    newLeadershipInfo: Option[LeaderIsrAndControllerEpoch]): Unit = {\n+    if (!isTopicQueuedUpForDeletion(partition.topic)) {\n+      oldReplicaAssignment.foreach { replicaAssignment =>\n+        oldLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount -= 1\n+        }\n+      }\n+\n+      newReplicaAssignment.foreach { replicaAssignment =>\n+        newLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount += 1\n+        }\n+      }\n+    }\n+  }\n+\n+  private def cleanPreferredReplicaImbalanceMetric(topic: String): Unit = {\n+    partitionAssignments.getOrElse(topic, mutable.Map.empty).foreach { case (partition, replicaAssignment) =>\n+      partitionLeadershipInfo.get(new TopicPartition(topic, partition)).foreach { leadershipInfo =>\n+        if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+          preferredReplicaImbalanceCount -= 1\n+      }\n+    }\n+  }\n+\n+  private def isReplicaImbalance(replicaAssignment: ReplicaAssignment,", "originalCommit": "f2c9df960726243528b91c1a4aa8de1af713e464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2MDc5NQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434360795", "bodyText": "Yes, that is fine.", "author": "dajac", "createdAt": "2020-06-03T07:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1OTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MTc3Mg==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434261772", "bodyText": "Not something to change here, but it's a little curious that we only do this when a reassignment is in progress. I'm not sure it's useful to distinguish that case as opposed to a broker that is catching up after a restart. If the preferred leader is not in the ISR, then we can't elect it anyway. Seems like it might be more useful if this metric captured the \"eligible imbalance\".", "author": "hachikuji", "createdAt": "2020-06-03T01:34:56Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],\n+                                                    newLeadershipInfo: Option[LeaderIsrAndControllerEpoch]): Unit = {\n+    if (!isTopicQueuedUpForDeletion(partition.topic)) {\n+      oldReplicaAssignment.foreach { replicaAssignment =>\n+        oldLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount -= 1\n+        }\n+      }\n+\n+      newReplicaAssignment.foreach { replicaAssignment =>\n+        newLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount += 1\n+        }\n+      }\n+    }\n+  }\n+\n+  private def cleanPreferredReplicaImbalanceMetric(topic: String): Unit = {\n+    partitionAssignments.getOrElse(topic, mutable.Map.empty).foreach { case (partition, replicaAssignment) =>\n+      partitionLeadershipInfo.get(new TopicPartition(topic, partition)).foreach { leadershipInfo =>\n+        if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+          preferredReplicaImbalanceCount -= 1\n+      }\n+    }\n+  }\n+\n+  private def isReplicaImbalance(replicaAssignment: ReplicaAssignment,\n+                                 leadershipInfo: LeaderIsrAndControllerEpoch): Boolean = {\n+    val preferredReplica = replicaAssignment.replicas.head\n+    if (replicaAssignment.isBeingReassigned && replicaAssignment.addingReplicas.contains(preferredReplica))\n+      // reassigning partitions are not counted as imbalanced until the new replica joins the ISR (completes reassignment)", "originalCommit": "f2c9df960726243528b91c1a4aa8de1af713e464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2MTIxMw==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434361213", "bodyText": "I agree with you.", "author": "dajac", "createdAt": "2020-06-03T07:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MjUzOQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434262539", "bodyText": "Wonder if we should consider making partitionLeadershipInfo private so that we do not mistakenly invoke put in the future directly.", "author": "hachikuji", "createdAt": "2020-06-03T01:38:18Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {", "originalCommit": "f2c9df960726243528b91c1a4aa8de1af713e464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2MTc5Mg==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434361792", "bodyText": "That makes total sense. I have updated the PR to make it private. I have added methods in the controller context for all the reads (moved code around).", "author": "dajac", "createdAt": "2020-06-03T07:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2Mjk3MQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434262971", "bodyText": "Ouch. So the main issue is that we were doing this full iteration over all partitions on every controller event.", "author": "hachikuji", "createdAt": "2020-06-03T01:40:10Z", "path": "core/src/main/scala/kafka/controller/KafkaController.scala", "diffHunk": "@@ -1254,23 +1254,7 @@ class KafkaController(val config: KafkaConfig,\n       if (!isActive) {\n         0\n       } else {\n-        controllerContext.allPartitions.count { topicPartition =>", "originalCommit": "f2c9df960726243528b91c1a4aa8de1af713e464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM2MTkxNw==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434361917", "bodyText": "Yeah...", "author": "dajac", "createdAt": "2020-06-03T07:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2Mjk3MQ=="}], "type": "inlineReview"}, {"oid": "303bb10bf7ddbea779a0bacab88267f9a6e79afc", "url": "https://github.com/apache/kafka/commit/303bb10bf7ddbea779a0bacab88267f9a6e79afc", "message": "refactor", "committedDate": "2020-06-03T07:16:01Z", "type": "commit"}, {"oid": "8c86178f5ece91fe815be17fc9ea9ffada19e99b", "url": "https://github.com/apache/kafka/commit/8c86178f5ece91fe815be17fc9ea9ffada19e99b", "message": "cleanuo", "committedDate": "2020-06-03T07:46:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwMjAyMw==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434702023", "bodyText": "nit: partitionLeadersOnBroker?", "author": "hachikuji", "createdAt": "2020-06-03T16:32:48Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,90 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putPartitionLeadershipInfo(partition: TopicPartition,\n+                                 leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  def partitionLeadershipInfo(partition: TopicPartition): Option[LeaderIsrAndControllerEpoch] = {\n+    partitionLeadershipInfo.get(partition)\n+  }\n+\n+  def partitionsLeadershipInfo(): Iterable[(TopicPartition, LeaderIsrAndControllerEpoch)] = {\n+    partitionLeadershipInfo\n+  }\n+\n+  def partitionsWithLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.keySet\n+  }\n+\n+  def partitionsWithoutLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.filter { case (topicPartition, leaderIsrAndControllerEpoch) =>\n+      !isReplicaOnline(leaderIsrAndControllerEpoch.leaderAndIsr.leader, topicPartition) &&\n+        !isTopicQueuedUpForDeletion(topicPartition.topic)\n+    }.keySet\n+  }\n+\n+  def partitionLeadsOnBroker(brokerId: Int): Set[TopicPartition] = {", "originalCommit": "8c86178f5ece91fe815be17fc9ea9ffada19e99b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3Njg0OQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r435076849", "bodyText": "That makes sense.", "author": "dajac", "createdAt": "2020-06-04T08:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwMjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDYwMg==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434710602", "bodyText": "This definition seems inconsistent with partitionsWithoutLeaders. I think you're just trying to preserve the existing logic. It might make sense to use a different name to avoid the apparent inconsistency? Maybe we could change partitionsWithoutLeaders to be partitionsWithOfflineLeaders or something like that. Looking at the caller, it looks like it would be reasonable to exclude topics which are being queued for deletion in both cases, but we could change that separately if you think it is risky.", "author": "hachikuji", "createdAt": "2020-06-03T16:46:02Z", "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,90 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putPartitionLeadershipInfo(partition: TopicPartition,\n+                                 leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  def partitionLeadershipInfo(partition: TopicPartition): Option[LeaderIsrAndControllerEpoch] = {\n+    partitionLeadershipInfo.get(partition)\n+  }\n+\n+  def partitionsLeadershipInfo(): Iterable[(TopicPartition, LeaderIsrAndControllerEpoch)] = {\n+    partitionLeadershipInfo\n+  }\n+\n+  def partitionsWithLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.keySet", "originalCommit": "8c86178f5ece91fe815be17fc9ea9ffada19e99b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NTAwMQ==", "url": "https://github.com/apache/kafka/pull/8724#discussion_r435085001", "bodyText": "Right. I did not pay attention to this detail but that makes total sense to use a better name here. Let's go with partitionsWithOfflineLeaders.\nWe can indeed exclude topics which are being queued for deletion. It is already done in partitionsWithOfflineLeaders but I have added it in partitionsWithLeaders.", "author": "dajac", "createdAt": "2020-06-04T08:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDYwMg=="}], "type": "inlineReview"}, {"oid": "4f016427bfc7a46f3cd5f2135ab56cccf1be176b", "url": "https://github.com/apache/kafka/commit/4f016427bfc7a46f3cd5f2135ab56cccf1be176b", "message": "address review", "committedDate": "2020-06-04T08:48:06Z", "type": "commit"}]}