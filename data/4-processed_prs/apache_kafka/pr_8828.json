{"pr_number": 8828, "pr_title": "KAFKA-9216: Enforce that Connect\u2019s internal topics use `compact` cleanup policy", "pr_createdAt": "2020-06-07T22:02:48Z", "pr_url": "https://github.com/apache/kafka/pull/8828", "timeline": [{"oid": "855f016c07b1f37ab25f679542dc8a972b42544d", "url": "https://github.com/apache/kafka/commit/855f016c07b1f37ab25f679542dc8a972b42544d", "message": "KAFKA-9216: Enforce that Connect\u2019s internal topics use `compact` cleanup policy\n\nThis change adds a check to the KafkaConfigBackingStore, KafkaOffsetBackingStore, and KafkaStatusBackingStore to use the admin client to verify that the internal topics are compacted and do not use the `delete` cleanup policy.\n\nConnect already will create the internal topics with `cleanup.policy=compact` if the topics do not yet exist when the Connect workers are started; the new topics are created always as compacted, overwriting any user-specified `cleanup.policy`. However, if the topics already exist the worker did not previously verify the internal topics were compacted, such as when a user manually creates the internal topics before starting Connect or manually changes the topic settings after the fact.\n\nThe current change helps guard against users running Connect with topics that have delete cleanup policy enabled, which will remove all connector configurations, source offsets, and connector & task statuses that are older than the retention time. This means that, for example, the configuation for a long-running connector could be deleted by the broker, and this will cause restart issues upon a subsequent rebalance or restarting of Connect worker(s).\n\nConnect behavior requires that its internal topics are compacted and not deleted after some retention time. Therefore, this additional check is simply enforcing the existing expectations, and therefore does not need a KIP.", "committedDate": "2020-06-07T22:00:48Z", "type": "commit"}, {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "url": "https://github.com/apache/kafka/commit/eb2f4c323856d0f35c4628df08bdb37d121d4613", "message": "KAFKA-9216: Added logic to skip this check if the topic cleanup policy could not be returned\n\nIf the Kafka principal that Connect uses for internal topics does not have proper ACLs or the Kafka broker is older than 0.11.0.0, the worker will not be able to validate the cleanup policy for the internal topics. This should not cause the worker to fail.", "committedDate": "2020-06-07T22:48:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxNTQ4Ng==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436415486", "bodyText": "volatile boolean is equivalent to AtomicBoolean and if we are not going to use any of the compare-and-set/get-and-set capabilities of the atomic class, maybe you'd want to consider using volatile instead to avoid the boilerplate of calling get/set on that boolean variable. But of course, the decision is a matter of style too.", "author": "kkonstantine", "createdAt": "2020-06-08T00:15:10Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/AbstractHerder.java", "diffHunk": "@@ -94,6 +95,7 @@\n     protected final StatusBackingStore statusBackingStore;\n     protected final ConfigBackingStore configBackingStore;\n     private final ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy;\n+    protected final AtomicBoolean running = new AtomicBoolean(false);", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjgwMw==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438292803", "bodyText": "ack", "author": "rhauch", "createdAt": "2020-06-10T17:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxNTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTE2OQ==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436421169", "bodyText": "Vararg gives some unintended consequences in naming. Should we stick to singular given that we expect at most a single topic to be created?", "author": "kkonstantine", "createdAt": "2020-06-08T01:14:28Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaConfigBackingStore.java", "diffHunk": "@@ -492,7 +493,14 @@ public void putSessionKey(SessionKey sessionKey) {\n             public void run() {\n                 log.debug(\"Creating admin client to manage Connect internal config topic\");\n                 try (TopicAdmin admin = new TopicAdmin(adminProps)) {\n-                    admin.createTopics(topicDescription);\n+                    // Create the topic if it doesn't exist\n+                    Set<String> newTopics = admin.createTopics(topicDescription);", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTY0Nw==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436421647", "bodyText": "nit: should we keep 2 tabs alignment for everything?", "author": "kkonstantine", "createdAt": "2020-06-08T01:18:32Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjE3Mw==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436422173", "bodyText": "I wonder if distinguishing like that, with null and empty pays off.\nWhy not return an empty collection in both cases and simplify the checks on the return values of this method?\nThis method doesn't seem to be the one to use when somebody wants to determine whether a topic exists or not.", "author": "kkonstantine", "createdAt": "2020-06-08T01:22:35Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, cleanupPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic exists", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjYwOA==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436422608", "bodyText": "nit: don't we need a space between the varargs type and the variable name? I'm surprised mainly at checkstyle here.", "author": "kkonstantine", "createdAt": "2020-06-08T01:26:17Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, cleanupPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic exists\n+     *         but has no cleanup policy, or may be null if the topic does not exist\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            return null;\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            return Arrays.stream(policyStr.split(\",\"))\n+                         .map(String::trim)\n+                         .map(String::toLowerCase)\n+                         .collect(Collectors.toSet());\n+        }\n+        return Collections.emptySet();\n+    }\n+\n+    /**\n+     * Attempt to fetch the topic configuration for the given topic.\n+     * Apache Kafka added support for describing topic configurations in 0.11.0.0, so this method\n+     * works as expected with that and later versions. With brokers older than 0.11.0.0, this method\n+     * is unable get the topic configurations and always returns a null value.\n+     *\n+     * <p>If the topic does not exist, a null value is returned.\n+     *\n+     * @param topic the name of the topic for which the topic configuration should be obtained\n+     * @return true if the operation was successful, or false if no topics were described\n+     * @throws RetriableException if a retriable error occurs, the operation takes too long, or the\n+     *         thread is interrupted while attempting to perform this operation\n+     * @throws ConnectException if a non retriable error occurs\n+     */\n+    public Config describeTopicConfig(String topic) {\n+        return describeTopicConfigs(topic).get(topic);\n+    }\n+\n+    /**\n+     * Attempt to fetch the topic configurations for the given topics.\n+     * Apache Kafka added support for describing topic configurations in 0.11.0.0, so this method\n+     * works as expected with that and later versions. With brokers older than 0.11.0.0, this method\n+     * is unable get the topic configurations and always returns an empty set.\n+     *\n+     * <p>An entry with a null Config is placed into the resulting map for any topic that does\n+     * not exist on the brokers.\n+     *\n+     * @param topicNames the topics to obtain configurations\n+     * @return true if the operation was successful, or false if no topics were described\n+     * @throws RetriableException if a retriable error occurs, the operation takes too long, or the\n+     *         thread is interrupted while attempting to perform this operation\n+     * @throws ConnectException if a non retriable error occurs\n+     */\n+    public Map<String, Config> describeTopicConfigs(String...topicNames) {", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436881026", "bodyText": "Is it possible that this will also be true if there isn't a cleanup policy configured on the topic?", "author": "C0urante", "createdAt": "2020-06-08T17:39:47Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "originalCommit": "eb2f4c323856d0f35c4628df08bdb37d121d4613", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5OTQ5NQ==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438299495", "bodyText": "Is it even possible to have a blank cleanup.policy? The topic will inherit the broker's log.cleanup.policy, which has a default and which is not allowed to be blank. And it looks like cleanup.policy is required to be either compact or delete or both.", "author": "rhauch", "createdAt": "2020-06-10T17:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMzY5OA==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438303698", "bodyText": "No kidding... I assumed it was possible to create topics without cleanup policies but it looks like you're right. My bad!", "author": "C0urante", "createdAt": "2020-06-10T17:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjMwOA==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438412308", "bodyText": "After some testing, I've discovered that even if the topic-specific settings don't explicitly specify the cleanup.policy, the config description for the topic returned by the admin client will still include cleanup.policy=<broker's log.cleanup.policy>. That means if we have permissions and the topic exists, we will always get the cleanup.policy for the topic.\nAnd, I've cleaned up the semantics of the topicCleanupPolicy(...) method to never return a null set. This means that if the set is empty, either the topic doesn't exist or the admin client could not return the topic settings (e.g., old broker, insufficient ACLs, etc.). Either way, this logic gets simplified a bit.\nI hope that helps address your concern/question.", "author": "rhauch", "createdAt": "2020-06-10T21:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzMzNw==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438417337", "bodyText": "I think my concern was invalid to begin with but your refactoring is certainly an improvement. LGTM \ud83d\udc4d", "author": "C0urante", "createdAt": "2020-06-10T21:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}], "type": "inlineReview"}, {"oid": "ead451a41e10ecfe2e824293351a8e2836556d3b", "url": "https://github.com/apache/kafka/commit/ead451a41e10ecfe2e824293351a8e2836556d3b", "message": "KAFKA-9216: Used volatile instead of AtomicBoolean", "committedDate": "2020-06-10T20:57:17Z", "type": "commit"}, {"oid": "5e9322cbe157cbe41fbd384e9d8eb30424d95f96", "url": "https://github.com/apache/kafka/commit/5e9322cbe157cbe41fbd384e9d8eb30424d95f96", "message": "KAFKA-9216: Incorporated review feedback by improving semantics", "committedDate": "2020-06-10T21:09:26Z", "type": "commit"}, {"oid": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8", "url": "https://github.com/apache/kafka/commit/5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8", "message": "KAFKA-9216: Corrected test case", "committedDate": "2020-06-10T21:10:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1NQ==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488255", "bodyText": "Should we consider info? It's a one time message right?", "author": "kkonstantine", "createdAt": "2020-06-11T01:08:12Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"", "originalCommit": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUyMTcxMw==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438521713", "bodyText": "I could see changing this to info, because this is important. But the others log messages really are just tracking that we're using the admin client and what we're finding, so I think debug is probably the best there. If the cleanup policy is wrong, then if we're logging that we're also going to fail the worker; if the cleanup policy is acceptable, I don't think it's worth logging it at info.", "author": "rhauch", "createdAt": "2020-06-11T03:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODQ0NA==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488444", "bodyText": "same question around log level as above", "author": "kkonstantine", "createdAt": "2020-06-11T01:09:00Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        if (!cleanupPolicies.equals(expectedPolicies)) {\n+            String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+            String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                    + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                    + \"%s, but found the topic currently has '%s=%s'. Continuing would likely \"\n+                    + \"result in eventually losing %s and problems restarting this Connect \"\n+                    + \"cluster in the future. Change the '%s' property in the \"\n+                    + \"Connect worker configurations to use a topic with '%s=%s'.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose,\n+                    workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic does not\n+     *         exist or the topic's cleanup policy could not be retrieved\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            // The topic must not exist\n+            log.debug(\"Unable to find topic '{}' when getting cleanup policy\", topic);\n+            return Collections.emptySet();\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            log.debug(\"Found cleanup.policy={} for topic '{}'\", policyStr, topic);", "originalCommit": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODQ1OQ==", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488459", "bodyText": "same question around log level as above", "author": "kkonstantine", "createdAt": "2020-06-11T01:09:04Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        if (!cleanupPolicies.equals(expectedPolicies)) {\n+            String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+            String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                    + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                    + \"%s, but found the topic currently has '%s=%s'. Continuing would likely \"\n+                    + \"result in eventually losing %s and problems restarting this Connect \"\n+                    + \"cluster in the future. Change the '%s' property in the \"\n+                    + \"Connect worker configurations to use a topic with '%s=%s'.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose,\n+                    workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic does not\n+     *         exist or the topic's cleanup policy could not be retrieved\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            // The topic must not exist\n+            log.debug(\"Unable to find topic '{}' when getting cleanup policy\", topic);\n+            return Collections.emptySet();\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            log.debug(\"Found cleanup.policy={} for topic '{}'\", policyStr, topic);\n+            return Arrays.stream(policyStr.split(\",\"))\n+                         .map(String::trim)\n+                         .filter(s -> !s.isEmpty())\n+                         .map(String::toLowerCase)\n+                         .collect(Collectors.toSet());\n+        }\n+        // This is unexpected, as the topic config should include the cleanup.policy even if\n+        // the topic settings don't override the broker's log.cleanup.policy. But just to be safe.\n+        log.debug(\"Found no cleanup.policy for topic '{}'\", topic);", "originalCommit": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ef4c994e57a321ccd562d31ad5fb32ff813e9fb9", "url": "https://github.com/apache/kafka/commit/ef4c994e57a321ccd562d31ad5fb32ff813e9fb9", "message": "KAFKA-9216: Changed one log message to info", "committedDate": "2020-06-11T03:38:03Z", "type": "commit"}]}