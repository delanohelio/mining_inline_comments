{"pr_number": 8053, "pr_title": "KAFKA-9499; Improve deletion process by batching more aggressively", "pr_createdAt": "2020-02-06T20:55:31Z", "pr_url": "https://github.com/apache/kafka/pull/8053", "timeline": [{"oid": "5fe1903ffc16cbbc76afcd1e5557576ed4410544", "url": "https://github.com/apache/kafka/commit/5fe1903ffc16cbbc76afcd1e5557576ed4410544", "message": "KAFKA-9499; Improve deletion process by batching more aggressively", "committedDate": "2020-02-06T20:30:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5NjEzNA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376096134", "bodyText": "nit: not from this patch, but can we document or remove this @param", "author": "hachikuji", "createdAt": "2020-02-06T21:37:57Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -292,22 +291,35 @@ class TopicDeletionManager(config: KafkaConfig,\n    * @param replicasForTopicsToBeDeleted", "originalCommit": "5fe1903ffc16cbbc76afcd1e5557576ed4410544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NTM4Nw==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376285387", "bodyText": "Ack. Removed.", "author": "dajac", "createdAt": "2020-02-07T09:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5NjEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMDgyNA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376100824", "bodyText": "In this function, we start with a list of topics and convert it to a flattened list of partitions. Ultimately in startReplicaDeletion, we end up regrouping by topic. I wonder if there is an opportunity to save a little work by avoiding the intermediate conversions.\nBy the way, because we are doing more batching now, this may be a good time to reduce or remove the info log line in onPartitionDeletion which can already be a bit noisy.", "author": "hachikuji", "createdAt": "2020-02-06T21:48:24Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -270,9 +271,7 @@ class TopicDeletionManager(config: KafkaConfig,\n     }\n \n     client.sendMetadataUpdate(partitions)\n-    topics.foreach { topic =>\n-      onPartitionDeletion(controllerContext.partitionsForTopic(topic))\n-    }\n+    onPartitionDeletion(partitions)", "originalCommit": "5fe1903ffc16cbbc76afcd1e5557576ed4410544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NTgzMA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376285830", "bodyText": "Good point. I have made an attempt which keeps a Map all the way through. Let me know what do you think.", "author": "dajac", "createdAt": "2020-02-07T09:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NjczNQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376286735", "bodyText": "I have removed the log as well.", "author": "dajac", "createdAt": "2020-02-07T09:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMjg0Nw==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376102847", "bodyText": "Not sure it matters too much, but because of the way these are collected, I don't think they need to be sets. We could use ListBuffer instead, which is already a Seq.", "author": "hachikuji", "createdAt": "2020-02-06T21:52:57Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -292,22 +291,35 @@ class TopicDeletionManager(config: KafkaConfig,\n    * @param replicasForTopicsToBeDeleted\n    */\n   private def startReplicaDeletion(replicasForTopicsToBeDeleted: Set[PartitionAndReplica]): Unit = {\n-    replicasForTopicsToBeDeleted.groupBy(_.topic).keys.foreach { topic =>\n-      val aliveReplicasForTopic = controllerContext.allLiveReplicas().filter(p => p.topic == topic)\n-      val deadReplicasForTopic = replicasForTopicsToBeDeleted -- aliveReplicasForTopic\n+    val allDeadReplicasForTopic = mutable.Set.empty[PartitionAndReplica]", "originalCommit": "5fe1903ffc16cbbc76afcd1e5557576ed4410544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NjMyMQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376286321", "bodyText": "You are absolutely right. I thought that a Set was required because we add Sets but ListBuffer works perfectly.", "author": "dajac", "createdAt": "2020-02-07T09:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwMjg0Nw=="}], "type": "inlineReview"}, {"oid": "9d8f86d33a2d1593d63cd30380185c32899dff22", "url": "https://github.com/apache/kafka/commit/9d8f86d33a2d1593d63cd30380185c32899dff22", "message": "Address Jason's comments", "committedDate": "2020-02-07T09:13:48Z", "type": "commit"}, {"oid": "79e218ff74e32bd86961238a3f2d9dfc84847bfc", "url": "https://github.com/apache/kafka/commit/79e218ff74e32bd86961238a3f2d9dfc84847bfc", "message": "more refactoring", "committedDate": "2020-02-07T21:42:09Z", "type": "commit"}, {"oid": "93202700b6cad9f9fa0fb7ed2d5bb2f444b2685c", "url": "https://github.com/apache/kafka/commit/93202700b6cad9f9fa0fb7ed2d5bb2f444b2685c", "message": "more bits", "committedDate": "2020-02-07T23:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1NDQ1OQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376654459", "bodyText": "nit: leftover from debugging i assume", "author": "hachikuji", "createdAt": "2020-02-07T23:28:15Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -257,78 +260,81 @@ class TopicDeletionManager(config: KafkaConfig,\n    */\n   private def onTopicDeletion(topics: Set[String]): Unit = {\n     info(s\"Topic deletion callback for ${topics.mkString(\",\")}\")\n-    // send update metadata so that brokers stop serving data for topics to be deleted\n-    val partitions = topics.flatMap(controllerContext.partitionsForTopic)\n+    val partitions = mutable.Set.empty[TopicPartition]\n+    val mapBuilder = Map.newBuilder[String, Set[TopicPartition]]\n+    topics.foreach { topic =>\n+      val topicPartitions = controllerContext.partitionsForTopic(topic)\n+      mapBuilder += topic -> topicPartitions\n+      partitions ++= topicPartitions\n+    }\n+    val partitionsByTopic = mapBuilder.result\n+\n     val unseenTopicsForDeletion = topics -- controllerContext.topicsWithDeletionStarted\n     if (unseenTopicsForDeletion.nonEmpty) {\n-      val unseenPartitionsForDeletion = unseenTopicsForDeletion.flatMap(controllerContext.partitionsForTopic)\n+      val unseenPartitionsForDeletion = unseenTopicsForDeletion.flatMap(partitionsByTopic)\n       partitionStateMachine.handleStateChanges(unseenPartitionsForDeletion.toSeq, OfflinePartition)\n       partitionStateMachine.handleStateChanges(unseenPartitionsForDeletion.toSeq, NonExistentPartition)\n       // adding of unseenTopicsForDeletion to topics with deletion started must be done after the partition\n       // state changes to make sure the offlinePartitionCount metric is properly updated\n       controllerContext.beginTopicDeletion(unseenTopicsForDeletion)\n     }\n \n+    // send update metadata so that brokers stop serving data for topics to be deleted\n     client.sendMetadataUpdate(partitions)\n-    topics.foreach { topic =>\n-      onPartitionDeletion(controllerContext.partitionsForTopic(topic))\n-    }\n+\n+    onPartitionDeletion(partitionsByTopic)\n   }\n \n   /**\n-   * Invoked by onPartitionDeletion. It is the 2nd step of topic deletion, the first being sending\n-   * UpdateMetadata requests to all brokers to start rejecting requests for deleted topics. As part of starting deletion,\n-   * the topics are added to the in progress list. As long as a topic is in the in progress list, deletion for that topic\n-   * is never retried. A topic is removed from the in progress list when\n-   * 1. Either the topic is successfully deleted OR\n-   * 2. No replica for the topic is in ReplicaDeletionStarted state and at least one replica is in ReplicaDeletionIneligible state\n-   * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic\n-   * As part of starting deletion, all replicas are moved to the ReplicaDeletionStarted state where the controller sends\n-   * the replicas a StopReplicaRequest (delete=true)\n-   * This method does the following things -\n+   * Invoked by onTopicDeletion with the list of partitions for topics to be deleted\n+   * It does the following -\n    * 1. Move all dead replicas directly to ReplicaDeletionIneligible state. Also mark the respective topics ineligible\n    *    for deletion if some replicas are dead since it won't complete successfully anyway\n-   * 2. Move all alive replicas to ReplicaDeletionStarted state so they can be deleted successfully\n-   * @param replicasForTopicsToBeDeleted\n+   * 2. Move all replicas for the partitions to OfflineReplica state. This will send StopReplicaRequest to the replicas\n+   *    and LeaderAndIsrRequest to the leader with the shrunk ISR. When the leader replica itself is moved to OfflineReplica state,\n+   *    it will skip sending the LeaderAndIsrRequest since the leader will be updated to -1\n+   * 3. Move all replicas to ReplicaDeletionStarted state. This will send StopReplicaRequest with deletePartition=true. And\n+   *    will delete all persistent data from all replicas of the respective partitions\n    */\n-  private def startReplicaDeletion(replicasForTopicsToBeDeleted: Set[PartitionAndReplica]): Unit = {\n-    replicasForTopicsToBeDeleted.groupBy(_.topic).keys.foreach { topic =>\n-      val aliveReplicasForTopic = controllerContext.allLiveReplicas().filter(p => p.topic == topic)\n-      val deadReplicasForTopic = replicasForTopicsToBeDeleted -- aliveReplicasForTopic\n+  private def onPartitionDeletion(partitionsToBeDeleted: Map[String, Set[TopicPartition]]): Unit = {\n+    val allDeadReplicasForTopic = mutable.ListBuffer.empty[PartitionAndReplica]\n+    val allReplicasForDeletionRetry = mutable.ListBuffer.empty[PartitionAndReplica]\n+    val allTopicsIneligibleForDeletion = mutable.Set.empty[String]\n+\n+    partitionsToBeDeleted.foreach { case (topic, partitions) =>\n+      val replicasForTopicToBeDeleted = controllerContext.replicasForPartition(partitions)\n+      val aliveReplicasForTopic = controllerContext.liveReplicasForTopic(topic)\n+      val deadReplicasForTopic = replicasForTopicToBeDeleted -- aliveReplicasForTopic\n       val successfullyDeletedReplicas = controllerContext.replicasInState(topic, ReplicaDeletionSuccessful)\n       val replicasForDeletionRetry = aliveReplicasForTopic -- successfullyDeletedReplicas\n-      // move dead replicas directly to failed state\n-      replicaStateMachine.handleStateChanges(deadReplicasForTopic.toSeq, ReplicaDeletionIneligible)\n-      // send stop replica to all followers that are not in the OfflineReplica state so they stop sending fetch requests to the leader\n-      replicaStateMachine.handleStateChanges(replicasForDeletionRetry.toSeq, OfflineReplica)\n-      debug(s\"Deletion started for replicas ${replicasForDeletionRetry.mkString(\",\")}\")\n-      replicaStateMachine.handleStateChanges(replicasForDeletionRetry.toSeq, ReplicaDeletionStarted)\n+\n+      allDeadReplicasForTopic ++= deadReplicasForTopic\n+      allReplicasForDeletionRetry ++= replicasForDeletionRetry\n+\n       if (deadReplicasForTopic.nonEmpty) {\n         debug(s\"Dead Replicas (${deadReplicasForTopic.mkString(\",\")}) found for topic $topic\")\n-        markTopicIneligibleForDeletion(Set(topic), reason = \"offline replicas\")\n+        allTopicsIneligibleForDeletion += topic\n       }\n     }\n-  }\n \n-  /**\n-   * Invoked by onTopicDeletion with the list of partitions for topics to be deleted\n-   * It does the following -\n-   * 1. Send UpdateMetadataRequest to all live brokers (that are not shutting down) for partitions that are being\n-   *    deleted. The brokers start rejecting all client requests with UnknownTopicOrPartitionException\n-   * 2. Move all replicas for the partitions to OfflineReplica state. This will send StopReplicaRequest to the replicas\n-   *    and LeaderAndIsrRequest to the leader with the shrunk ISR. When the leader replica itself is moved to OfflineReplica state,\n-   *    it will skip sending the LeaderAndIsrRequest since the leader will be updated to -1\n-   * 3. Move all replicas to ReplicaDeletionStarted state. This will send StopReplicaRequest with deletePartition=true. And\n-   *    will delete all persistent data from all replicas of the respective partitions\n-   */\n-  private def onPartitionDeletion(partitionsToBeDeleted: Set[TopicPartition]): Unit = {\n-    info(s\"Partition deletion callback for ${partitionsToBeDeleted.mkString(\",\")}\")\n-    val replicasPerPartition = controllerContext.replicasForPartition(partitionsToBeDeleted)\n-    startReplicaDeletion(replicasPerPartition)\n+    // move dead replicas directly to failed state\n+    replicaStateMachine.handleStateChanges(allDeadReplicasForTopic, ReplicaDeletionIneligible)\n+    // send stop replica to all followers that are not in the OfflineReplica state so they stop sending fetch requests to the leader\n+    replicaStateMachine.handleStateChanges(allReplicasForDeletionRetry, OfflineReplica)\n+    debug(s\"Deletion started for replicas ${allReplicasForDeletionRetry.mkString(\",\")}\")\n+    replicaStateMachine.handleStateChanges(allReplicasForDeletionRetry, ReplicaDeletionStarted)\n+\n+    if (allTopicsIneligibleForDeletion.nonEmpty) {\n+      markTopicIneligibleForDeletion(allTopicsIneligibleForDeletion, reason = \"offline replicas\")\n+    }\n   }\n \n   private def resumeDeletions(): Unit = {\n+    println(\"resumeDeletions\")", "originalCommit": "93202700b6cad9f9fa0fb7ed2d5bb2f444b2685c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDU2Nw==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376660567", "bodyText": "I think onTopicDeletion doesn't do any filtering on partitions that are passed through to this method. Would it be simpler to skip the construction of the map and pass through the set of topics? Then we could provide a convenient accessor in ControllerContext to access the PartitionAndReplica objects by topic.", "author": "hachikuji", "createdAt": "2020-02-07T23:55:50Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -257,78 +260,81 @@ class TopicDeletionManager(config: KafkaConfig,\n    */\n   private def onTopicDeletion(topics: Set[String]): Unit = {\n     info(s\"Topic deletion callback for ${topics.mkString(\",\")}\")\n-    // send update metadata so that brokers stop serving data for topics to be deleted\n-    val partitions = topics.flatMap(controllerContext.partitionsForTopic)\n+    val partitions = mutable.Set.empty[TopicPartition]\n+    val mapBuilder = Map.newBuilder[String, Set[TopicPartition]]\n+    topics.foreach { topic =>\n+      val topicPartitions = controllerContext.partitionsForTopic(topic)\n+      mapBuilder += topic -> topicPartitions\n+      partitions ++= topicPartitions\n+    }\n+    val partitionsByTopic = mapBuilder.result\n+\n     val unseenTopicsForDeletion = topics -- controllerContext.topicsWithDeletionStarted\n     if (unseenTopicsForDeletion.nonEmpty) {\n-      val unseenPartitionsForDeletion = unseenTopicsForDeletion.flatMap(controllerContext.partitionsForTopic)\n+      val unseenPartitionsForDeletion = unseenTopicsForDeletion.flatMap(partitionsByTopic)\n       partitionStateMachine.handleStateChanges(unseenPartitionsForDeletion.toSeq, OfflinePartition)\n       partitionStateMachine.handleStateChanges(unseenPartitionsForDeletion.toSeq, NonExistentPartition)\n       // adding of unseenTopicsForDeletion to topics with deletion started must be done after the partition\n       // state changes to make sure the offlinePartitionCount metric is properly updated\n       controllerContext.beginTopicDeletion(unseenTopicsForDeletion)\n     }\n \n+    // send update metadata so that brokers stop serving data for topics to be deleted\n     client.sendMetadataUpdate(partitions)\n-    topics.foreach { topic =>\n-      onPartitionDeletion(controllerContext.partitionsForTopic(topic))\n-    }\n+\n+    onPartitionDeletion(partitionsByTopic)\n   }\n \n   /**\n-   * Invoked by onPartitionDeletion. It is the 2nd step of topic deletion, the first being sending\n-   * UpdateMetadata requests to all brokers to start rejecting requests for deleted topics. As part of starting deletion,\n-   * the topics are added to the in progress list. As long as a topic is in the in progress list, deletion for that topic\n-   * is never retried. A topic is removed from the in progress list when\n-   * 1. Either the topic is successfully deleted OR\n-   * 2. No replica for the topic is in ReplicaDeletionStarted state and at least one replica is in ReplicaDeletionIneligible state\n-   * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic\n-   * As part of starting deletion, all replicas are moved to the ReplicaDeletionStarted state where the controller sends\n-   * the replicas a StopReplicaRequest (delete=true)\n-   * This method does the following things -\n+   * Invoked by onTopicDeletion with the list of partitions for topics to be deleted\n+   * It does the following -\n    * 1. Move all dead replicas directly to ReplicaDeletionIneligible state. Also mark the respective topics ineligible\n    *    for deletion if some replicas are dead since it won't complete successfully anyway\n-   * 2. Move all alive replicas to ReplicaDeletionStarted state so they can be deleted successfully\n-   * @param replicasForTopicsToBeDeleted\n+   * 2. Move all replicas for the partitions to OfflineReplica state. This will send StopReplicaRequest to the replicas\n+   *    and LeaderAndIsrRequest to the leader with the shrunk ISR. When the leader replica itself is moved to OfflineReplica state,\n+   *    it will skip sending the LeaderAndIsrRequest since the leader will be updated to -1\n+   * 3. Move all replicas to ReplicaDeletionStarted state. This will send StopReplicaRequest with deletePartition=true. And\n+   *    will delete all persistent data from all replicas of the respective partitions\n    */\n-  private def startReplicaDeletion(replicasForTopicsToBeDeleted: Set[PartitionAndReplica]): Unit = {\n-    replicasForTopicsToBeDeleted.groupBy(_.topic).keys.foreach { topic =>\n-      val aliveReplicasForTopic = controllerContext.allLiveReplicas().filter(p => p.topic == topic)\n-      val deadReplicasForTopic = replicasForTopicsToBeDeleted -- aliveReplicasForTopic\n+  private def onPartitionDeletion(partitionsToBeDeleted: Map[String, Set[TopicPartition]]): Unit = {", "originalCommit": "93202700b6cad9f9fa0fb7ed2d5bb2f444b2685c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk4MTE2NA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376981164", "bodyText": "You're right. I've made another pass to simplify it.", "author": "dajac", "createdAt": "2020-02-10T10:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2MTg5NQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r376661895", "bodyText": "nit: remove this", "author": "hachikuji", "createdAt": "2020-02-08T00:02:18Z", "path": "core/src/test/scala/unit/kafka/controller/MockReplicaStateMachine.scala", "diffHunk": "@@ -17,10 +17,23 @@\n package kafka.controller\n \n import scala.collection.Seq\n+import scala.collection.mutable\n \n class MockReplicaStateMachine(controllerContext: ControllerContext) extends ReplicaStateMachine(controllerContext) {\n+  val stateChangesByTargetState = mutable.Map.empty[ReplicaState, Int].withDefaultValue(0)\n+\n+  def stateChangesCalls(targetState: ReplicaState): Int = {\n+    stateChangesByTargetState(targetState)\n+  }\n+\n+  def clear(): Unit = {\n+    stateChangesByTargetState.clear()\n+  }\n \n   override def handleStateChanges(replicas: Seq[PartitionAndReplica], targetState: ReplicaState): Unit = {\n+    println(replicas, targetState)", "originalCommit": "93202700b6cad9f9fa0fb7ed2d5bb2f444b2685c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5bdc951a4b00e30a617ca6684d7476018f025427", "url": "https://github.com/apache/kafka/commit/5bdc951a4b00e30a617ca6684d7476018f025427", "message": "simplify", "committedDate": "2020-02-10T09:56:22Z", "type": "commit"}, {"oid": "e2074b76f72a441e91f6f52ba339e1a5644abfdd", "url": "https://github.com/apache/kafka/commit/e2074b76f72a441e91f6f52ba339e1a5644abfdd", "message": "small refactor", "committedDate": "2020-02-10T10:26:46Z", "type": "commit"}, {"oid": "47431e693f64e7d199248633b4deec47681dcb6d", "url": "https://github.com/apache/kafka/commit/47431e693f64e7d199248633b4deec47681dcb6d", "message": "fix log", "committedDate": "2020-02-10T10:36:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzMTU0MA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377331540", "bodyText": "nit: space before @param", "author": "hachikuji", "createdAt": "2020-02-10T21:38:13Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -226,12 +227,12 @@ class TopicDeletionManager(config: KafkaConfig,\n   /**\n    * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic\n    * To ensure a successful retry, reset states for respective replicas from ReplicaDeletionIneligible to OfflineReplica state\n-   *@param topic Topic for which deletion should be retried\n+   *@param topics Topics for which deletion should be retried", "originalCommit": "47431e693f64e7d199248633b4deec47681dcb6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyNjQ5MQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377426491", "bodyText": "Since we're in here, I wonder if info is appropriate. Retry seems more like a debug?", "author": "hachikuji", "createdAt": "2020-02-11T02:49:57Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -226,12 +227,12 @@ class TopicDeletionManager(config: KafkaConfig,\n   /**\n    * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic\n    * To ensure a successful retry, reset states for respective replicas from ReplicaDeletionIneligible to OfflineReplica state\n-   *@param topic Topic for which deletion should be retried\n+   *@param topics Topics for which deletion should be retried\n    */\n-  private def retryDeletionForIneligibleReplicas(topic: String): Unit = {\n+  private def retryDeletionForIneligibleReplicas(topics: Set[String]): Unit = {\n     // reset replica states from ReplicaDeletionIneligible to OfflineReplica\n-    val failedReplicas = controllerContext.replicasInState(topic, ReplicaDeletionIneligible)\n-    info(s\"Retrying deletion of topic $topic since replicas ${failedReplicas.mkString(\",\")} were not successfully deleted\")\n+    val failedReplicas = topics.flatMap(controllerContext.replicasInState(_, ReplicaDeletionIneligible))\n+    info(s\"Retrying deletion of topics ${topics.mkString(\",\")} since replicas ${failedReplicas.mkString(\",\")} were not successfully deleted\")", "originalCommit": "47431e693f64e7d199248633b4deec47681dcb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MDU5NA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377490594", "bodyText": "I agree.", "author": "dajac", "createdAt": "2020-02-11T08:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyNjQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyNzU0MQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377427541", "bodyText": "Another message that could be quite large with a large batch of deletions. Do you think this message is useful at all? There are already log messages for the state transitions.", "author": "hachikuji", "createdAt": "2020-02-11T02:55:45Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -269,66 +268,62 @@ class TopicDeletionManager(config: KafkaConfig,\n       controllerContext.beginTopicDeletion(unseenTopicsForDeletion)\n     }\n \n-    client.sendMetadataUpdate(partitions)\n-    topics.foreach { topic =>\n-      onPartitionDeletion(controllerContext.partitionsForTopic(topic))\n-    }\n-  }\n+    // send update metadata so that brokers stop serving data for topics to be deleted\n+    client.sendMetadataUpdate(topics.flatMap(controllerContext.partitionsForTopic))\n \n-  /**\n-   * Invoked by onPartitionDeletion. It is the 2nd step of topic deletion, the first being sending\n-   * UpdateMetadata requests to all brokers to start rejecting requests for deleted topics. As part of starting deletion,\n-   * the topics are added to the in progress list. As long as a topic is in the in progress list, deletion for that topic\n-   * is never retried. A topic is removed from the in progress list when\n-   * 1. Either the topic is successfully deleted OR\n-   * 2. No replica for the topic is in ReplicaDeletionStarted state and at least one replica is in ReplicaDeletionIneligible state\n-   * If the topic is queued for deletion but deletion is not currently under progress, then deletion is retried for that topic\n-   * As part of starting deletion, all replicas are moved to the ReplicaDeletionStarted state where the controller sends\n-   * the replicas a StopReplicaRequest (delete=true)\n-   * This method does the following things -\n-   * 1. Move all dead replicas directly to ReplicaDeletionIneligible state. Also mark the respective topics ineligible\n-   *    for deletion if some replicas are dead since it won't complete successfully anyway\n-   * 2. Move all alive replicas to ReplicaDeletionStarted state so they can be deleted successfully\n-   * @param replicasForTopicsToBeDeleted\n-   */\n-  private def startReplicaDeletion(replicasForTopicsToBeDeleted: Set[PartitionAndReplica]): Unit = {\n-    replicasForTopicsToBeDeleted.groupBy(_.topic).keys.foreach { topic =>\n-      val aliveReplicasForTopic = controllerContext.allLiveReplicas().filter(p => p.topic == topic)\n-      val deadReplicasForTopic = replicasForTopicsToBeDeleted -- aliveReplicasForTopic\n-      val successfullyDeletedReplicas = controllerContext.replicasInState(topic, ReplicaDeletionSuccessful)\n-      val replicasForDeletionRetry = aliveReplicasForTopic -- successfullyDeletedReplicas\n-      // move dead replicas directly to failed state\n-      replicaStateMachine.handleStateChanges(deadReplicasForTopic.toSeq, ReplicaDeletionIneligible)\n-      // send stop replica to all followers that are not in the OfflineReplica state so they stop sending fetch requests to the leader\n-      replicaStateMachine.handleStateChanges(replicasForDeletionRetry.toSeq, OfflineReplica)\n-      debug(s\"Deletion started for replicas ${replicasForDeletionRetry.mkString(\",\")}\")\n-      replicaStateMachine.handleStateChanges(replicasForDeletionRetry.toSeq, ReplicaDeletionStarted)\n-      if (deadReplicasForTopic.nonEmpty) {\n-        debug(s\"Dead Replicas (${deadReplicasForTopic.mkString(\",\")}) found for topic $topic\")\n-        markTopicIneligibleForDeletion(Set(topic), reason = \"offline replicas\")\n-      }\n-    }\n+    onPartitionDeletion(topics)\n   }\n \n   /**\n    * Invoked by onTopicDeletion with the list of partitions for topics to be deleted\n    * It does the following -\n-   * 1. Send UpdateMetadataRequest to all live brokers (that are not shutting down) for partitions that are being\n-   *    deleted. The brokers start rejecting all client requests with UnknownTopicOrPartitionException\n+   * 1. Move all dead replicas directly to ReplicaDeletionIneligible state. Also mark the respective topics ineligible\n+   *    for deletion if some replicas are dead since it won't complete successfully anyway\n    * 2. Move all replicas for the partitions to OfflineReplica state. This will send StopReplicaRequest to the replicas\n    *    and LeaderAndIsrRequest to the leader with the shrunk ISR. When the leader replica itself is moved to OfflineReplica state,\n    *    it will skip sending the LeaderAndIsrRequest since the leader will be updated to -1\n    * 3. Move all replicas to ReplicaDeletionStarted state. This will send StopReplicaRequest with deletePartition=true. And\n    *    will delete all persistent data from all replicas of the respective partitions\n    */\n-  private def onPartitionDeletion(partitionsToBeDeleted: Set[TopicPartition]): Unit = {\n-    info(s\"Partition deletion callback for ${partitionsToBeDeleted.mkString(\",\")}\")\n-    val replicasPerPartition = controllerContext.replicasForPartition(partitionsToBeDeleted)\n-    startReplicaDeletion(replicasPerPartition)\n+  private def onPartitionDeletion(topicsToBeDeleted: Set[String]): Unit = {\n+    val allDeadReplicas = mutable.ListBuffer.empty[PartitionAndReplica]\n+    val allReplicasForDeletionRetry = mutable.ListBuffer.empty[PartitionAndReplica]\n+    val allTopicsIneligibleForDeletion = mutable.Set.empty[String]\n+\n+    topicsToBeDeleted.foreach { topic =>\n+      val (aliveReplicas, deadReplicas) = controllerContext.replicasForTopic(topic).partition { r =>\n+        controllerContext.isReplicaOnline(r.replica, r.topicPartition)\n+      }\n+\n+      val successfullyDeletedReplicas = controllerContext.replicasInState(topic, ReplicaDeletionSuccessful)\n+      val replicasForDeletionRetry = aliveReplicas -- successfullyDeletedReplicas\n+\n+      allDeadReplicas ++= deadReplicas\n+      allReplicasForDeletionRetry ++= replicasForDeletionRetry\n+\n+      if (deadReplicas.nonEmpty) {\n+        debug(s\"Dead Replicas (${deadReplicas.mkString(\",\")}) found for topic $topic\")\n+        allTopicsIneligibleForDeletion += topic\n+      }\n+    }\n+\n+    // move dead replicas directly to failed state\n+    replicaStateMachine.handleStateChanges(allDeadReplicas, ReplicaDeletionIneligible)\n+    // send stop replica to all followers that are not in the OfflineReplica state so they stop sending fetch requests to the leader\n+    replicaStateMachine.handleStateChanges(allReplicasForDeletionRetry, OfflineReplica)\n+    debug(s\"Deletion started for replicas ${allReplicasForDeletionRetry.mkString(\",\")}\")", "originalCommit": "47431e693f64e7d199248633b4deec47681dcb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MzU2OQ==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377493569", "bodyText": "You're right. It does not bring much. Let me remove it.", "author": "dajac", "createdAt": "2020-02-11T08:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQyNzU0MQ=="}], "type": "inlineReview"}, {"oid": "4375e6c07c8bf446fd441dce79de047553a8946e", "url": "https://github.com/apache/kafka/commit/4375e6c07c8bf446fd441dce79de047553a8946e", "message": "remove logs or reduce level", "committedDate": "2020-02-11T08:33:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjU3NA==", "url": "https://github.com/apache/kafka/pull/8053#discussion_r377496574", "bodyText": "FYI - I have removed this one as well because the information is redundant with the log in resumeDeletions.", "author": "dajac", "createdAt": "2020-02-11T08:36:33Z", "path": "core/src/main/scala/kafka/controller/TopicDeletionManager.scala", "diffHunk": "@@ -256,9 +257,6 @@ class TopicDeletionManager(config: KafkaConfig,\n    * removed from their caches.\n    */\n   private def onTopicDeletion(topics: Set[String]): Unit = {\n-    info(s\"Topic deletion callback for ${topics.mkString(\",\")}\")", "originalCommit": "4375e6c07c8bf446fd441dce79de047553a8946e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}