{"pr_number": 9409, "pr_title": "KAFKA-10599: Implement basic CLI tool for feature versioning system", "pr_createdAt": "2020-10-11T09:49:09Z", "pr_url": "https://github.com/apache/kafka/pull/9409", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "aa639287eef752f050aa39bf87dfe9cc6638832c", "url": "https://github.com/apache/kafka/commit/aa639287eef752f050aa39bf87dfe9cc6638832c", "message": "KAFKA-10599: Implement basic CLI tool for feature versioning system", "committedDate": "2020-10-12T03:45:09Z", "type": "commit"}, {"oid": "aa639287eef752f050aa39bf87dfe9cc6638832c", "url": "https://github.com/apache/kafka/commit/aa639287eef752f050aa39bf87dfe9cc6638832c", "message": "KAFKA-10599: Implement basic CLI tool for feature versioning system", "committedDate": "2020-10-12T03:45:09Z", "type": "forcePushed"}, {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "url": "https://github.com/apache/kafka/commit/06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "message": "Minor changes", "committedDate": "2020-10-12T16:59:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0Mzc5Ng==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503443796", "bodyText": "Is the \\n necessary?", "author": "abbccdda", "createdAt": "2020-10-12T17:44:27Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExMzU2MQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504113561", "bodyText": "Yeah, it provides a separation between the regular o/p and the error.", "author": "kowshik", "createdAt": "2020-10-13T16:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0Mzc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NDkyOQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503444929", "bodyText": "I feel we don't need the has prefix for all the options, which seem not matching with the conventions by looking at examples as CofnigCommand.scala", "author": "abbccdda", "createdAt": "2020-10-12T17:46:53Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjEyOA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504116128", "bodyText": "This convention is used in TopicCommand.scala. See: https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/admin/TopicCommand.scala#L698-L702", "author": "kowshik", "createdAt": "2020-10-13T16:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NjEwMw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503446103", "bodyText": "A random thought I have is that since describe/upgrade/downgrade are mutually-exclusive, we could define one flag like --action and pass in the different options as strings to translate the an enum matching scenario.", "author": "abbccdda", "createdAt": "2020-10-12T17:49:31Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)\n+\n+  def hasFromControllerOption: Boolean = has(fromControllerOpt)\n+\n+  def hasDryRunOption: Boolean = has(dryRunOpt)\n+\n+  def hasUpgradeAllOption: Boolean = has(upgradeAllOpt)", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDExNA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503494114", "bodyText": "@abbccdda How do you envision the proposed --action flag for the advanced CLI scenarios where we would want to allow for --upgrade, --downgrade and --delete options as part of the same CLI command? Please see this section of the KIP. As such, the existing technique allows us to support the advanced CLI facilities in the future.", "author": "kowshik", "createdAt": "2020-10-12T19:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NjEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NzMxMg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503447312", "bodyText": "Could we just log a warning in this case instead of failing?", "author": "abbccdda", "createdAt": "2020-10-12T17:52:09Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)\n+\n+  def hasFromControllerOption: Boolean = has(fromControllerOpt)\n+\n+  def hasDryRunOption: Boolean = has(dryRunOpt)\n+\n+  def hasUpgradeAllOption: Boolean = has(upgradeAllOpt)\n+\n+  def hasDowngradeAllOption: Boolean = has(downgradeAllOpt)\n+\n+  def bootstrapServers: String = options.valueOf(bootstrapServerOpt)\n+\n+  def checkArgs(): Unit = {\n+    CommandLineUtils.printHelpAndExitIfNeeded(this, \"This tool describes and updates finalized features.\")\n+    val numActions = Seq(describeOpt, upgradeAllOpt, downgradeAllOpt).count(has)\n+    if (numActions != 1) {\n+      CommandLineUtils.printUsageAndDie(\n+        parser,\n+        \"Command must include exactly one action: --describe, --upgrade-all, --downgrade-all.\")\n+    }\n+    CommandLineUtils.checkRequiredArgs(parser, options, bootstrapServerOpt)\n+    if (hasDryRunOption && !hasUpgradeAllOption && !hasDowngradeAllOption) {\n+      CommandLineUtils.printUsageAndDie(\n+        parser,\n+        \"Command can contain --dry-run option only when either --upgrade-all or --downgrade-all actions are provided.\")\n+    }\n+    if (hasFromControllerOption && !hasDescribeOption) {", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNzgxOA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504117818", "bodyText": "What do we lose by making a stricter check? This is not the expected usage of the command, and therefore it should be disallowed.", "author": "kowshik", "createdAt": "2020-10-13T17:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NzMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE1MjM2MA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504152360", "bodyText": "I just don't see it hinders the command to succeed, which means it's an ignorable property. Anyway, I'm not insisting either.", "author": "abbccdda", "createdAt": "2020-10-13T18:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NzMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NjY4MQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504296681", "bodyText": "Sounds good. I'll mark this resolved since you don't feel strongly about t.", "author": "kowshik", "createdAt": "2020-10-13T22:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NzMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0OTY1Nw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503449657", "bodyText": "I'm not sure the exception thrown here is necessary since we already printed out the result, is this just for testing purpose?", "author": "abbccdda", "createdAt": "2020-10-12T17:57:21Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODAyOQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504118029", "bodyText": "Done. Good point. This is fixed now, as we are no longer printing exception from within FeatureCommand.main. Yes, the exception as such is useful for testing too.", "author": "kowshik", "createdAt": "2020-10-13T17:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0OTY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MjYxMw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503452613", "bodyText": "nit: case not necessary", "author": "abbccdda", "createdAt": "2020-10-12T18:01:58Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODM3OQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504118379", "bodyText": "Done.", "author": "kowshik", "createdAt": "2020-10-13T17:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MjYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MzIyMw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503453223", "bodyText": "Why do we need to sort the features?", "author": "abbccdda", "createdAt": "2020-10-12T18:02:38Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExODgyOQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504118829", "bodyText": "It is easy to compare command outputs when they are sorted based on feature names. Also, it is easier to write unit/integration tests when the output is uniform.", "author": "kowshik", "createdAt": "2020-10-13T17:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1NDQzNA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503454434", "bodyText": "nit: we could do the comment immediately after the version get extracted, just like moving L132 to be after L113", "author": "abbccdda", "createdAt": "2020-10-12T18:05:24Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTM1NQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504121355", "bodyText": "Done.", "author": "kowshik", "createdAt": "2020-10-13T17:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1NDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1OTA2MQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503459061", "bodyText": "Do we need a downgrade failure test as well?", "author": "abbccdda", "createdAt": "2020-10-12T18:13:44Z", "path": "core/src/test/scala/unit/kafka/admin/FeatureCommandTest.scala", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.api.KAFKA_2_7_IV0\n+import kafka.server.{BaseRequestTest, KafkaConfig, KafkaServer}\n+import kafka.utils.TestUtils\n+import kafka.utils.TestUtils.waitUntilTrue\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.Test\n+import org.scalatest.Assertions.intercept\n+\n+class FeatureCommandTest extends BaseRequestTest {\n+  override def brokerCount: Int = 3\n+\n+  override def brokerPropertyOverrides(props: Properties): Unit = {\n+    props.put(KafkaConfig.InterBrokerProtocolVersionProp, KAFKA_2_7_IV0.toString)\n+  }\n+\n+  private def defaultSupportedFeatures(): Features[SupportedVersionRange] = {\n+    Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 3)),\n+                                           Utils.mkEntry(\"feature_2\", new SupportedVersionRange(1, 5))))\n+  }\n+\n+  private def updateSupportedFeatures(features: Features[SupportedVersionRange],\n+                                      targetServers: Set[KafkaServer]): Unit = {\n+    targetServers.foreach(s => {\n+      s.brokerFeatures.setSupportedFeatures(features)\n+      s.zkClient.updateBrokerInfo(s.createBrokerInfo)\n+    })\n+\n+    // Wait until updates to all BrokerZNode supported features propagate to the controller.\n+    val brokerIds = targetServers.map(s => s.config.brokerId)\n+    waitUntilTrue(\n+      () => servers.exists(s => {\n+        if (s.kafkaController.isActive) {\n+          s.kafkaController.controllerContext.liveOrShuttingDownBrokers\n+            .filter(b => brokerIds.contains(b.id))\n+            .forall(b => {\n+              b.features.equals(features)\n+            })\n+        } else {\n+          false\n+        }\n+      }),\n+      \"Controller did not get broker updates\")\n+  }\n+\n+  private def updateSupportedFeaturesInAllBrokers(features: Features[SupportedVersionRange]): Unit = {\n+    updateSupportedFeatures(features, Set[KafkaServer]() ++ servers)\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#describeFeatures API works as expected when describing features before and\n+   * after upgrading features.\n+   */\n+  @Test\n+  def testDescribeFeaturesSuccess(): Unit = {\n+    updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+    val featureApis = new FeatureApis(new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--describe\", \"--from-controller\")))\n+    featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+    try {\n+      val initialDescribeOutput = TestUtils.grabConsoleOutput(featureApis.describeFeatures())\n+      val expectedInitialDescribeOutput =\n+        \"Feature: feature_1\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 3\\tFinalizedMinVersionLevel: -\\tFinalizedMaxVersionLevel: -\\tEpoch: 0\\n\" +\n+        \"Feature: feature_2\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 5\\tFinalizedMinVersionLevel: -\\tFinalizedMaxVersionLevel: -\\tEpoch: 0\\n\"\n+      assertEquals(expectedInitialDescribeOutput, initialDescribeOutput)\n+      featureApis.upgradeAllFeatures()\n+      val finalDescribeOutput = TestUtils.grabConsoleOutput(featureApis.describeFeatures())\n+      val expectedFinalDescribeOutput =\n+        \"Feature: feature_1\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 3\\tFinalizedMinVersionLevel: 1\\tFinalizedMaxVersionLevel: 3\\tEpoch: 1\\n\" +\n+        \"Feature: feature_2\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 5\\tFinalizedMinVersionLevel: 1\\tFinalizedMaxVersionLevel: 5\\tEpoch: 1\\n\"\n+      assertEquals(expectedFinalDescribeOutput, finalDescribeOutput)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#upgradeAllFeatures API works as expected during a success case.\n+   */\n+  @Test\n+  def testUpgradeAllFeaturesSuccess(): Unit = {\n+    val upgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--upgrade-all\"))\n+    val featureApis = new FeatureApis(upgradeOpts)\n+    try {\n+      // Step (1):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade non-existing feature_1 to maxVersionLevel: 2.\n+      // - Verify results.\n+      val initialSupportedFeatures = Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 2))))\n+      updateSupportedFeaturesInAllBrokers(initialSupportedFeatures)\n+      featureApis.setSupportedFeatures(initialSupportedFeatures)\n+      var output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      var expected =\n+        \"      [Add]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: -\\tNewFinalizedMaxVersion: 2\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (2):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade existing feature_1 to maxVersionLevel: 3.\n+      // - Upgrade non-existing feature_2 to maxVersionLevel: 5.\n+      // - Verify results.\n+      updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+      featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      expected =\n+        \"  [Upgrade]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 2\\tNewFinalizedMaxVersion: 3\\tResult: OK\\n\" +\n+        \"      [Add]\\tFeature: feature_2\\tExistingFinalizedMaxVersion: -\\tNewFinalizedMaxVersion: 5\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (3):\n+      // - Perform an upgrade of all features again.\n+      // - Since supported features have not changed, expect that the above action does not yield\n+      //   any results.\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+      featureApis.setOptions(upgradeOpts)\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#downgradeAllFeatures API works as expected during a success case.\n+   */\n+  @Test\n+  def testDowngradeFeaturesSuccess(): Unit = {\n+    val downgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--downgrade-all\"))\n+    val upgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--upgrade-all\"))\n+    val featureApis = new FeatureApis(upgradeOpts)\n+    try {\n+      // Step (1):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade non-existing feature_1 to maxVersionLevel: 3.\n+      // - Upgrade non-existing feature_2 to maxVersionLevel: 5.\n+      updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+      featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+      featureApis.upgradeAllFeatures()\n+\n+      // Step (2):\n+      // - Downgrade existing feature_1 to maxVersionLevel: 2.\n+      // - Delete feature_2 since it is no longer supported by the FeatureApis object.\n+      // - Verify results.\n+      val downgradedFeatures = Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 2))))\n+      featureApis.setSupportedFeatures(downgradedFeatures)\n+      featureApis.setOptions(downgradeOpts)\n+      var output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      var expected =\n+        \"[Downgrade]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 3\\tNewFinalizedMaxVersion: 2\\tResult: OK\\n\" +\n+        \"   [Delete]\\tFeature: feature_2\\tExistingFinalizedMaxVersion: 5\\tNewFinalizedMaxVersion: -\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (3):\n+      // - Perform a downgrade of all features again.\n+      // - Since supported features have not changed, expect that the above action does not yield\n+      //   any results.\n+      updateSupportedFeaturesInAllBrokers(downgradedFeatures)\n+      output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+\n+      // Step (4):\n+      // - Delete feature_1 since it is no longer supported by the FeatureApis object.\n+      // - Verify results.\n+      featureApis.setSupportedFeatures(Features.emptySupportedFeatures())\n+      output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      expected =\n+        \"   [Delete]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 2\\tNewFinalizedMaxVersion: -\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#upgradeAllFeatures API works as expected during a partial failure case.\n+   */\n+  @Test\n+  def testUpgradeFeaturesFailure(): Unit = {", "originalCommit": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODUwNQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504138505", "bodyText": "As such the downgrade can not fail currently on the server. The reason is the following: the FeatureCommand downgrades maxVersionLevel of existing finalized features to the max versions that it knows internally (since it links with the BrokerFeatures library). As a result, the only situation when the FeatureCommand can fail is if it tries to downgrade below the supported minVersion. But this can never happen since we don't (yet) have the facility on the broker to have a supported minVersion > 1 (this can only happen during feature deprecation, the support for this is future work).\nOn a side note, we could maybe write a test using AdminClientUnitTestEnv to create a mock setup specifically for the downgrade test and inject a mock admin client into the FeatureApis class. But that looks overkill to me...", "author": "kowshik", "createdAt": "2020-10-13T17:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1OTA2MQ=="}], "type": "inlineReview"}, {"oid": "4c57b7de4e8e93f008bc5089a615c1a539ce63c1", "url": "https://github.com/apache/kafka/commit/4c57b7de4e8e93f008bc5089a615c1a539ce63c1", "message": "Address comments from Boyang", "committedDate": "2020-10-13T17:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMTQxMg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504831412", "bodyText": "nit: we could make these functions package private", "author": "abbccdda", "createdAt": "2020-10-14T16:56:47Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {", "originalCommit": "4c57b7de4e8e93f008bc5089a615c1a539ce63c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxNTM5Mw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504915393", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-14T19:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMTQxMg=="}], "type": "inlineReview"}, {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "url": "https://github.com/apache/kafka/commit/b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "message": "Address comment from Boyang", "committedDate": "2020-10-14T19:19:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxOTI2NQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505019265", "bodyText": "Perhaps we can describe the format is host:port list.", "author": "junrao", "createdAt": "2020-10-14T22:22:34Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTcwNg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681706", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-16T19:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxOTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzE5Nw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505073197", "bodyText": "Perhaps we could use Option to avoid null?", "author": "junrao", "createdAt": "2020-10-14T23:40:13Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTc0OA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681748", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-16T19:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzY3Mg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505073672", "bodyText": "Could we use case to avoid unnamed reference _._1?", "author": "junrao", "createdAt": "2020-10-14T23:40:53Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTc3Mw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681773", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-16T19:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NDY0Mw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505074643", "bodyText": "Could we use case to avoid unnamed reference _._1?", "author": "junrao", "createdAt": "2020-10-14T23:42:16Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTgwMg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681802", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-16T19:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NDY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NzkxMQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505077911", "bodyText": "Do we need to get the cause from ExecutionException thrown from Future?", "author": "junrao", "createdAt": "2020-10-14T23:47:02Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTg4Nw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681887", "bodyText": "Done. I'm printing the exception toString output now, instead of getMessage.", "author": "kowshik", "createdAt": "2020-10-16T19:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4MTIxNg==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505081216", "bodyText": "The bootstrap port may be secured (e.g., SSL, SASL). So we need to be able to pass in the security configs from the command line. See commandConfigOpt in TopicCommand.", "author": "junrao", "createdAt": "2020-10-14T23:52:08Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTkyOA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681928", "bodyText": "Done. Great point! I've provided an additional arg: --command-config <path_to_properties> file that can be used to inject the additional properties into admin client.", "author": "kowshik", "createdAt": "2020-10-16T19:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4MTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4NjQ2MQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505086461", "bodyText": "Could this be a val?", "author": "junrao", "createdAt": "2020-10-14T23:59:36Z", "path": "core/src/test/scala/unit/kafka/admin/FeatureCommandTest.scala", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.api.KAFKA_2_7_IV0\n+import kafka.server.{BaseRequestTest, KafkaConfig, KafkaServer}\n+import kafka.utils.TestUtils\n+import kafka.utils.TestUtils.waitUntilTrue\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.Test\n+import org.scalatest.Assertions.intercept\n+\n+class FeatureCommandTest extends BaseRequestTest {\n+  override def brokerCount: Int = 3\n+\n+  override def brokerPropertyOverrides(props: Properties): Unit = {\n+    props.put(KafkaConfig.InterBrokerProtocolVersionProp, KAFKA_2_7_IV0.toString)\n+  }\n+\n+  private def defaultSupportedFeatures(): Features[SupportedVersionRange] = {", "originalCommit": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MTk2OA==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506681968", "bodyText": "Done", "author": "kowshik", "createdAt": "2020-10-16T19:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4NjQ2MQ=="}], "type": "inlineReview"}, {"oid": "0ef54f5aad2acaa3734200332daaf7787219d0df", "url": "https://github.com/apache/kafka/commit/0ef54f5aad2acaa3734200332daaf7787219d0df", "message": "Address comments from Jun", "committedDate": "2020-10-16T19:35:42Z", "type": "commit"}, {"oid": "98f6888d44181e22decd4371877a7b935d963706", "url": "https://github.com/apache/kafka/commit/98f6888d44181e22decd4371877a7b935d963706", "message": "Small changes", "committedDate": "2020-10-16T19:42:18Z", "type": "commit"}, {"oid": "0c4906b50154c24025fc55966beb6b420eb18180", "url": "https://github.com/apache/kafka/commit/0c4906b50154c24025fc55966beb6b420eb18180", "message": "Small change", "committedDate": "2020-10-16T19:43:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NjM5Ng==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506696396", "bodyText": "If we hit ExecutionException and the exception has a cause, the wrapper ExecutionException is not really relevant and we should just print the cause. See TopicCommand as a reference.", "author": "junrao", "createdAt": "2020-10-16T20:05:50Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,393 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge feature APIs provided by the the Admin client with\n+ * the requirements of the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = {\n+    val props = new Properties()\n+    props.putAll(opts.commandConfig)\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, Some((updateStr, new FeatureUpdate(targetVersionRange.max, false))))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, Some((updateStr, new FeatureUpdate(targetVersionRange.max, false))))\n+          } else {\n+            (feature, Option.empty)\n+          }\n+        }\n+    }.filter {\n+      case(_, updateInfo) => updateInfo.isDefined\n+    }.map {\n+      case(feature, updateInfo) => (feature, updateInfo.get)\n+    }.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, Some(updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, Some(updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, Option.empty)\n+          }\n+        }\n+    }.filter {\n+      case(_, updateInfo) => updateInfo.isDefined\n+    }.map {\n+      case(feature, updateInfo) => (feature, updateInfo.get)\n+    }.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\" + ListMap(\n+        updates\n+          .toSeq\n+          .sortBy { case(feature, _) => feature} :_*)\n+          .map { case(_, (updateStr, _)) => updateStr}\n+          .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates\n+          .map { case(feature, (_, update)) => (feature, update)}\n+          .asJava,\n+        new UpdateFeaturesOptions())\n+      val resultSortedByFeature = ListMap(\n+        result\n+          .values\n+          .asScala\n+          .toSeq\n+          .sortBy { case(feature, _) => feature} :_*)\n+      val failures = resultSortedByFeature.map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e)", "originalCommit": "0c4906b50154c24025fc55966beb6b420eb18180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczMDE5NQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506730195", "bodyText": "Done. Great point!", "author": "kowshik", "createdAt": "2020-10-16T21:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5ODEyMw==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506698123", "bodyText": "It seems that we can hit ExecutionException through describeFeatures. We want to handle it properly too.", "author": "junrao", "createdAt": "2020-10-16T20:10:12Z", "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,393 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>", "originalCommit": "0c4906b50154c24025fc55966beb6b420eb18180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczMDIxOQ==", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506730219", "bodyText": "Done.", "author": "kowshik", "createdAt": "2020-10-16T21:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5ODEyMw=="}], "type": "inlineReview"}, {"oid": "7a03f973b18d2468cd8a114e5b7ce22f2bf279b4", "url": "https://github.com/apache/kafka/commit/7a03f973b18d2468cd8a114e5b7ce22f2bf279b4", "message": "Address comments from Jun", "committedDate": "2020-10-16T21:31:39Z", "type": "commit"}, {"oid": "ecdb0830e433bd445d73bd51c9ea50a0226afc01", "url": "https://github.com/apache/kafka/commit/ecdb0830e433bd445d73bd51c9ea50a0226afc01", "message": "Small improvement", "committedDate": "2020-10-16T22:24:15Z", "type": "commit"}, {"oid": "2e568285c314102b9e4f7351badfcdf73a5c5a53", "url": "https://github.com/apache/kafka/commit/2e568285c314102b9e4f7351badfcdf73a5c5a53", "message": "Small improvement", "committedDate": "2020-10-16T22:32:10Z", "type": "commit"}]}