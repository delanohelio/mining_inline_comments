{"pr_number": 8181, "pr_title": "KAFKA-9584 Headers ConcurrentModificationException", "pr_createdAt": "2020-02-27T06:12:55Z", "pr_url": "https://github.com/apache/kafka/pull/8181", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjMxOQ==", "url": "https://github.com/apache/kafka/pull/8181#discussion_r492316319", "bodyText": "This is fine, but note that the new consumer record here is just a roundabout way to create a ProcessorRecordContext. It'd probably be better to just directly instantiate the context we want.", "author": "vvcephei", "createdAt": "2020-09-21T20:07:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -581,8 +580,8 @@ public void punctuate(final ProcessorNode node, final long timestamp, final Punc\n         if (processorContext.currentNode() != null) {\n             throw new IllegalStateException(format(\"%sCurrent node is not null\", logPrefix));\n         }\n-\n-        updateProcessorContext(new StampedRecord(DUMMY_RECORD, timestamp), node);\n+        \n+        updateProcessorContext(new StampedRecord(new ConsumerRecord<>(ProcessorContextImpl.NONEXIST_TOPIC, -1, -1L, null, null), timestamp), node);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MDgxNQ==", "url": "https://github.com/apache/kafka/pull/8181#discussion_r492360815", "bodyText": "From my understanding, neither the ConsumerRecord nor the ProcessroRecordContext are the issue, but the shared Header object -- it's just a \"side effect\" that creating a new ConsumerRecord creates an new Header object internally.", "author": "mjsax", "createdAt": "2020-09-21T21:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2OTg5NA==", "url": "https://github.com/apache/kafka/pull/8181#discussion_r494369894", "bodyText": "Yes, that's more or less what I was concerned about. We are trying to achieve a specific result here (and brand-new 'Header' instance each time), but it's only achieved via a side effect.\nOn the other hand, I just took a closer look at the code, and I see that there's a better reason to keep using ConsumerRecord, namely that updateProcessorContext is used both for regular processing (with \"real\" records) and for punctuation here with this dummy record. It seems like a good idea to prevent those code paths from diverging, so I'm +1 with keeping this change as-is.", "author": "vvcephei", "createdAt": "2020-09-24T14:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjMxOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "2abe2abfbfe06dd793f300b2557b736ea6ef4638", "url": "https://github.com/apache/kafka/commit/2abe2abfbfe06dd793f300b2557b736ea6ef4638", "message": "KAFKA-9584 Headers ConcurrentModificationException", "committedDate": "2020-09-26T02:17:30Z", "type": "commit"}, {"oid": "2abe2abfbfe06dd793f300b2557b736ea6ef4638", "url": "https://github.com/apache/kafka/commit/2abe2abfbfe06dd793f300b2557b736ea6ef4638", "message": "KAFKA-9584 Headers ConcurrentModificationException", "committedDate": "2020-09-26T02:17:30Z", "type": "forcePushed"}]}