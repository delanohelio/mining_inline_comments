{"pr_number": 7994, "pr_title": "KAFKA-9437: KIP-559: Make the Kafka Protocol Friendlier with L7 Proxies", "pr_createdAt": "2020-01-21T19:30:49Z", "pr_url": "https://github.com/apache/kafka/pull/7994", "timeline": [{"oid": "effa65da5c10d837c60532730a9d9b5726b2087e", "url": "https://github.com/apache/kafka/commit/effa65da5c10d837c60532730a9d9b5726b2087e", "message": "KIP-559: Make the Kafka Protocol Friendlier with L7 Proxies", "committedDate": "2020-01-23T13:10:45Z", "type": "commit"}, {"oid": "effa65da5c10d837c60532730a9d9b5726b2087e", "url": "https://github.com/apache/kafka/commit/effa65da5c10d837c60532730a9d9b5726b2087e", "message": "KIP-559: Make the Kafka Protocol Friendlier with L7 Proxies", "committedDate": "2020-01-23T13:10:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzNTY0OA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r370235648", "bodyText": "Actually, it should be areProtocolTypeAndNameMissing.", "author": "dajac", "createdAt": "2020-01-23T16:50:52Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/SyncGroupRequest.java", "diffHunk": "@@ -81,6 +81,10 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return groupAssignments;\n     }\n \n+    public boolean areProtocolTypeAndNamePresent() {", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzNTgzNQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r370235835", "bodyText": "Fix the typo.", "author": "dajac", "createdAt": "2020-01-23T16:51:11Z", "path": "clients/src/main/resources/common/message/SyncGroupRequest.json", "diffHunk": "@@ -22,7 +22,11 @@\n   // Starting from version 3, we add a new field called groupInstanceId to indicate member identity across restarts.\n   //\n   // Version 4 is the first flexible version.\n-  \"validVersions\": \"0-4\",\n+  //\n+  // Starting from version 5, the client sends the Protocol Type and the Protocol Name\n+  // to the broker (KIP-599). THe broker will reject the request if they are inconsistent", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6988e54801d8894520bc0e6c123f7a19b08e7a62", "url": "https://github.com/apache/kafka/commit/6988e54801d8894520bc0e6c123f7a19b08e7a62", "message": "fixup", "committedDate": "2020-01-26T04:39:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NjY3NA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r371966674", "bodyText": "The version check is probably not necessary. Also, shouldn't we be checking for non-null entries?", "author": "hachikuji", "createdAt": "2020-01-28T18:03:29Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/SyncGroupRequest.java", "diffHunk": "@@ -81,6 +81,10 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return groupAssignments;\n     }\n \n+    public boolean areProtocolTypeAndNamePresent() {\n+        return version() >= 5 && (data.protocolType() == null || data.protocolName() == null);", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzNTc2MA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372035760", "bodyText": "I think that we need the version check. ProtocolType and ProtocolName are null by default thus they will be null here for all the versions oldest than version 5 and we must accept them, right? However, for newer version, we want to ensure that both fields are provided.\nRegarding the non-null entries, the verification (== provided values match the group's ones) is done in the GroupCoordinator when the fields are provided. Does it answer your question?", "author": "dajac", "createdAt": "2020-01-28T20:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0NjYxNQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372146615", "bodyText": "Maybe I'm missing something, but the function name suggests that it should return true if both the protocol type and name are non-null. The current logic returns true if either field is null. Are we missing a !?", "author": "hachikuji", "createdAt": "2020-01-29T01:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MjQwMA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372162400", "bodyText": "Oh... The name is indeed misleading. I have reworked this part a bit. Now, the function is called areMandatoryProtocolTypeAndNamePresent. It returns true for any version above 5, and verifies that both fields are non-null for versions from 5 and above. The call is the Api layer has been updated accordingly. Apparently, my unit tests were broken as well as I was not calling the right function. Good catch!", "author": "dajac", "createdAt": "2020-01-29T02:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NjY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NTk0MQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r371975941", "bodyText": "nit: I'd suggest making each one of these \"stanzas\" a separate test case", "author": "hachikuji", "createdAt": "2020-01-28T18:22:03Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -1143,17 +1154,120 @@ class GroupCoordinatorTest {\n       initialRebalanceResult.generation + 1,\n       Set(leaderInstanceId, followerInstanceId, newMemberInstanceId),\n       groupId,\n-      CompletingRebalance)\n+      CompletingRebalance,\n+      Some(protocolType))\n \n     checkJoinGroupResult(newFollowerResult,\n       Errors.NONE,\n       initialRebalanceResult.generation + 1,\n       Set.empty,\n       groupId,\n       CompletingRebalance,\n+      Some(protocolType),\n       expectedLeaderId = newLeaderResult.memberId)\n   }\n \n+  @Test\n+  def testProtocolTypeInJoinAndSyncRequest(): Unit = {\n+    // JoinGroup(leader): The Protocol Type is None when there is an error\n+    EasyMock.reset(replicaManager)\n+    var leaderResponseFuture = sendJoinGroup(groupId, \"fake-id\", protocolType,\n+      protocolSuperset, leaderInstanceId, DefaultSessionTimeout)\n+\n+    var leaderJoinGroupResult = await(leaderResponseFuture, 1)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, leaderJoinGroupResult.error)\n+    assertEquals(None, leaderJoinGroupResult.protocolType)\n+\n+    // JoinGroup(leader): The Protocol Type is Defined when there is not error\n+    EasyMock.reset(replicaManager)\n+    leaderResponseFuture = sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType,\n+      protocolSuperset, leaderInstanceId, DefaultSessionTimeout)\n+\n+    // JoinGroup(follower): The Protocol Type is Defined when there is not error", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMjE0Ng==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372032146", "bodyText": "You're right. Let me separate them.", "author": "dajac", "createdAt": "2020-01-28T20:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NjI1Ng==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r371976256", "bodyText": "Would it be worth adding explicit matchers for these?", "author": "hachikuji", "createdAt": "2020-01-28T18:22:39Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -676,37 +691,274 @@ class KafkaApisTest {\n       anyInt,\n       anyInt,\n       anyString,\n-      EasyMock.eq(protocols.map(protocol => (protocol.name, protocol.metadata))),\n+      EasyMock.capture(capturedProtocols),\n       anyObject()\n     ))\n \n+    EasyMock.replay(groupCoordinator)\n+\n     createKafkaApis().handleJoinGroupRequest(\n       buildRequest(\n         new JoinGroupRequest.Builder(\n           new JoinGroupRequestData()\n             .setGroupId(\"test\")\n             .setMemberId(\"test\")\n             .setProtocolType(\"consumer\")\n-            .setProtocols(new JoinGroupRequestData.JoinGroupRequestProtocolCollection(protocols.iterator.asJava))\n-        )\n-      )._2)\n+            .setProtocols(new JoinGroupRequestData.JoinGroupRequestProtocolCollection(\n+              protocols.map { case (name, protocol) => new JoinGroupRequestProtocol()\n+                .setName(name).setMetadata(protocol)\n+              }.iterator.asJava))\n+        ).build()\n+      ))\n \n-    EasyMock.replay(groupCoordinator)\n+    EasyMock.verify(groupCoordinator)\n+\n+    val capturedProtocolsList = capturedProtocols.getValue\n+    assertEquals(protocols.size, capturedProtocolsList.size)\n+    protocols.zip(capturedProtocolsList).foreach { case ((expectedName, expectedBytes), (name, bytes)) =>\n+      assertEquals(expectedName, name)\n+      assertArrayEquals(expectedBytes, bytes)\n+    }\n+  }\n+\n+  @Test\n+  def testJoinGroupProtocolType(): Unit = {\n+    for (version <- ApiKeys.JOIN_GROUP.oldestVersion to ApiKeys.JOIN_GROUP.latestVersion) {\n+      testJoinGroupProtocolType(version.asInstanceOf[Short])\n+    }\n+  }\n+\n+  def testJoinGroupProtocolType(version: Short): Unit = {\n+    EasyMock.reset(groupCoordinator, clientRequestQuotaManager, requestChannel)\n+\n+    val capturedResponse = expectNoThrottling()\n+\n+    val groupId = \"group\"\n+    val memberId = \"member1\"\n+    val protocolType = \"consumer\"\n+    val protocols = List(\n+      new JoinGroupRequestProtocol().setName(\"first\").setMetadata(\"first\".getBytes()),\n+      new JoinGroupRequestProtocol().setName(\"second\").setMetadata(\"second\".getBytes())\n+    )\n+\n+    val capturedCallback = EasyMock.newCapture[JoinGroupCallback]()\n+\n+    EasyMock.expect(groupCoordinator.handleJoinGroup(\n+      anyString,", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA1ODg5Mw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372058893", "bodyText": "Good point. Being explicit is way better for sure.", "author": "dajac", "createdAt": "2020-01-28T21:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NjczMw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r371976733", "bodyText": "Should we change Generation.protocol to protocolName as well?", "author": "hachikuji", "createdAt": "2020-01-28T18:23:36Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -887,6 +900,14 @@ protected synchronized void requestRejoin() {\n         this.rejoinNeeded = true;\n     }\n \n+    private boolean isProtocolTypeInconsistent(String protocolType) {\n+        return protocolType != null && !protocolType.equals(protocolType());\n+    }\n+\n+    private boolean isProtocolNameInconsistent(String protocolName) {\n+        return protocolName != null && !protocolName.equals(generation().protocol);", "originalCommit": "effa65da5c10d837c60532730a9d9b5726b2087e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMTkxNw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r372031917", "bodyText": "Definitely. Good catch!", "author": "dajac", "createdAt": "2020-01-28T20:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3NjczMw=="}], "type": "inlineReview"}, {"oid": "525e84d283eac94fca1ef0ffa069d35fd63ed172", "url": "https://github.com/apache/kafka/commit/525e84d283eac94fca1ef0ffa069d35fd63ed172", "message": "Address Jason's reviews", "committedDate": "2020-01-28T21:24:06Z", "type": "commit"}, {"oid": "aa1008664116a7bc4c3084811982913e1e928482", "url": "https://github.com/apache/kafka/commit/aa1008664116a7bc4c3084811982913e1e928482", "message": "Address reviews", "committedDate": "2020-01-29T02:27:28Z", "type": "commit"}, {"oid": "832a6dbb2e0bd31de4045370e862ad9cd37db219", "url": "https://github.com/apache/kafka/commit/832a6dbb2e0bd31de4045370e862ad9cd37db219", "message": "typo", "committedDate": "2020-01-29T02:52:17Z", "type": "commit"}, {"oid": "f3457905bf31539a59db5888b912aa812880b1fa", "url": "https://github.com/apache/kafka/commit/f3457905bf31539a59db5888b912aa812880b1fa", "message": "fixup", "committedDate": "2020-01-29T13:16:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1MjUwNQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373352505", "bodyText": "nit: I'd suggest breaking this into two separate cases so that the user doesn't have to guess what was inconsistent. Also, can we include the expected value?", "author": "hachikuji", "createdAt": "2020-01-31T07:54:01Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -704,7 +712,12 @@ public void handle(JoinGroupResponse joinResponse, RequestFuture<ByteBuffer> fut\n         public void handle(SyncGroupResponse syncResponse,\n                            RequestFuture<ByteBuffer> future) {\n             Errors error = syncResponse.error();\n-            if (error == Errors.NONE) {\n+            if (isProtocolTypeInconsistent(syncResponse.data.protocolType())\n+                || isProtocolNameInconsistent(syncResponse.data.protocolName())) {\n+                log.debug(\"SyngGroup failed: Received inconsistent ProtocolType ({}) and/or ProtocolName ({})\",", "originalCommit": "f3457905bf31539a59db5888b912aa812880b1fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUxMjkxOQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373512919", "bodyText": "That makes sense. I will also include the expected value.", "author": "dajac", "createdAt": "2020-01-31T14:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1MjUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1NDczOQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373354739", "bodyText": "I think the error code should take precedence over this validation. Perhaps we do this only when the error is NONE? Similarly for the JoinGroup response.", "author": "hachikuji", "createdAt": "2020-01-31T08:01:43Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -704,7 +712,12 @@ public void handle(JoinGroupResponse joinResponse, RequestFuture<ByteBuffer> fut\n         public void handle(SyncGroupResponse syncResponse,\n                            RequestFuture<ByteBuffer> future) {\n             Errors error = syncResponse.error();\n-            if (error == Errors.NONE) {\n+            if (isProtocolTypeInconsistent(syncResponse.data.protocolType())", "originalCommit": "f3457905bf31539a59db5888b912aa812880b1fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUxMzMzNw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373513337", "bodyText": "You're right. Let me do this.", "author": "dajac", "createdAt": "2020-01-31T14:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1NDczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1ODIxOQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373358219", "bodyText": "nit: we could do this in a single line with a dual assignment val (protocolType, protocolName) = ...", "author": "hachikuji", "createdAt": "2020-01-31T08:13:52Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -917,8 +929,10 @@ class GroupCoordinator(val brokerId: Int,\n   }\n \n   private def propagateAssignment(group: GroupMetadata, error: Errors): Unit = {\n+    val protocolType = if (error == Errors.NONE) group.protocolType else None", "originalCommit": "f3457905bf31539a59db5888b912aa812880b1fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MDA0NQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373360045", "bodyText": "The inconsistency with SyncGroup is a little annoying, but I guess we have to keep it for compatibility. I was considering if it's worthwhile making the this field nullable going forward.", "author": "hachikuji", "createdAt": "2020-01-31T08:19:30Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1285,13 +1290,35 @@ case class GroupConfig(groupMinSessionTimeoutMs: Int,\n case class JoinGroupResult(members: List[JoinGroupResponseMember],\n                            memberId: String,\n                            generationId: Int,\n-                           subProtocol: String,\n+                           protocolType: Option[String],\n+                           protocolName: String,\n                            leaderId: String,\n                            error: Errors)\n \n-case class SyncGroupResult(memberAssignment: Array[Byte],\n+object JoinGroupResult {\n+  def apply(memberId: String, error: Errors): JoinGroupResult = {\n+    JoinGroupResult(\n+      members = List.empty,\n+      memberId = memberId,\n+      generationId = GroupCoordinator.NoGeneration,\n+      protocolType = None,\n+      protocolName = GroupCoordinator.NoProtocol,", "originalCommit": "f3457905bf31539a59db5888b912aa812880b1fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3NDkyNA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373574924", "bodyText": "You bring a really good point that I haven't considered. I have been looking at it and I think that it makes sense to make it nullable going forward. It means that Protocol Name would be null in case of an error instead of an empty string for versions 7 and above. Overall, it makes the internals better, the API more consistent and the changes in the API layer to handle the backward compatibility are small. Moreover, the impact on clients is very limited as likely few or none of them relies on the Protocol Name in case of an error. We don't for instance. Long story short, I am up for it.\nI went ahead and made the changes, let me know what do you think.", "author": "dajac", "createdAt": "2020-01-31T16:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjI2Nw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373822267", "bodyText": "From a non OO language perspective, changing the protocol name field in the join group response from non-null to nullable isn't the greatest / is backwards incompatible.\nEffectively, in Go, either I consider the string type in protocol to be a legitimate object that can at some future point be nullable, or I use the Go string primitive and hope that the Java side never changes the equation.\nThis will be the first instance of a primitive (non array) switching from non-nullable to nullable. So, while from a backwards compatibility perspective, there are no problems for the Java client, there are problems for clients of non-OO languages.\nBecause of the incompatibility, I can add support for decoding null as non-null, but I can't really add support for allowing the field itself in the JoinGroupResponse struct to be null. To do so would effectively necessitate adding a second field (non-null field v6 and below, nullable field v7 up).", "author": "twmb", "createdAt": "2020-02-02T06:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTI2NQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r375175265", "bodyText": "Thank you for your feedback. You bring a point that we haven't considered. I think that it is more challenging for languages where the string type is not an object such a Go.\nHave you considered changing the field type to a pointer to a string? Usually, the internal protocol is not exposed to the users of the consumer thus changing the type should only impact the internals which seems acceptable. That being said, I am not aware of your project so I may be completely wrong.", "author": "dajac", "createdAt": "2020-02-05T10:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwODgyNA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r376108824", "bodyText": "I think switching to a pointer now is alright. I agree about the internal protocol not usually being exposed, so it's probably alright to have more backwards incompatible changes in that. The API of the protocol is public, though, to theoretically allow anybody to build on top of it.\nIt's a work in progress, but barring integration tests showing clear failures, the API is complete.", "author": "twmb", "createdAt": "2020-02-06T22:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MTIwOQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373361209", "bodyText": "nit: \"an none\" seems ungrammatical", "author": "hachikuji", "createdAt": "2020-01-31T08:23:19Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -1143,17 +1154,123 @@ class GroupCoordinatorTest {\n       initialRebalanceResult.generation + 1,\n       Set(leaderInstanceId, followerInstanceId, newMemberInstanceId),\n       groupId,\n-      CompletingRebalance)\n+      CompletingRebalance,\n+      Some(protocolType))\n \n     checkJoinGroupResult(newFollowerResult,\n       Errors.NONE,\n       initialRebalanceResult.generation + 1,\n       Set.empty,\n       groupId,\n       CompletingRebalance,\n+      Some(protocolType),\n       expectedLeaderId = newLeaderResult.memberId)\n   }\n \n+  @Test\n+  def testJoinGroupReturnsAnNoneProtocolTypeWhenAnErrorOccurs(): Unit = {", "originalCommit": "f3457905bf31539a59db5888b912aa812880b1fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUxNTEwMw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373515103", "bodyText": "Indeed. I am not sure how I managed to write this ;)", "author": "dajac", "createdAt": "2020-01-31T14:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM2MTIwOQ=="}], "type": "inlineReview"}, {"oid": "8c160c96a266767182baaf3885770be9fbce16d9", "url": "https://github.com/apache/kafka/commit/8c160c96a266767182baaf3885770be9fbce16d9", "message": "Address Jason's comments", "committedDate": "2020-01-31T14:51:00Z", "type": "commit"}, {"oid": "6b7813176ef50d117a6f6107f75f989b23fdb7d7", "url": "https://github.com/apache/kafka/commit/6b7813176ef50d117a6f6107f75f989b23fdb7d7", "message": "Make ProtocolType nullable in the JoinGroupResponse", "committedDate": "2020-01-31T16:37:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3NTkzNQ==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373575935", "bodyText": "With the nullable Protocol Name, the code generator generates unreachable condition. I have added an exception for the time being and will address this in a follow up PR if you don't mind. It does not impact the behaviour of this PR.", "author": "dajac", "createdAt": "2020-01-31T16:44:16Z", "path": "gradle/spotbugs-exclude.xml", "diffHunk": "@@ -222,6 +222,12 @@ For a detailed description of spotbugs bug categories, see https://spotbugs.read\n         <Bug pattern=\"MS_MUTABLE_ARRAY\"/>\n     </Match>\n \n+    <Match>\n+        <!-- The code generator generates useless condition. Disable the check temporarily. -->\n+        <Class name=\"org.apache.kafka.common.message.JoinGroupResponseData\"/>\n+        <Bug pattern=\"UC_USELESS_CONDITION\"/>\n+    </Match>\n+", "originalCommit": "6b7813176ef50d117a6f6107f75f989b23fdb7d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDcwMw==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373820703", "bodyText": "KIP-559 (and elsewhere)", "author": "twmb", "createdAt": "2020-02-02T05:34:01Z", "path": "clients/src/main/resources/common/message/JoinGroupResponse.json", "diffHunk": "@@ -29,7 +29,9 @@\n   // Version 5 is bumped to apply group.instance.id to identify member across restarts.\n   //\n   // Version 6 is the first flexible version.\n-  \"validVersions\": \"0-6\",\n+  //\n+  // Starting from version 7, the broker sends back the Protocol Type to the client (KIP-599).", "originalCommit": "6b7813176ef50d117a6f6107f75f989b23fdb7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE2Mjg3NA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r375162874", "bodyText": "Good catch! Thanks!", "author": "dajac", "createdAt": "2020-02-05T10:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDcwOA==", "url": "https://github.com/apache/kafka/pull/7994#discussion_r373820708", "bodyText": "KIP-559", "author": "twmb", "createdAt": "2020-02-02T05:34:08Z", "path": "clients/src/main/resources/common/message/SyncGroupRequest.json", "diffHunk": "@@ -22,7 +22,11 @@\n   // Starting from version 3, we add a new field called groupInstanceId to indicate member identity across restarts.\n   //\n   // Version 4 is the first flexible version.\n-  \"validVersions\": \"0-4\",\n+  //\n+  // Starting from version 5, the client sends the Protocol Type and the Protocol Name\n+  // to the broker (KIP-599). The broker will reject the request if they are inconsistent", "originalCommit": "6b7813176ef50d117a6f6107f75f989b23fdb7d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}