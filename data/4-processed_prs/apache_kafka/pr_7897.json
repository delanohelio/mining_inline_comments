{"pr_number": 7897, "pr_title": "KAFKA-9365: Add server side change  to include consumer group information within transaction commit", "pr_createdAt": "2020-01-05T05:58:01Z", "pr_url": "https://github.com/apache/kafka/pull/7897", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYwOA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071608", "bodyText": "This is a clean-up as there is a duplicate struct in JoinGroupRequest already", "author": "abbccdda", "createdAt": "2020-01-05T06:04:57Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/JoinGroupResponse.java", "diffHunk": "@@ -31,7 +31,6 @@\n \n     public static final String UNKNOWN_PROTOCOL = \"\";\n     public static final int UNKNOWN_GENERATION_ID = -1;\n-    public static final String UNKNOWN_MEMBER_ID = \"\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MTIyNw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364461227", "bodyText": "Great!", "author": "guozhangwang", "createdAt": "2020-01-08T21:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYyMw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071623", "bodyText": "This file only contains clean-ups.", "author": "abbccdda", "createdAt": "2020-01-05T06:05:32Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -279,7 +279,7 @@ public void testGroupMaxSizeExceptionIsFatal() {\n         mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTY1Mw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071653", "bodyText": "We couldn't use JoinGroupRequest/Response defined structs here due to import control", "author": "abbccdda", "createdAt": "2020-01-05T06:06:07Z", "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,16 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                requestData.setGroupInstanceId(null);\n+                requestData.setMemberId(\"\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTcxMg==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071712", "bodyText": "The generation.id check needs to be put upfront before L734 as it treats txn commit same as assign mode consumer", "author": "abbccdda", "createdAt": "2020-01-05T06:07:30Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTc5Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071796", "bodyText": "It's debatable whether we should continue going to group state based for commit logic for transactional commit as well. We decide to leave it as it is for now, unless the group state becomes concerning factor.", "author": "abbccdda", "createdAt": "2020-01-05T06:09:48Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {\n+        // Validate non-zero generation id for both transactional and non-transactional commits.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.ILLEGAL_GENERATION })\n+      } else if (group.isUnknownCommit(memberId, producerId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (generationId < 0 && group.is(Empty) || producerId != NO_PRODUCER_ID) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTgwMA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071800", "bodyText": "clean-up for duplicate val.", "author": "abbccdda", "createdAt": "2020-01-05T06:10:12Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1169,7 +1172,6 @@ object GroupCoordinator {\n   val NoProtocol = \"\"\n   val NoLeader = \"\"\n   val NoGeneration = -1\n-  val NoMemberId = \"\"", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTg1MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071850", "bodyText": "Although it is possible to create a more condensed xx and (yy || zz) expression, I found current verbose version is more readable and understandable.", "author": "abbccdda", "createdAt": "2020-01-05T06:11:24Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadata.scala", "diffHunk": "@@ -402,6 +404,15 @@ private[group] class GroupMetadata(val groupId: String, initialState: GroupState\n       false\n   }\n \n+  def isUnknownCommit(memberId: String,\n+                      producerId: Long): Boolean = {\n+    if (producerId != NO_PRODUCER_ID) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2Njc1Nw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364466757", "bodyText": "prop: See my other comment: I think manual commit could not happen for txnal commit, and if yes we could make the caller logic more explicit -- it means a bit more LOC, but the logic is more readable.", "author": "guozhangwang", "createdAt": "2020-01-08T22:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTkzMA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071930", "bodyText": "By adding reset in the end of helper function, we reduced redundant replica manager reset.", "author": "abbccdda", "createdAt": "2020-01-05T06:14:08Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -1222,6 +1200,7 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.NONE, followerSyncGroupResult._2)\n     assertTrue(getGroup(groupId).is(Stable))\n \n+    EasyMock.reset(replicaManager)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MTE1NA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364461154", "bodyText": "qq: Hmm, why we can retry with UNKNOWN_MEMBER_ID?", "author": "guozhangwang", "createdAt": "2020-01-08T21:51:57Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -1465,15 +1465,14 @@ public void handleResponse(AbstractResponse response) {\n                         lookupCoordinator(FindCoordinatorRequest.CoordinatorType.GROUP, builder.data.groupId());\n                     }\n                 } else if (error == Errors.UNKNOWN_TOPIC_OR_PARTITION\n-                        || error == Errors.COORDINATOR_LOAD_IN_PROGRESS) {\n-                    // If the topic is unknown or the coordinator is loading, retry with the current coordinator\n+                        || error == Errors.COORDINATOR_LOAD_IN_PROGRESS\n+                        || error == Errors.UNKNOWN_MEMBER_ID) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU5MjQ4MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364592480", "bodyText": "This is to match the same behavior on the consumer side. After some thoughts I don't think this is actually correct behavior as we are using the additional information for fencing purposes.", "author": "abbccdda", "createdAt": "2020-01-09T07:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MTE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MjM0OA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364462348", "bodyText": "qq: Why not setting the default to UNKNOWN_GENERATION_ID etc for those new fields? It seems above we treat them as sentinel values anyways -- i.e. if they are not set, then setting them to those \"unknown\" values is safe and we check that if they are not unknown then the version should be newer.", "author": "guozhangwang", "createdAt": "2020-01-08T21:55:00Z", "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364466039", "bodyText": "prop: I'd propose we just make the producerId != NO_PRODUCER_ID condition in the first place to explicitly separate the checking logic for transactional / non-txnal commit starting at 732, e.g.:\nif (producerId != NO_PRODUCER_ID) {\n   // check if it is unknown\n} else {\n   // check if it is unknown, and\n   // check if it is manual\n}\n\nBecause if producer != NO_PRODUCER_ID it should never be manual, or am I wrong?", "author": "guozhangwang", "createdAt": "2020-01-08T22:04:18Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {\n+        // Validate non-zero generation id for both transactional and non-transactional commits.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.ILLEGAL_GENERATION })\n+      } else if (group.isUnknownCommit(memberId, producerId, generationId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (group.isManualCommit(generationId) || producerId != NO_PRODUCER_ID) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkyNDk3Mg==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364924972", "bodyText": "I think the example with KIP-98 is actually doing assign mode, single writer producer.\nSo the answer is false, txn commit could be manual", "author": "abbccdda", "createdAt": "2020-01-09T19:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzE3NQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365477175", "bodyText": "What I'm thinking is mainly for debuggability, wondering if we explicitly separate the logic of txn / non-txn commit it is more readable -- currently the isUnknownCommit and isManualCommit are a bit mixed.\nThinking about this a bit more, how about the following within a single function (ordered):\n\n\nif generation id < 0 or state is Empty, we just bindly store offset (we can actually be stricter and check that member.id should always be UNKNOWN, but this is not there before so we do not really need to enforce it).\n\n\nelse, check memberId != JoinGroupRequest.UNKNOWN_MEMBER_ID && !has(memberId).\n\n\nFor both txn commit or consumer commit, 2) should be the case. So we do not need to really distinguish on producerId --- i.e. previously if the producerId is set we do not do the check of 2), now we always do it regardless. Is that correct?", "author": "guozhangwang", "createdAt": "2020-01-11T00:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MjgxOQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365482819", "bodyText": "I think this actually looks like a much simpler version, just to add up after case 2), we need two more cases:\n3. else if generationId >= 0 && generationId != group.generationId we return ILLEGAL_GENERATION\n4. else if producerId != NO_PRODUCER_ID we blindly store offsets\nThe case 3 is necessary for generation check on both txn and non-txn commits. The case 4) is necessary as we don't want txn commit fall into group case match, where we actually do a val member = group.get(memberId). The member.id could still be unknown at this moment with an older txn producer who doesn't pack in consumer metadata.", "author": "abbccdda", "createdAt": "2020-01-11T00:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5NjY3Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365496676", "bodyText": "If we refactor the logic in the proposed way, testCommitOffsetInCompletingRebalanceFromUnknownMemberId will fail as we are not able to catch the unknown member.id when the commit is non-txn.\nMy main argument is that the complexity we are handling here is under-estimated, in a sense that for txn commit we also need to worry about whether this producer is on the old version or new version. I would attempt a separation logic just as what we did for doJoinGroup and doUnknownJoinGroup which is able to separate the txn vs non-txn commits", "author": "abbccdda", "createdAt": "2020-01-11T03:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NzE4MQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364467181", "bodyText": "nit: why UNKNOWN_GENERATION_ID and UNKNOWN_PROTOCOL belongs to response while UNKNOWN_MEMBER_ID belongs to request? If there's no real good reason let's put them in a single class.", "author": "guozhangwang", "createdAt": "2020-01-08T22:07:23Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1410,10 +1410,10 @@ class KafkaApis(val requestChannel: RequestChannel,\n       // the group.instance.id field, so static members could accidentally become \"dynamic\", which leads to wrong states.\n       sendResponseCallback(JoinGroupResult(\n         List.empty,\n-        JoinGroupResponse.UNKNOWN_MEMBER_ID,\n+        JoinGroupRequest.UNKNOWN_MEMBER_ID,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzI1MQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364897251", "bodyText": "I think it makes sense to move all the constant to request class.", "author": "abbccdda", "createdAt": "2020-01-09T18:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NzE4MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzM2MQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365477361", "bodyText": "Why reset the replica manager mock here?", "author": "guozhangwang", "createdAt": "2020-01-11T00:09:05Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2443,6 +2422,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithIllegalGeneration(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5NTc1Nw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365495757", "bodyText": "As we have used dynamicJoinGroup IIUC", "author": "abbccdda", "createdAt": "2020-01-11T03:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzM2MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1OTI4OQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366059289", "bodyText": "Since TxnOffsetCommit has been converted to use the generated protocol and we are bumping it here, let's add flexible version support. I was going to do this in #7931, but we may as well just do one version bump instead of two.", "author": "hachikuji", "createdAt": "2020-01-13T22:18:58Z", "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -20,7 +20,9 @@\n   // Version 1 is the same as version 0.\n   //\n   // Version 2 adds the committed leader epoch.\n-  \"validVersions\": \"0-2\",\n+  //\n+  // Version 3 adds the member.id, group.instance.id and generation.id.\n+  \"validVersions\": \"0-3\",\n   \"flexibleVersions\": \"none\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQzOTgyMg==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366439822", "bodyText": "If we make these fatal errors, then the user will have to close the producer and instantiate a new one. I think as long as the producer can still abort the transaction, they should be abortable errors.", "author": "hachikuji", "createdAt": "2020-01-14T16:27:35Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -1497,4 +1495,13 @@ public void handleResponse(AbstractResponse response) {\n             }\n         }\n     }\n+\n+    private boolean isFatalException(Errors error) {\n+        return error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED\n+                || error == Errors.INVALID_PRODUCER_EPOCH\n+                || error == Errors.UNSUPPORTED_FOR_MESSAGE_FORMAT\n+                || error == Errors.FENCED_INSTANCE_ID\n+                || error == Errors.UNKNOWN_MEMBER_ID", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3MTA2OQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366471069", "bodyText": "The purpose of throwing these exceptions should be catching user's attention IMO, as this indicates something going wrong on the consumer side. So if this is abortable error, how could we inform application(i.e consumer) level that sth is going wrong? Or we believe that as long as the consumer is in a bad state, it will get itself fenced eventually?", "author": "abbccdda", "createdAt": "2020-01-14T17:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQzOTgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ3NDE4Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366474186", "bodyText": "Abortable errors are still propagated to the user. But the user can abort the transaction and continue with the same producer. A fatal error on the other hand requires the user to close the producer.", "author": "hachikuji", "createdAt": "2020-01-14T17:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQzOTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ0MTExMA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366441110", "bodyText": "Let's add flexible version support in the response also.", "author": "hachikuji", "createdAt": "2020-01-14T16:29:41Z", "path": "clients/src/main/resources/common/message/TxnOffsetCommitResponse.json", "diffHunk": "@@ -18,8 +18,11 @@\n   \"type\": \"response\",\n   \"name\": \"TxnOffsetCommitResponse\",\n   // Starting in version 1, on quota violation, brokers send out responses before throttling.\n+  //\n   // Version 2 is the same as version 1.\n-  \"validVersions\": \"0-2\",\n+  //\n+  // Version 3 adds illegal generation, fenced instance id, and unknown member id errors.\n+  \"validVersions\": \"0-3\",\n   \"flexibleVersions\": \"none\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc0e77f6488028214fa1242869005f618c20d395", "url": "https://github.com/apache/kafka/commit/dc0e77f6488028214fa1242869005f618c20d395", "message": "add fencing", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "1624afa9d42316240d02521aa43cb3a057888015", "url": "https://github.com/apache/kafka/commit/1624afa9d42316240d02521aa43cb3a057888015", "message": "enforce on consumer commit generation", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "a0bdca618ccb5488ee6b543255a2f5e0a3efcf09", "url": "https://github.com/apache/kafka/commit/a0bdca618ccb5488ee6b543255a2f5e0a3efcf09", "message": "consolidate constants and put unknown.member.id as fatal exception", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "04e4d269eb9b50c3352ea40be017795e98ec79e2", "url": "https://github.com/apache/kafka/commit/04e4d269eb9b50c3352ea40be017795e98ec79e2", "message": "fencing fix", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "a3ec3429abbff25111d74d03250296b43e61dca0", "url": "https://github.com/apache/kafka/commit/a3ec3429abbff25111d74d03250296b43e61dca0", "message": "address Guozhang's comment on simplifying the commit logic", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "6c001dd81a295dd3eb649c191c87ae3f7db017e3", "url": "https://github.com/apache/kafka/commit/6c001dd81a295dd3eb649c191c87ae3f7db017e3", "message": "bump flexible versions for txn commit", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "2017357b974b1e12dca6a9ea4c822c6aa8380756", "url": "https://github.com/apache/kafka/commit/2017357b974b1e12dca6a9ea4c822c6aa8380756", "message": "convert to abortable error", "committedDate": "2020-01-14T17:39:48Z", "type": "commit"}, {"oid": "2017357b974b1e12dca6a9ea4c822c6aa8380756", "url": "https://github.com/apache/kafka/commit/2017357b974b1e12dca6a9ea4c822c6aa8380756", "message": "convert to abortable error", "committedDate": "2020-01-14T17:39:48Z", "type": "forcePushed"}, {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "url": "https://github.com/apache/kafka/commit/9fbb4528f1f1b71649df4a60751d03271aa03ec3", "message": "minor clean", "committedDate": "2020-01-14T17:59:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ5ODgxMg==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366498812", "bodyText": "Should we set the default to \"\"?", "author": "hachikuji", "createdAt": "2020-01-14T18:23:54Z", "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,\n+      \"about\": \"The generation of the consumer.\" },\n+    { \"name\": \"MemberId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,", "originalCommit": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ5OTcxNA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366499714", "bodyText": "It's a bit inconsistent to set these as ignorable if the builder actually raises an exception. I would suggest making them non-ignorable and removing the checks inside the builder.", "author": "hachikuji", "createdAt": "2020-01-14T18:25:47Z", "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,\n+      \"about\": \"The generation of the consumer.\" },\n+    { \"name\": \"MemberId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,\n+      \"about\": \"The member ID assigned by the group coordinator.\" },\n+    { \"name\": \"GroupInstanceId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,", "originalCommit": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMTY2NA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366501664", "bodyText": "These test cases are a bit odd. Why would we get a FENCED_INSTANCE_ID if we have not provided an instance id? I think it would make sense to do all of the client changes in a single PR and all the server changes in a separate PR. I'm ok doing them all at once also since this PR is not that big.", "author": "hachikuji", "createdAt": "2020-01-14T18:29:43Z", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java", "diffHunk": "@@ -940,6 +943,99 @@ public void testUnsupportedForMessageFormatInTxnOffsetCommit() {\n         assertFatalError(UnsupportedForMessageFormatException.class);\n     }\n \n+    @Test\n+    public void testFencedInstanceIdInTxnOffsetCommit() {", "originalCommit": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyNDE0MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366524140", "bodyText": "Cool, I will separate the PR to leave only server side changes", "author": "abbccdda", "createdAt": "2020-01-14T19:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMjM2Mw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366502363", "bodyText": "nit: I think it would be a little cleaner to rely on the defaults from the schema. So if we don't have a GroupMetadata object, then we don't set anything.", "author": "hachikuji", "createdAt": "2020-01-14T18:31:11Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/JoinGroupRequest.java", "diffHunk": "@@ -120,10 +122,10 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return new JoinGroupResponse(new JoinGroupResponseData()\n                 .setThrottleTimeMs(throttleTimeMs)\n                 .setErrorCode(Errors.forException(e).code())\n-                .setGenerationId(JoinGroupResponse.UNKNOWN_GENERATION_ID)\n-                .setProtocolName(JoinGroupResponse.UNKNOWN_PROTOCOL)\n-                .setLeader(JoinGroupResponse.UNKNOWN_MEMBER_ID)\n-                .setMemberId(JoinGroupResponse.UNKNOWN_MEMBER_ID)\n+                .setGenerationId(UNKNOWN_GENERATION_ID)", "originalCommit": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMzYxMw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366513613", "bodyText": "Sorry, wrong request type here. Please ignore.", "author": "hachikuji", "createdAt": "2020-01-14T18:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMjM2Mw=="}], "type": "inlineReview"}, {"oid": "57b278e7c538a2810e0d4da36a364d31d5319ce1", "url": "https://github.com/apache/kafka/commit/57b278e7c538a2810e0d4da36a364d31d5319ce1", "message": "Some comments from Jason", "committedDate": "2020-01-14T19:29:21Z", "type": "commit"}, {"oid": "437f8456983ba6234644c62a5cbfee5e77814cfb", "url": "https://github.com/apache/kafka/commit/437f8456983ba6234644c62a5cbfee5e77814cfb", "message": "revert client side changes", "committedDate": "2020-01-14T19:34:25Z", "type": "commit"}, {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "url": "https://github.com/apache/kafka/commit/943bdf3604b662dfd20e7cfd586ada10e3412bc8", "message": "checkstyle fix", "committedDate": "2020-01-14T20:19:53Z", "type": "commit"}, {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "url": "https://github.com/apache/kafka/commit/943bdf3604b662dfd20e7cfd586ada10e3412bc8", "message": "checkstyle fix", "committedDate": "2020-01-14T20:19:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjU4Mg==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366606582", "bodyText": "It's confusing that we call testAllMessageRoundTripsFromVersion here, because it will fail for the first version we pass in (ie, the internal for loop is not required. It would be easier to understand the test if we call testEquivalentMessageRoundTrip instead.\nApplies to there places too -- also to PR you do in parallel IIRC.", "author": "mjsax", "createdAt": "2020-01-14T22:28:31Z", "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,20 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                final short finalVersion = version;\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwODYxOQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366608619", "bodyText": "Also, we actually want to test that, if any of the three new fields is set on a lower version we get UnsupportedVersionException -- hence, for each case, we should set two fields to null IMHO. Atm, the test logic is somewhat confusing.", "author": "mjsax", "createdAt": "2020-01-14T22:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY2NTU2OQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366665569", "bodyText": "Yep, this is correct observation!", "author": "abbccdda", "createdAt": "2020-01-15T02:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNzc2MQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366607761", "bodyText": "Same here -- we actually loop through the version in the outer loop, so why do we need to loop through them again? Effectively, we run tests for smaller versions multiple times?", "author": "mjsax", "createdAt": "2020-01-14T22:31:51Z", "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,20 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                final short finalVersion = version;\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setGroupInstanceId(null);\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setMemberId(\"\");\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setGenerationId(-1);\n+            }\n+\n             testAllMessageRoundTripsFromVersion(version, requestData);", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwOTk3MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366609970", "bodyText": "Why do we need to check generationId >= 0 ?", "author": "mjsax", "createdAt": "2020-01-14T22:37:48Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -706,12 +706,39 @@ class GroupCoordinator(val brokerId: Int,\n     groupManager.scheduleHandleTxnCompletion(producerId, offsetsPartitions.map(_.partition).toSet, isCommit)\n   }\n \n+  private def doTxnCommitOffsets(group: GroupMetadata,\n+                                 memberId: String,\n+                                 groupInstanceId: Option[String],\n+                                 generationId: Int,\n+                                 producerId: Long,\n+                                 producerEpoch: Short,\n+                                 offsetMetadata: immutable.Map[TopicPartition, OffsetAndMetadata],\n+                                 responseCallback: immutable.Map[TopicPartition, Errors] => Unit): Unit = {\n+    group.inLock {\n+      if (group.is(Dead)) {\n+        // if the group is marked as dead, it means some other thread has just removed the group\n+        // from the coordinator metadata; it is likely that the group has migrated to some other\n+        // coordinator OR the group is in a transient unstable phase. Let the member retry\n+        // finding the correct coordinator and rejoin.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n+      } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n+      } else if (memberId != JoinGroupRequest.UNKNOWN_MEMBER_ID && !group.has(memberId)) {\n+        // Enforce member id when it is set.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (generationId >= 0 && generationId != group.generationId) {", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MDY4Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366670686", "bodyText": "This is a validation on whether the generationId is set in the txn commit, as we only do the check when the request actually sets that field.", "author": "abbccdda", "createdAt": "2020-01-15T02:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwOTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDA3Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366620076", "bodyText": "I am not sure if I understand this test. (1) why do we test with a static member? Fencing could also happen for non-static members now? (2) Why does the member get fenced at all (it seems that staticMembersJoinAndRebalance should successfully add two members to the consumer group?) (3) Why do we no pass a groupInstanceId into commitTransactionalOffsets() on the first call, as we use static group membership?", "author": "mjsax", "createdAt": "2020-01-14T23:06:38Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MTUxOQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366671519", "bodyText": "I will make this test more explicit by adding the definition for member.id. It basically tries to test out that static membership fencing is working properly, as the leader instance is already registered, and the txn commit call with leader.instance.id is not actually using a correct member.id: either empty or invalid", "author": "abbccdda", "createdAt": "2020-01-15T02:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDgyOA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366620828", "bodyText": "Why do we pass Option.empty -- isn't this the default anyway?", "author": "mjsax", "createdAt": "2020-01-14T23:08:54Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MzYzNw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366683637", "bodyText": "No, we don't need to, will address that.", "author": "abbccdda", "createdAt": "2020-01-15T03:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTU1Nw==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366621557", "bodyText": "This should be it's own test -- it test backward compatibility for older clients if I read it correctly.", "author": "mjsax", "createdAt": "2020-01-14T23:10:54Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4Mzk0MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366683940", "bodyText": "Actually I think this is safe to be removed, as other test cases who don't use member.id is covering this case.", "author": "abbccdda", "createdAt": "2020-01-15T03:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTg4MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366621880", "bodyText": "This should be it's own test -- the test name says WithUnknownMemberId but this test passes a known memberId", "author": "mjsax", "createdAt": "2020-01-14T23:11:53Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4NDA5MA==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366684090", "bodyText": "Will do", "author": "abbccdda", "createdAt": "2020-01-15T03:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMjI1Ng==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366622256", "bodyText": "The test name says WithIllegalGeneration -- but this is a positive test using the correct generationId -- should be two tests.", "author": "mjsax", "createdAt": "2020-01-14T23:13:09Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithIllegalGeneration(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val initialGenerationId = joinGroupResult.generationId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty, initialGenerationId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))", "originalCommit": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4NDE2NQ==", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366684165", "bodyText": "Will do", "author": "abbccdda", "createdAt": "2020-01-15T03:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMjI1Ng=="}], "type": "inlineReview"}]}