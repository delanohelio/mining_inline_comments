{"pr_number": 9275, "pr_title": "KAFKA-10435; Fetch protocol changes for KIP-595", "pr_createdAt": "2020-09-09T21:27:56Z", "pr_url": "https://github.com/apache/kafka/pull/9275", "timeline": [{"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "url": "https://github.com/apache/kafka/commit/0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "message": "KAFKA-10435; Fetch protocol changes for KIP-595", "committedDate": "2020-09-10T20:50:51Z", "type": "commit"}, {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "url": "https://github.com/apache/kafka/commit/0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "message": "KAFKA-10435; Fetch protocol changes for KIP-595", "committedDate": "2020-09-10T20:50:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3NDQwMQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r487974401", "bodyText": "currentLeaderEpoch and lastFetchEpoch are both set to -1 by default, but they are set in different ways above, is that deliberate?", "author": "rajinisivaram", "createdAt": "2020-09-14T14:26:15Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -232,19 +263,25 @@ public FetchRequest build(short version) {\n             // We collect the partitions in a single FetchTopic only if they appear sequentially in the fetchData\n             FetchRequestData.FetchTopic fetchTopic = null;\n             for (Map.Entry<TopicPartition, PartitionData> entry : fetchData.entrySet()) {\n-                if (fetchTopic == null || !entry.getKey().topic().equals(fetchTopic.topic())) {\n+                TopicPartition topicPartition = entry.getKey();\n+                PartitionData partitionData = entry.getValue();\n+\n+                if (fetchTopic == null || !topicPartition.topic().equals(fetchTopic.topic())) {\n                     fetchTopic = new FetchRequestData.FetchTopic()\n-                       .setTopic(entry.getKey().topic())\n+                       .setTopic(topicPartition.topic())\n                        .setPartitions(new ArrayList<>());\n                     fetchRequestData.topics().add(fetchTopic);\n                 }\n \n-                fetchTopic.partitions().add(\n-                    new FetchRequestData.FetchPartition().setPartition(entry.getKey().partition())\n-                        .setCurrentLeaderEpoch(entry.getValue().currentLeaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n-                        .setFetchOffset(entry.getValue().fetchOffset)\n-                        .setLogStartOffset(entry.getValue().logStartOffset)\n-                        .setPartitionMaxBytes(entry.getValue().maxBytes));\n+                FetchRequestData.FetchPartition fetchPartition = new FetchRequestData.FetchPartition()\n+                    .setPartition(topicPartition.partition())\n+                    .setCurrentLeaderEpoch(partitionData.currentLeaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n+                    .setFetchOffset(partitionData.fetchOffset)\n+                    .setLogStartOffset(partitionData.logStartOffset)\n+                    .setPartitionMaxBytes(partitionData.maxBytes);\n+                partitionData.lastFetchedEpoch.ifPresent(fetchPartition::setLastFetchedEpoch);", "originalCommit": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjY5NQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488262695", "bodyText": "I guess I was trying to rely on the default from the schema, but I agree probably no reason to be inconsistent.", "author": "hachikuji", "createdAt": "2020-09-14T22:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3NDQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4OTI3Ng==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r487989276", "bodyText": "we could produce without retries, wait for completion and then check exact value?", "author": "rajinisivaram", "createdAt": "2020-09-14T14:45:15Z", "path": "core/src/test/scala/unit/kafka/server/FetchRequestTest.scala", "diffHunk": "@@ -212,6 +212,44 @@ class FetchRequestTest extends BaseRequestTest {\n     assertEquals(Errors.NOT_LEADER_OR_FOLLOWER, partitionData.error)\n   }\n \n+  @Test\n+  def testLastFetchedEpochValidation(): Unit = {\n+    val topic = \"topic\"\n+    val topicPartition = new TopicPartition(topic, 0)\n+    val partitionToLeader = TestUtils.createTopic(zkClient, topic, numPartitions = 1, replicationFactor = 3, servers)\n+    val firstLeaderId = partitionToLeader(topicPartition.partition)\n+    val firstLeaderEpoch = TestUtils.findLeaderEpoch(firstLeaderId, topicPartition, servers)\n+\n+    initProducer()\n+\n+    // Write some data in epoch 0\n+    produceData(Seq(topicPartition), 100)\n+    // Force a leader change\n+    killBroker(firstLeaderId)\n+    // Write some more data\n+    produceData(Seq(topicPartition), 100)\n+\n+    val secondLeaderId = TestUtils.awaitLeaderChange(servers, topicPartition, firstLeaderId)\n+    val secondLeaderEpoch = TestUtils.findLeaderEpoch(secondLeaderId, topicPartition, servers)\n+\n+    // Build a fetch request at offset 150 with last fetched epoch 0\n+    val fetchOffset = 150\n+    val partitionMap = new util.LinkedHashMap[TopicPartition, FetchRequest.PartitionData]\n+    partitionMap.put(topicPartition, new FetchRequest.PartitionData(fetchOffset, 0L, 1024,\n+      Optional.of(secondLeaderEpoch), Optional.of(firstLeaderEpoch)))\n+    val fetchRequest = FetchRequest.Builder.forConsumer(0, 1, partitionMap).build()\n+\n+    // Validate the expected truncation\n+    val fetchResponse = sendFetchRequest(secondLeaderId, fetchRequest)\n+    val partitionData = fetchResponse.responseData.get(topicPartition)\n+    assertEquals(Errors.NONE, partitionData.error)\n+    assertEquals(0L, partitionData.records.sizeInBytes())\n+    assertTrue(partitionData.truncationOffset.isPresent)\n+\n+    // Should be exactly 100, but use a fuzzy truncation estimate in case there were produce retries\n+    assertTrue(partitionData.truncationOffset.get < 150)", "originalCommit": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTMyOQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488271329", "bodyText": "That's a good idea. Let me try that.", "author": "hachikuji", "createdAt": "2020-09-14T22:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4OTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MjI0NQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488042245", "bodyText": "I guess we would always be removing a range from the start or end. Are we going through the whole map and checking each one because there is no suitable API to remove multiple entries from start or end?", "author": "rajinisivaram", "createdAt": "2020-09-14T15:53:23Z", "path": "core/src/main/scala/kafka/server/epoch/LeaderEpochFileCache.scala", "diffHunk": "@@ -91,8 +95,23 @@ class LeaderEpochFileCache(topicPartition: TopicPartition,\n     }\n   }\n \n+  def removeEntries(predicate: EpochEntry => Boolean): Seq[EpochEntry] = {\n+    val removedEpochs = mutable.ListBuffer.empty[EpochEntry]\n+    val iterator = epochs.entrySet().iterator()\n+\n+    while (iterator.hasNext) {", "originalCommit": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwOTkxNw==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488309917", "bodyText": "That's a good question. We probably could be smarter in truncateAndAppend if it was safe to assume epoch/start offset increases monotonically. Maybe we just need to add the logic to validate that invariant on startup. Let me take a look at that.", "author": "hachikuji", "createdAt": "2020-09-15T00:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MjI0NQ=="}], "type": "inlineReview"}, {"oid": "eb821421f3c5dbaccc58cb6f28b80eb3963af41b", "url": "https://github.com/apache/kafka/commit/eb821421f3c5dbaccc58cb6f28b80eb3963af41b", "message": "Improve efficiency of epoch cache", "committedDate": "2020-09-15T03:11:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzMwOQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488833309", "bodyText": "Do we need to check again inside the lock before update because this is outside the lock?", "author": "rajinisivaram", "createdAt": "2020-09-15T17:20:47Z", "path": "core/src/main/scala/kafka/server/epoch/LeaderEpochFileCache.scala", "diffHunk": "@@ -47,63 +47,81 @@ class LeaderEpochFileCache(topicPartition: TopicPartition,\n   private val epochs = new util.TreeMap[Int, EpochEntry]()\n \n   inWriteLock(lock) {\n-    checkpoint.read().foreach { entry =>\n-      epochs.put(entry.epoch, entry)\n-    }\n+    checkpoint.read().foreach(assign)\n   }\n \n   /**\n     * Assigns the supplied Leader Epoch to the supplied Offset\n     * Once the epoch is assigned it cannot be reassigned\n     */\n   def assign(epoch: Int, startOffset: Long): Unit = {\n-    inWriteLock(lock) {\n-      val updateNeeded = if (epochs.isEmpty) {\n-        true\n-      } else {\n-        val lastEntry = epochs.lastEntry.getValue\n-        lastEntry.epoch != epoch || startOffset < lastEntry.startOffset\n-      }\n+    val entry = EpochEntry(epoch, startOffset)\n+    if (assign(entry)) {\n+      debug(s\"Appended new epoch entry $entry. Cache now contains ${epochs.size} entries.\")\n+      flush()\n+    }\n+  }\n \n-      if (updateNeeded) {\n-        truncateAndAppend(EpochEntry(epoch, startOffset))\n-        flush()\n+  private def assign(entry: EpochEntry): Boolean = {\n+    if (entry.epoch < 0 || entry.startOffset < 0) {\n+      throw new IllegalArgumentException(s\"Received invalid partition leader epoch entry $entry\")\n+    }\n+\n+    // Check whether the append is needed before acquiring the write lock\n+    // in order to avoid contention with readers in the common case\n+    latestEntry.foreach { lastEntry =>\n+      if (entry.epoch == lastEntry.epoch && entry.startOffset >= lastEntry.startOffset) {\n+        return false", "originalCommit": "eb821421f3c5dbaccc58cb6f28b80eb3963af41b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1MDIwOQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488850209", "bodyText": "Yeah, let me add it. I had debated it and convinced myself it was not needed, but that probably relies a bit too heavily on locking at higher layers. Probably better to err on the safe side.", "author": "hachikuji", "createdAt": "2020-09-15T17:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzMwOQ=="}], "type": "inlineReview"}, {"oid": "00867faf4ec2ac8b520191320832e88eb8fd1e83", "url": "https://github.com/apache/kafka/commit/00867faf4ec2ac8b520191320832e88eb8fd1e83", "message": "Check whether update is needed in write lock", "committedDate": "2020-09-15T17:45:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMjEwOQ==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r489612109", "bodyText": "Maybe you can fix this typo in your next PR.", "author": "ijuma", "createdAt": "2020-09-16T17:43:07Z", "path": "core/src/main/scala/kafka/api/ApiVersion.scala", "diffHunk": "@@ -100,7 +100,9 @@ object ApiVersion {\n     // Introduced StopReplicaRequest V3 containing the leader epoch for each partition (KIP-570)\n     KAFKA_2_6_IV0,\n     // Introduced feature versioning support (KIP-584)\n-    KAFKA_2_7_IV0\n+    KAFKA_2_7_IV0,\n+    // Bup Fetch protocol for Raft protocol (KIP-595)", "originalCommit": "00867faf4ec2ac8b520191320832e88eb8fd1e83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTM0Ng==", "url": "https://github.com/apache/kafka/pull/9275#discussion_r491241346", "bodyText": "Oops! Will do.", "author": "hachikuji", "createdAt": "2020-09-19T00:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMjEwOQ=="}], "type": "inlineReview"}]}