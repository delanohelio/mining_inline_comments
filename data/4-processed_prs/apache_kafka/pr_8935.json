{"pr_number": 8935, "pr_title": "KAFKA-10189: reset event queue time histogram when queue is empty", "pr_createdAt": "2020-06-27T00:40:58Z", "pr_url": "https://github.com/apache/kafka/pull/8935", "timeline": [{"oid": "25085e29e0468edefa99b5e5cc5d7dbad847c216", "url": "https://github.com/apache/kafka/commit/25085e29e0468edefa99b5e5cc5d7dbad847c216", "message": "reset event queue time histogram when queue is empty", "committedDate": "2020-06-27T00:35:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwMzc4NQ==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r447303785", "bodyText": "In Scala you can do:\nval dequeued = {\n  val count = eventQueueTimeHist.count()\n  if (count != 0) {\n    val event = queue.poll(..., ...)\n    if (event == null) {\n      eventQueueTimeHist.clear()\n      queue.take()\n    } else {\n      event\n    }\n  } else {\n    queue.take()\n  }\n}\nWe can probably move this code to a private method.", "author": "jsancio", "createdAt": "2020-06-29T22:51:35Z", "path": "core/src/main/scala/kafka/controller/ControllerEventManager.scala", "diffHunk": "@@ -115,7 +117,17 @@ class ControllerEventManager(controllerId: Int,\n     logIdent = s\"[ControllerEventThread controllerId=$controllerId] \"\n \n     override def doWork(): Unit = {\n-      val dequeued = queue.take()\n+      val count = eventQueueTimeHist.count()\n+      var dequeued: QueuedEvent = null\n+      if (count != 0) {\n+        dequeued = queue.poll(eventQueueTimeMetricTimeoutMs, TimeUnit.MILLISECONDS)\n+        if (dequeued == null) {\n+          eventQueueTimeHist.clear()\n+          return\n+        }\n+      } else {\n+        dequeued = queue.take()\n+      }", "originalCommit": "25085e29e0468edefa99b5e5cc5d7dbad847c216", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwNDY2MA==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r447304660", "bodyText": "I don't think we need this for this test. The test above has this because they want to check that the max is 500.", "author": "jsancio", "createdAt": "2020-06-29T22:54:17Z", "path": "core/src/test/scala/unit/kafka/controller/ControllerEventManagerTest.scala", "diffHunk": "@@ -135,6 +135,44 @@ class ControllerEventManagerTest {\n     assertEquals(500, queueTimeHistogram.max, 0.01)\n   }\n \n+  @Test\n+  def testEventQueueTimeResetOnTimeout(): Unit = {\n+    val metricName = \"kafka.controller:type=ControllerEventManager,name=EventQueueTimeMs\"\n+    val controllerStats = new ControllerStats\n+    val time = new MockTime()\n+    val latch = new CountDownLatch(1)\n+    val processedEvents = new AtomicInteger()\n+\n+    val eventProcessor = new ControllerEventProcessor {\n+      override def process(event: ControllerEvent): Unit = {\n+        latch.await()\n+        time.sleep(500)", "originalCommit": "25085e29e0468edefa99b5e5cc5d7dbad847c216", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fb8a1fb5e9d422b443e52910cf1035e72d39f51", "url": "https://github.com/apache/kafka/commit/9fb8a1fb5e9d422b443e52910cf1035e72d39f51", "message": "increase default timeout value", "committedDate": "2020-06-29T23:28:34Z", "type": "commit"}, {"oid": "885800ebb3e8b49969b91db5bb46b9f3c09c87b7", "url": "https://github.com/apache/kafka/commit/885800ebb3e8b49969b91db5bb46b9f3c09c87b7", "message": "move poll to private method, simplify unit test", "committedDate": "2020-06-30T01:46:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2MjMyMw==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r447662323", "bodyText": "We dont need new eventQueueTimeMetricTimeoutMs variable. we can use eventQueueTimeTimeoutMs directly ?", "author": "omkreddy", "createdAt": "2020-06-30T13:00:08Z", "path": "core/src/main/scala/kafka/controller/ControllerEventManager.scala", "diffHunk": "@@ -69,14 +69,16 @@ class QueuedEvent(val event: ControllerEvent,\n class ControllerEventManager(controllerId: Int,\n                              processor: ControllerEventProcessor,\n                              time: Time,\n-                             rateAndTimeMetrics: Map[ControllerState, KafkaTimer]) extends KafkaMetricsGroup {\n+                             rateAndTimeMetrics: Map[ControllerState, KafkaTimer],\n+                             eventQueueTimeTimeoutMs: Long = 60000) extends KafkaMetricsGroup {\n   import ControllerEventManager._\n \n   @volatile private var _state: ControllerState = ControllerState.Idle\n   private val putLock = new ReentrantLock()\n   private val queue = new LinkedBlockingQueue[QueuedEvent]\n   // Visible for test\n   private[controller] val thread = new ControllerEventThread(ControllerEventThreadName)\n+  val eventQueueTimeMetricTimeoutMs = eventQueueTimeTimeoutMs", "originalCommit": "885800ebb3e8b49969b91db5bb46b9f3c09c87b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31bb39e2111c6f4d54a58f44eb3817328c99af8a", "url": "https://github.com/apache/kafka/commit/31bb39e2111c6f4d54a58f44eb3817328c99af8a", "message": "remove unnecessary variable", "committedDate": "2020-06-30T17:05:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxODU4NA==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454018584", "bodyText": "Hmm, if eventQueueTimeHist.count() is not 0, it seems that we can block on queue.take() forever without resetting the histogram?", "author": "junrao", "createdAt": "2020-07-14T00:06:04Z", "path": "core/src/main/scala/kafka/controller/ControllerEventManager.scala", "diffHunk": "@@ -139,4 +140,19 @@ class ControllerEventManager(controllerId: Int,\n     }\n   }\n \n+  private def pollFromEventQueue(): QueuedEvent = {\n+    val count = eventQueueTimeHist.count()", "originalCommit": "31bb39e2111c6f4d54a58f44eb3817328c99af8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTUzMw==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454035533", "bodyText": "@junrao I'm not sure I follow. If there are no more events in the queue (count != 0), we'd like the histogram to reset after a specified timeout. count will always be a non-zero value until we reset the histogram.\nIf we block on queue.take() forever even when count != 0, wouldn't that behave the same way as before? In which case do you suggest resetting?", "author": "jeffkbkim", "createdAt": "2020-07-14T01:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxODU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MDIyOQ==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454480229", "bodyText": "@jeffkbkim : Yes, you are right. The code seems fine.", "author": "junrao", "createdAt": "2020-07-14T16:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxODU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTgyNA==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454019824", "bodyText": "This approach seems fine for this particular usage. There are other usage of histogram that all have the same issue. A more complete fix would be to fix the issue at the Histogram level. Could we try patching the Yammer code upstream or at least file an issue? I am thinking that we could track the last time a histogram is updated, if it passes a certain amount of time, we reset on next get() or update().", "author": "junrao", "createdAt": "2020-07-14T00:10:33Z", "path": "core/src/main/scala/kafka/controller/ControllerEventManager.scala", "diffHunk": "@@ -139,4 +140,19 @@ class ControllerEventManager(controllerId: Int,\n     }\n   }\n \n+  private def pollFromEventQueue(): QueuedEvent = {", "originalCommit": "31bb39e2111c6f4d54a58f44eb3817328c99af8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzOTg5OQ==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454039899", "bodyText": "@junrao Two of the biggest issues is that the histogram does not reset when the broker shuts down or when the controller moves. There will not be a next get()/update() in these scenarios - should we reset the histogram outside of ControllerEventThread instead?", "author": "jeffkbkim", "createdAt": "2020-07-14T01:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NDQyNw==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454484427", "bodyText": "What I was thinking is the following. We change Histogram so that it tracks the last time it's updated. If the expiration time has been reached, the histogram will reset on next update. If there is no next update, but the histogram value is being read, we will also reset the value on read.", "author": "junrao", "createdAt": "2020-07-14T16:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2NDI3NQ==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r456064275", "bodyText": "unfortunately, the metrics version kafka uses (v2.2.0) is no longer supported by yammer dropwizard/metrics#1618", "author": "jeffkbkim", "createdAt": "2020-07-16T20:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyMDIyNw==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454020227", "bodyText": "The exact value probably depends on the metric collecting interval. Perhaps we could be a bit conservative with a 5 min timeout?", "author": "junrao", "createdAt": "2020-07-14T00:11:59Z", "path": "core/src/main/scala/kafka/controller/ControllerEventManager.scala", "diffHunk": "@@ -69,7 +69,8 @@ class QueuedEvent(val event: ControllerEvent,\n class ControllerEventManager(controllerId: Int,\n                              processor: ControllerEventProcessor,\n                              time: Time,\n-                             rateAndTimeMetrics: Map[ControllerState, KafkaTimer]) extends KafkaMetricsGroup {\n+                             rateAndTimeMetrics: Map[ControllerState, KafkaTimer],\n+                             eventQueueTimeTimeoutMs: Long = 60000) extends KafkaMetricsGroup {", "originalCommit": "31bb39e2111c6f4d54a58f44eb3817328c99af8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwNzk3Ng==", "url": "https://github.com/apache/kafka/pull/8935#discussion_r454207976", "bodyText": "Why is this CountdownLatch necessary? Seems it\u2019s just delaying the wait condition being true - processedEvents.get() == 2", "author": "soarez", "createdAt": "2020-07-14T08:57:15Z", "path": "core/src/test/scala/unit/kafka/controller/ControllerEventManagerTest.scala", "diffHunk": "@@ -135,6 +135,43 @@ class ControllerEventManagerTest {\n     assertEquals(500, queueTimeHistogram.max, 0.01)\n   }\n \n+  @Test\n+  def testEventQueueTimeResetOnTimeout(): Unit = {\n+    val metricName = \"kafka.controller:type=ControllerEventManager,name=EventQueueTimeMs\"\n+    val controllerStats = new ControllerStats\n+    val time = new MockTime()\n+    val latch = new CountDownLatch(1)\n+    val processedEvents = new AtomicInteger()\n+\n+    val eventProcessor = new ControllerEventProcessor {\n+      override def process(event: ControllerEvent): Unit = {\n+        latch.await()\n+        processedEvents.incrementAndGet()\n+      }\n+      override def preempt(event: ControllerEvent): Unit = {}\n+    }\n+\n+    controllerEventManager = new ControllerEventManager(0, eventProcessor,\n+      time, controllerStats.rateAndTimeMetrics, 1)\n+    controllerEventManager.start()\n+\n+    controllerEventManager.put(TopicChange)\n+    controllerEventManager.put(TopicChange)\n+    latch.countDown()", "originalCommit": "31bb39e2111c6f4d54a58f44eb3817328c99af8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a7b9438a35d1a696ec95b24e8b636f2a0b10b1b", "url": "https://github.com/apache/kafka/commit/1a7b9438a35d1a696ec95b24e8b636f2a0b10b1b", "message": "update default timeout, remove latch", "committedDate": "2020-07-16T20:41:20Z", "type": "commit"}]}