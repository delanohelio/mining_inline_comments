{"pr_number": 9733, "pr_title": "KAFKA-10017: fix 2 issues in EosBetaUpgradeIntegrationTest", "pr_createdAt": "2020-12-11T09:27:46Z", "pr_url": "https://github.com/apache/kafka/pull/9733", "timeline": [{"oid": "d3693f40fb7536822fd84d12a35b77e2562b93b3", "url": "https://github.com/apache/kafka/commit/d3693f40fb7536822fd84d12a35b77e2562b93b3", "message": "KAFKA-10017: fix 2 issues in EosBetaUpgradeIntegrationTest", "committedDate": "2020-12-11T09:18:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg1OTkzNw==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543859937", "bodyText": "To avoid the issue you point out, we actually use this line. As a matter of fact, there is no guarantee if there would be even more than two rebalances. \\cc @ableegoldman might be able to provide more input?", "author": "mjsax", "createdAt": "2020-12-16T02:54:06Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosBetaUpgradeIntegrationTest.java", "diffHunk": "@@ -256,8 +261,8 @@ public void shouldUpgradeFromEosAlphaToEosBeta() throws Exception {\n             streams2Alpha.cleanUp();\n             streams2Alpha.start();\n             assignmentListener.waitForNextStableAssignment(MAX_WAIT_TIME_MS);", "originalCommit": "d3693f40fb7536822fd84d12a35b77e2562b93b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg4MjAyMw==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543882023", "bodyText": "@mjsax\nThe stacktrace is like this. The line number is not mapped to master branch correctly, but you can know what it is from the method name. It failed when it's trying to get all state data and checking if the current stream is in RUNNING state, but it's under rebalancing. And this exception won't do any retry.\nStacktrace\n\norg.apache.kafka.streams.errors.InvalidStateStoreException: Cannot get state store store because the stream thread is PARTITIONS_ASSIGNED, not RUNNING\n\tat org.apache.kafka.streams.state.internals.StreamThreadStateStoreProvider.stores(StreamThreadStateStoreProvider.java:81)\n\tat org.apache.kafka.streams.state.internals.WrappingStoreProvider.stores(WrappingStoreProvider.java:50)\n\tat org.apache.kafka.streams.state.internals.CompositeReadOnlyKeyValueStore.all(CompositeReadOnlyKeyValueStore.java:119)\n\tat org.apache.kafka.streams.integration.EosBetaUpgradeIntegrationTest.keysFromInstance(EosBetaUpgradeIntegrationTest.java:1112)\n\tat org.apache.kafka.streams.integration.EosBetaUpgradeIntegrationTest.shouldUpgradeFromEosAlphaToEosBeta(EosBetaUpgradeIntegrationTest.java:494)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\nAnd, yes, we make sure it completed the rebalance then checking the running state, but as I mentioned, there will be 2 rebalance happened(1 for Adding new member, 1 for leader re-joining group during Stable), and we only wait 1 rebalance completes, so there might be another rebalancing later. The 2 stream state transition log is like this:\nstateTransitions1:\n[KeyValue(CREATED, REBALANCING), KeyValue(REBALANCING, RUNNING), KeyValue(RUNNING, REBALANCING), KeyValue(REBALANCING, RUNNING)]  \n\nstateTransitions2: \n[KeyValue(RUNNING, REBALANCING), KeyValue(REBALANCING, RUNNING), KeyValue(RUNNING, REBALANCING), KeyValue(REBALANCING, RUNNING)]\n\nSo, as you can see, we might enter next step when we are in step 2 (KeyValue(REBALANCING, RUNNING)), and there will be another rebalancing soon. That's why I'll wait explicitly for this transition pair [KeyValue(RUNNING, REBALANCING), KeyValue(REBALANCING, RUNNING)]", "author": "showuon", "createdAt": "2020-12-16T03:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg1OTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1NDcyOA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543954728", "bodyText": "The line number is not mapped to master branch correctly, but you can know what it is from the method name.\n\nWell, this seem to imply the the run was on an older version that did not contain the retry yet -- note. adding the retry it was part of the latest PR for this test that we merged: https://github.com/apache/kafka/pull/9688/files#diff-86a5136ae170df067137442b5eae05fa5fd9d1e02aca85bac8a251b7d2557b0eR1089\nThus, I would assume the the whole test failure you observes was before the last fix.\n\nthere will be 2 rebalance happened\n\nCorrect, but we actually \"cut off\" the unstable rebalances (there might actually be more then 2...) via assignmentListener.waitForNextStableAssignment(MAX_WAIT_TIME_MS);\nTo me, it seems that you observe the test failure before the PR got merged -- otherwise the line numbers for keysFromInstance would match.", "author": "mjsax", "createdAt": "2020-12-16T05:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg1OTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwMjA4Mg==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r544002082", "bodyText": "You're right! I didn't notice there is already new added retry in master. I'll revert my change for it. Thank you!", "author": "showuon", "createdAt": "2020-12-16T06:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg1OTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg2MzQxMw==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543863413", "bodyText": "Seems this fail did not work as expected? Otherwise the test would have failed all the time? Maybe we should rather set a boolean flag that we evaluate outside of the callback to let the test fail?\nAlso, we have one run with zero exceptions and one run with 2 exception (one exception type each) -- not 4. Thus, we need to handle this differently for the error-injection and the \"clean run\" differently depending on the boolean test flag.", "author": "mjsax", "createdAt": "2020-12-16T02:58:29Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosBetaUpgradeIntegrationTest.java", "diffHunk": "@@ -938,11 +943,13 @@ public void close() {}\n \n         final KafkaStreams streams = new KafkaStreams(builder.build(), config, new TestKafkaClientSupplier());\n         streams.setUncaughtExceptionHandler((t, e) -> {\n-            if (uncaughtException != null) {\n+            // should only have our injected exception or commit exception\n+            if (!(e instanceof RuntimeException) && !(e.getMessage().contains(\"test exception\"))) {\n+                // The exception won't cause the test fail since we actually \"expected\" exception thrown and failed the stream.\n+                // So, log to stderr for debugging when the exception is not what we expected\n                 e.printStackTrace(System.err);\n                 fail(\"Should only get one uncaught exception from Streams.\");", "originalCommit": "d3693f40fb7536822fd84d12a35b77e2562b93b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5MjM2NA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543892364", "bodyText": "Seems this fail did not work as expected? Otherwise the test would have failed all the time?\n\nYes, the fail() is throwing AssertionError to fail the stream, but that's excatly what we expected to fail the stream, just not with our injected exception. So it won't failed the test.\n\nwe need to handle this differently for the error-injection and the \"clean run\" differently depending on the boolean test flag.\n\nI see, will update it. Thanks.", "author": "showuon", "createdAt": "2020-12-16T03:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg2MzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1NTk2MA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r543955960", "bodyText": "Well, but the AsseriontError does not mark the test as failed as it seems, because it would be thrown in a different thread? We would need to set a boolean flag, and add an assertThat to the main test code to see if the flag fired?", "author": "mjsax", "createdAt": "2020-12-16T05:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg2MzQxMw=="}], "type": "inlineReview"}, {"oid": "ee037dd69633ce50ffdffd0fa77e47938458ff19", "url": "https://github.com/apache/kafka/commit/ee037dd69633ce50ffdffd0fa77e47938458ff19", "message": "KAFKA-10017: wait for specific number of rebalancing for new started stream", "committedDate": "2020-12-21T08:49:42Z", "type": "commit"}, {"oid": "ee037dd69633ce50ffdffd0fa77e47938458ff19", "url": "https://github.com/apache/kafka/commit/ee037dd69633ce50ffdffd0fa77e47938458ff19", "message": "KAFKA-10017: wait for specific number of rebalancing for new started stream", "committedDate": "2020-12-21T08:49:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0Mjg4NA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r547542884", "bodyText": "nit: missing space between or (line above) and there", "author": "mjsax", "createdAt": "2020-12-22T22:45:00Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosBetaUpgradeIntegrationTest.java", "diffHunk": "@@ -135,8 +137,13 @@\n     private final static String CONSUMER_GROUP_ID = \"readCommitted\";\n     private final static String MULTI_PARTITION_INPUT_TOPIC = \"multiPartitionInputTopic\";\n     private final static String MULTI_PARTITION_OUTPUT_TOPIC = \"multiPartitionOutputTopic\";\n+    private final static String APP_DIR_1 = \"appDir1\";\n+    private final static String APP_DIR_2 = \"appDir2\";\n+    private final static String UNEXPECTED_EXCEPTION_MSG = \"Fail the test since we got an unexpected exception or\" +\n+        \"there are too many exceptions thrown, please check standard error log for more info.\";", "originalCommit": "ee037dd69633ce50ffdffd0fa77e47938458ff19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MjkwNA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r547542904", "bodyText": "This variable should be declare volatile because the callback is executed on a different thread.", "author": "mjsax", "createdAt": "2020-12-22T22:45:02Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosBetaUpgradeIntegrationTest.java", "diffHunk": "@@ -147,9 +154,16 @@\n     private final AtomicInteger commitCounterClient2 = new AtomicInteger(-1);\n     private final AtomicInteger commitRequested = new AtomicInteger(0);\n \n-    private Throwable uncaughtException;\n-\n     private int testNumber = 0;\n+    private boolean hasUnexpectedError = false;", "originalCommit": "ee037dd69633ce50ffdffd0fa77e47938458ff19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxNzk5OA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r547617998", "bodyText": "Nice catch! Fixed.", "author": "showuon", "createdAt": "2020-12-23T03:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MjkwNA=="}], "type": "inlineReview"}, {"oid": "89eb7efaf2cf5ca1908309dc543d8ab60346861e", "url": "https://github.com/apache/kafka/commit/89eb7efaf2cf5ca1908309dc543d8ab60346861e", "message": "KAFKA-10017: address reviewer's comment to use volatile for different threads", "committedDate": "2020-12-23T03:24:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2MDEyMg==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r548160122", "bodyText": "If you reasoning is right, do we need to use waitForNumRebalancingToRunning here, too? If there are multiple rebalances, both clients would participate?\nAlso, you PR does not update all stages when we wait for state changes. Why? Would we not need to apply to logic each time?", "author": "mjsax", "createdAt": "2020-12-23T19:22:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosBetaUpgradeIntegrationTest.java", "diffHunk": "@@ -246,18 +261,19 @@ public void shouldUpgradeFromEosAlphaToEosBeta() throws Exception {\n             assignmentListener.waitForNextStableAssignment(MAX_WAIT_TIME_MS);\n             waitForRunning(stateTransitions1);\n \n-            streams2Alpha = getKafkaStreams(\"appDir2\", StreamsConfig.EXACTLY_ONCE);\n+            streams2Alpha = getKafkaStreams(APP_DIR_2, StreamsConfig.EXACTLY_ONCE);\n             streams2Alpha.setStateListener(\n                 (newState, oldState) -> stateTransitions2.add(KeyValue.pair(oldState, newState))\n             );\n             stateTransitions1.clear();\n \n-            assignmentListener.prepareForRebalance();\n+            prevNumAssignments = assignmentListener.prepareForRebalance();\n             streams2Alpha.cleanUp();\n             streams2Alpha.start();\n             assignmentListener.waitForNextStableAssignment(MAX_WAIT_TIME_MS);\n+            expectedNumAssignments = assignmentListener.numTotalAssignments() - prevNumAssignments;\n+            waitForNumRebalancingToRunning(stateTransitions2, expectedNumAssignments);\n             waitForRunning(stateTransitions1);", "originalCommit": "89eb7efaf2cf5ca1908309dc543d8ab60346861e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM5OTY2MA==", "url": "https://github.com/apache/kafka/pull/9733#discussion_r548399660", "bodyText": "Thanks for your questions. Answer them below:\n\nAlso, you PR does not update all stages when we wait for state changes. Why? Would we not need to apply to logic each time?\n\n--> Yes, I should do that. What I did now is just focusing on the case: 1 new started stream + 1 already running stream, which will have more failures here. But you're right, I should put the change in all stages.\n\nIf you reasoning is right, do we need to use waitForNumRebalancingToRunning here, too? If there are multiple rebalances, both clients would participate?\n\n--> Good question! I have explained in the previous comment (#9733 (comment)) though, I can explain again since I know you didn't understand exactly why I did this change before.\nI only waitForNumRebalancingToRunning for the new started stream only, not for the \"already running stream\" because I found sometimes if the stream runs fast enough, the \"already running stream\" might not have the expected number of [REBALANCING -> RUNNING] state transition. The reason is this line:\n[appDir2-StreamThread-1] State transition from PARTITIONS_ASSIGNED to PARTITIONS_ASSIGNED \n\nBasically, The already running stream thread should have the state change: [RUNNING to PARTITIONS_REVOKED], [PARTITIONS_REVOKED to PARTITIONS_ASSIGNED](unstable), [PARTITIONS_ASSIGNED to RUNNING], [RUNNING to PARTITIONS_ASSIGNED](stable), [PARTITIONS_ASSIGNED to RUNNING]. Because it needs one more PARTITIONS_REVOKED step, it might be under 2 PARTITIONS_ASSIGNED at the same time (no RUNNING in the middle). And that's why the stream client doesn't change to RUNNING as we expected.\nDoes that make sense?", "author": "showuon", "createdAt": "2020-12-24T05:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2MDEyMg=="}], "type": "inlineReview"}, {"oid": "f2f096758b4b02a7426c88b44978787e54c98c95", "url": "https://github.com/apache/kafka/commit/f2f096758b4b02a7426c88b44978787e54c98c95", "message": "KAFKA-10017: fix the exception handler issue", "committedDate": "2021-01-15T02:30:10Z", "type": "commit"}, {"oid": "f2f096758b4b02a7426c88b44978787e54c98c95", "url": "https://github.com/apache/kafka/commit/f2f096758b4b02a7426c88b44978787e54c98c95", "message": "KAFKA-10017: fix the exception handler issue", "committedDate": "2021-01-15T02:30:10Z", "type": "forcePushed"}, {"oid": "62cbfb648aed3469ba546b80f7de7060f0934583", "url": "https://github.com/apache/kafka/commit/62cbfb648aed3469ba546b80f7de7060f0934583", "message": "trigger the jenkins test again", "committedDate": "2021-01-15T11:35:25Z", "type": "commit"}]}