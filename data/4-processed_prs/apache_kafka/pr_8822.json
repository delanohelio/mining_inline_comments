{"pr_number": 8822, "pr_title": "KAFKA-10113; Specify fetch offsets correctly in LogTruncationException", "pr_createdAt": "2020-06-06T19:18:36Z", "pr_url": "https://github.com/apache/kafka/pull/8822", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxODYyNg==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436318626", "bodyText": "Why do we move this check out of setFatalOffsetForLeaderException?", "author": "abbccdda", "createdAt": "2020-06-07T02:40:19Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -852,14 +835,28 @@ public void onFailure(RuntimeException e) {\n                     subscriptions.requestFailed(fetchPositions.keySet(), time.milliseconds() + retryBackoffMs);\n                     metadata.requestUpdate();\n \n-                    setFatalOffsetForLeaderException(e);\n+                    if (!(e instanceof RetriableException)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjkxMw==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436386913", "bodyText": "Seemed inconsistent to have a method named setFatal which checks for retriable exceptions.", "author": "hachikuji", "createdAt": "2020-06-07T17:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxODYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxODk0Mw==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436318943", "bodyText": "Should require non-null for fetchPosition", "author": "abbccdda", "createdAt": "2020-06-07T02:47:33Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -1050,4 +1062,43 @@ public String toString() {\n                     '}';\n         }\n     }\n+\n+    public static class LogTruncation {\n+        public final TopicPartition topicPartition;\n+        public final FetchPosition fetchPosition;\n+        public final Optional<OffsetAndMetadata> divergentOffsetOpt;\n+\n+        public LogTruncation(TopicPartition topicPartition,\n+                             FetchPosition fetchPosition,\n+                             Optional<OffsetAndMetadata> divergentOffsetOpt) {\n+            this.topicPartition = topicPartition;\n+            this.fetchPosition = fetchPosition;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4Nzg2OQ==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436387869", "bodyText": "Out of curiosity, why fetchPosition specifically and not the other fields?", "author": "hachikuji", "createdAt": "2020-06-07T18:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxODk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgwMDY2Ng==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436800666", "bodyText": "After a second thought, I don't feel strong about it.", "author": "abbccdda", "createdAt": "2020-06-08T15:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxODk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTMxOQ==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319319", "bodyText": "Should still mention no configured reset policy here IMHO.", "author": "abbccdda", "createdAt": "2020-06-07T02:53:34Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1325,23 +1323,15 @@ private CompletedFetch initializeCompletedFetch(CompletedFetch nextCompletedFetc\n         return completedFetch;\n     }\n \n-    private void handleOffsetOutOfRange(FetchPosition fetchPosition,\n-                                        TopicPartition topicPartition,\n-                                        String reason) {\n+    private void handleOffsetOutOfRange(FetchPosition fetchPosition, TopicPartition topicPartition) {\n+        String errorMessage = \"Fetch position \" + fetchPosition + \" is out of range for partition \" + topicPartition;\n         if (subscriptions.hasDefaultOffsetResetPolicy()) {\n-            log.info(\"Fetch offset epoch {} is out of range for partition {}, resetting offset\",\n-                fetchPosition, topicPartition);\n+            log.info(\"{}, resetting offset\", errorMessage);\n             subscriptions.requestOffsetReset(topicPartition);\n         } else {\n-            Map<TopicPartition, Long> offsetOutOfRangePartitions =\n-                Collections.singletonMap(topicPartition, fetchPosition.offset);\n-            String errorMessage = String.format(\"Offsets out of range \" +\n-                \"with no configured reset policy for partitions: %s\" +\n-                \", for fetch offset: %d, \" +\n-                \"root cause: %s\",\n-                offsetOutOfRangePartitions, fetchPosition.offset, reason);\n-            log.info(errorMessage);\n-            throw new OffsetOutOfRangeException(errorMessage, offsetOutOfRangePartitions);\n+            log.info(\"{}, raising error to the application\", errorMessage);\n+            throw new OffsetOutOfRangeException(errorMessage,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTQyMg==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319422", "bodyText": "I feel we could still share handleOffsetOutOfRange in two places by letting it return a struct of Optional<LogTruncation> and decide when to throw it by the caller.", "author": "abbccdda", "createdAt": "2020-06-07T02:55:40Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1325,23 +1323,15 @@ private CompletedFetch initializeCompletedFetch(CompletedFetch nextCompletedFetc\n         return completedFetch;\n     }\n \n-    private void handleOffsetOutOfRange(FetchPosition fetchPosition,\n-                                        TopicPartition topicPartition,\n-                                        String reason) {\n+    private void handleOffsetOutOfRange(FetchPosition fetchPosition, TopicPartition topicPartition) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5MDY4Ng==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436390686", "bodyText": "After thinking about it, it seemed simpler to always use LogTruncationException for validation failures, even if the divergent offset is not known. Then direct OffsetOutOfRange errors are reserved for fetch responses which indicate the OFFSET_OUT_OF_RANGE error.", "author": "hachikuji", "createdAt": "2020-06-07T18:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTUzNw==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319537", "bodyText": "We could just build the actual singleton mapping to compare with thrown.offsetOutOfRangePartitions()", "author": "abbccdda", "createdAt": "2020-06-07T02:58:03Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3856,12 +3857,16 @@ private void testOffsetValidationWithGivenEpochOffset(final EpochEndOffset epoch\n         assertEquals(initialOffset, subscriptions.position(tp0).offset);\n \n         if (offsetResetStrategy == OffsetResetStrategy.NONE) {\n-            OffsetOutOfRangeException thrown =\n-                assertThrows(OffsetOutOfRangeException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            LogTruncationException thrown =\n+                assertThrows(LogTruncationException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            assertEquals(initialOffset, thrown.offsetOutOfRangePartitions().get(tp0).longValue());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTU3Mg==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319572", "bodyText": "Should we just assert thrown.divergentOffsets().isEmpty()?", "author": "abbccdda", "createdAt": "2020-06-07T02:59:21Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3856,12 +3857,16 @@ private void testOffsetValidationWithGivenEpochOffset(final EpochEndOffset epoch\n         assertEquals(initialOffset, subscriptions.position(tp0).offset);\n \n         if (offsetResetStrategy == OffsetResetStrategy.NONE) {\n-            OffsetOutOfRangeException thrown =\n-                assertThrows(OffsetOutOfRangeException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            LogTruncationException thrown =\n+                assertThrows(LogTruncationException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            assertEquals(initialOffset, thrown.offsetOutOfRangePartitions().get(tp0).longValue());\n \n-            // If epoch offset is valid, we are testing for the log truncation case.\n-            if (!epochEndOffset.hasUndefinedEpochOrOffset()) {\n-                assertTrue(thrown instanceof LogTruncationException);\n+            if (epochEndOffset.hasUndefinedEpochOrOffset()) {\n+                assertFalse(thrown.divergentOffsets().containsKey(tp0));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5MTI1NQ==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436391255", "bodyText": "I did assertEquals with an empty map.", "author": "hachikuji", "createdAt": "2020-06-07T18:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTU4Nw==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319587", "bodyText": "Similar here, compare against an actual map to ensure no unexpected topic partitions exist.", "author": "abbccdda", "createdAt": "2020-06-07T02:59:50Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3856,12 +3857,16 @@ private void testOffsetValidationWithGivenEpochOffset(final EpochEndOffset epoch\n         assertEquals(initialOffset, subscriptions.position(tp0).offset);\n \n         if (offsetResetStrategy == OffsetResetStrategy.NONE) {\n-            OffsetOutOfRangeException thrown =\n-                assertThrows(OffsetOutOfRangeException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            LogTruncationException thrown =\n+                assertThrows(LogTruncationException.class, () -> fetcher.validateOffsetsIfNeeded());\n+            assertEquals(initialOffset, thrown.offsetOutOfRangePartitions().get(tp0).longValue());\n \n-            // If epoch offset is valid, we are testing for the log truncation case.\n-            if (!epochEndOffset.hasUndefinedEpochOrOffset()) {\n-                assertTrue(thrown instanceof LogTruncationException);\n+            if (epochEndOffset.hasUndefinedEpochOrOffset()) {\n+                assertFalse(thrown.divergentOffsets().containsKey(tp0));\n+            } else {\n+                OffsetAndMetadata expectedDivergentOffset = new OffsetAndMetadata(\n+                    epochEndOffset.endOffset(), Optional.of(epochEndOffset.leaderEpoch()), \"\");\n+                assertEquals(expectedDivergentOffset, thrown.divergentOffsets().get(tp0));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxOTYzMg==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436319632", "bodyText": "divergentOffsetMetadataOpt -> logTruncationOpt, same for the rest.", "author": "abbccdda", "createdAt": "2020-06-07T03:00:28Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java", "diffHunk": "@@ -572,7 +573,7 @@ public void testMaybeCompleteValidationAfterPositionChange() {\n                 Optional.of(updateOffsetEpoch), new Metadata.LeaderAndEpoch(Optional.of(broker1), Optional.of(currentEpoch)));\n         state.seekUnvalidated(tp0, updatePosition);\n \n-        Optional<OffsetAndMetadata> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,\n+        Optional<LogTruncation> divergentOffsetMetadataOpt = state.maybeCompleteValidation(tp0, initialPosition,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMDExNg==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436320116", "bodyText": "I was thinking where is the best to put the check, since previously it was before maybeCompleteValidation. If the partition is not awaiting validation or the returned result doesn't match our current position, should we still trigger undefined epoch offset logic here?", "author": "abbccdda", "createdAt": "2020-06-07T03:10:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -480,6 +480,17 @@ public synchronized boolean maybeValidatePositionForCurrentLeader(ApiVersions ap\n                 log.debug(\"Skipping completed validation for partition {} since the current position {} \" +\n                                 \"no longer matches the position {} when the request was sent\",\n                         tp, currentPosition, requestPosition);\n+            } else if (epochEndOffset.hasUndefinedEpochOrOffset()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NzE1NA==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r436387154", "bodyText": "If the fetch position has changed or we are no longer awaiting validation, we want to ignore the result. This was a bug in the previous patch which we didn't catch.", "author": "hachikuji", "createdAt": "2020-06-07T17:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMDExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NTA4OQ==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r438245089", "bodyText": "Ok, so before this change, we were raising OffsetOutOfRangeException regardless of the state of the subscription which meant that a regular truncation case was being masked as a failed offset validation?", "author": "mumrah", "createdAt": "2020-06-10T16:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMDExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcxOTY2OA==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r441719668", "bodyText": "It was what @abbccdda and I had agreed in the previous PR. The problem was that we didn't have divergent offsets to include in the exception, so we just raised it as OffsetOutOfRange. After I noticed the problem with LogTruncationException here, I decided to just simplify the logic here and return the truncation exception with the divergent offsets undefined.", "author": "hachikuji", "createdAt": "2020-06-17T17:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0MjExNQ==", "url": "https://github.com/apache/kafka/pull/8822#discussion_r438242115", "bodyText": "Need to update the return javadoc", "author": "mumrah", "createdAt": "2020-06-10T16:08:27Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -466,9 +466,9 @@ public synchronized boolean maybeValidatePositionForCurrentLeader(ApiVersions ap\n      * Attempt to complete validation with the end offset returned from the OffsetForLeaderEpoch request.\n      * @return The diverging offset if truncation was detected and no reset policy is defined.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "328da43a87902361752dd9f7a192ba16f84fc497", "url": "https://github.com/apache/kafka/commit/328da43a87902361752dd9f7a192ba16f84fc497", "message": "KAFKA-10113; Specify fetch offsets correctly in LogTruncationException", "committedDate": "2020-06-18T05:39:56Z", "type": "commit"}, {"oid": "8e513c66de8b4a8ba5e36bc7a3b88543a279e8ea", "url": "https://github.com/apache/kafka/commit/8e513c66de8b4a8ba5e36bc7a3b88543a279e8ea", "message": "review comments", "committedDate": "2020-06-18T05:39:56Z", "type": "commit"}, {"oid": "0fa803c0899f0e678f52eb7bc4d438e8b33bd70a", "url": "https://github.com/apache/kafka/commit/0fa803c0899f0e678f52eb7bc4d438e8b33bd70a", "message": "Fix return javadoc for `maybeCompleteValidation`", "committedDate": "2020-06-18T05:39:56Z", "type": "commit"}, {"oid": "0fa803c0899f0e678f52eb7bc4d438e8b33bd70a", "url": "https://github.com/apache/kafka/commit/0fa803c0899f0e678f52eb7bc4d438e8b33bd70a", "message": "Fix return javadoc for `maybeCompleteValidation`", "committedDate": "2020-06-18T05:39:56Z", "type": "forcePushed"}]}