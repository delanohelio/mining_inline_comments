{"pr_number": 8983, "pr_title": "KAFKA-8398: Prevent NPE in `forceUnmap`", "pr_createdAt": "2020-07-06T00:57:31Z", "pr_url": "https://github.com/apache/kafka/pull/8983", "timeline": [{"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81", "url": "https://github.com/apache/kafka/commit/a37ad7cde90a3c0be6ba936ca6e4180b1418ef81", "message": "KAFKA-8398: Prevent NPE in `forceUnmap`\n\nWithout this change, we would catch the NPE and log it.\nThis was misleading and could cause excessive log\nvolume.\n\nThe NPE can happen after `AlterReplicaLogDirs` completes\nsuccessfully and when unmapping older regions. Example\nstacktrace:\n\n```text\n[2019-05-20 14:08:13,999] ERROR Error unmapping index /tmp/kafka-logs/test-0.567a0d8ff88b45ab95794020d0b2e66f-delete/00000000000000000000.index (kafka.log.OffsetIndex)\njava.lang.NullPointerException\nat org.apache.kafka.common.utils.MappedByteBuffers.unmap(MappedByteBuffers.java:73)\nat kafka.log.AbstractIndex.forceUnmap(AbstractIndex.scala:318)\nat kafka.log.AbstractIndex.safeForceUnmap(AbstractIndex.scala:308)\nat kafka.log.AbstractIndex.$anonfun$closeHandler$1(AbstractIndex.scala:257)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)\nat kafka.log.AbstractIndex.closeHandler(AbstractIndex.scala:257)\nat kafka.log.AbstractIndex.deleteIfExists(AbstractIndex.scala:226)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$6(LogSegment.scala:597)\nat kafka.log.LogSegment.delete$1(LogSegment.scala:585)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$5(LogSegment.scala:597)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1(CoreUtils.scala:115)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1$adapted(CoreUtils.scala:114)\nat scala.collection.immutable.List.foreach(List.scala:392)\nat kafka.utils.CoreUtils$.tryAll(CoreUtils.scala:114)\nat kafka.log.LogSegment.deleteIfExists(LogSegment.scala:599)\nat kafka.log.Log.$anonfun$delete$3(Log.scala:1762)\nat kafka.log.Log.$anonfun$delete$3$adapted(Log.scala:1762)\nat scala.collection.Iterator.foreach(Iterator.scala:941)\nat scala.collection.Iterator.foreach$(Iterator.scala:941)\nat scala.collection.AbstractIterator.foreach(Iterator.scala:1429)\nat scala.collection.IterableLike.foreach(IterableLike.scala:74)\nat scala.collection.IterableLike.foreach$(IterableLike.scala:73)\nat scala.collection.AbstractIterable.foreach(Iterable.scala:56)\nat kafka.log.Log.$anonfun$delete$2(Log.scala:1762)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.log.Log.maybeHandleIOException(Log.scala:2013)\nat kafka.log.Log.delete(Log.scala:1759)\nat kafka.log.LogManager.deleteLogs(LogManager.scala:761)\nat kafka.log.LogManager.$anonfun$deleteLogs$6(LogManager.scala:775)\nat kafka.utils.KafkaScheduler.$anonfun$schedule$2(KafkaScheduler.scala:114)\nat kafka.utils.CoreUtils$$anon$1.run(CoreUtils.scala:63)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat java.lang.Thread.run(Thread.java:748)\n```", "committedDate": "2020-07-06T00:55:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MTg3Mg==", "url": "https://github.com/apache/kafka/pull/8983#discussion_r449971872", "bodyText": "#7387 added null check to forceUnmap rather than safeForceUnmap. Which one makes sense? For another, forceUnmap is used by safeForceUnmap only. We can merge them so above question gets resolved.", "author": "chia7712", "createdAt": "2020-07-06T03:58:25Z", "path": "core/src/main/scala/kafka/log/AbstractIndex.scala", "diffHunk": "@@ -311,9 +311,11 @@ abstract class AbstractIndex(@volatile private var _file: File, val baseOffset:\n   }\n \n   protected def safeForceUnmap(): Unit = {\n-    try forceUnmap()\n-    catch {\n-      case t: Throwable => error(s\"Error unmapping index $file\", t)\n+    if (mmap != null) {", "originalCommit": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3ODcyNQ==", "url": "https://github.com/apache/kafka/pull/8983#discussion_r449978725", "bodyText": "This one and hence why I did it this way.", "author": "ijuma", "createdAt": "2020-07-06T04:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MTg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3OTMwMQ==", "url": "https://github.com/apache/kafka/pull/8983#discussion_r450279301", "bodyText": "To clarify, we do use forceUnmap directly in a test. It's difficult to test methods that swallow all exceptions and hence it's useful to have forceUnmap from that perspective.", "author": "ijuma", "createdAt": "2020-07-06T14:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MTg3Mg=="}], "type": "inlineReview"}]}