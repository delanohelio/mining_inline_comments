{"pr_number": 8280, "pr_title": "KAFKA-9707: Fix InsertField.Key should apply to keys of tombstone records", "pr_createdAt": "2020-03-11T21:49:11Z", "pr_url": "https://github.com/apache/kafka/pull/8280", "timeline": [{"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "url": "https://github.com/apache/kafka/commit/25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "message": "KAFKA-9707: Fix InsertField.Key not applying to tombstone events\n\n* Fix typo that hardcoded .value() instead of abstract operatingValue\n* Add test for Key transform that was previously not tested\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-11T21:46:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTUxNA==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391311514", "bodyText": "Maybe also assertNull the value just for completeness?", "author": "ncliang", "createdAt": "2020-03-11T22:42:29Z", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "originalCommit": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMzQ5Ng==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391313496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(null, transformedRecord.value());", "author": "gharris1727", "createdAt": "2020-03-11T22:48:19Z", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "originalCommit": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63", "url": "https://github.com/apache/kafka/commit/af8eb9207b2fbadd6b9dd8b3157394607029dc63", "message": "Add null value assertion to tombstone test", "committedDate": "2020-03-11T22:48:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEwOTk2Nw==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398109967", "bodyText": "Can we please clean up the logic? This method no longer returns true if it's just a tombstone record; it also returns true if the key is null for InsertField$Key.\nI'd suggest removing this method altogether and just changing the point where this method is called to simply be:\n          if (operatingValue(record) == null) {", "author": "rhauch", "createdAt": "2020-03-25T19:20:38Z", "path": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/InsertField.java", "diffHunk": "@@ -137,7 +137,7 @@ public R apply(R record) {\n     }\n \n     private boolean isTombstoneRecord(R record) {\n-        return record.value() == null;\n+        return operatingValue(record) == null;", "originalCommit": "af8eb9207b2fbadd6b9dd8b3157394607029dc63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExMzkxMg==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398113912", "bodyText": "Plus one for this; confusion around the term tombstone has already caused plenty of miscommunication around this issue and we should be careful to use it correctly.", "author": "C0urante", "createdAt": "2020-03-25T19:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEwOTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExMTAxMg==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398111012", "bodyText": "This method is testing that the function works when applied to a tombstone record with a non-null key, but we should add a test that verifies the function skips a record that has a null key.", "author": "rhauch", "createdAt": "2020-03-25T19:22:33Z", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,40 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());", "originalCommit": "af8eb9207b2fbadd6b9dd8b3157394607029dc63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a", "url": "https://github.com/apache/kafka/commit/54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a", "message": "Remove mis-named function and add test for passing-through a null-keyed record.\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-25T19:42:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNTA2NQ==", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398125065", "bodyText": "Wouldn't it be sufficient to replace these two asserts with the following?\n   assertSame(record, transformedRecord);\n\nThis is a bit more correct, since we want to assert that in this case the transform returns the original record. WDYT?", "author": "rhauch", "createdAt": "2020-03-25T19:47:29Z", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,60 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertKeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());\n+    }\n+\n+    @Test\n+    public void insertIntoNullKeyLeavesKeyUnchanged() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+          null, null, null, Collections.singletonMap(\"magic\", 42L));\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(null, transformedRecord.key());\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.value()).get(\"magic\"));", "originalCommit": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d8105ef99160af136b86fd4fce2a9572c714ca3", "url": "https://github.com/apache/kafka/commit/5d8105ef99160af136b86fd4fce2a9572c714ca3", "message": "Simplify unchanged record assertion\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-25T19:55:55Z", "type": "commit"}, {"oid": "a75bcc27e9dc14123cb2ef1c1c651204918ef296", "url": "https://github.com/apache/kafka/commit/a75bcc27e9dc14123cb2ef1c1c651204918ef296", "message": "Replace assertEquals with assertSame\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-25T20:49:02Z", "type": "commit"}, {"oid": "34eacf09195d560b288cafca4e4be036885b7f0a", "url": "https://github.com/apache/kafka/commit/34eacf09195d560b288cafca4e4be036885b7f0a", "message": "Fix checkstyleTest indent issue\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-26T05:36:31Z", "type": "commit"}]}