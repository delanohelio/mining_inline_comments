{"pr_number": 8330, "pr_title": "KAFKA-9742: Fix broken StandbyTaskEOSIntegrationTest", "pr_createdAt": "2020-03-22T23:21:49Z", "pr_url": "https://github.com/apache/kafka/pull/8330", "timeline": [{"oid": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "url": "https://github.com/apache/kafka/commit/269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "message": "KAFKA-9742: Fix broken StandbyTaskEOSIntegrationTest", "committedDate": "2020-03-22T23:03:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1ODc1MA==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396158750", "bodyText": "I moved this into a try-with-resources so that the instances would get closed even if the assertions fail.", "author": "vvcephei", "createdAt": "2020-03-22T23:23:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -82,29 +82,27 @@ public void surviveWithOneTaskAsStandby() throws ExecutionException, Interrupted\n \n         final CountDownLatch instanceLatch = new CountDownLatch(1);\n \n-        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n-        final KafkaStreams streamInstanceOne =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+        try (\n+            final KafkaStreams streamInstanceOne = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-1/\", instanceLatch);\n+            final KafkaStreams streamInstanceTwo = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-2/\", instanceLatch);\n+        ) {", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1ODg4NQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396158885", "bodyText": "Close them both asynchronously so we can tear them down in parallel. The try-with-resources will block until they are really closed.", "author": "vvcephei", "createdAt": "2020-03-22T23:25:12Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -82,29 +82,27 @@ public void surviveWithOneTaskAsStandby() throws ExecutionException, Interrupted\n \n         final CountDownLatch instanceLatch = new CountDownLatch(1);\n \n-        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n-        final KafkaStreams streamInstanceOne =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+        try (\n+            final KafkaStreams streamInstanceOne = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-1/\", instanceLatch);\n+            final KafkaStreams streamInstanceTwo = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-2/\", instanceLatch);\n+        ) {\n \n-        final String stateDirPathTwo = stateDirPath + \"/\" + appId + \"-2/\";\n-        final KafkaStreams streamInstanceTwo =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathTwo, instanceLatch);\n \n-        streamInstanceOne.start();\n+            streamInstanceOne.start();\n \n-        streamInstanceTwo.start();\n+            streamInstanceTwo.start();\n \n-        // Wait for the record to be processed\n-        assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n+            // Wait for the record to be processed\n+            assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n \n-        waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n-            \"Stream instance one should be up and running by now\");\n-        waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n-            \"Stream instance one should be up and running by now\");\n-\n-        streamInstanceOne.close(Duration.ofSeconds(30));\n-        streamInstanceTwo.close(Duration.ofSeconds(30));\n+            waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n+                             \"Stream instance one should be up and running by now\");\n+            waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n+                             \"Stream instance one should be up and running by now\");\n \n+            streamInstanceOne.close(Duration.ZERO);\n+            streamInstanceTwo.close(Duration.ZERO);", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1ODk5Nw==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396158997", "bodyText": "This test isn't logically changed, but I noticed a couple of problems with it that I fixed on the side.", "author": "vvcephei", "createdAt": "2020-03-22T23:26:08Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -82,29 +82,27 @@ public void surviveWithOneTaskAsStandby() throws ExecutionException, Interrupted\n \n         final CountDownLatch instanceLatch = new CountDownLatch(1);\n \n-        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n-        final KafkaStreams streamInstanceOne =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+        try (", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396159297", "bodyText": "This is the fix, to return an accurate estimate instead of throwing an exception. I felt a warning was appropriate, given that this does indicate task corruption, or some other unexpected situation.", "author": "vvcephei", "createdAt": "2020-03-22T23:29:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ClientState.java", "diffHunk": "@@ -194,11 +199,12 @@ public void computeTaskLags(final Map<TaskId, Long> allTaskEndOffsetSums) {\n             final Long offsetSum = taskOffsetSums.getOrDefault(task, 0L);\n \n             if (endOffsetSum < offsetSum) {\n-                throw new IllegalStateException(\"Task \" + task + \" had endOffsetSum=\" + endOffsetSum +\n-                                                    \" smaller than offsetSum=\" + offsetSum);\n-            }\n-\n-            if (offsetSum == Task.LATEST_OFFSET) {\n+                LOG.warn(\"Task \" + task + \" had endOffsetSum=\" + endOffsetSum +\n+                             \" smaller than offsetSum=\" + offsetSum + \". This probably means the task is corrupted,\" +\n+                             \" which in turn indicates that it will need to restore from scratch, so we pin the lag\" +\n+                             \" to the end offset of the log.\");\n+                taskLagTotals.put(task, endOffsetSum);", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE2NTEyNw==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396165127", "bodyText": "Should we report the lag as the whole log in this case? Even if the log is truncated it is not guaranteed to throw the invalid offset exception and hence task-corruption logic would not necessarily triggered.", "author": "guozhangwang", "createdAt": "2020-03-23T00:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDQ0OQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396344449", "bodyText": "Do we know the exact reason, why the offset sum on the client is larger than the end offset sum on the broker? Before we change this invariant we should make sure we understand why it is not satisfied. Is it our code that breaks it or some external influences that we cannot control?", "author": "cadonna", "createdAt": "2020-03-23T10:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzA2NA==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396647064", "bodyText": "@guozhangwang if the end offset is less than the checkpointed offset, how is it possible to not throw a TaskCorruptedException? I thought that was thrown after checking this exact condition?\nedit: what I mean is, do we think this is a possible state? If so, we should explicitly check for it and throw TaskCorrupted if detected. (If not, it's an illegal state and thus the check here is appropriate)", "author": "ableegoldman", "createdAt": "2020-03-23T17:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDkxMQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396654911", "bodyText": "Also, @vvcephei , if a single task is corrupted and we do hit the TaskCorruptedException don't we close, wipe, and recreate stores of all tasks in the thread? Seems we would need to keep track of the thread ownership, and if we detect this condition then set the lag for all tasks owned by that thread to the endOffset\nedit: nevermind, I checked the TaskCorruptedExcepion PR, looks like we ended up just setting the invalid offsets to 0 instead of wiping everything. So, disregard this comment \ud83d\ude42", "author": "ableegoldman", "createdAt": "2020-03-23T18:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3OTIyNA==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396679224", "bodyText": "A task is corrupted if the store changelogs in the checkpoint file don't match the store changelogs in the assigned task.\nWhen the member sends its lag estimate, it doesn't validate whether the task is valid or corrupted. It just reads the values out of the checkpoint files and sums them. I think this is fine, actually, but if we want to check for task corrupted at that time, we can add that in.\nI don't think it really changes how the assignor should behave, though. I think it's could easily happen that any past, present, or future versioned member reports a task sum that's beyond the end-offset sum of what the leader thinks the task contains. If that happens, it doesn't seem like it's a good idea to just crash the leader's thread. It would be better to handle it gracefully in some way.\nIt seems like assuming the task is corrupted, and therefore essentially that it isn't cached at all, is reasonable. This just de-prioritizes that member to get assigned the task, which is harmless.", "author": "vvcephei", "createdAt": "2020-03-23T18:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NTYxMQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396685611", "bodyText": "Whoops, edited my previous comment before refreshing & seeing your response. Makes sense, although I still believe we should be checking for this and throwing TaskCorrupted if we detect this case (in the owning StreamThread, not in the leader during assignment)", "author": "ableegoldman", "createdAt": "2020-03-23T18:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5NTU4Mw==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396695583", "bodyText": "I think it's could easily happen that any past, present, or future versioned member reports a task sum that's beyond the end-offset sum of what the leader thinks the task contains.\n\nIf the corruption comes from our code, we should throw. The leader fetches the end offset shortly before that code, so they are most probably up-to-date. If the corruption is caused by failure we should handle it gracefully.", "author": "cadonna", "createdAt": "2020-03-23T19:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMTc0MQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396721741", "bodyText": "Let's think about cases where this could possibly go wrong. We know it must reach or already be in standby/restoring phase. I will use logEndOffset for the actual endOffset of the partition, and endOffset for the offset a standby/restoring task is allowed to restore up to.\nNewly-assigned: we read the invalid offset from the checkpoint, and determine the endOffset as either logEndOffset (normal) or min(logEndOffset, LCO) (optimized-source-changelog). In both cases, the endOffset <= logEndOffset so the invalid offset should also satisfy offset > endOffset which we can detect and throw as TaskCorrupted.\nAlready-assigned: in this case, we must have been the ones who wrote the invalid offset and/or have it in our checkpointableOffsets map. But we still need to fetch the endOffset to know when to stop, so the above applies here as well and we can detect the corruption.\nIn either case, I'd agree the leader should not throw and should just treat that task's offset sum as 0. But, we should make sure that on the other end we actually do detect this case and handle it the way the assignor expects.", "author": "ableegoldman", "createdAt": "2020-03-23T19:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTA2NQ==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396771065", "bodyText": "@ableegoldman If the log is truncated and then immediately more records are appended to go beyond the original log-end-offset, in old versions we would not throw the exception.\nAfter some thoughts I think it makes sense to report the lag as the whole log.", "author": "guozhangwang", "createdAt": "2020-03-23T21:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4ODEzNg==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396788136", "bodyText": "Thanks for the conversation, all. I think where it nets out for me is that we don't really expect this to happen for non-bugged code, but there are a few edge cases where it could. Thus, logging a warning actually seems reasonable.\nSince the graceful handling option is still safe in any case, and since there do exist edge cases where this condition doesn't indicate a bug in Streams, we'll just keep the proposed graceful handling of reporting the lag as the whole log. Either the member in question won't get assigned the task (because it's de-prioritized wrt to other members who report valid positions), and it winds up cleaning up its state dir on its own, or it gets assigned the task, detects the corruption on its side, and recovers appropriately.", "author": "vvcephei", "createdAt": "2020-03-23T22:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1OTM0Mg==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396159342", "bodyText": "The test for the affected code of course has to change.", "author": "vvcephei", "createdAt": "2020-03-22T23:30:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/ClientStateTest.java", "diffHunk": "@@ -233,11 +233,12 @@ public void shouldReturnUnknownOffsetSumForLagOfTaskWithUnknownOffset() {\n     }\n \n     @Test\n-    public void shouldThrowIllegalStateExceptionIfOffsetSumIsGreaterThanEndOffsetSum() {\n+    public void shouldReturnEndOffsetSumIfOffsetSumIsGreaterThanEndOffsetSum() {\n         final Map<TaskId, Long> taskOffsetSums = Collections.singletonMap(taskId01, 5L);\n         final Map<TaskId, Long> allTaskEndOffsetSums = Collections.singletonMap(taskId01, 1L);\n         client.addPreviousTasksAndOffsetSums(taskOffsetSums);\n-        assertThrows(IllegalStateException.class, () -> client.computeTaskLags(allTaskEndOffsetSums));\n+        client.computeTaskLags(allTaskEndOffsetSums);\n+        assertThat(client.lagFor(taskId01), equalTo(1L));", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1NjA2Ng==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396256066", "bodyText": "Stream instance \"one\" -> \"two\"", "author": "chia7712", "createdAt": "2020-03-23T07:37:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -82,29 +82,27 @@ public void surviveWithOneTaskAsStandby() throws ExecutionException, Interrupted\n \n         final CountDownLatch instanceLatch = new CountDownLatch(1);\n \n-        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n-        final KafkaStreams streamInstanceOne =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+        try (\n+            final KafkaStreams streamInstanceOne = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-1/\", instanceLatch);\n+            final KafkaStreams streamInstanceTwo = buildStreamWithDirtyStateDir(appId, stateDirPath + \"/\" + appId + \"-2/\", instanceLatch);\n+        ) {\n \n-        final String stateDirPathTwo = stateDirPath + \"/\" + appId + \"-2/\";\n-        final KafkaStreams streamInstanceTwo =\n-            buildStreamWithDirtyStateDir(appId, stateDirPathTwo, instanceLatch);\n \n-        streamInstanceOne.start();\n+            streamInstanceOne.start();\n \n-        streamInstanceTwo.start();\n+            streamInstanceTwo.start();\n \n-        // Wait for the record to be processed\n-        assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n+            // Wait for the record to be processed\n+            assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n \n-        waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n-            \"Stream instance one should be up and running by now\");\n-        waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n-            \"Stream instance one should be up and running by now\");\n-\n-        streamInstanceOne.close(Duration.ofSeconds(30));\n-        streamInstanceTwo.close(Duration.ofSeconds(30));\n+            waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n+                             \"Stream instance one should be up and running by now\");\n+            waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n+                             \"Stream instance one should be up and running by now\");", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MDY1Ng==", "url": "https://github.com/apache/kafka/pull/8330#discussion_r396340656", "bodyText": "prop: Could you explain a bit better what the warning is about? If somebody does not know the code, it is hard to understand what is going on.", "author": "cadonna", "createdAt": "2020-03-23T10:14:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ClientState.java", "diffHunk": "@@ -194,11 +199,12 @@ public void computeTaskLags(final Map<TaskId, Long> allTaskEndOffsetSums) {\n             final Long offsetSum = taskOffsetSums.getOrDefault(task, 0L);\n \n             if (endOffsetSum < offsetSum) {\n-                throw new IllegalStateException(\"Task \" + task + \" had endOffsetSum=\" + endOffsetSum +\n-                                                    \" smaller than offsetSum=\" + offsetSum);\n-            }\n-\n-            if (offsetSum == Task.LATEST_OFFSET) {\n+                LOG.warn(\"Task \" + task + \" had endOffsetSum=\" + endOffsetSum +\n+                             \" smaller than offsetSum=\" + offsetSum + \". This probably means the task is corrupted,\" +\n+                             \" which in turn indicates that it will need to restore from scratch, so we pin the lag\" +\n+                             \" to the end offset of the log.\");\n+                taskLagTotals.put(task, endOffsetSum);", "originalCommit": "269bcf66ac9fe1a404d5d5571dfd3cbcd0b2707c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "06c17350dac09c8b4a35edeb1b3c8e29132dfa17", "url": "https://github.com/apache/kafka/commit/06c17350dac09c8b4a35edeb1b3c8e29132dfa17", "message": "CR feedback", "committedDate": "2020-03-23T22:24:44Z", "type": "commit"}]}