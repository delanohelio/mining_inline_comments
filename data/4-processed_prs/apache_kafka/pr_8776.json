{"pr_number": 8776, "pr_title": "KAFKA-9441: Improve Kafka Streams task management", "pr_createdAt": "2020-06-02T06:55:31Z", "pr_url": "https://github.com/apache/kafka/pull/8776", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659050", "bodyText": "Align code style to use switch if all states are used", "author": "mjsax", "createdAt": "2020-06-02T06:56:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1ODM5MA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434158390", "bodyText": "Is this intentional to use switch and if/else in different functions?", "author": "guozhangwang", "createdAt": "2020-06-02T20:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNTMxNQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434215315", "bodyText": "I think in general it's better to use switch and I never changed from switch -> if/else -- but did not update all methods either (if we only check for a single state, it seems overkill to use switch?", "author": "mjsax", "createdAt": "2020-06-02T22:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzNjMwNg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435636306", "bodyText": "Yup, makes sense, just curious :)", "author": "guozhangwang", "createdAt": "2020-06-05T01:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTE3NQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659175", "bodyText": "Align code style to use switch if all states are used", "author": "mjsax", "createdAt": "2020-06-02T06:56:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);\n         }\n     }\n \n     @Override\n     public void suspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            stateMgr.checkpoint(checkpointableOffsets());\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended running\");\n-        } else if (state() == State.RESTORING) {\n-            // we just checkpoint the position that we've restored up to without\n-            // going through the commit process\n-            stateMgr.checkpoint(emptyMap());\n-\n-            // we should also clear any buffered records of a task when suspending it\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+        switch (state()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTI3Nw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659277", "bodyText": "Minor: improve error message", "author": "mjsax", "createdAt": "2020-06-02T06:57:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTMyMA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659320", "bodyText": "Minor: improve error message", "author": "mjsax", "createdAt": "2020-06-02T06:57:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);\n         }\n     }\n \n     @Override\n     public void suspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            stateMgr.checkpoint(checkpointableOffsets());\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended running\");\n-        } else if (state() == State.RESTORING) {\n-            // we just checkpoint the position that we've restored up to without\n-            // going through the commit process\n-            stateMgr.checkpoint(emptyMap());\n-\n-            // we should also clear any buffered records of a task when suspending it\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip suspending since state is {}\", state());\n+\n+                break;\n+\n+            case RUNNING:\n+                stateMgr.checkpoint(checkpointableOffsets());\n+                partitionGroup.clear();\n+\n+                transitionTo(State.SUSPENDED);\n+                log.info(\"Suspended running\");\n+\n+                break;\n+\n+            case RESTORING:\n+                // we just checkpoint the position that we've restored up to without\n+                // going through the commit process\n+                stateMgr.checkpoint(emptyMap());\n+\n+                // we should also clear any buffered records of a task when suspending it\n+                partitionGroup.clear();\n+\n+                transitionTo(State.SUSPENDED);\n+                log.info(\"Suspended restoring\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTcxMQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659711", "bodyText": "State \"closing\" was removed in a previous PR already; just updating the comment", "author": "mjsax", "createdAt": "2020-06-02T06:58:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -59,14 +58,9 @@\n      *          |            |                      |         |\n      *          |            |                      |         |\n      *          |            v                      |         |\n-     *          |      +-----+-------+              |         |\n-     *          +----> | Closing (4) | <------------+         |\n-     *                 +-----+-------+                        |\n-     *                       |                                |\n-     *                       v                                |\n-     *                 +-----+-------+                        |\n-     *                 | Closed (5)  | -----------------------+\n-     *                 +-------------+\n+     *          |      +-----+-------+ <------------+         |\n+     *          +----> | Closed (4)  |                        |\n+     *                 +-------------+ <----------------------+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTk1NQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659955", "bodyText": "Making tasks idempotent; this check is not required any longer.", "author": "mjsax", "createdAt": "2020-06-02T06:58:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -390,19 +387,17 @@ boolean tryToCompleteRestoration() {\n \n         final List<Task> restoringTasks = new LinkedList<>();\n         for (final Task task : tasks.values()) {\n-            if (task.state() == CREATED) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDI3Ng==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433660276", "bodyText": "StandbyTask are never in RESTORING state.", "author": "mjsax", "createdAt": "2020-06-02T06:59:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -390,19 +387,17 @@ boolean tryToCompleteRestoration() {\n \n         final List<Task> restoringTasks = new LinkedList<>();\n         for (final Task task : tasks.values()) {\n-            if (task.state() == CREATED) {\n-                try {\n-                    task.initializeIfNeeded();\n-                } catch (final LockException | TimeoutException e) {\n-                    // it is possible that if there are multiple threads within the instance that one thread\n-                    // trying to grab the task from the other, while the other has not released the lock since\n-                    // it did not participate in the rebalance. In this case we can just retry in the next iteration\n-                    log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n-                    allRunning = false;\n-                }\n+            try {\n+                task.initializeIfNeeded();\n+            } catch (final LockException | TimeoutException e) {\n+                // it is possible that if there are multiple threads within the instance that one thread\n+                // trying to grab the task from the other, while the other has not released the lock since\n+                // it did not participate in the rebalance. In this case we can just retry in the next iteration\n+                log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n+                allRunning = false;\n             }\n \n-            if (task.state() == RESTORING) {\n+            if (task.isActive()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzODQ5NQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434038495", "bodyText": "Can we add a comment or rename restoringTasks to clarify that it's ok to put an active-but-not-restoring task in here since Task#completeRestoration is idempotent/no-op for RUNNING tasks?", "author": "ableegoldman", "createdAt": "2020-06-02T17:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNzc5Ng==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434117796", "bodyText": "Ack. -- I think this need further refactoring... Will do in a follow up PR. Renaming for now.", "author": "mjsax", "createdAt": "2020-06-02T19:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDU4OA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433660588", "bodyText": "Make TM agnostic to task state -- putting some more logic into sumOfChangelogOffsets to make this work -- note that task.changelogOffsets() set offsets to LATEST_OFFSET for StreamsTasks that are RUNNING.", "author": "mjsax", "createdAt": "2020-06-02T07:00:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -529,11 +524,7 @@ void handleLostAll() {\n         for (final TaskId id : lockedTaskDirectories) {\n             final Task task = tasks.get(id);\n             if (task != null) {\n-                if (task.isActive() && task.state() == RUNNING) {\n-                    taskOffsetSums.put(id, Task.LATEST_OFFSET);\n-                } else {\n-                    taskOffsetSums.put(id, sumOfChangelogOffsets(id, task.changelogOffsets()));\n-                }\n+                taskOffsetSums.put(id, sumOfChangelogOffsets(id, task.changelogOffsets()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433661972", "bodyText": "If an active tasks is RUNNING, the offsets are set to LATEST_OFFSET in task.changelogOffsets() that is passed as parameter.", "author": "mjsax", "createdAt": "2020-06-02T07:03:19Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNzM0NA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434037344", "bodyText": "nice", "author": "ableegoldman", "createdAt": "2020-06-02T17:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNDAyOA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434114028", "bodyText": "Should we also check task.isActive here?", "author": "abbccdda", "createdAt": "2020-06-02T19:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNzc5Ng==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434217796", "bodyText": "No necessary IMHO, because offset == Task.LATEST_OFFSET can only be true iff the task is active. For Standbys the offset is never set to LATEST_OFFSET (cf. StreamTask#changelogOffsets() and StandbyTask#changelogOffsets())", "author": "mjsax", "createdAt": "2020-06-02T22:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjgzNg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435522836", "bodyText": "This seems pretty subtle, can you convert your GH explanation into a code comment?\nIt also seems mentioning that we assume that if any changelog offset in the task is \"latest\", then we assume the whole task is active and therefore return \"latest\". Took me a minute to work that out.", "author": "vvcephei", "createdAt": "2020-06-04T20:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1NTAwMA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435555000", "bodyText": "Well, this is by definition of the sentinel LATEST_OFFSET -- but I agree it's subtle that if any offset is \"latest\" then we know they all are, ie the task is active and RUNNING", "author": "ableegoldman", "createdAt": "2020-06-04T21:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4ODAyOA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435588028", "bodyText": "Sure, can add a comment.", "author": "mjsax", "createdAt": "2020-06-04T22:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MjM0Mg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433662342", "bodyText": "A \"standby\" must transit to RUNNING here (cf StandbyTask)", "author": "mjsax", "createdAt": "2020-06-02T07:04:15Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -2637,11 +2646,17 @@ private File getCheckpointFile(final TaskId task) {\n         public void initializeIfNeeded() {\n             if (state() == State.CREATED) {\n                 transitionTo(State.RESTORING);\n+                if (!active) {\n+                    transitionTo(State.RUNNING);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MjQyNg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433662426", "bodyText": "Must be idempotent.", "author": "mjsax", "createdAt": "2020-06-02T07:04:30Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -2637,11 +2646,17 @@ private File getCheckpointFile(final TaskId task) {\n         public void initializeIfNeeded() {\n             if (state() == State.CREATED) {\n                 transitionTo(State.RESTORING);\n+                if (!active) {\n+                    transitionTo(State.RUNNING);\n+                }\n             }\n         }\n \n         @Override\n         public void completeRestoration() {\n+            if (state() == State.RUNNING) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNDY2Mw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434034663", "bodyText": "Can we use if/ else if here for consistency?", "author": "ableegoldman", "createdAt": "2020-06-02T17:03:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -218,6 +218,10 @@ public void initializeIfNeeded() {\n      */\n     @Override\n     public void completeRestoration() {\n+        if (state() == State.RUNNING) {\n+            return;\n+        }\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0Nzc1OA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434047758", "bodyText": "I think this might be one of those exceptions where we should still enforce that the state is not CLOSED (ie throw IllegalStateException) since there are related actions that occur outside of the Task implementation that will fail if we try to recycle a CLOSED task. Similar to prepare/post commit, resume, etc", "author": "ableegoldman", "createdAt": "2020-06-02T17:26:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -466,6 +510,11 @@ public void closeAndRecycleState() {\n                 stateMgr.recycle();\n                 recordCollector.close();\n                 break;\n+\n+            case CLOSED:\n+                log.trace(\"Skip close since state is {}\", state());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDQ0NQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434050445", "bodyText": "github won't let me leave a comment below this line, but can we use the \"Illegal state\"/\"Unknown state\" improvement in this method as well?", "author": "ableegoldman", "createdAt": "2020-06-02T17:30:35Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -218,6 +218,10 @@ public void initializeIfNeeded() {\n      */\n     @Override\n     public void completeRestoration() {\n+        if (state() == State.RUNNING) {\n+            return;\n+        }\n+\n         if (state() == State.RESTORING) {\n             initializeMetadata();\n             initializeTopology();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434050826", "bodyText": "Illegal state -> Unknown state?", "author": "ableegoldman", "createdAt": "2020-06-02T17:31:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {\n+            log.trace(\"Skip closing since state is {}\", state());\n+            return;\n         } else {\n             throw new IllegalStateException(\"Illegal state \" + state() + \" while closing standby task \" + id);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMTQyNg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434111426", "bodyText": "The state could be RESTORING what is illegal but not unknown -- We would need more conditions to distinguish both cases (introducing switch() would be helpful for this case). Thoughts?\nI guess this applied to other places in the code, too. I am happy to update all. Was just hesitant.", "author": "mjsax", "createdAt": "2020-06-02T19:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExODgwMA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434118800", "bodyText": "I see. I guess personally I'd prefer to use a switch and just case all states explicitly, to make it clear when an action is a no-op for a certain state", "author": "ableegoldman", "createdAt": "2020-06-02T19:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyMTg5Mg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434121892", "bodyText": "I'd be in favor... I can see how the choice can go both ways on if/else vs. switch, but at the end of the day, it's nice just to do the same thing everywhere. I think switch tends to be nicer when you need to enumerate most/all of the cases, which seems to be the direction we're heading here.", "author": "vvcephei", "createdAt": "2020-06-02T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyMDIyOQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434220229", "bodyText": "I update most. Only left a few for which we only check a single state (seems overkill to use switch() for this case). Is that ok with you?", "author": "mjsax", "createdAt": "2020-06-02T22:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MTE5MA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434051190", "bodyText": "Should we switch to switch here as well?", "author": "ableegoldman", "createdAt": "2020-06-02T17:31:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMDMxNA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434110314", "bodyText": "We could... (cf. comment below)", "author": "mjsax", "createdAt": "2020-06-02T19:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwNzEyNw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434107127", "bodyText": "nit: call -> calls", "author": "abbccdda", "createdAt": "2020-06-02T18:55:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1799,8 +1799,8 @@ public void shouldThrowIfClosingOnIllegalState() {\n         task.closeClean(checkpoint);\n \n         // close call are not idempotent since we are already in closed", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTg2NA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434109864", "bodyText": "We could just say Skip closing since state is closed here", "author": "abbccdda", "createdAt": "2020-06-02T19:00:30Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {\n+            log.trace(\"Skip closing since state is {}\", state());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMjAxNA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434112014", "bodyText": "Could we merge the case CLOSED and CREATED? Also could you elaborate why we do empty checkpoint map instead of null?", "author": "abbccdda", "createdAt": "2020-06-02T19:04:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +542,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {\n+            case CREATED:\n+                // the task is created and not initialized, just re-write the checkpoint file\n+                checkpoint = Collections.emptyMap();\n \n-            if (clean) {\n-                stateMgr.flush();\n-                recordCollector.flush();\n-                checkpoint = checkpointableOffsets();\n-            } else {\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(clean);\n+\n+                if (clean) {\n+                    stateMgr.flush();\n+                    recordCollector.flush();\n+                    checkpoint = checkpointableOffsets();\n+                } else {\n+                    checkpoint = null; // `null` indicates to not write a checkpoint\n+                    executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n+                }\n+\n+                break;\n+\n+            case RESTORING:\n+                executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+                checkpoint = Collections.emptyMap();\n+\n+                break;\n+\n+            case SUSPENDED:\n+                // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n                 checkpoint = null; // `null` indicates to not write a checkpoint\n-                executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n-            }\n-        } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.SUSPENDED) {\n-            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n-            checkpoint = null; // `null` indicates to not write a checkpoint\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while prepare closing active task \" + id);\n+\n+                break;\n+            case CLOSED:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNjc3Mw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434216773", "bodyText": "Not sure if we can merge CLOSE and CREATED -- but I plan to do follow up PRs to change state handling further. Hence, I would like to keep it out-of-scope for this PR.\nemptyMap() is not an empty checkpoint: the map we return is some additional data we write into the checkpoint. null on the other hand means to not write any checkpoint but in a clean-close case we want to write a checkpoint.", "author": "mjsax", "createdAt": "2020-06-02T22:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MDk5Ng==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434160996", "bodyText": "Out of the scope of this PR: why we need to return the checkpoint map to bookkeep at the task-manager? It seems we just re-distribute it in the close call.\nI think we do not need to expose the checkpoint map in task-manager eventually?", "author": "guozhangwang", "createdAt": "2020-06-02T20:37:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +549,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNTkxNw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434215917", "bodyText": "Not 100% sure what the end state will be atm, but yes, we should be able to simplify this further in follow up PRs.", "author": "mjsax", "createdAt": "2020-06-02T22:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MDk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIyMw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434164223", "bodyText": "I think we should use null to indicate no need to write new checkpoint?", "author": "guozhangwang", "createdAt": "2020-06-02T20:43:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +549,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {\n+            case CREATED:\n+                // the task is created and not initialized, just re-write the checkpoint file\n+                checkpoint = Collections.emptyMap();\n \n-            if (clean) {\n-                stateMgr.flush();\n-                recordCollector.flush();\n-                checkpoint = checkpointableOffsets();\n-            } else {\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(clean);\n+\n+                if (clean) {\n+                    stateMgr.flush();\n+                    recordCollector.flush();\n+                    checkpoint = checkpointableOffsets();\n+                } else {\n+                    checkpoint = null; // `null` indicates to not write a checkpoint\n+                    executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n+                }\n+\n+                break;\n+\n+            case RESTORING:\n+                executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+                checkpoint = Collections.emptyMap();\n+\n+                break;\n+\n+            case SUSPENDED:\n+                // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n                 checkpoint = null; // `null` indicates to not write a checkpoint\n-                executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n-            }\n-        } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.SUSPENDED) {\n-            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n-            checkpoint = null; // `null` indicates to not write a checkpoint\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while prepare closing active task \" + id);\n+\n+                break;\n+            case CLOSED:\n+                checkpoint = Collections.emptyMap();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIxNzAzNw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434217037", "bodyText": "Was not 100% -- could null not lead to a wipeout of an existing checkpoint file? Writing the checkpoint again should be idempotent?", "author": "mjsax", "createdAt": "2020-06-02T22:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MjI1NA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434892254", "bodyText": "I think null and emptyMap has different semantics: the former indicates do not try to override the checkpoint file, while the latter indicates \u201cjust writing the checkpoint file as of the current state store maintained offset\u201d I.e. in stateMgr.checkpoint(writtenOffsets)  if the map is empty, we would still write the checkpoint file but just based on each store\u2019s current storeMetadata.offset.\nSo back to prepareClose: if we are in CREATED, meaning we\u2019ve read the checkpoint file into the store, we still need to write that loaded offsets back to the file; in SUSPENDED we know we\u2019ve written the offset to the checkpoint file already when transiting to that state, so we can return null to indicate no need to write again.", "author": "guozhangwang", "createdAt": "2020-06-03T22:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIyMw=="}], "type": "inlineReview"}, {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "url": "https://github.com/apache/kafka/commit/9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "message": "KAFKA-9441: Improve Kafka Streams task management\n - make task manager agnostic to task state\n - make tasks state transitions idempotent", "committedDate": "2020-06-04T00:26:39Z", "type": "commit"}, {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "url": "https://github.com/apache/kafka/commit/9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "message": "KAFKA-9441: Improve Kafka Streams task management\n - make task manager agnostic to task state\n - make tasks state transitions idempotent", "committedDate": "2020-06-04T00:26:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzgyOQ==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435523829", "bodyText": "It might be nice to have a sanity check here that offset is non-negative, since that would indicate we've unexpectedly received a sentinel value. I thought we did that already, but it's obviously not here.", "author": "vvcephei", "createdAt": "2020-06-04T20:16:30Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {\n+                return Task.LATEST_OFFSET;\n+            } else {\n+                offsetSum += offset;", "originalCommit": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1MjUwMg==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435552502", "bodyText": "We put the check for negative offsets in the RecordCollector, but I guess it doesn't hurt to check again here?", "author": "ableegoldman", "createdAt": "2020-06-04T21:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1OTg2MA==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435559860", "bodyText": "Aha! Thanks. Yeah, I'd be in favor of coding defensively here as well.", "author": "vvcephei", "createdAt": "2020-06-04T21:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTcwNw==", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435589707", "bodyText": "Ack", "author": "mjsax", "createdAt": "2020-06-04T22:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzgyOQ=="}], "type": "inlineReview"}, {"oid": "f98207900282ef4d7a27980a4cc018216098236c", "url": "https://github.com/apache/kafka/commit/f98207900282ef4d7a27980a4cc018216098236c", "message": "Github comments", "committedDate": "2020-06-04T22:38:26Z", "type": "commit"}]}