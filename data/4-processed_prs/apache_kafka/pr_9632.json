{"pr_number": 9632, "pr_title": "KAFKA-10702; Skip bookkeeping of empty transactions", "pr_createdAt": "2020-11-20T21:11:05Z", "pr_url": "https://github.com/apache/kafka/pull/9632", "timeline": [{"oid": "4a61c530b8f331eea0dc80eb31bae26a36f52d6b", "url": "https://github.com/apache/kafka/commit/4a61c530b8f331eea0dc80eb31bae26a36f52d6b", "message": "KAFKA-10702; Skip transaction bookkeeping of empty transactions", "committedDate": "2020-11-20T21:02:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjkzNQ==", "url": "https://github.com/apache/kafka/pull/9632#discussion_r528006935", "bodyText": "Could you check my understanding? If we have a a non-empty currentTxnFirstOffset value (indicating a non-empty transaction), we'll return a valid CompletedTxn, otherwise we will return None. For the empty transactions this means that we aren't accumulating completed transactions. This saves us from having to call lastStableOffset on every empty completed transaction https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/Log.scala#L1240?", "author": "lbradstreet", "createdAt": "2020-11-20T22:35:44Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -301,26 +304,28 @@ private[log] class ProducerAppendInfo(val topicPartition: TopicPartition,\n     }\n   }\n \n-  def appendEndTxnMarker(endTxnMarker: EndTransactionMarker,\n-                         producerEpoch: Short,\n-                         offset: Long,\n-                         timestamp: Long): CompletedTxn = {\n+  def appendEndTxnMarker(\n+    endTxnMarker: EndTransactionMarker,\n+    producerEpoch: Short,\n+    offset: Long,\n+    timestamp: Long\n+  ): Option[CompletedTxn] = {\n     checkProducerEpoch(producerEpoch, offset)\n     checkCoordinatorEpoch(endTxnMarker, offset)\n \n-    val firstOffset = updatedEntry.currentTxnFirstOffset match {\n-      case Some(txnFirstOffset) => txnFirstOffset\n-      case None =>\n-        transactions += new TxnMetadata(producerId, offset)\n-        offset\n+    // Only emit the `CompletedTxn` for non-empty transactions. A transaction marker\n+    // without any associated data will not have any impact on the last stable offset\n+    // and would not need to be reflected in the transaction index.\n+    val completedTxn = updatedEntry.currentTxnFirstOffset.map { firstOffset =>\n+      CompletedTxn(producerId, firstOffset, offset, endTxnMarker.controlType == ControlRecordType.ABORT)", "originalCommit": "4a61c530b8f331eea0dc80eb31bae26a36f52d6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNzYzNw==", "url": "https://github.com/apache/kafka/pull/9632#discussion_r528007637", "bodyText": "Yes, that is right. Additionally, we are not adding the transaction to the list of started transactions which are accumulated in the ProducerAppendInfo.", "author": "hachikuji", "createdAt": "2020-11-20T22:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjkzNQ=="}], "type": "inlineReview"}, {"oid": "99894fcfa96d090e8042085a45227b94d07fc872", "url": "https://github.com/apache/kafka/commit/99894fcfa96d090e8042085a45227b94d07fc872", "message": "Fix failed test `LogTest.testAppendToTransactionIndexFailure`", "committedDate": "2020-11-30T19:59:13Z", "type": "commit"}]}