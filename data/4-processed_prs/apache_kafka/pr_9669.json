{"pr_number": 9669, "pr_title": "KAFKA-10792: Prevent source task shutdown from blocking herder thread", "pr_createdAt": "2020-12-01T19:59:55Z", "pr_url": "https://github.com/apache/kafka/pull/9669", "timeline": [{"oid": "2be183ef36640deae7b9a75166639e72ee1d7929", "url": "https://github.com/apache/kafka/commit/2be183ef36640deae7b9a75166639e72ee1d7929", "message": "KAFKA-10792: Prevent source task shutdown from blocking herder thread", "committedDate": "2020-12-01T19:53:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODc2NA==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r533788764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // can happy reliably if it's started in the PAUSED state), we don't have to invoke stop on it\n          \n          \n            \n                    // can happen reliably if it's started in the PAUSED state), we don't have to invoke stop on it", "author": "ncliang", "createdAt": "2020-12-01T23:21:02Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java", "diffHunk": "@@ -206,16 +203,13 @@ public void cancel() {\n     public void stop() {\n         super.stop();\n         stopRequestedLatch.countDown();\n-        synchronized (this) {\n-            if (finishedStart)\n-                tryStop();\n-            else\n-                startedShutdownBeforeStartCompleted = true;\n-        }\n     }\n \n-    private synchronized void tryStop() {\n-        if (!stopped) {\n+    // Note: This method is not thread-safe\n+    private void tryStop() {\n+        // If the task is scheduled for shutdown before we invoke initialize or start on it (which\n+        // can happy reliably if it's started in the PAUSED state), we don't have to invoke stop on it", "originalCommit": "2be183ef36640deae7b9a75166639e72ee1d7929", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "50b0792cd1300a3ff783bfa0411fed140fdfade6", "url": "https://github.com/apache/kafka/commit/50b0792cd1300a3ff783bfa0411fed140fdfade6", "message": "KAFKA-10792: Fix typo in comment\r\n\r\nhappy -> happen\n\nCo-authored-by: Nigel Liang <nigel@nigelliang.com>", "committedDate": "2020-12-01T23:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxOTY1NQ==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534419655", "bodyText": "Maybe a nit, but this comment seems a bit misleading. It sounds as if the method need be called from a thread safe point, but otherwise there are no restrictions on how it's used.\nStrictly speaking, this method need not be thread safe because it should only be called from within close(), which is called from the task's own thread and therefore is thread safe. Perhaps this design assumption should be mentioned here.", "author": "rhauch", "createdAt": "2020-12-02T19:17:26Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java", "diffHunk": "@@ -206,16 +203,13 @@ public void cancel() {\n     public void stop() {\n         super.stop();\n         stopRequestedLatch.countDown();\n-        synchronized (this) {\n-            if (finishedStart)\n-                tryStop();\n-            else\n-                startedShutdownBeforeStartCompleted = true;\n-        }\n     }\n \n-    private synchronized void tryStop() {\n-        if (!stopped) {\n+    // Note: This method is not thread-safe", "originalCommit": "50b0792cd1300a3ff783bfa0411fed140fdfade6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1MzIwNg==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534453206", "bodyText": "This is a fair point. TBH I don't think this method deserves to exist anymore at all and can just be folded into close where a bunch of similar blocks already exist. There's also no need to track stopped since close is only ever invoked once. I'll refactor and remove the comment entirely since everything should be more readable after that change even without commenting.", "author": "C0urante", "createdAt": "2020-12-02T20:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxOTY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4OTAzNw==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534489037", "bodyText": "Yeah, it's unclear whether to keep the tryStop() method to minimize deltas, or remove it to simplify things. +1 for simplifying things by moving the logic into close().", "author": "rhauch", "createdAt": "2020-12-02T21:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxOTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNzUzOQ==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534427539", "bodyText": "Minor suggestions to improve wording and to be a bit more explicit about expectations for Task implementations:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // If we try to start the task at all (by invoking initialize and possibly start), we count this as\n          \n          \n            \n                        // \"started\" in order to properly clean up any resources allocated by those invocations when the task is\n          \n          \n            \n                        // shut down by calling stop. If the task throws an exception during startup, it should still be able to\n          \n          \n            \n                        // clean up any allocated resources when stop is called, and if it isn't able to or even throws another\n          \n          \n            \n                        // exception during stop, the worst thing that happens is another exception gets logged for an already-\n          \n          \n            \n                        // failed task\n          \n          \n            \n                        // If we try to start the task at all by invoking initialize, then count this as\n          \n          \n            \n                        // \"started\" and expect a subsequent call to the task's stop() method\n          \n          \n            \n                        // to properly clean up any resources allocated by its initialize() or \n          \n          \n            \n                        // start() methods. If the task throws an exception during stop(),\n          \n          \n            \n                        // the worst thing that happens is another exception gets logged for an already-\n          \n          \n            \n                        // failed task", "author": "rhauch", "createdAt": "2020-12-02T19:30:46Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java", "diffHunk": "@@ -228,17 +222,16 @@ private synchronized void tryStop() {\n     @Override\n     public void execute() {\n         try {\n+            // If we try to start the task at all (by invoking initialize and possibly start), we count this as\n+            // \"started\" in order to properly clean up any resources allocated by those invocations when the task is\n+            // shut down by calling stop. If the task throws an exception during startup, it should still be able to\n+            // clean up any allocated resources when stop is called, and if it isn't able to or even throws another\n+            // exception during stop, the worst thing that happens is another exception gets logged for an already-\n+            // failed task", "originalCommit": "50b0792cd1300a3ff783bfa0411fed140fdfade6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0MTg5MQ==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534441891", "bodyText": "How does this static field initialization work within a blocking connector that also has a blocking task instance? Aren't both constructors called, resulting in the task constructor re-initializing the static blockLatch instance? Does it work because the tests don't block both a connector method and a task method? If so, doesn't that make it somewhat brittle if people want to add more tests but don't infer that limitation?\nWould it be better to store a static list of all Block latches, have the constructor simply create a block latch and add it to that static list, and then have the resetBlockLatch() method remove each of the Block latches and call countDown() on them? (This still doesn't bode well for running the tests in parallel, but ATM that's not an issue.)", "author": "rhauch", "createdAt": "2020-12-02T19:55:30Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/integration/BlockingConnectorTest.java", "diffHunk": "@@ -263,145 +332,153 @@ private void verifyNormalConnector() throws InterruptedException {\n         normalConnectorHandle.awaitCommits(RECORD_TRANSFER_DURATION_MS);\n     }\n \n-    public static class BlockingConnector extends SourceConnector {\n-\n+    private static class Block {\n         private static CountDownLatch blockLatch;\n \n-        private String block;\n+        private final String block;\n \n         public static final String BLOCK_CONFIG = \"block\";\n \n-        public static final String INITIALIZE = \"initialize\";\n-        public static final String INITIALIZE_WITH_TASK_CONFIGS = \"initializeWithTaskConfigs\";\n-        public static final String START = \"start\";\n-        public static final String RECONFIGURE = \"reconfigure\";\n-        public static final String TASK_CLASS = \"taskClass\";\n-        public static final String TASK_CONFIGS = \"taskConfigs\";\n-        public static final String STOP = \"stop\";\n-        public static final String VALIDATE = \"validate\";\n-        public static final String CONFIG = \"config\";\n-        public static final String VERSION = \"version\";\n-\n-        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n-            .define(\n-                BLOCK_CONFIG,\n-                ConfigDef.Type.STRING,\n-                \"\",\n-                ConfigDef.Importance.MEDIUM,\n-                \"Where to block indefinitely, e.g., 'start', 'initialize', 'taskConfigs', 'version'\"\n-            );\n-\n-        // No-args constructor required by the framework\n-        public BlockingConnector() {\n-            this(null);\n-        }\n-\n-        protected BlockingConnector(String block) {\n-            this.block = block;\n-            synchronized (BlockingConnector.class) {\n-                if (blockLatch != null) {\n-                    blockLatch.countDown();\n-                }\n-                blockLatch = new CountDownLatch(1);\n-            }\n+        private static ConfigDef config() {\n+            return new ConfigDef()\n+                .define(\n+                    BLOCK_CONFIG,\n+                    ConfigDef.Type.STRING,\n+                    \"\",\n+                    ConfigDef.Importance.MEDIUM,\n+                    \"Where to block indefinitely, e.g., 'start', 'initialize', 'taskConfigs', 'version'\"\n+                );\n         }\n \n         public static void waitForBlock() throws InterruptedException {\n-            synchronized (BlockingConnector.class) {\n+            synchronized (Block.class) {\n                 if (blockLatch == null) {\n                     throw new IllegalArgumentException(\"No connector has been created yet\");\n                 }\n             }\n-            \n+\n             log.debug(\"Waiting for connector to block\");\n             blockLatch.await();\n             log.debug(\"Connector should now be blocked\");\n         }\n \n         public static void resetBlockLatch() {\n-            synchronized (BlockingConnector.class) {\n+            synchronized (Block.class) {\n                 if (blockLatch != null) {\n                     blockLatch.countDown();\n                     blockLatch = null;\n                 }\n             }\n         }\n \n+        public Block(Map<String, String> props) {\n+            this(new AbstractConfig(config(), props).getString(BLOCK_CONFIG));\n+        }\n+\n+        public Block(String block) {\n+            this.block = block;\n+            synchronized (Block.class) {\n+                if (blockLatch != null) {\n+                    blockLatch.countDown();\n+                }\n+                blockLatch = new CountDownLatch(1);", "originalCommit": "50b0792cd1300a3ff783bfa0411fed140fdfade6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2NTU0Mw==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534465543", "bodyText": "Does it work because the tests don't block both a connector method and a task method?\n\nYep, that's exactly it. Actually, it's even broader--it works because no test involves blocking in more than one method.\n\nIf so, doesn't that make it somewhat brittle if people want to add more tests but don't infer that limitation?\n\nIt does make it brittle for that case, although since connectors and tasks are completely decoupled w/r/t allocation in a Connect cluster (they frequently exist on separate workers, for example), I'm a little skeptical of the need for a test that touches on a connector that blocks in its Connector and Task classes, either now or in the future.\n\nWould it be better to store a static list of all Block latches, have the constructor simply create a block latch and add it to that static list, and then have the resetBlockLatch() method remove each of the Block latches and call countDown() on them?\n\nI'm happy to leave a comment on the limitations of the current test setup and how it could be expanded to cover more ground in the future, but it seems a bit premature to put in the necessary infrastructure for that when there aren't any identified cases yet that would require it, especially since the PR already greatly expands on the capabilities for testing blocks in connectors and tasks but only uses a portion of it. Is that fair?", "author": "C0urante", "createdAt": "2020-12-02T20:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0MTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4OTY3OA==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534489678", "bodyText": "Yeah, maybe the simplest fix is to add a comment on the resetBlockLatch() method mentioning the limitation.", "author": "rhauch", "createdAt": "2020-12-02T21:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0MTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0ODk3Mw==", "url": "https://github.com/apache/kafka/pull/9669#discussion_r534548973", "bodyText": "Ack, added a comment. LMKWYT", "author": "C0urante", "createdAt": "2020-12-02T23:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0MTg5MQ=="}], "type": "inlineReview"}, {"oid": "31942bdef370ac7e26f7150b761a097926d11e40", "url": "https://github.com/apache/kafka/commit/31942bdef370ac7e26f7150b761a097926d11e40", "message": "KAFKA-10792: Improve wording in comment\n\nCo-authored-by: Randall Hauch <rhauch@gmail.com>", "committedDate": "2020-12-02T20:16:24Z", "type": "commit"}, {"oid": "9a82bc441d62f7fb3ba1e489ad46b29da3c5c4e9", "url": "https://github.com/apache/kafka/commit/9a82bc441d62f7fb3ba1e489ad46b29da3c5c4e9", "message": "KAFKA-10792: Slight refactoring for readability", "committedDate": "2020-12-02T20:39:04Z", "type": "commit"}, {"oid": "f349014317f0005564eef55ef83dde815d877e12", "url": "https://github.com/apache/kafka/commit/f349014317f0005564eef55ef83dde815d877e12", "message": "KAFKA-10792: Add comment on current limitations of blocking connector/task tests", "committedDate": "2020-12-02T23:19:29Z", "type": "commit"}]}