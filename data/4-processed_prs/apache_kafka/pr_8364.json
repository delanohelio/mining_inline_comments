{"pr_number": 8364, "pr_title": "MINOR: Partition is under reassignment when adding and removing", "pr_createdAt": "2020-03-26T15:28:15Z", "pr_url": "https://github.com/apache/kafka/pull/8364", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r399336231", "bodyText": "Why would we have URPs in the first place? Reassignment should not cause URPs now, right?", "author": "ijuma", "createdAt": "2020-03-27T15:11:46Z", "path": "core/src/test/scala/unit/kafka/admin/TopicCommandWithAdminClientTest.scala", "diffHunk": "@@ -680,9 +680,14 @@ class TopicCommandWithAdminClientTest extends KafkaServerTestHarness with Loggin\n     assertTrue(simpleDescribeOutputRows(0).startsWith(s\"Topic: $testTopicName\"))\n     assertEquals(2, simpleDescribeOutputRows.size)\n \n-    val underReplicatedOutput = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--under-replicated-partitions\"))))\n-    assertEquals(\"--under-replicated-partitions shouldn't return anything\", \"\", underReplicatedOutput)\n+    TestUtils.waitUntilTrue(\n+      () => {\n+        val underReplicatedOutput = TestUtils.grabConsoleOutput(\n+          topicService.describeTopic(new TopicCommandOptions(Array(\"--under-replicated-partitions\"))))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzNzU5Nw==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r399437597", "bodyText": "Good point. We are actually seeing this in 2.4. I just took at look at that release and it looks like that release doesn't have the fix. Should I target this change to 2.4 only?", "author": "jsancio", "createdAt": "2020-03-27T17:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0OTM4OQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r399449389", "bodyText": "Sure.", "author": "ijuma", "createdAt": "2020-03-27T18:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1MDUwMQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r399450501", "bodyText": "What I just said is not true. Let me get back to you.", "author": "jsancio", "createdAt": "2020-03-27T18:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Mzk4NA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r400483984", "bodyText": "You were correct. I think there was a small issue in how we determined the replication factor and if a partition was under reassignment.", "author": "jsancio", "createdAt": "2020-03-30T20:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwMDcwNg==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r400500706", "bodyText": "Nit: Int.unbox -> _.intValue?", "author": "ijuma", "createdAt": "2020-03-30T21:19:21Z", "path": "core/src/main/scala/kafka/admin/TopicCommand.scala", "diffHunk": "@@ -563,10 +563,10 @@ object TopicCommand extends Logging {\n     // It is possible for a reassignment to complete between the time we have fetched its state and the time\n     // we fetch partition metadata. In ths case, we ignore the reassignment when determining replication factor.\n     def isReassignmentInProgress(ra: PartitionReassignment): Boolean = {\n-      // Reassignment is still in progress as long as the removing replicas are still present\n+      // Reassignment is still in progress as long as the removing and adding replicas are still present\n       val allReplicaIds = tpi.replicas.asScala.map(_.id).toSet\n-      val removingReplicaIds = ra.removingReplicas.asScala.map(Int.unbox).toSet\n-      allReplicaIds.exists(removingReplicaIds.contains)\n+      val changingReplicaIds = ra.removingReplicas.asScala.map(Int.unbox).toSet ++ ra.addingReplicas.asScala.map(Int.unbox).toSet", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxMzg2Ng==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r400613866", "bodyText": "Sure. It is type safer.", "author": "jsancio", "createdAt": "2020-03-31T02:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwMDcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNTc3NA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401235774", "bodyText": "This file was actually moved/renamed to core/src/test/scala/unit/kafka/admin/TopicCommandWithZKClientTest.scala", "author": "jsancio", "createdAt": "2020-03-31T21:48:50Z", "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -16,585 +16,41 @@\n  */", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjE4NA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401236184", "bodyText": "This test fails against trunk\nkafka.admin.TopicCommandTest > testIsNotUnderReplicatedWhenAdding FAILED\n    java.lang.AssertionError\n        at org.junit.Assert.fail(Assert.java:87)\n        at org.junit.Assert.assertTrue(Assert.java:42)\n        at org.junit.Assert.assertFalse(Assert.java:65)\n        at org.junit.Assert.assertFalse(Assert.java:75)\n        at kafka.admin.TopicCommandTest.testIsNotUnderReplicatedWhenAdding(TopicCommandTest.scala:54)\n\n1 test completed, 1 failed", "author": "jsancio", "createdAt": "2020-03-31T21:49:37Z", "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -16,585 +16,41 @@\n  */\n package kafka.admin\n \n-import kafka.admin.TopicCommand.{TopicCommandOptions, ZookeeperTopicService}\n-import kafka.server.ConfigType\n-import kafka.utils.{Logging, TestUtils}\n-import kafka.zk.{ConfigEntityChangeNotificationZNode, DeleteTopicsTopicZNode, ZooKeeperTestHarness}\n-import org.apache.kafka.common.TopicPartition\n-import org.apache.kafka.common.config.{ConfigException, ConfigResource}\n-import org.apache.kafka.common.errors.{InvalidPartitionsException, InvalidReplicationFactorException, TopicExistsException}\n-import org.apache.kafka.common.internals.Topic\n+import kafka.admin.TopicCommand.PartitionDescription\n+import org.apache.kafka.clients.admin.PartitionReassignment\n+import org.apache.kafka.common.Node\n+import org.apache.kafka.common.TopicPartitionInfo\n import org.junit.Assert._\n-import org.junit.rules.TestName\n-import org.junit.{After, Before, Rule, Test}\n-import org.scalatest.Assertions.intercept\n-\n-import scala.util.Random\n-\n-class TopicCommandTest extends ZooKeeperTestHarness with Logging with RackAwareTest {\n-\n-  private var topicService: ZookeeperTopicService = _\n-  private var testTopicName: String = _\n-\n-  private val _testName = new TestName\n-  @Rule def testName = _testName\n-\n-  @Before\n-  def setup(): Unit = {\n-    topicService = ZookeeperTopicService(zkClient)\n-    testTopicName = s\"${testName.getMethodName}-${Random.alphanumeric.take(10).mkString}\"\n-  }\n-\n-  @After\n-  def teardown(): Unit = {\n-    if (topicService != null)\n-      topicService.close()\n-  }\n-\n-  @Test\n-  def testCreate(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    assertTrue(zkClient.getAllTopicsInCluster().contains(testTopicName))\n-  }\n-\n-  @Test\n-  def testCreateWithConfigs(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val configResource = new ConfigResource(ConfigResource.Type.TOPIC, testTopicName)\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"2\", \"--topic\", configResource.name(), \"--config\", \"delete.retention.ms=1000\")))\n-\n-    val configs = zkClient.getEntityConfigs(ConfigType.Topic, testTopicName)\n-    assertEquals(1000, Integer.valueOf(configs.getProperty(\"delete.retention.ms\")))\n-  }\n-\n-  @Test\n-  def testCreateIfNotExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val numPartitions = 1\n-\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", numPartitions.toString, \"--replication-factor\", \"1\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // try to re-create the topic without --if-not-exists\n-    intercept[TopicExistsException] {\n-      topicService.createTopic(createOpts)\n-    }\n-\n-    // try to re-create the topic with --if-not-exists\n-    val createNotExistsOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", numPartitions.toString, \"--replication-factor\", \"1\", \"--topic\", testTopicName, \"--if-not-exists\"))\n-    topicService.createTopic(createNotExistsOpts)\n-  }\n-\n-  @Test\n-  def testCreateWithReplicaAssignment(): Unit = {\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--replica-assignment\", \"5:4,3:2,1:0\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    val replicas0 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 0))\n-    assertEquals(List(5, 4), replicas0)\n-    val replicas1 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 1))\n-    assertEquals(List(3, 2), replicas1)\n-    val replicas2 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 2))\n-    assertEquals(List(1, 0), replicas2)\n-  }\n-\n-  @Test\n-  def testCreateWithInvalidReplicationFactor(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidReplicationFactorException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"2\", \"--replication-factor\", (Short.MaxValue+1).toString, \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testCreateWithNegativeReplicationFactor(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidReplicationFactorException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"2\", \"--replication-factor\", \"-1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testCreateWithNegativePartitionCount(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidPartitionsException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"-1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testInvalidTopicLevelConfig(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName,\n-        \"--config\", \"message.timestamp.type=boom\"))\n-    intercept[ConfigException] {\n-      topicService.createTopic(createOpts)\n-    }\n-\n-    // try to create the topic with another invalid config\n-    val createOpts2 = new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName,\n-        \"--config\", \"message.format.version=boom\"))\n-    intercept[ConfigException] {\n-      topicService.createTopic(createOpts2)\n-    }\n-  }\n-\n-  @Test\n-  def testListTopics(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array())))\n-\n-    assertTrue(output.contains(testTopicName))\n-  }\n-\n-  @Test\n-  def testListTopicsWithWhitelist(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val topic1 = \"kafka.testTopic1\"\n-    val topic2 = \"kafka.testTopic2\"\n-    val topic3 = \"oooof.testTopic1\"\n-    adminZkClient.createTopic(topic1, 2, 2)\n-    adminZkClient.createTopic(topic2, 2, 2)\n-    adminZkClient.createTopic(topic3, 2, 2)\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--topic\", \"kafka.*\"))))\n-\n-    assertTrue(output.contains(topic1))\n-    assertTrue(output.contains(topic2))\n-    assertFalse(output.contains(topic3))\n-  }\n-\n-  @Test\n-  def testListTopicsWithExcludeInternal(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-    adminZkClient.createTopic(Topic.GROUP_METADATA_TOPIC_NAME, 2, 2)\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--exclude-internal\"))))\n-\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-  }\n-\n-  @Test\n-  def testAlterPartitionCount(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--partitions\", \"3\")))\n-\n-    assertEquals(3, zkClient.getPartitionsForTopics(Set(testTopicName))(testTopicName).size)\n-  }\n-\n-  @Test\n-  def testAlterAssignment(): Unit = {\n-    val brokers = List(0, 1, 2, 3, 4, 5)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--replica-assignment\", \"5:3,3:1,4:2\", \"--partitions\", \"3\")))\n-\n-    val replicas0 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 2))\n-    assertEquals(3, zkClient.getPartitionsForTopics(Set(testTopicName))(testTopicName).size)\n-    assertEquals(List(4,2), replicas0)\n-  }\n-\n-  @Test\n-  def testAlterWithInvalidPartitionCount(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    intercept[InvalidPartitionsException] {\n-      topicService.alterTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"-1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testAlterIfExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // alter a topic that does not exist without --if-exists\n-    val alterOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--partitions\", \"1\"))\n-    intercept[IllegalArgumentException] {\n-      topicService.alterTopic(alterOpts)\n-    }\n-\n-    // alter a topic that does not exist with --if-exists\n-    val alterExistsOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--partitions\", \"1\", \"--if-exists\"))\n-    topicService.alterTopic(alterExistsOpts)\n-  }\n-\n-  @Test\n-  def testAlterConfigs(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--config\", \"cleanup.policy=compact\")))\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    assertTrue(\"The output should contain the modified config\", output.contains(\"Configs: cleanup.policy=compact\"))\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--config\", \"cleanup.policy=delete\")))\n-\n-    val output2 = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    assertTrue(\"The output should contain the modified config\", output2.contains(\"Configs: cleanup.policy=delete\"))\n-  }\n-\n-  @Test\n-  def testConfigPreservationAcrossPartitionAlteration(): Unit = {\n-    val numPartitionsOriginal = 1\n-    val cleanupKey = \"cleanup.policy\"\n-    val cleanupVal = \"compact\"\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--config\", cleanupKey + \"=\" + cleanupVal,\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-    val props = adminZkClient.fetchEntityConfig(ConfigType.Topic, testTopicName)\n-    assertTrue(\"Properties after creation don't contain \" + cleanupKey, props.containsKey(cleanupKey))\n-    assertTrue(\"Properties after creation have incorrect value\", props.getProperty(cleanupKey).equals(cleanupVal))\n-\n-    // pre-create the topic config changes path to avoid a NoNodeException\n-    zkClient.makeSurePersistentPathExists(ConfigEntityChangeNotificationZNode.path)\n-\n-    // modify the topic to add new partitions\n-    val numPartitionsModified = 3\n-    val alterOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsModified.toString, \"--topic\", testTopicName))\n-    topicService.alterTopic(alterOpts)\n-    val newProps = adminZkClient.fetchEntityConfig(ConfigType.Topic, testTopicName)\n-    assertTrue(\"Updated properties do not contain \" + cleanupKey, newProps.containsKey(cleanupKey))\n-    assertTrue(\"Updated properties have incorrect value\", newProps.getProperty(cleanupKey).equals(cleanupVal))\n-  }\n-\n-  @Test\n-  def testTopicDeletion(): Unit = {\n-\n-    val numPartitionsOriginal = 1\n-\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the NormalTopic\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // delete the NormalTopic\n-    val deleteOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    val deletePath = DeleteTopicsTopicZNode.path(testTopicName)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deletePath))\n-    topicService.deleteTopic(deleteOpts)\n-    assertTrue(\"Delete path for topic should exist after deletion.\", zkClient.pathExists(deletePath))\n-\n-    // create the offset topic\n-    val createOffsetTopicOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    topicService.createTopic(createOffsetTopicOpts)\n-\n-    // try to delete the Topic.GROUP_METADATA_TOPIC_NAME and make sure it doesn't\n-    val deleteOffsetTopicOpts = new TopicCommandOptions(Array(\"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    val deleteOffsetTopicPath = DeleteTopicsTopicZNode.path(Topic.GROUP_METADATA_TOPIC_NAME)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-    intercept[AdminOperationException] {\n-      topicService.deleteTopic(deleteOffsetTopicOpts)\n-    }\n-    assertFalse(\"Delete path for topic shouldn't exist after deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-  }\n-\n-  @Test\n-  def testDeleteIfExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // delete a topic that does not exist without --if-exists\n-    val deleteOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    intercept[IllegalArgumentException] {\n-      topicService.deleteTopic(deleteOpts)\n-    }\n-\n-    // delete a topic that does not exist with --if-exists\n-    val deleteExistsOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--if-exists\"))\n-    topicService.deleteTopic(deleteExistsOpts)\n-  }\n-\n-  @Test\n-  def testDeleteInternalTopic(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the offset topic\n-    val createOffsetTopicOpts = new TopicCommandOptions(Array(\"--partitions\", \"1\",\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    topicService.createTopic(createOffsetTopicOpts)\n-\n-    val deleteOffsetTopicOpts = new TopicCommandOptions(Array(\"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    val deleteOffsetTopicPath = DeleteTopicsTopicZNode.path(Topic.GROUP_METADATA_TOPIC_NAME)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-    intercept[AdminOperationException] {\n-      topicService.deleteTopic(deleteOffsetTopicOpts)\n-    }\n-  }\n-\n-  @Test\n-  def testDescribeIfTopicNotExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // describe topic that does not exist\n-    val describeOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    intercept[IllegalArgumentException] {\n-      topicService.describeTopic(describeOpts)\n-    }\n-\n-    // describe all topics\n-    val describeOptsAllTopics = new TopicCommandOptions(Array())\n-    // should not throw any error\n-    topicService.describeTopic(describeOptsAllTopics)\n-\n-    // describe topic that does not exist with --if-exists\n-    val describeOptsWithExists = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--if-exists\"))\n-    // should not throw any error\n-    topicService.describeTopic(describeOptsWithExists)\n-  }\n-\n-  @Test\n-  def testCreateAlterTopicWithRackAware(): Unit = {\n-    val rackInfo = Map(0 -> \"rack1\", 1 -> \"rack2\", 2 -> \"rack2\", 3 -> \"rack1\", 4 -> \"rack3\", 5 -> \"rack3\")\n-    TestUtils.createBrokersInZk(toBrokerMetadata(rackInfo), zkClient)\n-\n-    val numPartitions = 18\n-    val replicationFactor = 3\n-    val createOpts = new TopicCommandOptions(Array(\n-      \"--partitions\", numPartitions.toString,\n-      \"--replication-factor\", replicationFactor.toString,\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    var assignment = zkClient.getReplicaAssignmentForTopics(Set(testTopicName)).map { case (tp, replicas) =>\n-      tp.partition -> replicas\n-    }\n-    checkReplicaDistribution(assignment, rackInfo, rackInfo.size, numPartitions, replicationFactor)\n-\n-    val alteredNumPartitions = 36\n-    // verify that adding partitions will also be rack aware\n-    val alterOpts = new TopicCommandOptions(Array(\n-      \"--partitions\", alteredNumPartitions.toString,\n-      \"--topic\", testTopicName))\n-    topicService.alterTopic(alterOpts)\n-    assignment = zkClient.getReplicaAssignmentForTopics(Set(testTopicName)).map { case (tp, replicas) =>\n-      tp.partition -> replicas\n-    }\n-    checkReplicaDistribution(assignment, rackInfo, rackInfo.size, alteredNumPartitions, replicationFactor)\n-  }\n-\n-  @Test\n-  def testDescribe(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    val rows = output.split(\"\\n\")\n-    assertEquals(3, rows.size)\n-    rows(0).startsWith(\"Topic:testTopic\\tPartitionCount:2\")\n-  }\n-\n-  @Test\n-  def testDescribeReportOverriddenConfigs(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val config = \"file.delete.delay.ms=1000\"\n-    val configResource = new ConfigResource(ConfigResource.Type.TOPIC, testTopicName)\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"2\", \"--topic\", configResource.name(), \"--config\", config)))\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array())))\n-    assertTrue(output.contains(config))\n-  }\n-\n-  @Test\n-  def testDescribeAndListTopicsMarkedForDeletion(): Unit = {\n-    val brokers = List(0)\n-    val markedForDeletionDescribe = \"MarkedForDeletion\"\n-    val markedForDeletionList = \"marked for deletion\"\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // delete the broker first, so when we attempt to delete the topic it gets into \"marked for deletion\"\n-    TestUtils.deleteBrokersInZk(zkClient, brokers)\n-    topicService.deleteTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName)))\n-\n-    // Test describe topics\n-    def describeTopicsWithConfig(): Unit = {\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--describe\")))\n-    }\n-    val outputWithConfig = TestUtils.grabConsoleOutput(describeTopicsWithConfig())\n-    assertTrue(outputWithConfig.contains(testTopicName) && outputWithConfig.contains(markedForDeletionDescribe))\n-\n-    def describeTopicsNoConfig(): Unit = {\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--describe\", \"--unavailable-partitions\")))\n-    }\n-    val outputNoConfig = TestUtils.grabConsoleOutput(describeTopicsNoConfig())\n-    assertTrue(outputNoConfig.contains(testTopicName) && outputNoConfig.contains(markedForDeletionDescribe))\n-\n-    // Test list topics\n-    def listTopics(): Unit = {\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--list\")))\n-    }\n-    val output = TestUtils.grabConsoleOutput(listTopics())\n-    assertTrue(output.contains(testTopicName) && output.contains(markedForDeletionList))\n-  }\n-\n-  @Test\n-  def testDescribeAndListTopicsWithoutInternalTopics(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(\n-      new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-    // create a internal topic\n-    topicService.createTopic(\n-      new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME)))\n-\n-    // test describe\n-    var output = TestUtils.grabConsoleOutput(topicService.describeTopic(\n-      new TopicCommandOptions(Array(\"--describe\", \"--exclude-internal\"))))\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-\n-    // test list\n-    output = TestUtils.grabConsoleOutput(topicService.listTopics(\n-      new TopicCommandOptions(Array(\"--list\", \"--exclude-internal\"))))\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-  }\n-\n-  @Test\n-  def testTopicOperationsWithRegexSymbolInTopicName(): Unit = {\n-    val topic1 = \"test.topic\"\n-    val topic2 = \"test-topic\"\n-    val escapedTopic = \"\\\"test\\\\.topic\\\"\"\n-    val unescapedTopic = \"test.topic\"\n-    val numPartitionsOriginal = 1\n-\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the topics\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\", \"--topic\", topic1))\n-    topicService.createTopic(createOpts)\n-    val createOpts2 = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\", \"--topic\", topic2))\n-    topicService.createTopic(createOpts2)\n-\n-    val escapedCommandOpts = new TopicCommandOptions(Array(\"--topic\", escapedTopic))\n-    val unescapedCommandOpts = new TopicCommandOptions(Array(\"--topic\", unescapedTopic))\n-\n-    // topic actions with escaped regex do not affect 'test-topic'\n-    // topic actions with unescaped topic affect 'test-topic'\n-\n-    assertFalse(TestUtils.grabConsoleOutput(topicService.describeTopic(escapedCommandOpts)).contains(topic2))\n-    assertTrue(TestUtils.grabConsoleOutput(topicService.describeTopic(unescapedCommandOpts)).contains(topic2))\n-\n-    assertFalse(TestUtils.grabConsoleOutput(topicService.deleteTopic(escapedCommandOpts)).contains(topic2))\n-    assertTrue(TestUtils.grabConsoleOutput(topicService.deleteTopic(unescapedCommandOpts)).contains(topic2))\n-  }\n-\n-  @Test\n-  def testAlterInternalTopicPartitionCount(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-    \n-    // create internal topics\n-    adminZkClient.createTopic(Topic.GROUP_METADATA_TOPIC_NAME, 1, 1)\n-    adminZkClient.createTopic(Topic.TRANSACTION_STATE_TOPIC_NAME, 1, 1)\n-\n-    def expectAlterInternalTopicPartitionCountFailed(topic: String): Unit = {\n-      try {\n-        topicService.alterTopic(new TopicCommandOptions(\n-          Array(\"--topic\", topic, \"--partitions\", \"2\")))\n-        fail(\"Should have thrown an IllegalArgumentException\")\n-      } catch {\n-        case _: IllegalArgumentException => // expected\n-      }\n-    }\n-    expectAlterInternalTopicPartitionCountFailed(Topic.GROUP_METADATA_TOPIC_NAME)\n-    expectAlterInternalTopicPartitionCountFailed(Topic.TRANSACTION_STATE_TOPIC_NAME)\n+import org.junit.Test\n+import scala.collection.JavaConverters._\n+\n+final class TopicCommandTest { \n+  @Test\n+  def testIsNotUnderReplicatedWhenAdding(): Unit = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb0bc802928ad0d4a44966a42a0abacf69d9358c", "url": "https://github.com/apache/kafka/commit/eb0bc802928ad0d4a44966a42a0abacf69d9358c", "message": "MINOR: Parition is under reassignment when adding and removing\n\nA partition is under reassignment if the either the set of adding\nreplicas or set removing replicas is non-empty.\n\nFix the test assertion such that it prints stdout on failure.", "committedDate": "2020-04-01T19:51:59Z", "type": "commit"}, {"oid": "a7d69ce0899117265666d65baa81555538c9a410", "url": "https://github.com/apache/kafka/commit/a7d69ce0899117265666d65baa81555538c9a410", "message": "Use intValue instead of unbox", "committedDate": "2020-04-01T19:51:59Z", "type": "commit"}, {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5", "url": "https://github.com/apache/kafka/commit/f276d286e7c15679430eaee5c4504e7c213694b5", "message": "Unit test for false URP when adding", "committedDate": "2020-04-01T19:58:50Z", "type": "commit"}, {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5", "url": "https://github.com/apache/kafka/commit/f276d286e7c15679430eaee5c4504e7c213694b5", "message": "Unit test for false URP when adding", "committedDate": "2020-04-01T19:58:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401874900", "bodyText": "I forgot to rename class with the previous git mv.", "author": "jsancio", "createdAt": "2020-04-01T20:01:04Z", "path": "core/src/test/scala/unit/kafka/admin/TopicCommandWithZKClientTest.scala", "diffHunk": "@@ -31,7 +31,7 @@ import org.scalatest.Assertions.intercept\n \n import scala.util.Random\n \n-class TopicCommandTest extends ZooKeeperTestHarness with Logging with RackAwareTest {\n+final class TopicCommandWithZKClientTest extends ZooKeeperTestHarness with Logging with RackAwareTest {", "originalCommit": "f276d286e7c15679430eaee5c4504e7c213694b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4MjYzMQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401882631", "bodyText": "Why did we make it final?", "author": "ijuma", "createdAt": "2020-04-01T20:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NDI5OA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401894298", "bodyText": "Habit. Do we want developers extending test suites?", "author": "jsancio", "createdAt": "2020-04-01T20:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTM5NA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401901394", "bodyText": "No, but we don't actively protect against it. I think nearly all tests don't have final. It's one of those things that looks a bit weird if we do it occasionally but it's not actively recommended.", "author": "ijuma", "createdAt": "2020-04-01T20:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4OTI5MQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r414889291", "bodyText": "Done.", "author": "jsancio", "createdAt": "2020-04-24T22:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MTU0OQ==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r414551549", "bodyText": "This needs to be changed to CollectionConverters and the branch needs to be rebased from master.", "author": "ijuma", "createdAt": "2020-04-24T12:51:44Z", "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.admin\n+\n+import kafka.admin.TopicCommand.PartitionDescription\n+import org.apache.kafka.clients.admin.PartitionReassignment\n+import org.apache.kafka.common.Node\n+import org.apache.kafka.common.TopicPartitionInfo\n+import org.junit.Assert._\n+import org.junit.Test\n+import scala.collection.JavaConverters._", "originalCommit": "f276d286e7c15679430eaee5c4504e7c213694b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4ODIxOA==", "url": "https://github.com/apache/kafka/pull/8364#discussion_r414888218", "bodyText": "Done.", "author": "jsancio", "createdAt": "2020-04-24T22:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MTU0OQ=="}], "type": "inlineReview"}, {"oid": "82afaccc0fb977e35acac4842bc700e38199be14", "url": "https://github.com/apache/kafka/commit/82afaccc0fb977e35acac4842bc700e38199be14", "message": "Merge remote-tracking branch 'upstream/trunk' into minor-under-replicated-test", "committedDate": "2020-04-24T21:46:03Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e4e2760c25867cd26ab27f12c45cd95ce0101243", "url": "https://github.com/apache/kafka/commit/e4e2760c25867cd26ab27f12c45cd95ce0101243", "message": "Use CollectionConverters", "committedDate": "2020-04-24T22:04:11Z", "type": "commit"}, {"oid": "e4e2760c25867cd26ab27f12c45cd95ce0101243", "url": "https://github.com/apache/kafka/commit/e4e2760c25867cd26ab27f12c45cd95ce0101243", "message": "Use CollectionConverters", "committedDate": "2020-04-24T22:04:11Z", "type": "forcePushed"}]}