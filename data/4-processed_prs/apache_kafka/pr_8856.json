{"pr_number": 8856, "pr_title": "KAFKA-10150: task state transitions/management and committing cleanup", "pr_createdAt": "2020-06-12T00:36:09Z", "pr_url": "https://github.com/apache/kafka/pull/8856", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzIxOQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439493219", "bodyText": "When closing-clean a standby task, we would checkpoint the file and close the state store which would also flush it as well, so I think we do not need to call\ntask.prepareCommit();\ntask.postCommit();\n\nwhich is just to flush the stores and write checkpoint files, right?", "author": "guozhangwang", "createdAt": "2020-06-12T15:37:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -220,12 +215,18 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             } else {\n                 try {\n                     task.suspend();\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-\n-                    tasksToClose.add(task);\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+                    if (task.commitNeeded()) {\n+                        if (task.isActive()) {\n+                            log.error(\"Active task {} was revoked and should have already been committed\", task.id());\n+                            throw new IllegalStateException(\"Revoked active task was not committed during handleRevocation\");\n+                        } else {\n+                            task.prepareCommit();\n+                            task.postCommit();\n+                        }\n                     }\n+                    completeTaskCloseClean(task);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyMDg3MA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439520870", "bodyText": "Actually we don't checkpoint during closeClean anymore. You always have to commit (if clean && commitNeeded) before closing", "author": "ableegoldman", "createdAt": "2020-06-12T16:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyMzY0MQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439523641", "bodyText": "Is there a different PR removing that? I still see\nif (clean) {\n                // since there's no written offsets we can checkpoint with empty map,\n                // and the state current offset would be used to checkpoint\n                stateMgr.checkpoint(Collections.emptyMap());\n                offsetSnapshotSinceLastCommit = new HashMap<>(stateMgr.changelogOffsets());\n            }\n\nin Standby.close() in trunk.", "author": "guozhangwang", "createdAt": "2020-06-12T16:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyOTQ4MA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439529480", "bodyText": "I suspect your trunk is out of date \ud83d\ude42\n(that code & comment is now in postCommit)", "author": "ableegoldman", "createdAt": "2020-06-12T16:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1MzQ2NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439553465", "bodyText": "You're right :)", "author": "guozhangwang", "createdAt": "2020-06-12T17:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzkyNA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439493924", "bodyText": "nit: Add in the above javadoc that we should only revoke active tasks here?", "author": "guozhangwang", "createdAt": "2020-06-12T15:38:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -440,41 +402,35 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n+        final Set<TopicPartition> remainingRevokedPartitions = new HashSet<>(revokedPartitions);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyMjc1Mw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439522753", "bodyText": "ack", "author": "ableegoldman", "createdAt": "2020-06-12T16:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5MzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439494301", "bodyText": "nit: add a comment above task.suspend() that for active it should always be an no-op?", "author": "guozhangwang", "createdAt": "2020-06-12T15:39:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -220,12 +215,18 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             } else {\n                 try {\n                     task.suspend();\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-\n-                    tasksToClose.add(task);\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+                    if (task.commitNeeded()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyMjk3OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439522978", "bodyText": "ack", "author": "ableegoldman", "createdAt": "2020-06-12T16:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyNDY1OQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439524659", "bodyText": "Actually it's not always a no-op, since we will bail on suspending/committing the remaining active tasks if any of them throws an exception in handleRevocation -- so it's possible some active tasks are not yet suspended at this point.\nI will add a comment to clarify", "author": "ableegoldman", "createdAt": "2020-06-12T16:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MDc0OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439540748", "bodyText": "Not sure if I can follow -- if it's a no-op, why do we call it? Or do you say, we need to tall if for standbies as we don't suspend them presiously?", "author": "mjsax", "createdAt": "2020-06-12T17:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NTg5OQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439545899", "bodyText": "We need to do it for all standbys, and we may need to do it for some actives. Since suspending is now idempotent we may as well just call suspend universally", "author": "ableegoldman", "createdAt": "2020-06-12T17:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4ODIzOA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439688238", "bodyText": "For this case, it won't be a no-op for some active tasks? So we should not have such a comment?", "author": "mjsax", "createdAt": "2020-06-13T00:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTgwMQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439689801", "bodyText": "The current comment is\n// Should be a no-op for active tasks, unless we hit an exception during handleRevocation", "author": "ableegoldman", "createdAt": "2020-06-13T00:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ5NDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNzA3Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439537076", "bodyText": "Can we update the comment with the state transitions above, too?", "author": "mjsax", "createdAt": "2020-06-12T16:58:19Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -66,11 +66,11 @@\n      * </pre>\n      */\n     enum State {\n-        CREATED(1, 4),         // 0\n-        RESTORING(2, 3, 4),    // 1\n-        RUNNING(3),            // 2\n-        SUSPENDED(1, 4),       // 3\n-        CLOSED(0);             // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks\n+        CREATED(1, 3, 4),         // 0\n+        RESTORING(2, 3, 4),       // 1\n+        RUNNING(3),               // 2\n+        SUSPENDED(1, 3, 4),       // 3\n+        CLOSED(0);                // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1MjY1Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439552656", "bodyText": ":/ yeah...", "author": "ableegoldman", "createdAt": "2020-06-12T17:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNzA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzODE5Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439538197", "bodyText": "and there is no new commit needed -> this seem to be miss leading because the commitNeeded flag is not really a guard for this case. -- Also, if the previous commit has complete is something we don't really know here.", "author": "mjsax", "createdAt": "2020-06-12T17:00:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -528,7 +521,8 @@ private void maybeScheduleCheckpoint() {\n \n     private void writeCheckpointIfNeed() {\n         if (commitNeeded) {\n-            throw new IllegalStateException(\"A checkpoint should only be written if no commit is needed.\");\n+            throw new IllegalStateException(\"A checkpoint should only be written if the previous commit has completed\"\n+                                                + \" and there is no new commit needed.\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0OTY3Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439549676", "bodyText": "and there is no new commit needed -> this seem to be miss leading because the commitNeeded flag is not really a guard for this case.\n\nIsn't that exactly what the commitNeeded flag is?\nThat said, looking at this again, I agree this new phrasing doesn't really make sense. But the original comment took me a while to understand also (shouldn't we only write a checkpoint if there's a commit needed?) IIUC the point is that we should not write a checkpoint before doing the actual commit, ie there should not be pending uncommitted data when we write the checkpoint.", "author": "ableegoldman", "createdAt": "2020-06-12T17:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzODE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1MDc1NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439550755", "bodyText": "I'll revert it to the original and add a error log message: does\nlog.error(\"Tried to write a checkpoint with pending uncommitted data, should complete the commit first.\");\nmake sense to you?", "author": "ableegoldman", "createdAt": "2020-06-12T17:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzODE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTA3Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439539076", "bodyText": "Seems we need to transit from RESTORING to SUSPENDED now, before closing, and never directly from RESTORING to CLOSED?", "author": "mjsax", "createdAt": "2020-06-12T17:02:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -66,11 +66,11 @@\n      * </pre>\n      */\n     enum State {\n-        CREATED(1, 4),         // 0\n-        RESTORING(2, 3, 4),    // 1\n-        RUNNING(3),            // 2\n-        SUSPENDED(1, 4),       // 3\n-        CLOSED(0);             // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks\n+        CREATED(1, 3, 4),         // 0\n+        RESTORING(2, 3, 4),       // 1", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1MTM4MA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439551380", "bodyText": "Ack good catch. Same with CREATED", "author": "ableegoldman", "createdAt": "2020-06-12T17:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MjI2NA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439542264", "bodyText": "Above, we call suspend() blindly and have a comment that for active it's a no-op. -- Might be good to align both cases to use the same pattern (I don't care which one we pick)?", "author": "mjsax", "createdAt": "2020-06-12T17:08:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -239,54 +240,15 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             }\n         }\n \n-        if (!consumedOffsetsAndMetadataPerTask.isEmpty()) {\n-            try {\n-                for (final Task task : additionalTasksForCommitting) {\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n-                    }\n-                }\n-\n-                commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n-\n-                for (final Task task : additionalTasksForCommitting) {\n-                    task.postCommit();\n-                }\n-            } catch (final RuntimeException e) {\n-                log.error(\"Failed to batch commit tasks, \" +\n-                    \"will close all tasks involved in this commit as dirty by the end\", e);\n-                dirtyTasks.addAll(additionalTasksForCommitting);\n-                dirtyTasks.addAll(tasksToClose);\n-\n-                tasksToClose.clear();\n-                // Just add first taskId to re-throw by the end.\n-                taskCloseExceptions.put(consumedOffsetsAndMetadataPerTask.keySet().iterator().next(), e);\n-            }\n-        }\n-\n-        for (final Task task : tasksToClose) {\n-            try {\n-                completeTaskCloseClean(task);\n-                cleanUpTaskProducer(task, taskCloseExceptions);\n-                tasks.remove(task.id());\n-            } catch (final RuntimeException e) {\n-                final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n-                log.error(uncleanMessage, e);\n-                taskCloseExceptions.put(task.id(), e);\n-                // We've already recorded the exception (which is the point of clean).\n-                // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n-                dirtyTasks.add(task);\n-            }\n-        }\n-\n         for (final Task oldTask : tasksToRecycle) {\n             final Task newTask;\n             try {\n                 if (oldTask.isActive()) {\n+                    // If active, the task should have already been suspended and committed during handleRevocation", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1NTM5OQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439555399", "bodyText": "Actually I forgot to update this. We should always call suspend since some active tasks may not have been suspended during handleRevocation.", "author": "ableegoldman", "createdAt": "2020-06-12T17:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzMjE5Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439532197", "bodyText": "I get that standbys should never really be in RESTORING state, but it still doesn't seem like it's philosophically any more illegal to suspend from RESTORING than it is from RUNNING. I'd vote to legalize RESTORING here. It does seem like a useful sanity check for CLOSED to be illegal, though.", "author": "vvcephei", "createdAt": "2020-06-12T16:48:29Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -112,10 +112,19 @@ public void completeRestoration() {\n     @Override\n     public void suspend() {\n         log.trace(\"No-op suspend with state {}\", state());\n-        if (state() == State.RUNNING) {\n-            transitionTo(State.SUSPENDED);\n-        } else if (state() == State.RESTORING) {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending standby task \" + id);\n+        switch (state()) {\n+            case CREATED:\n+            case RUNNING:\n+            case SUSPENDED:\n+                transitionTo(State.SUSPENDED);\n+                break;\n+\n+            case RESTORING:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTg0OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439585848", "bodyText": "I agree 100%, but at some point in the past we started checking for RESTORING and throwing IllegalStateException all over StandbyTask. I wanted to keep the changes here to a minimum and figured we should at least be consistent with the current pattern elsewhere", "author": "ableegoldman", "createdAt": "2020-06-12T18:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzMjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNDI5NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439534295", "bodyText": "It looks like your changes in the tasks have prohibited any state from transitioning to CLOSED except SUSPENDED. Should we update the state machine to reflect this?", "author": "vvcephei", "createdAt": "2020-06-12T16:52:46Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -66,11 +66,11 @@\n      * </pre>\n      */\n     enum State {\n-        CREATED(1, 4),         // 0\n-        RESTORING(2, 3, 4),    // 1\n-        RUNNING(3),            // 2\n-        SUSPENDED(1, 4),       // 3\n-        CLOSED(0);             // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks\n+        CREATED(1, 3, 4),         // 0\n+        RESTORING(2, 3, 4),       // 1\n+        RUNNING(3),               // 2\n+        SUSPENDED(1, 3, 4),       // 3\n+        CLOSED(0);                // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjExOA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439586118", "bodyText": "I think you're looking at an old version of the PR :)", "author": "ableegoldman", "createdAt": "2020-06-12T18:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNDI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNTIwMQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439535201", "bodyText": "I think we previously followed the \"loop over iterator and remove during iteration\" pattern, and we got away from it because it was too confusing. Do we really need to re-introduce it now?", "author": "vvcephei", "createdAt": "2020-06-12T16:54:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -219,13 +214,19 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                 tasksToRecycle.add(task);\n             } else {\n                 try {\n-                    task.suspend();\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-\n-                    tasksToClose.add(task);\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+                    task.suspend(); // Should be a no-op for all active tasks, unless we hit an exception during handleRevocation\n+                    if (task.commitNeeded()) {\n+                        if (task.isActive()) {\n+                            log.error(\"Active task {} was revoked and should have already been committed\", task.id());\n+                            throw new IllegalStateException(\"Revoked active task was not committed during handleRevocation\");\n+                        } else {\n+                            task.prepareCommit();\n+                            task.postCommit();\n+                        }\n                     }\n+                    completeTaskCloseClean(task);\n+                    cleanUpTaskProducer(task, taskCloseExceptions);\n+                    taskIter.remove();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjM5OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439586398", "bodyText": "Oh, I thought we removed/refactored it for other reasons. I'm happy to undo this", "author": "ableegoldman", "createdAt": "2020-06-12T18:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzNTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNjkzOQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439606939", "bodyText": "This was a test I added a little while back in response to a bugfix, but it no longer makes sense in the current context (in fact it's currently not really testing anything at all, since the original point was to make sure the changelog reader partitions were cleaned up but that's not even the responsibility of the TaskManager anymore)", "author": "ableegoldman", "createdAt": "2020-06-12T19:32:57Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -952,58 +951,11 @@ public void shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed() {\n     }\n \n     @Test\n-    public void shouldCleanupAnyTasksClosedAsDirtyAfterCommitException() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5f47cda67e0876be6877c7aec3ec770cc46891b", "url": "https://github.com/apache/kafka/commit/a5f47cda67e0876be6877c7aec3ec770cc46891b", "message": "always close all tasks during shutdown", "committedDate": "2020-06-12T21:52:50Z", "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTEwNw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695107", "bodyText": "So far, we did not allow idempotent state transitions in the state machine itself, but handle it caller side. -- It seem inconsistent to allow SUSPENDED -> SUSPEND but not CREATE -> CREATED etc.\nI would recommend to keep the current pattern and avoid calling transiteState() if the task is already in the target state. -- I would also be happy to change it, but for this case, we should change it for all cases. However, this would enlarge the scope of this PR and I think it better not to do it in this PR.", "author": "mjsax", "createdAt": "2020-06-13T01:12:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -56,21 +56,21 @@\n      *          |            |              |     |\n      *          |            v              |     |\n      *          |     +------+--------+     |     |\n-     *          |     | Suspended (3) | <---+     |    //TODO Suspended(3) could be removed after we've stable on KIP-429\n-     *          |     +------+--------+           |\n-     *          |            |                    |\n-     *          |            v                    |\n-     *          |      +-----+-------+            |\n-     *          +----> | Closed (4)  | -----------+\n+     *          +---->| Suspended (3) | ----+     |    //TODO Suspended(3) could be removed after we've stable on KIP-429\n+     *                +------+--------+           |\n+     *                       |                    |\n+     *                       v                    |\n+     *                 +-----+-------+            |\n+     *                 | Closed (4)  | -----------+\n      *                 +-------------+\n      * </pre>\n      */\n     enum State {\n-        CREATED(1, 4),         // 0\n-        RESTORING(2, 3, 4),    // 1\n-        RUNNING(3),            // 2\n-        SUSPENDED(1, 4),       // 3\n-        CLOSED(0);             // 4, we allow CLOSED to transit to CREATED to handle corrupted tasks\n+        CREATED(1, 3),            // 0\n+        RESTORING(2, 3),          // 1\n+        RUNNING(3),               // 2\n+        SUSPENDED(1, 3, 4),       // 3", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDkyMA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439700920", "bodyText": "I see. I was just thinking we should make the idempotency explicit for each state by allowing/disallowing the transition, but I agree we can do that in a followup PR", "author": "ableegoldman", "createdAt": "2020-06-13T02:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTE5NA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695194", "bodyText": "The SUSPEND case should be no-op IMHO and not call transiteTo() (compare my other comment in Task.java).", "author": "mjsax", "createdAt": "2020-06-13T01:13:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -112,10 +112,19 @@ public void completeRestoration() {\n     @Override\n     public void suspend() {\n         log.trace(\"No-op suspend with state {}\", state());\n-        if (state() == State.RUNNING) {\n-            transitionTo(State.SUSPENDED);\n-        } else if (state() == State.RESTORING) {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending standby task \" + id);\n+        switch (state()) {\n+            case CREATED:\n+            case RUNNING:\n+            case SUSPENDED:", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTMxNA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695314", "bodyText": "IMHO, we should keep the SUSPENDED case for consistency reasons. Only merge CREATED and RESTORING (cf. my other comment on Task.java)", "author": "mjsax", "createdAt": "2020-06-13T01:14:37Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -250,14 +250,10 @@ public void completeRestoration() {\n     public void suspend() {\n         switch (state()) {\n             case CREATED:\n-            case SUSPENDED:", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTUxMg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695512", "bodyText": "Is the comment necessary? Seem the code is self-explaining?", "author": "mjsax", "createdAt": "2020-06-13T01:16:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -474,20 +470,17 @@ public void update(final Set<TopicPartition> topicPartitions, final Map<String,\n \n     @Override\n     public void closeAndRecycleState() {\n-        suspend();\n-        prepareCommit();\n-        writeCheckpointIfNeed();\n-\n+        // Stream tasks should have already been suspended and their consumed offsets committed before recycling", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5OTg5NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439699895", "bodyText": "Yeah it does seem unnecessary", "author": "ableegoldman", "createdAt": "2020-06-13T02:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTcwMA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695700", "bodyText": "Why remove the < arrow? We can still transit from RESTORING to SUSPENDED.\nSuper-nit: +---->| Suspended -> +---> | Suspended", "author": "mjsax", "createdAt": "2020-06-13T01:18:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -56,21 +56,21 @@\n      *          |            |              |     |\n      *          |            v              |     |\n      *          |     +------+--------+     |     |\n-     *          |     | Suspended (3) | <---+     |    //TODO Suspended(3) could be removed after we've stable on KIP-429\n-     *          |     +------+--------+           |\n-     *          |            |                    |\n-     *          |            v                    |\n-     *          |      +-----+-------+            |\n-     *          +----> | Closed (4)  | -----------+\n+     *          +---->| Suspended (3) | ----+     |    //TODO Suspended(3) could be removed after we've stable on KIP-429", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDcxMQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439700711", "bodyText": "The diff makes it hard to tell, but I \"merged\" the path to SUSPENDED from CREATED and RESTORING. I find it a bit easier to follow when all the arrows are unidirectional", "author": "ableegoldman", "createdAt": "2020-06-13T02:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTg0Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439695846", "bodyText": "Nit: Why LinkedList<Task> tasksToClose? Should we only declare it as List?", "author": "mjsax", "createdAt": "2020-06-13T01:20:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -215,91 +215,54 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                      \"\\tExisting standby tasks: {}\",\n                  activeTasks.keySet(), standbyTasks.keySet(), activeTaskIds(), standbyTaskIds());\n \n-        final Map<TaskId, Set<TopicPartition>> activeTasksToCreate = new HashMap<>(activeTasks);\n-        final Map<TaskId, Set<TopicPartition>> standbyTasksToCreate = new HashMap<>(standbyTasks);\n-        final Set<Task> tasksToRecycle = new HashSet<>();\n-\n         builder.addSubscribedTopicsFromAssignment(\n             activeTasks.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n             logPrefix\n         );\n \n-        // first rectify all existing tasks\n         final LinkedHashMap<TaskId, RuntimeException> taskCloseExceptions = new LinkedHashMap<>();\n \n-        final Set<Task> tasksToClose = new HashSet<>();\n-        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n-        final Set<Task> additionalTasksForCommitting = new HashSet<>();\n+        final Map<TaskId, Set<TopicPartition>> activeTasksToCreate = new HashMap<>(activeTasks);\n+        final Map<TaskId, Set<TopicPartition>> standbyTasksToCreate = new HashMap<>(standbyTasks);\n+        final LinkedList<Task> tasksToClose = new LinkedList<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5OTk2MA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439699960", "bodyText": "ack", "author": "ableegoldman", "createdAt": "2020-06-13T02:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439696982", "bodyText": "If we hit an exception in handleRevocation why would we continue here? Are we still in a \"clean enough\" state to actually continue?\nBelow we call completeTaskCloseClean(task) what seem incorrect for this case as it might close clean task even if we did not successfully commit before.", "author": "mjsax", "createdAt": "2020-06-13T01:32:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -215,91 +215,54 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                      \"\\tExisting standby tasks: {}\",\n                  activeTasks.keySet(), standbyTasks.keySet(), activeTaskIds(), standbyTaskIds());\n \n-        final Map<TaskId, Set<TopicPartition>> activeTasksToCreate = new HashMap<>(activeTasks);\n-        final Map<TaskId, Set<TopicPartition>> standbyTasksToCreate = new HashMap<>(standbyTasks);\n-        final Set<Task> tasksToRecycle = new HashSet<>();\n-\n         builder.addSubscribedTopicsFromAssignment(\n             activeTasks.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n             logPrefix\n         );\n \n-        // first rectify all existing tasks\n         final LinkedHashMap<TaskId, RuntimeException> taskCloseExceptions = new LinkedHashMap<>();\n \n-        final Set<Task> tasksToClose = new HashSet<>();\n-        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n-        final Set<Task> additionalTasksForCommitting = new HashSet<>();\n+        final Map<TaskId, Set<TopicPartition>> activeTasksToCreate = new HashMap<>(activeTasks);\n+        final Map<TaskId, Set<TopicPartition>> standbyTasksToCreate = new HashMap<>(standbyTasks);\n+        final LinkedList<Task> tasksToClose = new LinkedList<>();\n+        final Set<Task> tasksToRecycle = new HashSet<>();\n         final Set<Task> dirtyTasks = new HashSet<>();\n \n+        // first rectify all existing tasks\n         for (final Task task : tasks.values()) {\n             if (activeTasks.containsKey(task.id()) && task.isActive()) {\n                 updateInputPartitionsAndResume(task, activeTasks.get(task.id()));\n-                if (task.commitNeeded()) {\n-                    additionalTasksForCommitting.add(task);\n-                }\n                 activeTasksToCreate.remove(task.id());\n             } else if (standbyTasks.containsKey(task.id()) && !task.isActive()) {\n                 updateInputPartitionsAndResume(task, standbyTasks.get(task.id()));\n                 standbyTasksToCreate.remove(task.id());\n-                // check for tasks that were owned previously but have changed active/standby status\n             } else if (activeTasks.containsKey(task.id()) || standbyTasks.containsKey(task.id())) {\n+                // check for tasks that were owned previously but have changed active/standby status\n                 tasksToRecycle.add(task);\n             } else {\n-                try {\n-                    task.suspend();\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-\n-                    tasksToClose.add(task);\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n-                    }\n-                } catch (final RuntimeException e) {\n-                    final String uncleanMessage = String.format(\n-                        \"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\",\n-                        task.id());\n-                    log.error(uncleanMessage, e);\n-                    taskCloseExceptions.put(task.id(), e);\n-                    // We've already recorded the exception (which is the point of clean).\n-                    // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n-                    dirtyTasks.add(task);\n-                }\n+                tasksToClose.add(task);\n             }\n         }\n \n-        if (!consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+        for (final Task task : tasksToClose) {\n             try {\n-                for (final Task task : additionalTasksForCommitting) {\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+                task.suspend(); // Should be a no-op for active tasks, unless we hit an exception during handleRevocation", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMTkxNw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439701917", "bodyText": "If we hit an exception in handleRevocation on some task then we would skip out on suspending the rest of the tasks, ie the set of not-suspended tasks does not contain the task that threw (of course if one task threw an exception then its likely others will too, but not guaranteed).\nBut maybe it's cleaner to catch exceptions during handleRevocation and at least make sure every task gets suspended? I'll try that\nOn a related note, if we always  have to commit before closing (or at least attempt to), should we just remove the writeCheckpointIfNeeded call from closeClean? Seems like the pre/postCommit should be responsible for whether to checkpoint, not close. In this case, it's completely fine to attempt a clean close of a dirty task, as the closeClean method will just maybe throw in which case we can close dirty. WDYT?", "author": "ableegoldman", "createdAt": "2020-06-13T02:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMjUzNg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439702536", "bodyText": "Instead of checkpointing, we can check if clean && commitNeeded & checkpoint != null and then throw an exception on closeClean (which would result in calling closeDirty)", "author": "ableegoldman", "createdAt": "2020-06-13T02:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTkwNA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439851904", "bodyText": "I re-read the current code structure and got some questions:\n\nwe collect checkpoint from prepareCommit and check if it is not null in postCommit, but the actual checkpoint value itself is always collectable post the commit, and hence what's only required to that we need to know if we need to write a checkpoint file or not. Previously this needs to be decided since we may transit the state in between but now from the source code it seems to me that we would only call prepare/post before suspend / close ever, so this is no longer required actually, i.e. we can decide whether we need to checkpoint and then collect the checkpoint map and write the file if needed in a single call. Is that right?\n\n\nI think I agree with you that it is cleaner to make sure in handleRevocation, we still transit those revoked partition's corresponding tasks to suspended even if some of their commit call failed.", "author": "guozhangwang", "createdAt": "2020-06-14T17:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5MzAwNQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440493005", "bodyText": "I think you're right, we don't need to keep track of the current checkpoint offsets at all and can just write the current checkpointableOffsets in postCommit\ndone", "author": "ableegoldman", "createdAt": "2020-06-15T23:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU1NTE0Mg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440555142", "bodyText": "postCommit only writes a checkpoint for non-eos. Thus, we still need to write a checkpoint in close() for the eos-case (if just blindly for all cases as we do atm).", "author": "mjsax", "createdAt": "2020-06-16T02:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU1NTQ1OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440555458", "bodyText": "postCommit will always write the checkpoint if the task is in SUSPENDED, which it should always be before being closed", "author": "ableegoldman", "createdAt": "2020-06-16T02:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5Njk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439697426", "bodyText": "Why do we do the try-catch as outer-layer? In an exception occurs, we should stop looping through the tasks to call postCommit() -- is this intended? If yes, why?", "author": "mjsax", "createdAt": "2020-06-13T01:39:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -714,13 +696,20 @@ void shutdown(final boolean clean) {\n             }\n         }\n \n-        if (clean && !consumedOffsetsAndMetadataPerTask.isEmpty()) {\n-            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        try {\n+            if (clean && !consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+                commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+            }\n+            for (final TaskId taskId : consumedOffsetsAndMetadataPerTask.keySet()) {\n+                final Task task = tasks.get(taskId);\n+                task.postCommit();\n+            }\n+        } catch (final RuntimeException e) {\n+            firstException.compareAndSet(null, e);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDMxMQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439700311", "bodyText": "Well if commit throws an exception, then we shouldn't call postCommit right?\nOr are you saying if  commit succeeds but postCommit throws for one task, we should still loop through and try to postCommit all the other tasks?", "author": "ableegoldman", "createdAt": "2020-06-13T02:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjU2NA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439852564", "bodyText": "Yeah I think if the actual consumer.commit call failed, then we should not trigger postCommit for any one.\nAs for postCommit, I think it should never fail (we swallow the IO exception happened, because for non-EOS it is just fine, for EOS we would bootstrap from scratch).", "author": "guozhangwang", "createdAt": "2020-06-14T17:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU1NDI0OQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440554249", "bodyText": "I meant the later. And I agree that if commit fails, we should not call postCommit().\nFor failure in postCommit: we make assumptions about the current code what seems dangerous (ie, not future prove)? -- IMHO, if postCommit fails, we need to close the corresponding task dirty and either recreate it, or rebalance, but we should also continue to call postCommit() for all other tasks?", "author": "mjsax", "createdAt": "2020-06-16T02:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU1NTkxOA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440555918", "bodyText": "I see. Then I think it makes sense to always attempt to write the checkpoint/call postCommit for a task that was successfully committed, regardless of whether something went wrong during postCommit with a different task\nAnd I agree, we should not make assumptions about the current code not throwing, unless it's explicitly in the contract of the method that it will never throw (which is not the case for postCommit", "author": "ableegoldman", "createdAt": "2020-06-16T02:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzNDQ5Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441034497", "bodyText": "Sounds good, in that case the nested try-catch would be necessary.", "author": "guozhangwang", "createdAt": "2020-06-16T17:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTYxNg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r439851616", "bodyText": "Seems we would never commit and checkpoint state manager any more.", "author": "guozhangwang", "createdAt": "2020-06-14T17:35:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -539,19 +537,18 @@ private void writeCheckpointIfNeed() {\n     /**\n      * <pre>\n      * the following order must be followed:\n-     *  1. checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed\n+     *  1. commit/checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3MzcyNg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r440473726", "bodyText": "ack", "author": "ableegoldman", "createdAt": "2020-06-15T22:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTYxNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNjQ4NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441026485", "bodyText": "nit: was an active scheduled checkpoint -> there was a pending uncommitted data.", "author": "guozhangwang", "createdAt": "2020-06-16T17:37:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -502,56 +494,24 @@ public void closeAndRecycleState() {\n         log.info(\"Closed clean and recycled state\");\n     }\n \n-    private void maybeScheduleCheckpoint() {\n-        switch (state()) {\n-            case RESTORING:\n-            case SUSPENDED:\n-                this.checkpoint = checkpointableOffsets();\n-\n-                break;\n-\n-            case RUNNING:\n-                if (!eosEnabled) {\n-                    this.checkpoint = checkpointableOffsets();\n-                }\n-\n-                break;\n-\n-            case CREATED:\n-            case CLOSED:\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while scheduling checkpoint for active task \" + id);\n-\n-            default:\n-                throw new IllegalStateException(\"Unknown state \" + state() + \" while scheduling checkpoint for active task \" + id);\n-        }\n-    }\n-\n-    private void writeCheckpointIfNeed() {\n+    private void maybeWriteCheckpoint() {\n         if (commitNeeded) {\n+            log.error(\"Tried to write a checkpoint with pending uncommitted data, should complete the commit first.\");\n             throw new IllegalStateException(\"A checkpoint should only be written if no commit is needed.\");\n         }\n-        if (checkpoint != null) {\n-            stateMgr.checkpoint(checkpoint);\n-            checkpoint = null;\n-        }\n+        stateMgr.checkpoint(checkpointableOffsets());\n     }\n \n     /**\n-     * <pre>\n-     * the following order must be followed:\n-     *  1. checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed\n-     *  2. then if we are closing on EOS and dirty, wipe out the state store directory\n-     *  3. finally release the state manager lock\n-     * </pre>\n+     * You must commit a task and checkpoint the state manager before closing as this will release the state dir lock\n      */\n     private void close(final boolean clean) {\n-        if (clean) {\n-            executeAndMaybeSwallow(true, this::writeCheckpointIfNeed, \"state manager checkpoint\", log);\n+        if (clean && commitNeeded) {\n+            log.debug(\"Tried to close clean but there was an active scheduled checkpoint, this means we failed to\"", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441046024", "bodyText": "I think we still need to make this call -- in eager rebalancing, we suspend a task when we get a partition revoked. For this case, we \"forget\" the current offset within the consumer and thus need to clear the partition grouper. Otherwise, we might read the data a second time, if the partition is reassigned (what would violate EOS).", "author": "mjsax", "createdAt": "2020-06-16T18:10:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -409,32 +407,28 @@ public void resume() {\n         return committableOffsets;\n     }\n \n+    /**\n+     * This should only be called if the attempted commit succeeded for this task\n+     */\n     @Override\n     public void postCommit() {\n         commitRequested = false;\n         commitNeeded = false;\n \n         switch (state()) {\n             case RESTORING:\n-                writeCheckpointIfNeed();\n+            case SUSPENDED:\n+                maybeWriteCheckpoint();\n \n                 break;\n \n             case RUNNING:\n-                if (!eosEnabled) { // if RUNNING, checkpoint only for non-eos\n-                    writeCheckpointIfNeed();\n+                if (!eosEnabled) {\n+                    maybeWriteCheckpoint();\n                 }\n \n                 break;\n \n-            case SUSPENDED:\n-                writeCheckpointIfNeed();\n-                // we cannot `clear()` the `PartitionGroup` in `suspend()` already, but only after committing,\n-                // because otherwise we loose the partition-time information\n-                partitionGroup.clear();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0OTgxNw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441049817", "bodyText": "I see. So we should only clear it here, and not in close\nJust curious, why do we \"forget\" the current offset? I mean, haven't we just committed the current offset before suspending (and if that failed we would close all tasks right away). Maybe I'm misunderstanding what you mean", "author": "ableegoldman", "createdAt": "2020-06-16T18:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NTA5MQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441065091", "bodyText": "The consumer tracks offset internal, however, we buffer data in our internal queue. Thus, the offset tracked by the consumer, might be larger than the offset we commit (we take the offset we commit not from the consumer, but it's based on the records we did take out of the queue and processed).\nIn eager rebalancing, the consumer clears its internal state if a partition in revoked (and we only suspend the task), including the tracked offsets. If the partition in re-assigned, the consumer fetches the last committed offset to start fetching. Thus, if we don't clear the queue, we might fetch same data that is already in the queue a second time.\nDoes this make sense?", "author": "mjsax", "createdAt": "2020-06-16T18:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4ODg0Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441088847", "bodyText": "Ah that's a good catch. Makes sense to me.", "author": "guozhangwang", "createdAt": "2020-06-16T19:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4OTM5Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441089397", "bodyText": "Got it, thanks for the explanation. I'll move it back to postCommit with a note", "author": "ableegoldman", "createdAt": "2020-06-16T19:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MjcwMw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441092703", "bodyText": "I'm not 100% certain that the Consumer does clear its internal buffer on revocation. At least, I couldn't find it in the code, but maybe I'm looking in the wrong place.\nNot arguing we shouldn't clear the partition group here, was just wondering about this for my own sake. Hm", "author": "ableegoldman", "createdAt": "2020-06-16T19:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwOTAxMA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441109010", "bodyText": "Not 100% familiar with the consumer code, but in SubscriptionState#assignFromSubscribed new TopicPartitionState are created with position = null.", "author": "mjsax", "createdAt": "2020-06-16T20:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNDc1Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441114757", "bodyText": "Ah that seems right. Thanks!", "author": "ableegoldman", "createdAt": "2020-06-16T20:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NzM2MA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441047360", "bodyText": "As we always suspend a task before closing (even for unclean closing), I think we can actually remove this call? (We only needed it before, because SUSPEND could be skipped.", "author": "mjsax", "createdAt": "2020-06-16T18:12:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -474,26 +468,24 @@ public void update(final Set<TopicPartition> topicPartitions, final Map<String,\n \n     @Override\n     public void closeAndRecycleState() {\n-        suspend();\n-        prepareCommit();\n-        writeCheckpointIfNeed();\n-\n         switch (state()) {\n-            case CREATED:\n             case SUSPENDED:\n                 stateMgr.recycle();\n                 recordCollector.close();\n \n                 break;\n \n-            case RESTORING: // we should have transitioned to `SUSPENDED` already\n-            case RUNNING: // we should have transitioned to `SUSPENDED` already\n+            case CREATED:\n+            case RESTORING:\n+            case RUNNING:\n             case CLOSED:\n                 throw new IllegalStateException(\"Illegal state \" + state() + \" while recycling active task \" + id);\n             default:\n                 throw new IllegalStateException(\"Unknown state \" + state() + \" while recycling active task \" + id);\n         }\n \n+        // we cannot `clear()` the `PartitionGroup` in `suspend()` already, but only after committing,\n+        // because otherwise we loose the partition-time information\n         partitionGroup.clear();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0OTIwMA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441049200", "bodyText": "Seems we call stateMgr.checkpoint unconditionally now. Should we rename this this writeCheckpoint ? Or even remove it all together as we if (commitNeeded) check is \"just\" a guard and the method is a single liner now?", "author": "mjsax", "createdAt": "2020-06-16T18:16:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -502,56 +494,24 @@ public void closeAndRecycleState() {\n         log.info(\"Closed clean and recycled state\");\n     }\n \n-    private void maybeScheduleCheckpoint() {\n-        switch (state()) {\n-            case RESTORING:\n-            case SUSPENDED:\n-                this.checkpoint = checkpointableOffsets();\n-\n-                break;\n-\n-            case RUNNING:\n-                if (!eosEnabled) {\n-                    this.checkpoint = checkpointableOffsets();\n-                }\n-\n-                break;\n-\n-            case CREATED:\n-            case CLOSED:\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while scheduling checkpoint for active task \" + id);\n-\n-            default:\n-                throw new IllegalStateException(\"Unknown state \" + state() + \" while scheduling checkpoint for active task \" + id);\n-        }\n-    }\n-\n-    private void writeCheckpointIfNeed() {\n+    private void maybeWriteCheckpoint() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MTQ0Ng==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441081446", "bodyText": "Well, the commitNeeded guard is a good idea imo. But I agree we should rename this", "author": "ableegoldman", "createdAt": "2020-06-16T19:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0OTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NjE0OQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441056149", "bodyText": "Is this necessarily a warning? A wall-clock-time punctuation could have set commitNeeded to true?", "author": "mjsax", "createdAt": "2020-06-16T18:24:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -465,44 +429,82 @@ boolean tryToCompleteRestoration() {\n     }\n \n     /**\n+     * Handle the revoked partitions and prepare for closing the associated tasks in {@link #handleAssignment(Map, Map)}\n+     * We should commit the revoked tasks now as we will not officially own them anymore when {@link #handleAssignment(Map, Map)}\n+     * is called. Note that only active task partitions are passed in from the rebalance listener, so we only need to\n+     * consider/commit active tasks here\n+     *\n+     * If eos-beta is used, we must commit ALL tasks. Otherwise, we can just commit those (active) tasks which are revoked\n+     *\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n+        final Set<TopicPartition> remainingRevokedPartitions = new HashSet<>(revokedPartitions);\n \n-        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n-        for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                task.suspend();\n-                final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n+        final Set<Task> tasksToCommit = new HashSet<>();\n+        final Set<Task> additionalTasksForCommitting = new HashSet<>();\n \n-                if (!committableOffsets.isEmpty()) {\n-                    consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+        final AtomicReference<RuntimeException> firstException = new AtomicReference<>(null);\n+        for (final Task task : activeTaskIterable()) {\n+            if (remainingRevokedPartitions.containsAll(task.inputPartitions())) {\n+                try {\n+                    task.suspend();\n+                    if (task.commitNeeded()) {\n+                        tasksToCommit.add(task);\n+                    }\n+                } catch (final RuntimeException e) {\n+                    log.error(\"Caught the following exception while trying to suspend revoked task \" + task.id(), e);\n+                    firstException.compareAndSet(null, new StreamsException(\"Failed to suspend \" + task.id(), e));\n                 }\n-            } else if (task.isActive() && task.commitNeeded()) {\n-                final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n+            } else if (task.commitNeeded()) {\n+                additionalTasksForCommitting.add(task);\n+            }\n+            remainingRevokedPartitions.removeAll(task.inputPartitions());\n+        }\n \n-                if (!committableOffsets.isEmpty()) {\n-                    consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n-                }\n+        if (!remainingRevokedPartitions.isEmpty()) {\n+            log.warn(\"The following partitions {} are missing from the task partitions. It could potentially \" +\n+                         \"due to race condition of consumer detecting the heartbeat failure, or the tasks \" +\n+                         \"have been cleaned up by the handleAssignment callback.\", remainingRevokedPartitions);\n+        }\n+\n+        final RuntimeException suspendException = firstException.get();\n+        if (suspendException != null) {\n+            throw suspendException;\n+        }\n+\n+        // If using eos-beta, if we must commit any task then we must commit all of them\n+        // TODO: when KAFKA-9450 is done this will be less expensive, and we can simplify by always committing everything\n+        if (processingMode ==  EXACTLY_ONCE_BETA && !tasksToCommit.isEmpty()) {\n+            tasksToCommit.addAll(additionalTasksForCommitting);\n+        }\n+\n+        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n+        for (final Task task : tasksToCommit) {\n+            final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n+            if (!committableOffsets.isEmpty()) {\n+                consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+            } else {\n+                log.warn(\"Task {} claimed to need a commit but had no committable consumed offsets\", task.id());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTg2NQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441059865", "bodyText": "Oh good point. I'll remove this", "author": "ableegoldman", "createdAt": "2020-06-16T18:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTEwMA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441059100", "bodyText": "Thinking about punctuation, should we actually call commitOffsetsOrTransaction() unconditionally (ie, not consider if consumedOffsetsAndMetadataPerTask is empty or not?\nWe can still move the check inside consumedOffsetsAndMetadataPerTask, but for EOS there might pending writes from punctuation that we still need to commit?\nThis would apply to all calls of commitOffsetsOrTransaction ?", "author": "mjsax", "createdAt": "2020-06-16T18:29:37Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -714,13 +717,26 @@ void shutdown(final boolean clean) {\n             }\n         }\n \n-        if (clean && !consumedOffsetsAndMetadataPerTask.isEmpty()) {\n-            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        try {\n+            if (clean && !consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+                commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MTE3Nw==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441081177", "bodyText": "Hm. So in the punctuation case -- where commitNeeded is true but consumedOffsets is empty -- we still need to call commitOffsetsOrTransaction (and postCommit) because the punctuation may for example write to a state store and generate changelog records. So we would need to commit that transaction, and also write the checkpoint file.\nMakes sense", "author": "ableegoldman", "createdAt": "2020-06-16T19:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MjM4Mg==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441092382", "bodyText": "Committable offsets here should contain consumed offsets, and punctuation itself should never update those consumed offsets right?\nI think we can skip the call if consumedOffsetsAndMetadataPerTask is empty.", "author": "guozhangwang", "createdAt": "2020-06-16T19:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMTY4OA==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441101688", "bodyText": "Committable offsets here should contain consumed offsets, and punctuation itself should never update those consumed offsets right\n\nYes.\n\nI think we can skip the call if consumedOffsetsAndMetadataPerTask is empty.\n\nFor non-eos, yes, because for non-eos commitOffsetsOrTransaction() would only commit offsets via the consumer (this can be skipped if empty). However, for eos (alpha and beta), we might have a pending transaction that we need to commit on the producer, too.", "author": "mjsax", "createdAt": "2020-06-16T19:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTEwMA=="}], "type": "inlineReview"}, {"oid": "3789a7c1dc71b69ec4d6af621a3415210d731fa8", "url": "https://github.com/apache/kafka/commit/3789a7c1dc71b69ec4d6af621a3415210d731fa8", "message": "enforce SUSPENDED and check commitNeeded", "committedDate": "2020-06-16T20:00:35Z", "type": "commit"}, {"oid": "f621c3a02d673a57bcfb32a653a257bfc4d48241", "url": "https://github.com/apache/kafka/commit/f621c3a02d673a57bcfb32a653a257bfc4d48241", "message": "check if commit needed in TM", "committedDate": "2020-06-16T20:00:35Z", "type": "commit"}, {"oid": "0c3c080bf6c6007979404dcfaf45e75399711332", "url": "https://github.com/apache/kafka/commit/0c3c080bf6c6007979404dcfaf45e75399711332", "message": "just suspend in closeandRecycleState", "committedDate": "2020-06-16T20:00:35Z", "type": "commit"}, {"oid": "a6805838f5c3fbbade7eaa82330b14d88e52f783", "url": "https://github.com/apache/kafka/commit/a6805838f5c3fbbade7eaa82330b14d88e52f783", "message": "clean up handleRevocation and handleAssignment", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "fb64b9787153ae1da96db9694008139f4d299a4d", "url": "https://github.com/apache/kafka/commit/fb64b9787153ae1da96db9694008139f4d299a4d", "message": "Task and TaskManager tests", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "7b08e28d940ae822b05da54460064c261b56e0ed", "url": "https://github.com/apache/kafka/commit/7b08e28d940ae822b05da54460064c261b56e0ed", "message": "always close all tasks during shutdown", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "dd03646b9c8c01602219d7afb25730df5663a7d0", "url": "https://github.com/apache/kafka/commit/dd03646b9c8c01602219d7afb25730df5663a7d0", "message": "only commit all for eos-beta", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "1f989fc78ffa6b89cf50775767e563a64120460a", "url": "https://github.com/apache/kafka/commit/1f989fc78ffa6b89cf50775767e563a64120460a", "message": "addressing CR feedback", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "cf21fb5d42e1a5b1521ae58b7f57839195a4791b", "url": "https://github.com/apache/kafka/commit/cf21fb5d42e1a5b1521ae58b7f57839195a4791b", "message": "get rid of checkpoint member", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "d2ba0df1befe929672850755d1610427c6234e57", "url": "https://github.com/apache/kafka/commit/d2ba0df1befe929672850755d1610427c6234e57", "message": "fixing up last few TM tests", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "bd032c97d515c9dfff9ed940ae795105b2c466c7", "url": "https://github.com/apache/kafka/commit/bd032c97d515c9dfff9ed940ae795105b2c466c7", "message": "log before transition", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "0349663e2836129908a73e9e587ece9afb3bc04f", "url": "https://github.com/apache/kafka/commit/0349663e2836129908a73e9e587ece9afb3bc04f", "message": "attempt to postCommit all tasks", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "3ff79ea351cd20c4021b053133061984c0bbd202", "url": "https://github.com/apache/kafka/commit/3ff79ea351cd20c4021b053133061984c0bbd202", "message": "always commit when commitNeeded", "committedDate": "2020-06-16T20:00:36Z", "type": "commit"}, {"oid": "3ff79ea351cd20c4021b053133061984c0bbd202", "url": "https://github.com/apache/kafka/commit/3ff79ea351cd20c4021b053133061984c0bbd202", "message": "always commit when commitNeeded", "committedDate": "2020-06-16T20:00:36Z", "type": "forcePushed"}, {"oid": "2529fb91b156a520ceb4178665ab313051f68cfd", "url": "https://github.com/apache/kafka/commit/2529fb91b156a520ceb4178665ab313051f68cfd", "message": "only commit active tasks", "committedDate": "2020-06-16T20:13:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNjE0MQ==", "url": "https://github.com/apache/kafka/pull/8856#discussion_r441116141", "bodyText": "As @mjsax pointed out, we should still commit even if there are no consumed offsets. However, we should not commit the offsets/transaction if there are no active tasks that need committing", "author": "ableegoldman", "createdAt": "2020-06-16T20:17:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -690,18 +686,21 @@ void shutdown(final boolean clean) {\n         final AtomicReference<RuntimeException> firstException = new AtomicReference<>(null);\n \n         final Set<Task> tasksToClose = new HashSet<>();\n+        final Set<Task> tasksToCommit = new HashSet<>();\n         final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n \n         for (final Task task : tasks.values()) {\n             if (clean) {\n                 try {\n                     task.suspend();\n-                    final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n-\n-                    tasksToClose.add(task);\n-                    if (!committableOffsets.isEmpty()) {\n-                        consumedOffsetsAndMetadataPerTask.put(task.id(), committableOffsets);\n+                    if (task.commitNeeded()) {\n+                        tasksToCommit.add(task);\n+                        final Map<TopicPartition, OffsetAndMetadata> committableOffsets = task.prepareCommit();\n+                        if (task.isActive()) {", "originalCommit": "2529fb91b156a520ceb4178665ab313051f68cfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}