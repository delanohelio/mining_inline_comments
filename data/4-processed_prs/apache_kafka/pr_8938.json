{"pr_number": 8938, "pr_title": "KAFKA-10173: Use SmokeTest for upgrade system tests", "pr_createdAt": "2020-06-27T18:08:15Z", "pr_url": "https://github.com/apache/kafka/pull/8938", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MTg4OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446551889", "bodyText": "This isn't needed anymore, as SmokeTestClient#start now blocks until the instance goes to running the first time.", "author": "vvcephei", "createdAt": "2020-06-27T18:10:14Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/SmokeTestDriverIntegrationTest.java", "diffHunk": "@@ -104,10 +104,6 @@ public void shouldWorkWithRebalance() throws InterruptedException {\n             clients.add(smokeTestClient);\n             smokeTestClient.start(props);\n \n-            while (!clients.get(clients.size() - 1).started()) {\n-                Thread.sleep(100);\n-            }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MTk3Nw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446551977", "bodyText": "I inlined these utilities to make this class \"portable\". I.e., we can copy and paste it into the \"upgrade test\" modules without also dragging in a dependency on the client utils.", "author": "vvcephei", "createdAt": "2020-06-27T18:11:15Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2OTY3OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448569679", "bodyText": "Sounds good.", "author": "guozhangwang", "createdAt": "2020-07-01T19:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjA4Nw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552087", "bodyText": "Inlining this function actually fixed a bug in which the next line was setting a handler that actually replaced the handler registered in createKafkaStreams.\nThe function was only used from right here anyway, so it was needless complexity.", "author": "vvcephei", "createdAt": "2020-06-27T18:12:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjI3Ng==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552276", "bodyText": "This is logic from the inlined function that had gotten lost when we set the handler again.", "author": "vvcephei", "createdAt": "2020-06-27T18:13:54Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjM0Ng==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552346", "bodyText": "Blocking and then printing this gives the system tests the ability to explicitly wait until the instances are joined.", "author": "vvcephei", "createdAt": "2020-06-27T18:14:43Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));\n         });\n \n-        Exit.addShutdownHook(\"streams-shutdown-hook\", () -> close());\n+        addShutdownHook(\"streams-shutdown-hook\", this::close);\n \n-        thread = new Thread(() -> streams.start());\n-        thread.start();\n+        streams.start();\n+        try {\n+            if (!countDownLatch.await(1, TimeUnit.MINUTES)) {\n+                System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't start in one minute\");\n+            }\n+        } catch (final InterruptedException e) {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: \" + e);\n+            e.printStackTrace(System.out);\n+        }\n+        System.out.println(name + \": SMOKE-TEST-CLIENT-STARTED\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjQ5Ng==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552496", "bodyText": "I just happened to notice that we weren't previously checking that Streams actually finished closing. It looks like we were expecting some kind of exception to get thrown during the join() below, but that's not the way it works.", "author": "vvcephei", "createdAt": "2020-06-27T18:15:57Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));\n         });\n \n-        Exit.addShutdownHook(\"streams-shutdown-hook\", () -> close());\n+        addShutdownHook(\"streams-shutdown-hook\", this::close);\n \n-        thread = new Thread(() -> streams.start());\n-        thread.start();\n+        streams.start();\n+        try {\n+            if (!countDownLatch.await(1, TimeUnit.MINUTES)) {\n+                System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't start in one minute\");\n+            }\n+        } catch (final InterruptedException e) {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: \" + e);\n+            e.printStackTrace(System.out);\n+        }\n+        System.out.println(name + \": SMOKE-TEST-CLIENT-STARTED\");\n+        System.out.println(name + \" started at \" + Instant.now());\n     }\n \n     public void closeAsync() {\n         streams.close(Duration.ZERO);\n     }\n \n     public void close() {\n-        streams.close(Duration.ofSeconds(5));\n-        // do not remove these printouts since they are needed for health scripts\n-        if (!uncaughtException) {\n+        final boolean wasClosed = streams.close(Duration.ofMinutes(1));\n+\n+        if (wasClosed && !uncaughtException) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjU3MQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552571", "bodyText": "So here's what we print if there was no uncaught exception, but we also didn't close in time.", "author": "vvcephei", "createdAt": "2020-06-27T18:16:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));\n         });\n \n-        Exit.addShutdownHook(\"streams-shutdown-hook\", () -> close());\n+        addShutdownHook(\"streams-shutdown-hook\", this::close);\n \n-        thread = new Thread(() -> streams.start());\n-        thread.start();\n+        streams.start();\n+        try {\n+            if (!countDownLatch.await(1, TimeUnit.MINUTES)) {\n+                System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't start in one minute\");\n+            }\n+        } catch (final InterruptedException e) {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: \" + e);\n+            e.printStackTrace(System.out);\n+        }\n+        System.out.println(name + \": SMOKE-TEST-CLIENT-STARTED\");\n+        System.out.println(name + \" started at \" + Instant.now());\n     }\n \n     public void closeAsync() {\n         streams.close(Duration.ZERO);\n     }\n \n     public void close() {\n-        streams.close(Duration.ofSeconds(5));\n-        // do not remove these printouts since they are needed for health scripts\n-        if (!uncaughtException) {\n+        final boolean wasClosed = streams.close(Duration.ofMinutes(1));\n+\n+        if (wasClosed && !uncaughtException) {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-CLOSED\");\n-        }\n-        try {\n-            thread.join();\n-        } catch (final Exception ex) {\n-            // do not remove these printouts since they are needed for health scripts\n+        } else if (wasClosed) {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n-            // ignore\n+        } else {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't close\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MjE5MA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448572190", "bodyText": "nit: Didn't close in time?", "author": "guozhangwang", "createdAt": "2020-07-01T19:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4MTYwNw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448581607", "bodyText": "Sounds good.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't close\");\n          \n          \n            \n                        System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't close in time.\");", "author": "vvcephei", "createdAt": "2020-07-01T19:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjY0OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552649", "bodyText": "5 seconds seems a bit stingy :) . Note that we were previously ignoring the case where we didn't close within the timeout, so we have no idea if 5 seconds was ever long enough. I figured a minute is more reasonable.", "author": "vvcephei", "createdAt": "2020-06-27T18:17:50Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));\n         });\n \n-        Exit.addShutdownHook(\"streams-shutdown-hook\", () -> close());\n+        addShutdownHook(\"streams-shutdown-hook\", this::close);\n \n-        thread = new Thread(() -> streams.start());\n-        thread.start();\n+        streams.start();\n+        try {\n+            if (!countDownLatch.await(1, TimeUnit.MINUTES)) {\n+                System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't start in one minute\");\n+            }\n+        } catch (final InterruptedException e) {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: \" + e);\n+            e.printStackTrace(System.out);\n+        }\n+        System.out.println(name + \": SMOKE-TEST-CLIENT-STARTED\");\n+        System.out.println(name + \" started at \" + Instant.now());\n     }\n \n     public void closeAsync() {\n         streams.close(Duration.ZERO);\n     }\n \n     public void close() {\n-        streams.close(Duration.ofSeconds(5));\n-        // do not remove these printouts since they are needed for health scripts\n-        if (!uncaughtException) {\n+        final boolean wasClosed = streams.close(Duration.ofMinutes(1));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MTg4Mg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448571882", "bodyText": "+1", "author": "guozhangwang", "createdAt": "2020-07-01T19:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1Mjc1NQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552755", "bodyText": "Moved these to the python code, where the \"properties file\" itself is built. I left only the properties that are better off dynamically generated in the java code.", "author": "vvcephei", "createdAt": "2020-06-27T18:18:56Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();\n+\n+        addShutdownHook(\"delete-temp-file-shutdown-hook\", () -> {\n+            try {\n+                Utils.delete(file);\n+            } catch (final IOException e) {\n+                System.out.println(\"Error deleting \" + file.getAbsolutePath());\n+                e.printStackTrace(System.out);\n+            }\n+        });\n+\n+        return file;\n+    }\n+\n+    public SmokeTestClient(final String name) {\n+        this.name = name;\n     }\n \n     public boolean closed() {\n         return closed;\n     }\n \n     public void start(final Properties streamsProperties) {\n-        streams = createKafkaStreams(streamsProperties);\n+        final Topology build = getTopology();\n+        streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n+\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        streams.setStateListener((newState, oldState) -> {\n+            System.out.printf(\"%s %s: %s -> %s%n\", name, Instant.now(), oldState, newState);\n+            if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) {\n+                countDownLatch.countDown();\n+            }\n+\n+            if (newState == KafkaStreams.State.NOT_RUNNING) {\n+                closed = true;\n+            }\n+        });\n+\n         streams.setUncaughtExceptionHandler((t, e) -> {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n+            System.out.println(name + \": FATAL: An unexpected exception is encountered on thread \" + t + \": \" + e);\n+            e.printStackTrace(System.out);\n             uncaughtException = true;\n-            e.printStackTrace();\n+            streams.close(Duration.ofSeconds(30));\n         });\n \n-        Exit.addShutdownHook(\"streams-shutdown-hook\", () -> close());\n+        addShutdownHook(\"streams-shutdown-hook\", this::close);\n \n-        thread = new Thread(() -> streams.start());\n-        thread.start();\n+        streams.start();\n+        try {\n+            if (!countDownLatch.await(1, TimeUnit.MINUTES)) {\n+                System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't start in one minute\");\n+            }\n+        } catch (final InterruptedException e) {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: \" + e);\n+            e.printStackTrace(System.out);\n+        }\n+        System.out.println(name + \": SMOKE-TEST-CLIENT-STARTED\");\n+        System.out.println(name + \" started at \" + Instant.now());\n     }\n \n     public void closeAsync() {\n         streams.close(Duration.ZERO);\n     }\n \n     public void close() {\n-        streams.close(Duration.ofSeconds(5));\n-        // do not remove these printouts since they are needed for health scripts\n-        if (!uncaughtException) {\n+        final boolean wasClosed = streams.close(Duration.ofMinutes(1));\n+\n+        if (wasClosed && !uncaughtException) {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-CLOSED\");\n-        }\n-        try {\n-            thread.join();\n-        } catch (final Exception ex) {\n-            // do not remove these printouts since they are needed for health scripts\n+        } else if (wasClosed) {\n             System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION\");\n-            // ignore\n+        } else {\n+            System.out.println(name + \": SMOKE-TEST-CLIENT-EXCEPTION: Didn't close\");\n         }\n     }\n \n     private Properties getStreamsConfig(final Properties props) {\n         final Properties fullProps = new Properties(props);\n         fullProps.put(StreamsConfig.APPLICATION_ID_CONFIG, \"SmokeTest\");\n         fullProps.put(StreamsConfig.CLIENT_ID_CONFIG, \"SmokeTest-\" + name);\n-        fullProps.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 3);\n-        fullProps.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 2);\n-        fullProps.put(StreamsConfig.BUFFERED_RECORDS_PER_PARTITION_CONFIG, 100);\n-        fullProps.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG, 1000);\n-        fullProps.put(StreamsConfig.REPLICATION_FACTOR_CONFIG, 3);\n-        fullProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        fullProps.put(ProducerConfig.ACKS_CONFIG, \"all\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1Mjg4MA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552880", "bodyText": "I just happened to notice that the newline was missing when I looked at the stdout. It didn't affect the tests' ability to grep.", "author": "vvcephei", "createdAt": "2020-06-27T18:19:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestUtil.java", "diffHunk": "@@ -75,7 +75,7 @@ public void process(final Object key, final Object value) {\n \n                     @Override\n                     public void close() {\n-                        System.out.printf(\"Close processor for task %s\", context().taskId());\n+                        System.out.printf(\"Close processor for task %s%n\", context().taskId());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1Mjk0OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446552949", "bodyText": "Everything in the upgrade-system-tests... directories is just copy/pasted from the main SmokeTest implementations.", "author": "vvcephei", "createdAt": "2020-06-27T18:20:12Z", "path": "streams/upgrade-system-tests-22/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.KafkaThread;\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Grouped;\n+import org.apache.kafka.streams.kstream.KGroupedStream;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Produced;\n+import org.apache.kafka.streams.kstream.Suppressed.BufferConfig;\n+import org.apache.kafka.streams.kstream.TimeWindows;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.streams.state.WindowStore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n+\n+public class SmokeTestClient extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAwOQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553009", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:20:39Z", "path": "streams/upgrade-system-tests-22/src/test/java/org/apache/kafka/streams/tests/SmokeTestDriver.java", "diffHunk": "@@ -0,0 +1,632 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.KafkaConsumer;\n+import org.apache.kafka.clients.producer.Callback;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.errors.TimeoutException;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.utils.Exit;\n+import org.apache.kafka.common.utils.Utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+\n+public class SmokeTestDriver extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAxOQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553019", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:20:46Z", "path": "streams/upgrade-system-tests-22/src/test/java/org/apache/kafka/streams/tests/SmokeTestUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.KeyValueMapper;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.ProcessorSupplier;\n+\n+import java.time.Instant;\n+\n+public class SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAyMQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553021", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:20:51Z", "path": "streams/upgrade-system-tests-22/src/test/java/org/apache/kafka/streams/tests/StreamsSmokeTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.StreamsConfig;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generate;\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generatePerpetually;\n+\n+public class StreamsSmokeTest {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAyNg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553026", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:20:57Z", "path": "streams/upgrade-system-tests-23/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.KafkaThread;\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Grouped;\n+import org.apache.kafka.streams.kstream.KGroupedStream;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Produced;\n+import org.apache.kafka.streams.kstream.Suppressed.BufferConfig;\n+import org.apache.kafka.streams.kstream.TimeWindows;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.streams.state.WindowStore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n+\n+public class SmokeTestClient extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAzNg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553036", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:06Z", "path": "streams/upgrade-system-tests-23/src/test/java/org/apache/kafka/streams/tests/SmokeTestDriver.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.KafkaConsumer;\n+import org.apache.kafka.clients.producer.Callback;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.errors.TimeoutException;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.utils.Exit;\n+import org.apache.kafka.common.utils.Utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+\n+public class SmokeTestDriver extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzA0Mw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553043", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:15Z", "path": "streams/upgrade-system-tests-23/src/test/java/org/apache/kafka/streams/tests/SmokeTestUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.KeyValueMapper;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.ProcessorSupplier;\n+\n+import java.time.Instant;\n+\n+public class SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzA1OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553059", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:21Z", "path": "streams/upgrade-system-tests-23/src/test/java/org/apache/kafka/streams/tests/StreamsSmokeTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.StreamsConfig;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generate;\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generatePerpetually;\n+\n+public class StreamsSmokeTest {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzA3MA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553070", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:26Z", "path": "streams/upgrade-system-tests-24/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.KafkaThread;\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Grouped;\n+import org.apache.kafka.streams.kstream.KGroupedStream;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Produced;\n+import org.apache.kafka.streams.kstream.Suppressed.BufferConfig;\n+import org.apache.kafka.streams.kstream.TimeWindows;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.streams.state.WindowStore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n+\n+public class SmokeTestClient extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzA4NA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553084", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:35Z", "path": "streams/upgrade-system-tests-24/src/test/java/org/apache/kafka/streams/tests/SmokeTestDriver.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.KafkaConsumer;\n+import org.apache.kafka.clients.producer.Callback;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.errors.TimeoutException;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.utils.Exit;\n+import org.apache.kafka.common.utils.Utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+\n+public class SmokeTestDriver extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzA5MA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553090", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:41Z", "path": "streams/upgrade-system-tests-24/src/test/java/org/apache/kafka/streams/tests/SmokeTestUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.KeyValueMapper;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.ProcessorSupplier;\n+\n+import java.time.Instant;\n+\n+public class SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzEwNg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553106", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:46Z", "path": "streams/upgrade-system-tests-24/src/test/java/org/apache/kafka/streams/tests/StreamsSmokeTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.StreamsConfig;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generate;\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generatePerpetually;\n+\n+public class StreamsSmokeTest {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzExOQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553119", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:21:52Z", "path": "streams/upgrade-system-tests-25/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.KafkaThread;\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Grouped;\n+import org.apache.kafka.streams.kstream.KGroupedStream;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Produced;\n+import org.apache.kafka.streams.kstream.Suppressed.BufferConfig;\n+import org.apache.kafka.streams.kstream.TimeWindows;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.streams.state.WindowStore;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n+\n+public class SmokeTestClient extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzEyNQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553125", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:22:00Z", "path": "streams/upgrade-system-tests-25/src/test/java/org/apache/kafka/streams/tests/SmokeTestDriver.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.KafkaConsumer;\n+import org.apache.kafka.clients.producer.Callback;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.errors.TimeoutException;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.utils.Exit;\n+import org.apache.kafka.common.utils.Utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyMap;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+\n+public class SmokeTestDriver extends SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzEzMA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553130", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:22:06Z", "path": "streams/upgrade-system-tests-25/src/test/java/org/apache/kafka/streams/tests/SmokeTestUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.KeyValueMapper;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.ProcessorSupplier;\n+\n+import java.time.Instant;\n+\n+public class SmokeTestUtil {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzEzNQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553135", "bodyText": "copy/pasted", "author": "vvcephei", "createdAt": "2020-06-27T18:22:12Z", "path": "streams/upgrade-system-tests-25/src/test/java/org/apache/kafka/streams/tests/StreamsSmokeTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.tests;\n+\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.StreamsConfig;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generate;\n+import static org.apache.kafka.streams.tests.SmokeTestDriver.generatePerpetually;\n+\n+public class StreamsSmokeTest {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzE3Nw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553177", "bodyText": "Added the ability to set this, so that we can just run one broker from the upgrade tests.", "author": "vvcephei", "createdAt": "2020-06-27T18:22:36Z", "path": "tests/kafkatest/services/streams.py", "diffHunk": "@@ -305,23 +305,62 @@ def start_node(self, node):\n class StreamsSmokeTestBaseService(StreamsTestBaseService):\n     \"\"\"Base class for Streams Smoke Test services providing some common settings and functionality\"\"\"\n \n-    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3):\n+    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3, replication_factor = 3):", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzE5OQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553199", "bodyText": "some other stuff for the upgrade tests.", "author": "vvcephei", "createdAt": "2020-06-27T18:22:51Z", "path": "tests/kafkatest/services/streams.py", "diffHunk": "@@ -305,23 +305,62 @@ def start_node(self, node):\n class StreamsSmokeTestBaseService(StreamsTestBaseService):\n     \"\"\"Base class for Streams Smoke Test services providing some common settings and functionality\"\"\"\n \n-    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3):\n+    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3, replication_factor = 3):\n         super(StreamsSmokeTestBaseService, self).__init__(test_context,\n                                                           kafka,\n                                                           \"org.apache.kafka.streams.tests.StreamsSmokeTest\",\n                                                           command)\n         self.NUM_THREADS = num_threads\n         self.PROCESSING_GUARANTEE = processing_guarantee\n+        self.KAFKA_STREAMS_VERSION = \"\"\n+        self.UPGRADE_FROM = None\n+        self.REPLICATION_FACTOR = replication_factor\n+\n+    def set_version(self, kafka_streams_version):\n+        self.KAFKA_STREAMS_VERSION = kafka_streams_version\n+\n+    def set_upgrade_from(self, upgrade_from):\n+        self.UPGRADE_FROM = upgrade_from", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzIxOA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553218", "bodyText": "moved from Java", "author": "vvcephei", "createdAt": "2020-06-27T18:23:06Z", "path": "tests/kafkatest/services/streams.py", "diffHunk": "@@ -305,23 +305,62 @@ def start_node(self, node):\n class StreamsSmokeTestBaseService(StreamsTestBaseService):\n     \"\"\"Base class for Streams Smoke Test services providing some common settings and functionality\"\"\"\n \n-    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3):\n+    def __init__(self, test_context, kafka, command, processing_guarantee = 'at_least_once', num_threads = 3, replication_factor = 3):\n         super(StreamsSmokeTestBaseService, self).__init__(test_context,\n                                                           kafka,\n                                                           \"org.apache.kafka.streams.tests.StreamsSmokeTest\",\n                                                           command)\n         self.NUM_THREADS = num_threads\n         self.PROCESSING_GUARANTEE = processing_guarantee\n+        self.KAFKA_STREAMS_VERSION = \"\"\n+        self.UPGRADE_FROM = None\n+        self.REPLICATION_FACTOR = replication_factor\n+\n+    def set_version(self, kafka_streams_version):\n+        self.KAFKA_STREAMS_VERSION = kafka_streams_version\n+\n+    def set_upgrade_from(self, upgrade_from):\n+        self.UPGRADE_FROM = upgrade_from\n \n     def prop_file(self):\n         properties = {streams_property.STATE_DIR: self.PERSISTENT_ROOT,\n                       streams_property.KAFKA_SERVERS: self.kafka.bootstrap_servers(),\n                       streams_property.PROCESSING_GUARANTEE: self.PROCESSING_GUARANTEE,\n-                      streams_property.NUM_THREADS: self.NUM_THREADS}\n+                      streams_property.NUM_THREADS: self.NUM_THREADS,\n+                      \"replication.factor\": self.REPLICATION_FACTOR,\n+                      \"num.standby.replicas\": 2,\n+                      \"buffered.records.per.partition\": 100,\n+                      \"commit.interval.ms\": 1000,\n+                      \"auto.offset.reset\": \"earliest\",\n+                      \"acks\": \"all\"}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzI5Nw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553297", "bodyText": "Unfortunately, 2.1 doesn't work. See https://issues.apache.org/jira/browse/KAFKA-10203", "author": "vvcephei", "createdAt": "2020-06-27T18:24:03Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -37,6 +37,9 @@\n # can be replaced with metadata_2_versions\n backward_compatible_metadata_2_versions = [str(LATEST_0_10_2), str(LATEST_0_11_0), str(LATEST_1_0), str(LATEST_1_1)]\n metadata_3_or_higher_versions = [str(LATEST_2_0), str(LATEST_2_1), str(LATEST_2_2), str(LATEST_2_3), str(LATEST_2_4), str(LATEST_2_5), str(DEV_VERSION)]\n+smoke_test_versions = [str(LATEST_2_2), str(LATEST_2_3), str(LATEST_2_4), str(LATEST_2_5)]", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzMzNA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553334", "bodyText": "Changed the name to reflect that we're just testing upgrades now.", "author": "vvcephei", "createdAt": "2020-06-27T18:24:44Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -189,8 +192,8 @@ def test_upgrade_downgrade_brokers(self, from_version, to_version):\n         processor.stop()\n         processor.node.account.ssh_capture(\"grep SMOKE-TEST-CLIENT-CLOSED %s\" % processor.STDOUT_FILE, allow_fail=False)\n \n-    @matrix(from_version=metadata_2_versions, to_version=metadata_2_versions)\n-    def test_simple_upgrade_downgrade(self, from_version, to_version):\n+    @matrix(from_version=smoke_test_versions, to_version=dev_version)\n+    def test_app_upgrade(self, from_version, to_version):", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzM4Mg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553382", "bodyText": "required setup for the smoke test app", "author": "vvcephei", "createdAt": "2020-06-27T18:25:01Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -201,14 +204,29 @@ def test_simple_upgrade_downgrade(self, from_version, to_version):\n         self.zk = ZookeeperService(self.test_context, num_nodes=1)\n         self.zk.start()\n \n-        self.kafka = KafkaService(self.test_context, num_nodes=1, zk=self.zk, topics=self.topics)\n+        self.kafka = KafkaService(self.test_context, num_nodes=1, zk=self.zk, topics={\n+            'echo' : { 'partitions': 5, 'replication-factor': 1 },\n+            'data' : { 'partitions': 5, 'replication-factor': 1 },\n+            'min' : { 'partitions': 5, 'replication-factor': 1 },\n+            'min-suppressed' : { 'partitions': 5, 'replication-factor': 1 },\n+            'min-raw' : { 'partitions': 5, 'replication-factor': 1 },\n+            'max' : { 'partitions': 5, 'replication-factor': 1 },\n+            'sum' : { 'partitions': 5, 'replication-factor': 1 },\n+            'sws-raw' : { 'partitions': 5, 'replication-factor': 1 },\n+            'sws-suppressed' : { 'partitions': 5, 'replication-factor': 1 },\n+            'dif' : { 'partitions': 5, 'replication-factor': 1 },\n+            'cnt' : { 'partitions': 5, 'replication-factor': 1 },\n+            'avg' : { 'partitions': 5, 'replication-factor': 1 },\n+            'wcnt' : { 'partitions': 5, 'replication-factor': 1 },\n+            'tagg' : { 'partitions': 5, 'replication-factor': 1 }\n+        })", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzUyMA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553520", "bodyText": "I changed the \"first time startup\" method to just start all the instances at the same time, rather than waiting for them to start up and process one at a time.\nFor the upgrade part of the test, we still do rolling upgrades.", "author": "vvcephei", "createdAt": "2020-06-27T18:26:20Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -349,56 +370,42 @@ def get_version_string(self, version):\n     def start_all_nodes_with(self, version):\n         kafka_version_str = self.get_version_string(version)\n \n-        # start first with <version>\n         self.prepare_for(self.processor1, version)\n-        node1 = self.processor1.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as monitor:\n-            with node1.account.monitor_log(self.processor1.LOG_FILE) as log_monitor:\n-                self.processor1.start()\n-                log_monitor.wait_until(kafka_version_str,\n-                                       timeout_sec=60,\n-                                       err_msg=\"Could not detect Kafka Streams version \" + version + \" \" + str(node1.account))\n-                monitor.wait_until(self.processed_msg,\n-                                   timeout_sec=60,\n-                                   err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-\n-        # start second with <version>\n         self.prepare_for(self.processor2, version)\n-        node2 = self.processor2.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node2.account.monitor_log(self.processor2.LOG_FILE) as log_monitor:\n-                    self.processor2.start()\n-                    log_monitor.wait_until(kafka_version_str,\n-                                           timeout_sec=60,\n-                                           err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node2.account))\n-                    first_monitor.wait_until(self.processed_msg,\n-                                             timeout_sec=60,\n-                                             err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                    second_monitor.wait_until(self.processed_msg,\n-                                              timeout_sec=60,\n-                                              err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-\n-        # start third with <version>\n         self.prepare_for(self.processor3, version)\n-        node3 = self.processor3.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node3.account.monitor_log(self.processor3.STDOUT_FILE) as third_monitor:\n-                    with node3.account.monitor_log(self.processor3.LOG_FILE) as log_monitor:\n-                        self.processor3.start()\n-                        log_monitor.wait_until(kafka_version_str,\n-                                               timeout_sec=60,\n-                                               err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node3.account))\n-                        first_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                        second_monitor.wait_until(self.processed_msg,\n-                                                  timeout_sec=60,\n-                                                  err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-                        third_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node3.account))\n+\n+        self.processor1.start()\n+        self.processor2.start()\n+        self.processor3.start()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzU3MQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553571", "bodyText": "Here's where we use that new output line after synchronously waiting to join the group in start()", "author": "vvcephei", "createdAt": "2020-06-27T18:27:02Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -349,56 +370,42 @@ def get_version_string(self, version):\n     def start_all_nodes_with(self, version):\n         kafka_version_str = self.get_version_string(version)\n \n-        # start first with <version>\n         self.prepare_for(self.processor1, version)\n-        node1 = self.processor1.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as monitor:\n-            with node1.account.monitor_log(self.processor1.LOG_FILE) as log_monitor:\n-                self.processor1.start()\n-                log_monitor.wait_until(kafka_version_str,\n-                                       timeout_sec=60,\n-                                       err_msg=\"Could not detect Kafka Streams version \" + version + \" \" + str(node1.account))\n-                monitor.wait_until(self.processed_msg,\n-                                   timeout_sec=60,\n-                                   err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-\n-        # start second with <version>\n         self.prepare_for(self.processor2, version)\n-        node2 = self.processor2.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node2.account.monitor_log(self.processor2.LOG_FILE) as log_monitor:\n-                    self.processor2.start()\n-                    log_monitor.wait_until(kafka_version_str,\n-                                           timeout_sec=60,\n-                                           err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node2.account))\n-                    first_monitor.wait_until(self.processed_msg,\n-                                             timeout_sec=60,\n-                                             err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                    second_monitor.wait_until(self.processed_msg,\n-                                              timeout_sec=60,\n-                                              err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-\n-        # start third with <version>\n         self.prepare_for(self.processor3, version)\n-        node3 = self.processor3.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node3.account.monitor_log(self.processor3.STDOUT_FILE) as third_monitor:\n-                    with node3.account.monitor_log(self.processor3.LOG_FILE) as log_monitor:\n-                        self.processor3.start()\n-                        log_monitor.wait_until(kafka_version_str,\n-                                               timeout_sec=60,\n-                                               err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node3.account))\n-                        first_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                        second_monitor.wait_until(self.processed_msg,\n-                                                  timeout_sec=60,\n-                                                  err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-                        third_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node3.account))\n+\n+        self.processor1.start()\n+        self.processor2.start()\n+        self.processor3.start()\n+\n+        # double-check the version\n+        self.wait_for_verification(self.processor1, kafka_version_str, self.processor1.LOG_FILE)\n+        self.wait_for_verification(self.processor2, kafka_version_str, self.processor2.LOG_FILE)\n+        self.wait_for_verification(self.processor3, kafka_version_str, self.processor3.LOG_FILE)\n+\n+        # wait for the members to join", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzYxNA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553614", "bodyText": "Copied this over here so that we don't have to mess with monitors if we just want to search from the beginning of the files.", "author": "vvcephei", "createdAt": "2020-06-27T18:27:38Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -349,56 +370,42 @@ def get_version_string(self, version):\n     def start_all_nodes_with(self, version):\n         kafka_version_str = self.get_version_string(version)\n \n-        # start first with <version>\n         self.prepare_for(self.processor1, version)\n-        node1 = self.processor1.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as monitor:\n-            with node1.account.monitor_log(self.processor1.LOG_FILE) as log_monitor:\n-                self.processor1.start()\n-                log_monitor.wait_until(kafka_version_str,\n-                                       timeout_sec=60,\n-                                       err_msg=\"Could not detect Kafka Streams version \" + version + \" \" + str(node1.account))\n-                monitor.wait_until(self.processed_msg,\n-                                   timeout_sec=60,\n-                                   err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-\n-        # start second with <version>\n         self.prepare_for(self.processor2, version)\n-        node2 = self.processor2.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node2.account.monitor_log(self.processor2.LOG_FILE) as log_monitor:\n-                    self.processor2.start()\n-                    log_monitor.wait_until(kafka_version_str,\n-                                           timeout_sec=60,\n-                                           err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node2.account))\n-                    first_monitor.wait_until(self.processed_msg,\n-                                             timeout_sec=60,\n-                                             err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                    second_monitor.wait_until(self.processed_msg,\n-                                              timeout_sec=60,\n-                                              err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-\n-        # start third with <version>\n         self.prepare_for(self.processor3, version)\n-        node3 = self.processor3.node\n-        with node1.account.monitor_log(self.processor1.STDOUT_FILE) as first_monitor:\n-            with node2.account.monitor_log(self.processor2.STDOUT_FILE) as second_monitor:\n-                with node3.account.monitor_log(self.processor3.STDOUT_FILE) as third_monitor:\n-                    with node3.account.monitor_log(self.processor3.LOG_FILE) as log_monitor:\n-                        self.processor3.start()\n-                        log_monitor.wait_until(kafka_version_str,\n-                                               timeout_sec=60,\n-                                               err_msg=\"Could not detect Kafka Streams version \" + version + \" on \" + str(node3.account))\n-                        first_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node1.account))\n-                        second_monitor.wait_until(self.processed_msg,\n-                                                  timeout_sec=60,\n-                                                  err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node2.account))\n-                        third_monitor.wait_until(self.processed_msg,\n-                                                 timeout_sec=60,\n-                                                 err_msg=\"Never saw output '%s' on \" % self.processed_msg + str(node3.account))\n+\n+        self.processor1.start()\n+        self.processor2.start()\n+        self.processor3.start()\n+\n+        # double-check the version\n+        self.wait_for_verification(self.processor1, kafka_version_str, self.processor1.LOG_FILE)\n+        self.wait_for_verification(self.processor2, kafka_version_str, self.processor2.LOG_FILE)\n+        self.wait_for_verification(self.processor3, kafka_version_str, self.processor3.LOG_FILE)\n+\n+        # wait for the members to join\n+        self.wait_for_verification(self.processor1, \"SMOKE-TEST-CLIENT-STARTED\", self.processor1.STDOUT_FILE)\n+        self.wait_for_verification(self.processor2, \"SMOKE-TEST-CLIENT-STARTED\", self.processor2.STDOUT_FILE)\n+        self.wait_for_verification(self.processor3, \"SMOKE-TEST-CLIENT-STARTED\", self.processor3.STDOUT_FILE)\n+\n+        # make sure they've processed something\n+        self.wait_for_verification(self.processor1, self.processed_msg, self.processor1.STDOUT_FILE)\n+        self.wait_for_verification(self.processor2, self.processed_msg, self.processor2.STDOUT_FILE)\n+        self.wait_for_verification(self.processor3, self.processed_msg, self.processor3.STDOUT_FILE)\n+\n+    def wait_for_verification(self, processor, message, file, num_lines=1):\n+        wait_until(lambda: self.verify_from_file(processor, message, file) >= num_lines,\n+                   timeout_sec=60,\n+                   err_msg=\"Did expect to read '%s' from %s\" % (message, processor.node.account))\n+\n+    @staticmethod\n+    def verify_from_file(processor, message, file):", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzY2NA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553664", "bodyText": "no longer needed, since start() is now blocking", "author": "vvcephei", "createdAt": "2020-06-27T18:28:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzgwMg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r446553802", "bodyText": "This thread was actually pointless, since StreamThreads are already user (not daemon) threads.", "author": "vvcephei", "createdAt": "2020-06-27T18:29:50Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2d0b95650f597bf52d49a05f7d3fed8cc03080a", "url": "https://github.com/apache/kafka/commit/e2d0b95650f597bf52d49a05f7d3fed8cc03080a", "message": "KAFKA-10173: Use SmokeTest for upgrade system tests\n\nReplaces the previous upgrade test's trivial Streams app\nwith the commonly used SmokeTest, exercising many more\nfeatures. Also adjust the test matrix to test upgrading\nfrom each released version since 2.2 to the current branch.", "committedDate": "2020-07-01T14:33:29Z", "type": "commit"}, {"oid": "be475ec5ed5aa7b439713717d502f71ee643fc5e", "url": "https://github.com/apache/kafka/commit/be475ec5ed5aa7b439713717d502f71ee643fc5e", "message": "move new test to new file", "committedDate": "2020-07-01T15:01:05Z", "type": "commit"}, {"oid": "b6b296163adcd47a79ead6af55b7b7e1972c06fc", "url": "https://github.com/apache/kafka/commit/b6b296163adcd47a79ead6af55b7b7e1972c06fc", "message": "revamp upgrade test", "committedDate": "2020-07-01T16:07:12Z", "type": "commit"}, {"oid": "131f98db8faddf7342eda3e07fa612daba534fe3", "url": "https://github.com/apache/kafka/commit/131f98db8faddf7342eda3e07fa612daba534fe3", "message": "disable rolling upgrade test until compatible release 2.5.1 is done", "committedDate": "2020-07-01T16:08:56Z", "type": "commit"}, {"oid": "b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "url": "https://github.com/apache/kafka/commit/b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "message": "fix log copy; shouldn't clean state during upgrade", "committedDate": "2020-07-01T17:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTAzMw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448531033", "bodyText": "Rotating the config file as well as the logs gives us better visibility for debugging.", "author": "vvcephei", "createdAt": "2020-07-01T18:03:16Z", "path": "tests/kafkatest/services/streams.py", "diffHunk": "@@ -48,6 +48,15 @@ class StreamsTestBaseService(KafkaPathResolverMixin, JmxMixin, Service):\n         \"streams_config\": {\n             \"path\": CONFIG_FILE,\n             \"collect_default\": True},\n+        \"streams_config.1\": {\n+            \"path\": CONFIG_FILE + \".1\",\n+            \"collect_default\": True},\n+        \"streams_config.0-1\": {\n+            \"path\": CONFIG_FILE + \".0-1\",\n+            \"collect_default\": True},\n+        \"streams_config.1-1\": {\n+            \"path\": CONFIG_FILE + \".1-1\",\n+            \"collect_default\": True},", "originalCommit": "b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MzgwOA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448573808", "bodyText": "Why only .1 / 0-1/ 1-1? There are more rotated log files below?", "author": "guozhangwang", "createdAt": "2020-07-01T19:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4MzMwNg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448583306", "bodyText": "Yep, but those are for other tests. The upgrade tests only roll one time. I wanted to try and avoid touching any other tests in this PR, so I only implemented config file rotation for the new test.", "author": "vvcephei", "createdAt": "2020-07-01T19:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTQ4OA==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448531488", "bodyText": "Moved this case to the new test file, streams_application_upgrade_test.py to avoid messing too much with the other tests here.", "author": "vvcephei", "createdAt": "2020-07-01T18:04:16Z", "path": "tests/kafkatest/tests/streams/streams_upgrade_test.py", "diffHunk": "@@ -189,54 +189,6 @@ def test_upgrade_downgrade_brokers(self, from_version, to_version):\n         processor.stop()\n         processor.node.account.ssh_capture(\"grep SMOKE-TEST-CLIENT-CLOSED %s\" % processor.STDOUT_FILE, allow_fail=False)\n \n-    @matrix(from_version=metadata_2_versions, to_version=metadata_2_versions)\n-    def test_simple_upgrade_downgrade(self, from_version, to_version):", "originalCommit": "b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3NTQyOQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448575429", "bodyText": "Should we merge the test_metadata_upgrade below to the new file? I think with the new principle it is less meaningful to test the upgrade path from an old v1 to another old v2, since, the test of v2 should already cover that.", "author": "guozhangwang", "createdAt": "2020-07-01T19:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NDc2Mg==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448584762", "bodyText": "Aha! For that, I've been preparing a separate PR: #8971", "author": "vvcephei", "createdAt": "2020-07-01T19:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448534345", "bodyText": "During a rolling bounce, we might see an old node try to read the changelog records of a new node, which would fail. All you have to do to recover is to continue upgrading, but we can't tolerate the failure in this system test. This is the exact same failure that we would see if we tried to downgrade.\nTo repair the non-downgradability of Streams (and hence allow rolling bounces to work without errors), we need to go back and release forward-compatible versions of older releases. For example, 2.5.1 and 2.4.2 would be such versions. I'll create a ticket to come back here and add the missing matrix coordinates once those versions are released. Additionally, when new versions are released, we should add them to the downgrade matrix and the rolling-bounce matrix to prevent this situation from arising again.", "author": "vvcephei", "createdAt": "2020-07-01T18:10:02Z", "path": "tests/kafkatest/tests/streams/streams_application_upgrade_test.py", "diffHunk": "@@ -0,0 +1,297 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import random\n+from ducktape.mark import matrix\n+from ducktape.tests.test import Test\n+from ducktape.utils.util import wait_until\n+from kafkatest.services.kafka import KafkaService\n+from kafkatest.services.streams import StreamsSmokeTestDriverService, StreamsSmokeTestJobRunnerService\n+from kafkatest.services.zookeeper import ZookeeperService\n+from kafkatest.version import LATEST_2_2, LATEST_2_3, LATEST_2_4, LATEST_2_5, DEV_VERSION, KafkaVersion\n+\n+smoke_test_versions = [str(LATEST_2_2), str(LATEST_2_3), str(LATEST_2_4), str(LATEST_2_5)]\n+dev_version = [str(DEV_VERSION)]\n+\n+class StreamsUpgradeTest(Test):\n+    \"\"\"\n+    Test upgrading Kafka Streams (all version combination)\n+    If metadata was changes, upgrade is more difficult\n+    Metadata version was bumped in 0.10.1.0 and\n+    subsequently bumped in 2.0.0\n+    \"\"\"\n+\n+    def __init__(self, test_context):\n+        super(StreamsUpgradeTest, self).__init__(test_context)\n+        self.topics = {\n+            'echo' : { 'partitions': 5 },\n+            'data' : { 'partitions': 5 },\n+        }\n+\n+    processed_msg = \"processed [0-9]* records\"\n+    base_version_number = str(DEV_VERSION).split(\"-\")[0]\n+\n+    def perform_broker_upgrade(self, to_version):\n+        self.logger.info(\"First pass bounce - rolling broker upgrade\")\n+        for node in self.kafka.nodes:\n+            self.kafka.stop_node(node)\n+            node.version = KafkaVersion(to_version)\n+            self.kafka.start_node(node)\n+\n+    @matrix(from_version=smoke_test_versions, to_version=dev_version, bounce_type=[\"full\"])", "originalCommit": "b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3NDUwMw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448574503", "bodyText": "All you have to do to recover is to continue upgrading, but we can't tolerate the failure in this system test.  how this is handled now?", "author": "guozhangwang", "createdAt": "2020-07-01T19:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4Njc5Ng==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448586796", "bodyText": "When you say \"how is this handled\", do you mean in the system tests or in \"real life\"?\nI'm handling it in the system tests by not doing rolling bounces at all. If we do them, we'll see the test fail nondeterministically, when it just so happens that an old-version node tries to read a new-version record. Once we release 2.6.0, we'll be able to add a downgrade test from trunk to 2.6.0, and once we release 2.5.1, we can add a downgrade test from trunk to 2.5.1, and also one in the 2.6 branch from 2.6.x to 2.5.1.\nIn real life, you would see some of the old-versioned threads get exceptions and crash. But it wouldn't be a huge deal, since you can just continue with the rolling bounce until there are no more old-versioned instances, at which point everything is fine. There would be no data corruption or anything.", "author": "vvcephei", "createdAt": "2020-07-01T20:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzUwNw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448653507", "bodyText": "I was asking about in system tests :) More specifically I'm wondering if we could separate the upgrade path which are \"rolling bouncible\" from others that are not, e.g. as two separate tests in our python code base. And this can also be used as a cross-reference for our upgrade docs.\nAnyways, sine for trunk / 2.7 we would only be rolling bouncible from 2.6 and not from others this is not a big point. We can leave it to another follow-up PR.", "author": "guozhangwang", "createdAt": "2020-07-01T22:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwNDA0Mw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448704043", "bodyText": "Ah, thanks for the clarification. Yes, I was thinking we would just add new matrices for both rolling-bounceable and downgradable versions. E.g., after the two pending releases, we'd also have:\n@matrix(from=[2.5.1, 2.6.0], to=[DEV_VERSION], bounce_type=[full, rolling])\n@matrix(from=[DEV_VERSION], to=[2.5.1, 2.6.0], bounce_type=[full, rolling])\n\n(just for illustrative purposes, we'd probably declare a variable to make it maintainable)", "author": "vvcephei", "createdAt": "2020-07-02T01:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4NDE3Mw==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r449684173", "bodyText": "Sounds great, thank you!!", "author": "guozhangwang", "createdAt": "2020-07-03T19:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MDc2MQ==", "url": "https://github.com/apache/kafka/pull/8938#discussion_r448570761", "bodyText": "Do we still need a shutdown hook to delete with file.deleteOnExit();? I think the latter can still be triggered even with abnormal exits.", "author": "guozhangwang", "createdAt": "2020-07-01T19:25:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "diffHunk": "@@ -38,107 +37,128 @@\n import org.apache.kafka.streams.kstream.Windowed;\n import org.apache.kafka.streams.state.Stores;\n import org.apache.kafka.streams.state.WindowStore;\n-import org.apache.kafka.test.TestUtils;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;\n \n public class SmokeTestClient extends SmokeTestUtil {\n \n     private final String name;\n \n-    private Thread thread;\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n-    private boolean started;\n-    private boolean closed;\n+    private volatile boolean closed;\n \n-    public SmokeTestClient(final String name) {\n-        super();\n-        this.name = name;\n+    private static void addShutdownHook(final String name, final Runnable runnable) {\n+        if (name != null) {\n+            Runtime.getRuntime().addShutdownHook(KafkaThread.nonDaemon(name, runnable));\n+        } else {\n+            Runtime.getRuntime().addShutdownHook(new Thread(runnable));\n+        }\n     }\n \n-    public boolean started() {\n-        return started;\n+    private static File tempDirectory() {\n+        final String prefix = \"kafka-\";\n+        final File file;\n+        try {\n+            file = Files.createTempDirectory(prefix).toFile();\n+        } catch (final IOException ex) {\n+            throw new RuntimeException(\"Failed to create a temp dir\", ex);\n+        }\n+        file.deleteOnExit();", "originalCommit": "b1a54f0701be5304fc31ddffa6b1404f1aff9beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0163c8023d3b9fc61df35c0428269ca2752e9e6f", "url": "https://github.com/apache/kafka/commit/0163c8023d3b9fc61df35c0428269ca2752e9e6f", "message": "Update streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java", "committedDate": "2020-07-01T19:49:47Z", "type": "commit"}]}