{"pr_number": 8696, "pr_title": "KAFKA-6145: KIP-441: Enforce Standby Task Stickiness", "pr_createdAt": "2020-05-19T21:27:00Z", "pr_url": "https://github.com/apache/kafka/pull/8696", "timeline": [{"oid": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "url": "https://github.com/apache/kafka/commit/d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "message": "KAFKA-6145: KIP-441: Enforce Standby Task Stickiness\n\nWe should treat standbys similarly to active stateful tasks and\nre-assign them to instances that are already caught-up on them\nwhile we warm them up on the desired destination, instead of\nimmediately moving them to the destination.", "committedDate": "2020-05-19T21:23:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDc4Mg==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427610782", "bodyText": "Moved the counter out here because we need to decrement it while assigning both active and standby warmups", "author": "vvcephei", "createdAt": "2020-05-19T21:28:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -57,14 +59,42 @@ public boolean assign(final Map<UUID, ClientState> clients,\n             configs.numStandbyReplicas\n         );\n \n-        final boolean probingRebalanceNeeded = assignTaskMovements(\n-            tasksToCaughtUpClients(statefulTasks, clientStates, configs.acceptableRecoveryLag),\n+        final AtomicInteger remainingWarmupReplicas = new AtomicInteger(configs.maxWarmupReplicas);", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTQ5OA==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427611498", "bodyText": "The mechanism by which we enforce \"stickiness\" is by assigning movements after computing the ideal assignment, so if we want standbys as well as actives to be sticky, we need to assign movements for those as well.", "author": "vvcephei", "createdAt": "2020-05-19T21:29:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -57,14 +59,42 @@ public boolean assign(final Map<UUID, ClientState> clients,\n             configs.numStandbyReplicas\n         );\n \n-        final boolean probingRebalanceNeeded = assignTaskMovements(\n-            tasksToCaughtUpClients(statefulTasks, clientStates, configs.acceptableRecoveryLag),\n+        final AtomicInteger remainingWarmupReplicas = new AtomicInteger(configs.maxWarmupReplicas);\n+\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = tasksToCaughtUpClients(\n+            statefulTasks,\n+            clientStates,\n+            configs.acceptableRecoveryLag\n+        );\n+\n+        // We temporarily need to know which standby tasks were intended as warmups\n+        // for active tasks, so that we don't move them (again) when we plan standby\n+        // task movements. We can then immediately treat warmups exactly the same as\n+        // hot-standby replicas, so we just track it right here as metadata, rather\n+        // than add \"warmup\" assignments to ClientState, for example.\n+        final Map<UUID, Set<TaskId>> warmups = new TreeMap<>();\n+\n+        final int neededActiveTaskMovements = assignActiveTaskMovements(\n+            tasksToCaughtUpClients,\n             clientStates,\n-            configs.maxWarmupReplicas\n+            warmups,\n+            remainingWarmupReplicas\n+        );\n+\n+        final int neededStandbyTaskMovements = assignStandbyTaskMovements(\n+            tasksToCaughtUpClients,\n+            clientStates,\n+            remainingWarmupReplicas,\n+            warmups", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMjg4OA==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427612888", "bodyText": "One might wonder whether we should even allow \"max_warmups := 0\". I think this is actually ok, as someone might want to completely disable this state shuffling mechanism and instead just be 100% sticky. Also factoring into my thinking is that it's pretty obvious what will happen if you configure \"no warmups\", so I don't think it's going to hurt someone who didn't actually want to completely disable the warmup mechanism.", "author": "vvcephei", "createdAt": "2020-05-19T21:32:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -57,14 +59,42 @@ public boolean assign(final Map<UUID, ClientState> clients,\n             configs.numStandbyReplicas\n         );\n \n-        final boolean probingRebalanceNeeded = assignTaskMovements(\n-            tasksToCaughtUpClients(statefulTasks, clientStates, configs.acceptableRecoveryLag),\n+        final AtomicInteger remainingWarmupReplicas = new AtomicInteger(configs.maxWarmupReplicas);\n+\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = tasksToCaughtUpClients(\n+            statefulTasks,\n+            clientStates,\n+            configs.acceptableRecoveryLag\n+        );\n+\n+        // We temporarily need to know which standby tasks were intended as warmups\n+        // for active tasks, so that we don't move them (again) when we plan standby\n+        // task movements. We can then immediately treat warmups exactly the same as\n+        // hot-standby replicas, so we just track it right here as metadata, rather\n+        // than add \"warmup\" assignments to ClientState, for example.\n+        final Map<UUID, Set<TaskId>> warmups = new TreeMap<>();\n+\n+        final int neededActiveTaskMovements = assignActiveTaskMovements(\n+            tasksToCaughtUpClients,\n             clientStates,\n-            configs.maxWarmupReplicas\n+            warmups,\n+            remainingWarmupReplicas\n+        );\n+\n+        final int neededStandbyTaskMovements = assignStandbyTaskMovements(\n+            tasksToCaughtUpClients,\n+            clientStates,\n+            remainingWarmupReplicas,\n+            warmups\n         );\n \n         assignStatelessActiveTasks(clientStates, diff(TreeSet::new, allTaskIds, statefulTasks));\n \n+        // We shouldn't plan a probing rebalance if we _needed_ task movements, but couldn't do any\n+        // due to being configured for no warmups.", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMjk4Mw==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r429202983", "bodyText": "To be clear, according to StreamsConfig, we do NOT allow max.warmup.replicas = 0. It must at least be 1.  Or was your statement hypothetical, that it would be OK to allow it? Anyway, I am in favour of keeping the > 0 check here.", "author": "cadonna", "createdAt": "2020-05-22T11:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NjA4NQ==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r429346085", "bodyText": "Yeah, I've just realized this, too. And upon second consideration, I don't think the warmup=0 really provides a good mechanism for what I was thinking of. I think we'd better leave it as \"at least one\". Thanks!", "author": "vvcephei", "createdAt": "2020-05-22T16:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMjg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMzU2OQ==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427613569", "bodyText": "I changed this to return an int just because it made stepping through the assignment in the debugger a bit easier to understand. It serves no algorithmic purpose.", "author": "vvcephei", "createdAt": "2020-05-19T21:34:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -64,12 +66,10 @@ private static boolean taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(final Task\n         return caughtUpClients == null || caughtUpClients.contains(client);\n     }\n \n-    /**\n-     * @return whether any warmup replicas were assigned\n-     */\n-    static boolean assignTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                       final Map<UUID, ClientState> clientStates,\n-                                       final int maxWarmupReplicas) {\n+    static int assignActiveTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNDIwOA==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427614208", "bodyText": "This algorithm is similar to the active one, but there are also important differences, so I didn't converge them.", "author": "vvcephei", "createdAt": "2020-05-19T21:35:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -132,22 +132,97 @@ static boolean assignTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCau\n         return movementsNeeded;\n     }\n \n+    static int assignStandbyTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNDgxNw==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427614817", "bodyText": "Similar to the other matchers, it just gives us mildly nicer test output.", "author": "vvcephei", "createdAt": "2020-05-19T21:36:47Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/AssignmentTestUtils.java", "diffHunk": "@@ -326,6 +326,10 @@ static TaskSkewReport analyzeTaskAssignmentBalance(final Map<UUID, ClientState>\n         return new TaskSkewReport(maxTaskSkew, skewedSubtopologies, subtopologyToClientsWithPartition);\n     }\n \n+    static Matcher<ClientState> hasAssignedTasks(final int taskCount) {\n+        return hasProperty(\"assignedTasks\", ClientState::assignedTaskCount, taskCount);\n+    }", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNTQxNA==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427615414", "bodyText": "First test for stickiness: we should be 100% sticky and also not schedule a probing rebalance when we are configured for no warmups.", "author": "vvcephei", "createdAt": "2020-05-19T21:37:56Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -78,6 +80,64 @@\n         /*probingRebalanceIntervalMs*/ 60 * 1000L\n     );\n \n+    @Test\n+    public void shouldBeStickyForActiveAndStandbyTasksEvenIfNoWarmups() {", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNTczMA==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427615730", "bodyText": "Main test case for stickiness: we should be sticky for standbys, and also schedule warmups.", "author": "vvcephei", "createdAt": "2020-05-19T21:38:43Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -78,6 +80,64 @@\n         /*probingRebalanceIntervalMs*/ 60 * 1000L\n     );\n \n+    @Test\n+    public void shouldBeStickyForActiveAndStandbyTasksEvenIfNoWarmups() {\n+        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2, TASK_2_0, TASK_2_1, TASK_2_2);\n+        final ClientState clientState1 = new ClientState(allTaskIds, emptySet(), allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L)), 1);\n+        final ClientState clientState2 = new ClientState(emptySet(), allTaskIds, allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 10L)), 1);\n+        final ClientState clientState3 = new ClientState(emptySet(), emptySet(), allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE)), 1);\n+\n+        final Map<UUID, ClientState> clientStates = mkMap(\n+            mkEntry(UUID_1, clientState1),\n+            mkEntry(UUID_2, clientState2),\n+            mkEntry(UUID_3, clientState3)\n+        );\n+\n+        final boolean unstable = new HighAvailabilityTaskAssignor().assign(\n+            clientStates,\n+            allTaskIds,\n+            allTaskIds,\n+            new AssignmentConfigs(11L, 0, 1, 0L)\n+        );\n+\n+        assertThat(clientState1, hasAssignedTasks(allTaskIds.size()));\n+\n+        assertThat(clientState2, hasAssignedTasks(allTaskIds.size()));\n+\n+        assertThat(clientState3, hasAssignedTasks(0));\n+\n+        assertThat(unstable, is(false));\n+    }\n+\n+    @Test\n+    public void shouldBeStickyForActiveAndStandbyTasksWhileWarmingUp() {", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNTkxNQ==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427615915", "bodyText": "Now that we're warming up standbys also, we need to relax the convergence limit.", "author": "vvcephei", "createdAt": "2020-05-19T21:39:08Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignorConvergenceTest.java", "diffHunk": "@@ -338,7 +338,7 @@ private static void runRandomizedScenario(final long seed) {\n                         throw new IllegalStateException(\"Unexpected event: \" + event);\n                 }\n                 if (!harness.clientStates.isEmpty()) {\n-                    testForConvergence(harness, configs, numStatefulTasks * 2);\n+                    testForConvergence(harness, configs, 2 * (numStatefulTasks + numStatefulTasks * numStandbyReplicas));", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjE2OQ==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r427616169", "bodyText": "Just accommodating the new method signature, no semantic changes.", "author": "vvcephei", "createdAt": "2020-05-19T21:39:43Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -65,11 +67,13 @@ public void shouldAssignTasksToClientsAndReturnFalseWhenAllClientsCaughtUp() {\n         final ClientState client3 = getClientStateWithActiveAssignment(asList(TASK_0_2, TASK_1_2));\n \n         assertThat(\n-            assignTaskMovements(\n+            assignActiveTaskMovements(\n                 tasksToCaughtUpClients,\n                 getClientStatesMap(client1, client2, client3),\n-                maxWarmupReplicas),\n-            is(false)\n+                new TreeMap<>(),\n+                new AtomicInteger(maxWarmupReplicas)\n+            ),\n+            is(0)", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NjI0MQ==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r429196241", "bodyText": "prop: Could you add a method taskIsNotCaughtUpOnClientAndCaughtUpClientsExist()? Applying De Morgan's law every time I read this code gives me headache.", "author": "cadonna", "createdAt": "2020-05-22T11:37:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -132,22 +132,97 @@ static boolean assignTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCau\n         return movementsNeeded;\n     }\n \n+    static int assignStandbyTaskMovements(final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                          final Map<UUID, ClientState> clientStates,\n+                                          final AtomicInteger remainingWarmupReplicas,\n+                                          final Map<UUID, Set<TaskId>> warmups) {\n+        final BiFunction<UUID, TaskId, Boolean> caughtUpPredicate =\n+            (client, task) -> taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, client, tasksToCaughtUpClients);\n+\n+        final ConstrainedPrioritySet caughtUpClientsByTaskLoad = new ConstrainedPrioritySet(\n+            caughtUpPredicate,\n+            client -> clientStates.get(client).assignedTaskLoad()\n+        );\n+\n+        final Queue<TaskMovement> taskMovements = new PriorityQueue<>(\n+            Comparator.comparing(TaskMovement::numCaughtUpClients).thenComparing(TaskMovement::task)\n+        );\n+\n+        for (final Map.Entry<UUID, ClientState> clientStateEntry : clientStates.entrySet()) {\n+            final UUID destination = clientStateEntry.getKey();\n+            final ClientState state = clientStateEntry.getValue();\n+            for (final TaskId task : state.standbyTasks()) {\n+                if (warmups.getOrDefault(destination, Collections.emptySet()).contains(task)) {\n+                    // this is a warmup, so we won't move it.\n+                } else if (!taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, destination, tasksToCaughtUpClients)) {", "originalCommit": "d85c12b3089132a8952c8c4cbebaf44e1836fd3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NjQxNw==", "url": "https://github.com/apache/kafka/pull/8696#discussion_r429346417", "bodyText": "Haha, sure :)", "author": "vvcephei", "createdAt": "2020-05-22T16:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NjI0MQ=="}], "type": "inlineReview"}]}