{"pr_number": 9098, "pr_title": "KAFKA-9924: Prepare RocksDB and metrics for RocksDB properties recording", "pr_createdAt": "2020-07-29T11:46:15Z", "pr_url": "https://github.com/apache/kafka/pull/9098", "timeline": [{"oid": "dd647535339a9d0cc6003caa5f297195fd64d615", "url": "https://github.com/apache/kafka/commit/dd647535339a9d0cc6003caa5f297195fd64d615", "message": "Add wrapper around BlockBasedTableConfig to make cache accessible", "committedDate": "2020-07-29T11:34:40Z", "type": "commit"}, {"oid": "634d18b15ff400dced3b1af6b43c98630e115d8d", "url": "https://github.com/apache/kafka/commit/634d18b15ff400dced3b1af6b43c98630e115d8d", "message": "Refactor RocksDBMetricsRecorder and instantiation of RocksDBMetricsRecordingTrigger", "committedDate": "2020-07-29T11:34:40Z", "type": "commit"}, {"oid": "67986c4b3e7c8fa627ec52a10bbdc3138e828b8d", "url": "https://github.com/apache/kafka/commit/67986c4b3e7c8fa627ec52a10bbdc3138e828b8d", "message": "Add unit test when user specifies new table format config", "committedDate": "2020-07-30T08:51:12Z", "type": "commit"}, {"oid": "0afb35d8bba0d76adf9002bd9db14025cd0ca340", "url": "https://github.com/apache/kafka/commit/0afb35d8bba0d76adf9002bd9db14025cd0ca340", "message": "Make RocksDB recording trigger member variable final", "committedDate": "2020-07-30T10:25:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyODM5OA==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r463128398", "bodyText": "Ah, after reading your test, I now see the issue. I'd overlooked the fact that users would independently construct the table config object AND the cache. I see now that this makes it impossible to reliably capture the cache, since users have to actually choose to pass our special table config to the Options and then pass the Cache to that table config.\nThis doesn't seem ideal. What do you think about just using reflection instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (tableFormatConfig instanceof BlockBasedTableConfigWithAccessibleCache) {\n          \n          \n            \n                        final Cache cache = ((BlockBasedTableConfigWithAccessibleCache) tableFormatConfig).blockCache();\n          \n          \n            \n                        metricsRecorder.addValueProviders(name, db, cache, statistics);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        metricsRecorder.addValueProviders(name, db, null, statistics);\n          \n          \n            \n                        log.warn(\"A table format configuration is used that does not expose the block cache. This means \" +\n          \n          \n            \n                            \"that metrics that relate to the block cache may be wrong if the block cache is shared.\");\n          \n          \n            \n                    }\n          \n          \n            \n                    if (tableFormatConfig instanceof BlockBasedTableConfig) {\n          \n          \n            \n                        final BlockBasedTableConfig blockBasedTableConfig = (BlockBasedTableConfig) tableFormatConfig;\n          \n          \n            \n                        try {\n          \n          \n            \n                            final Field blockCacheField = BlockBasedTableConfig.class.getDeclaredField(\"blockCache_\");\n          \n          \n            \n                            blockCacheField.setAccessible(true);\n          \n          \n            \n                            final Cache nullableBlockCache = (Cache) blockCacheField.get(blockBasedTableConfig);\n          \n          \n            \n                            metricsRecorder.addValueProviders(name, db, nullableBlockCache, statistics);\n          \n          \n            \n                        } catch (final NoSuchFieldException | IllegalAccessException | ClassCastException e) {\n          \n          \n            \n                            log.warn(\"Expected to find and access field 'blockCache_' in BlockBasedTableConfig. \" +\n          \n          \n            \n                                         \"Probably, an incompatible version of RocksDB is being used. \" +\n          \n          \n            \n                                         \"Cache will be missing from memory metrics.\", e);\n          \n          \n            \n                            metricsRecorder.addValueProviders(name, db, null, statistics);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        metricsRecorder.addValueProviders(name, db, null, statistics);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nWe would obviously test all the branches here to de-risk the reflection. We can also add a test that searches the classpath for implementations of TableFormatConfig to ensure we don't miss the memo if RocksDB adds a new TableFormatConfig implementation.\nAlternative thought, if you don't like the reflection: We would also subclass Options and override org.rocksdb.Options#setTableFormatConfig to check if the passed TableFormatConfig is a BlockBasedTableConfig, and if so, then we wrap it with BlockBasedTableConfigWithAccessibleCache.", "author": "vvcephei", "createdAt": "2020-07-30T16:39:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBStore.java", "diffHunk": "@@ -181,23 +181,39 @@ void openDB(final ProcessorContext context) {\n             throw new ProcessorStateException(fatal);\n         }\n \n-        // Setup metrics before the database is opened, otherwise the metrics are not updated\n+        // Setup statistics before the database is opened, otherwise the statistics are not updated\n         // with the measurements from Rocks DB\n-        maybeSetUpMetricsRecorder(configs);\n+        maybeSetUpStatistics(configs);\n \n         openRocksDB(dbOptions, columnFamilyOptions);\n         open = true;\n+\n+        addValueProvidersToMetricsRecorder(configs);\n     }\n \n-    private void maybeSetUpMetricsRecorder(final Map<String, Object> configs) {\n-        if (userSpecifiedOptions.statistics() == null &&\n+    private void maybeSetUpStatistics(final Map<String, Object> configs) {\n+        if (userSpecifiedOptions.statistics() != null) {\n+            userSpecifiedStatistics = true;\n+        }\n+        if (!userSpecifiedStatistics &&\n             RecordingLevel.forName((String) configs.get(METRICS_RECORDING_LEVEL_CONFIG)) == RecordingLevel.DEBUG) {\n \n-            isStatisticsRegistered = true;\n             // metrics recorder will clean up statistics object\n             final Statistics statistics = new Statistics();\n             userSpecifiedOptions.setStatistics(statistics);\n-            metricsRecorder.addStatistics(name, statistics);\n+        }\n+    }\n+\n+    private void addValueProvidersToMetricsRecorder(final Map<String, Object> configs) {\n+        final TableFormatConfig tableFormatConfig = userSpecifiedOptions.tableFormatConfig();\n+        final Statistics statistics = userSpecifiedStatistics ? null : userSpecifiedOptions.statistics();\n+        if (tableFormatConfig instanceof BlockBasedTableConfigWithAccessibleCache) {\n+            final Cache cache = ((BlockBasedTableConfigWithAccessibleCache) tableFormatConfig).blockCache();\n+            metricsRecorder.addValueProviders(name, db, cache, statistics);\n+        } else {\n+            metricsRecorder.addValueProviders(name, db, null, statistics);\n+            log.warn(\"A table format configuration is used that does not expose the block cache. This means \" +\n+                \"that metrics that relate to the block cache may be wrong if the block cache is shared.\");\n         }", "originalCommit": "0afb35d8bba0d76adf9002bd9db14025cd0ca340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYxNzg5OQ==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r463617899", "bodyText": "I agree with you that it is not ideal and thank you for this lesson on reflection.\nIndeed, I do not like reflection in this case, because it makes the code too much dependent on RocksDB internals. We should use reflection to check if the public API to configure RocksDB changed in a newer version, but that is another story.\nI do not understand how the alternative of wrapping BlockBasedTableConfig into BlockBasedTableConfigWithAccessibleCache should work. Since the cache is not accessible in BlockBasedTableConfig it will also not be accessible when it is wrapped in BlockBasedTableConfigWithAccessibleCache (despite the name). We need to get the reference to the cache when the cache is set in BlockBasedTableConfig. If the cache is already set we can only use reflection.\nSince the block based table format is the only format in RocksDB that uses the cache, I do not see why a user absolutely needs to pass a new BlockBasedTableConfig object. I think for now it is OK to log a warning, and clearly document that the provided BlockBasedTableConfig object should be used.", "author": "cadonna", "createdAt": "2020-07-31T13:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyODM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzMjU2Ng==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r463132566", "bodyText": "Interesting... Should we add a Time argument to the constructor? It would be a minor amendment to the KIP.", "author": "vvcephei", "createdAt": "2020-07-30T16:46:43Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/processor/MockProcessorContext.java", "diffHunk": "@@ -227,7 +228,8 @@ public MockProcessorContext(final Properties config, final TaskId taskId, final\n         this.metrics = new StreamsMetricsImpl(\n             new Metrics(metricConfig),\n             threadId,\n-            streamsConfig.getString(StreamsConfig.BUILT_IN_METRICS_VERSION_CONFIG)\n+            streamsConfig.getString(StreamsConfig.BUILT_IN_METRICS_VERSION_CONFIG),\n+            Time.SYSTEM", "originalCommit": "0afb35d8bba0d76adf9002bd9db14025cd0ca340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3ODgxNg==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r463578816", "bodyText": "I would prefer to postpone that, because currently it is not strictly needed and the time is only used in the RocksDB recording trigger that records only internal RocksDB metrics. I do not see how exposing time would be useful for users during testing. If anybody complains, we can still do it in a future KIP.", "author": "cadonna", "createdAt": "2020-07-31T12:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzMjU2Ng=="}], "type": "inlineReview"}, {"oid": "4331821d84ecc8873f814cd691e9bb13b7762fe2", "url": "https://github.com/apache/kafka/commit/4331821d84ecc8873f814cd691e9bb13b7762fe2", "message": "Make warning regarding RocksDB's table configuration clearer", "committedDate": "2020-07-31T13:46:51Z", "type": "commit"}, {"oid": "34dac91f6249d809df5b366eaf82596dde3d5b3b", "url": "https://github.com/apache/kafka/commit/34dac91f6249d809df5b366eaf82596dde3d5b3b", "message": "Remove unused parameter", "committedDate": "2020-07-31T13:50:02Z", "type": "commit"}, {"oid": "91b3430b9db78b0cff834d6197f509f65a639dcd", "url": "https://github.com/apache/kafka/commit/91b3430b9db78b0cff834d6197f509f65a639dcd", "message": "Throw exception instead of log a warning", "committedDate": "2020-08-10T20:15:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMzk3NQ==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r468713975", "bodyText": "It seems like we would now be forbidding the use of PlainTableConfig. Is that intentional?", "author": "vvcephei", "createdAt": "2020-08-11T16:34:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBStore.java", "diffHunk": "@@ -204,17 +204,17 @@ private void maybeSetUpStatistics(final Map<String, Object> configs) {\n         }\n     }\n \n-    private void addValueProvidersToMetricsRecorder(final Map<String, Object> configs) {\n+    private void addValueProvidersToMetricsRecorder() {\n         final TableFormatConfig tableFormatConfig = userSpecifiedOptions.tableFormatConfig();\n         final Statistics statistics = userSpecifiedStatistics ? null : userSpecifiedOptions.statistics();\n-        if (tableFormatConfig instanceof BlockBasedTableConfigWithAccessibleCache) {\n-            final Cache cache = ((BlockBasedTableConfigWithAccessibleCache) tableFormatConfig).blockCache();\n-            metricsRecorder.addValueProviders(name, db, cache, statistics);\n-        } else {\n-            metricsRecorder.addValueProviders(name, db, null, statistics);\n-            log.warn(\"A table format configuration is used that does not expose the block cache. This means \" +\n-                \"that metrics that relate to the block cache may be wrong if the block cache is shared.\");\n-        }\n+        if (!(tableFormatConfig instanceof BlockBasedTableConfigWithAccessibleCache)) {", "originalCommit": "91b3430b9db78b0cff834d6197f509f65a639dcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwMjg0MQ==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r468802841", "bodyText": "No, it was not intentional. I simply did not think hard enough.\nI agree with you that we should also allow PlainTableConfig. If users use the PlainTable format they should already expect that block cache specific metrics do not show up or report constant zero.\nThank you for pointing this out!", "author": "cadonna", "createdAt": "2020-08-11T19:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r468775002", "bodyText": "Could this ever be null actually? I think even in unit tests the DBOptions would contain stats?", "author": "guozhangwang", "createdAt": "2020-08-11T18:18:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBStore.java", "diffHunk": "@@ -181,26 +181,42 @@ void openDB(final ProcessorContext context) {\n             throw new ProcessorStateException(fatal);\n         }\n \n-        // Setup metrics before the database is opened, otherwise the metrics are not updated\n+        // Setup statistics before the database is opened, otherwise the statistics are not updated\n         // with the measurements from Rocks DB\n-        maybeSetUpMetricsRecorder(configs);\n+        maybeSetUpStatistics(configs);\n \n         openRocksDB(dbOptions, columnFamilyOptions);\n         open = true;\n+\n+        addValueProvidersToMetricsRecorder();\n     }\n \n-    private void maybeSetUpMetricsRecorder(final Map<String, Object> configs) {\n-        if (userSpecifiedOptions.statistics() == null &&\n+    private void maybeSetUpStatistics(final Map<String, Object> configs) {\n+        if (userSpecifiedOptions.statistics() != null) {", "originalCommit": "91b3430b9db78b0cff834d6197f509f65a639dcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NjMzMw==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r468796333", "bodyText": "The statistics are null when it is not set in the options. If it were not null unit test RocksDBTest#shouldAddValueProvidersWithStatisticsToInjectedMetricsRecorderWhenRecordingLevelDebug() would fail. I also verified with a debug run.", "author": "cadonna", "createdAt": "2020-08-11T18:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5MTEyMg==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r468891122", "bodyText": "I was thinking that, if we know maybeSetUpStatistics is only called once in lifetime of the store then here we could check that userSpecifiedOptions.statistics() == null and otherwise throw illegal-state exception. And then in addValueProvidersToMetricsRecorder we check that ``userSpecifiedOptions.statistics() != null` and otherwise throw illegal-state exception. This is to make the call-trace assumptions more specific.", "author": "guozhangwang", "createdAt": "2020-08-11T22:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5NTc1Nw==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r469095757", "bodyText": "I see what you are aiming at. However, why should we throw an IllegalStateException when userSpecifiedOptions.statistics() != null? The user could provide a statistics object through the config setter and use it to read the statistics externally to our metric framework. Such a pattern was supported before and was not changed in this PR or the PR that introduced the statistics-based RocksDB metrics.\nAnyways, it is good that you mentioned this, because I checked again the code in the metrics recorder and a null check was missing. Plus I included some checks to ensure that either all statistics of a metrics recorder arenull or all statistics of a metrics recorder are NOT null.", "author": "cadonna", "createdAt": "2020-08-12T08:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM4ODY1NA==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r469388654", "bodyText": "Hmm, that means if a user calls setStatistics externally then streams itself would not provide the built-in metrics, is that right? I was not aware of this, and if it is by-design then that's fine.", "author": "guozhangwang", "createdAt": "2020-08-12T16:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQyMjExMA==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r469422110", "bodyText": "Actually, Streams would provide the built-in metrics, but not update them. I also thought about not providing them at all, but that is a bit tricky and I did not want spent too much time on such a rare case. I will open a Jira and defer this to later.", "author": "cadonna", "createdAt": "2020-08-12T17:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTAwMg=="}], "type": "inlineReview"}, {"oid": "ebab7af0bb7ea98af111aa626874f678d9fe3c56", "url": "https://github.com/apache/kafka/commit/ebab7af0bb7ea98af111aa626874f678d9fe3c56", "message": "Allow other table formats than block-based tables", "committedDate": "2020-08-11T19:41:48Z", "type": "commit"}, {"oid": "5c967a48033bcf92438e8fc419a6a8b4835ba665", "url": "https://github.com/apache/kafka/commit/5c967a48033bcf92438e8fc419a6a8b4835ba665", "message": "Improve statistics handling in metrics recorder", "committedDate": "2020-08-12T08:36:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyNzUwMA==", "url": "https://github.com/apache/kafka/pull/9098#discussion_r469327500", "bodyText": "I think it's implied in addValueProviders that if any of the valueProviders' statistics are non-null, then they are all non-null, in which case, this makes sense as a guard. Still, it's kind of subtle.\nWhy not just put a guard inside the loop instead to continue or break if it turns out that valueProviders.statistics == null?", "author": "vvcephei", "createdAt": "2020-08-12T15:03:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/metrics/RocksDBMetricsRecorder.java", "diffHunk": "@@ -187,37 +206,39 @@ public void record(final long now) {\n         long bytesReadDuringCompaction = 0;\n         long numberOfOpenFiles = 0;\n         long numberOfFileErrors = 0;\n-        for (final DbAndCacheAndStatistics valueProviders : storeToValueProviders.values()) {\n-            bytesWrittenToDatabase += valueProviders.statistics.getAndResetTickerCount(TickerType.BYTES_WRITTEN);\n-            bytesReadFromDatabase += valueProviders.statistics.getAndResetTickerCount(TickerType.BYTES_READ);\n-            memtableBytesFlushed += valueProviders.statistics.getAndResetTickerCount(TickerType.FLUSH_WRITE_BYTES);\n-            memtableHits += valueProviders.statistics.getAndResetTickerCount(TickerType.MEMTABLE_HIT);\n-            memtableMisses += valueProviders.statistics.getAndResetTickerCount(TickerType.MEMTABLE_MISS);\n-            blockCacheDataHits += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_DATA_HIT);\n-            blockCacheDataMisses += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_DATA_MISS);\n-            blockCacheIndexHits += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_INDEX_HIT);\n-            blockCacheIndexMisses += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_INDEX_MISS);\n-            blockCacheFilterHits += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_FILTER_HIT);\n-            blockCacheFilterMisses += valueProviders.statistics.getAndResetTickerCount(TickerType.BLOCK_CACHE_FILTER_MISS);\n-            writeStallDuration += valueProviders.statistics.getAndResetTickerCount(TickerType.STALL_MICROS);\n-            bytesWrittenDuringCompaction += valueProviders.statistics.getAndResetTickerCount(TickerType.COMPACT_WRITE_BYTES);\n-            bytesReadDuringCompaction += valueProviders.statistics.getAndResetTickerCount(TickerType.COMPACT_READ_BYTES);\n-            numberOfOpenFiles += valueProviders.statistics.getAndResetTickerCount(TickerType.NO_FILE_OPENS)\n-                - valueProviders.statistics.getAndResetTickerCount(TickerType.NO_FILE_CLOSES);\n-            numberOfFileErrors += valueProviders.statistics.getAndResetTickerCount(TickerType.NO_FILE_ERRORS);\n+        if (storeToValueProviders.values().stream().anyMatch(valueProviders -> valueProviders.statistics != null)) {", "originalCommit": "5c967a48033bcf92438e8fc419a6a8b4835ba665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb15c3a5bf91f9a46d6914739b617ca2291f52da", "url": "https://github.com/apache/kafka/commit/fb15c3a5bf91f9a46d6914739b617ca2291f52da", "message": "Change guard to avoid recording when statistics are null", "committedDate": "2020-08-12T15:27:07Z", "type": "commit"}]}