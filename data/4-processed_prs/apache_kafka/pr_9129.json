{"pr_number": 9129, "pr_title": "MINOR: Update jmh to 1.27 for async profiler support", "pr_createdAt": "2020-08-05T13:57:55Z", "pr_url": "https://github.com/apache/kafka/pull/9129", "timeline": [{"oid": "7ec327b4ecc7d13019e88cd4e20fe58335cbcbdb", "url": "https://github.com/apache/kafka/commit/7ec327b4ecc7d13019e88cd4e20fe58335cbcbdb", "message": "MINOR: Update jmh to 1.24 for async profiler support\n\nHighlights:\n\n* async-profiler integration. Can be used with -prof async,\npass -prof async:help to look for the accepted options.\n* perf c2c [2] integration. Can be used with -prof perfc2c,\nif available.\n\nFull details:\nhttps://mail.openjdk.java.net/pipermail/jmh-dev/2020-August/002982.html", "committedDate": "2020-08-05T14:12:44Z", "type": "forcePushed"}, {"oid": "debff2513346486163477008efbf5e895f5d25f8", "url": "https://github.com/apache/kafka/commit/debff2513346486163477008efbf5e895f5d25f8", "message": "Improve jmh benchmarking docs", "committedDate": "2020-08-11T09:18:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1ODMxMw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r468658313", "bodyText": "Rather than \"in order to verify that they are valid\", how about \"in order to verify that they are measuring what you think they are. For example, if you use mocks they may use reflection that can easily dominate the benchmark's run time.\".", "author": "lbradstreet", "createdAt": "2020-08-11T15:13:07Z", "path": "README.md", "diffHunk": "@@ -199,6 +199,27 @@ You can run spotbugs using:\n The spotbugs warnings will be found in `reports/spotbugs/main.html` and `reports/spotbugs/test.html` files in the subproject build\n directories.  Use -PxmlSpotBugsReport=true to generate an XML report instead of an HTML one.\n \n+### JMH microbenchmarks ###\n+We use [JMH](https://openjdk.java.net/projects/code-tools/jmh/) to write microbenchmarks that produce reliable results in the JVM.\n+You can run all the benchmarks using:\n+\n+    ./jmh-benchmarks/jmh.sh\n+    \n+Pass a pattern or name after the command to select the benchmarks, for example:\n+\n+    ./jmh-benchmarks/jmh.sh LRUCacheBenchmark\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.", "originalCommit": "debff2513346486163477008efbf5e895f5d25f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r468661408", "bodyText": "While we're at it we can also mention -prof gc and how you should look for the norm allocation rate (since we care about garbage generated per operation rather than per second).", "author": "lbradstreet", "createdAt": "2020-08-11T15:17:20Z", "path": "README.md", "diffHunk": "@@ -199,6 +199,27 @@ You can run spotbugs using:\n The spotbugs warnings will be found in `reports/spotbugs/main.html` and `reports/spotbugs/test.html` files in the subproject build\n directories.  Use -PxmlSpotBugsReport=true to generate an XML report instead of an HTML one.\n \n+### JMH microbenchmarks ###", "originalCommit": "debff2513346486163477008efbf5e895f5d25f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTUwOQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r468661509", "bodyText": "I'll provide some text for this soon.", "author": "lbradstreet", "createdAt": "2020-08-11T15:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5NTIyNw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r468895227", "bodyText": "Sure. Do you think I should have only the link to jmh-benchmarks/README.md and have all the information on to use it in that page?", "author": "ijuma", "createdAt": "2020-08-11T22:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjAwMA==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r475106000", "bodyText": "Including only the link sounds good.", "author": "lbradstreet", "createdAt": "2020-08-22T16:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNzA5Nw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478637097", "bodyText": "Let's drop this and include that link before merge.", "author": "lbradstreet", "createdAt": "2020-08-27T19:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTM3Nw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478639377", "bodyText": "Yeah, I fixed this in my local copy, but I wanted to test it before pushing the changes.", "author": "ijuma", "createdAt": "2020-08-27T19:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3MTQ0Mg==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r539871442", "bodyText": "Updated.", "author": "ijuma", "createdAt": "2020-12-10T06:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTQwOA=="}], "type": "inlineReview"}, {"oid": "ad5b568aa3f35804b7191d35f4be3bb778fc8e33", "url": "https://github.com/apache/kafka/commit/ad5b568aa3f35804b7191d35f4be3bb778fc8e33", "message": "JMH 1.25", "committedDate": "2020-08-22T23:09:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNTc3MA==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478635770", "bodyText": "Suggested addition:\nUsing JMH GC profiler\nIt's good practice to run your benchmark with -prof gc to measure the allocation rate for your code:\n  ./jmh-benchmarks/jmh.sh -prof gc\n\nOf particular importance is the \"norm\" alloc rates, which measure the allocations per operation rather than allocations per second which can increase when you have made your code faster.", "author": "lbradstreet", "createdAt": "2020-08-27T19:08:30Z", "path": "jmh-benchmarks/README.md", "diffHunk": "@@ -34,7 +34,18 @@ the jmh.sh script from the jmh-benchmarks module.\n * By default all JMH output goes to stdout.  To run a benchmark and capture the results in a file:\n `./jmh.sh -f 2 -o benchmarkResults.txt LRUCacheBenchmark`\n NOTE: For now this script needs to be run from the jmh-benchmarks directory.\n+\n+### Using JMH with async-profiler\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.\n+JMH includes [async-profiler](https://github.com/jvm-profiling-tools/async-profiler) integration that makes this easy:\n  \n+    LD_LIBRARY_PATH=/path/to/async-profiler ./jmh-benchmarks/jmh.sh -prof async\n+    \n+A number of arguments can be passed to async-profiler, run the following for a description: \n+\n+    ./jmh-benchmarks/jmh.sh -prof async:help\n+", "originalCommit": "ad5b568aa3f35804b7191d35f4be3bb778fc8e33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTk4MQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478639981", "bodyText": "Will add.", "author": "ijuma", "createdAt": "2020-08-27T19:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNjcxOQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478636719", "bodyText": "We should document this variant instead so linux and mac os users are covered.\n -prof async:libPath=/Users/lucas/Downloads/async-profiler-1.8-macos-x64/build/libasyncProfiler.so", "author": "lbradstreet", "createdAt": "2020-08-27T19:10:18Z", "path": "jmh-benchmarks/README.md", "diffHunk": "@@ -34,7 +34,18 @@ the jmh.sh script from the jmh-benchmarks module.\n * By default all JMH output goes to stdout.  To run a benchmark and capture the results in a file:\n `./jmh.sh -f 2 -o benchmarkResults.txt LRUCacheBenchmark`\n NOTE: For now this script needs to be run from the jmh-benchmarks directory.\n+\n+### Using JMH with async-profiler\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.\n+JMH includes [async-profiler](https://github.com/jvm-profiling-tools/async-profiler) integration that makes this easy:\n  \n+    LD_LIBRARY_PATH=/path/to/async-profiler ./jmh-benchmarks/jmh.sh -prof async", "originalCommit": "ad5b568aa3f35804b7191d35f4be3bb778fc8e33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MDUxOQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r478640519", "bodyText": "Agreed, I tested this variant on Mac, but not Linux yet. Will do before changing.", "author": "ijuma", "createdAt": "2020-08-27T19:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNjcxOQ=="}], "type": "inlineReview"}, {"oid": "f735d9e88f3f49884fd988aa825571fb0e23362e", "url": "https://github.com/apache/kafka/commit/f735d9e88f3f49884fd988aa825571fb0e23362e", "message": "JMH 1.27 and README improvements", "committedDate": "2020-12-09T20:37:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwMTE0Mg==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r539901142", "bodyText": "The file name of async-profiler is libasyncProfiler.so. Should we follow the naming in this example?", "author": "chia7712", "createdAt": "2020-12-10T06:42:46Z", "path": "jmh-benchmarks/README.md", "diffHunk": "@@ -1,10 +1,69 @@\n-### JMH-Benchmark module\n+### JMH-Benchmarks module\n \n This module contains benchmarks written using [JMH](https://openjdk.java.net/projects/code-tools/jmh/) from OpenJDK.\n Writing correct micro-benchmarks in Java (or another JVM language) is difficult and there are many non-obvious pitfalls (many\n due to compiler optimizations). JMH is a framework for running and analyzing benchmarks (micro or macro) written in Java (or\n another JVM language).\n \n+### Running benchmarks\n+\n+If you want to set specific JMH flags or only run certain benchmarks, passing arguments via\n+gradle tasks is cumbersome. These are simplified by the provided `jmh.sh` script.\n+\n+The default behavior is to run all benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh\n+    \n+Pass a pattern or name after the command to select the benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh LRUCacheBenchmark\n+\n+Check which benchmarks that match the provided pattern:\n+\n+    ./jmh-benchmarks/jmh.sh -l LRUCacheBenchmark\n+\n+Run a specific test and override the number of forks, iterations and warm-up iteration to `2`:\n+\n+    ./jmh-benchmarks/jmh.sh -f 2 -i 2 -wi 2 LRUCacheBenchmark\n+\n+Run a specific test with async and GC profilers on Linux and flame graph output:\n+\n+    ./jmh-benchmarks/jmh.sh -prof gc -prof 'async:libPath=/path/to/async-profiler.so;output=flamegraph' LRUCacheBenchmark\n+\n+The following sections cover async profiler and GC profilers in more detail.\n+\n+### Using JMH with async profiler\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.\n+JMH includes [async-profiler](https://github.com/jvm-profiling-tools/async-profiler) integration that makes this easy:\n+\n+    ./jmh-benchmarks/jmh.sh -prof async:libPath=/path/to/async-profiler.so", "originalCommit": "cfd375eb595950c325c0d1f2ae02869ad704760a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkxODU4MA==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r539918580", "bodyText": "Yeah, that makes sense. Will do when I'm near a computer.", "author": "ijuma", "createdAt": "2020-12-10T07:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwMTE0Mg=="}], "type": "inlineReview"}, {"oid": "45d097210326d2e9284c55150143de98c66309d6", "url": "https://github.com/apache/kafka/commit/45d097210326d2e9284c55150143de98c66309d6", "message": "MINOR: Update jmh to 1.24 for async profiler support\n\nHighlights:\n\n* async-profiler integration. Can be used with -prof async,\npass -prof async:help to look for the accepted options.\n* perf c2c [2] integration. Can be used with -prof perfc2c,\nif available.\n\nFull details:\nhttps://mail.openjdk.java.net/pipermail/jmh-dev/2020-August/002982.html", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "35ec135a4e2398ed75b39278270d774d85cfe5c5", "url": "https://github.com/apache/kafka/commit/35ec135a4e2398ed75b39278270d774d85cfe5c5", "message": "Exclude jopt from jmh project", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "c00f2f5674355ee8f3761620231e786a2f142cf6", "url": "https://github.com/apache/kafka/commit/c00f2f5674355ee8f3761620231e786a2f142cf6", "message": "Improve jmh benchmarking docs", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "f24e61a05aa450828960866c0103b8df192e6421", "url": "https://github.com/apache/kafka/commit/f24e61a05aa450828960866c0103b8df192e6421", "message": "JMH 1.25", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "a5ad3a9da5d60c1ec25aa54b8554ddfb07675a09", "url": "https://github.com/apache/kafka/commit/a5ad3a9da5d60c1ec25aa54b8554ddfb07675a09", "message": "WIP", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "bbdbc76810ad8a2771d476f64f35d106a6bfa3f8", "url": "https://github.com/apache/kafka/commit/bbdbc76810ad8a2771d476f64f35d106a6bfa3f8", "message": "JMH 1.27 and README improvements", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "4993b7c7e4b7cdbe93322c83d3fd9a18346f2081", "url": "https://github.com/apache/kafka/commit/4993b7c7e4b7cdbe93322c83d3fd9a18346f2081", "message": "Fix compiler error with latest jmh and doc improvements", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "97db7556399f633f1f1c0ca187f1a106daecffba", "url": "https://github.com/apache/kafka/commit/97db7556399f633f1f1c0ca187f1a106daecffba", "message": "Readme fixes", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "b64b1f1eff6684873df88b1d411fd3be3b750e5e", "url": "https://github.com/apache/kafka/commit/b64b1f1eff6684873df88b1d411fd3be3b750e5e", "message": "Fix missing single quotes in readme", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "67458a3b106abc2fbe4754b3f8618d6e936d79c5", "url": "https://github.com/apache/kafka/commit/67458a3b106abc2fbe4754b3f8618d6e936d79c5", "message": "Readme tweaks", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "8e52198d80925a06a9532f4c9d04d781de70c079", "url": "https://github.com/apache/kafka/commit/8e52198d80925a06a9532f4c9d04d781de70c079", "message": "Adjust spotbugs exclusion to account for differences in the generated code", "committedDate": "2020-12-10T13:40:55Z", "type": "commit"}, {"oid": "8e52198d80925a06a9532f4c9d04d781de70c079", "url": "https://github.com/apache/kafka/commit/8e52198d80925a06a9532f4c9d04d781de70c079", "message": "Adjust spotbugs exclusion to account for differences in the generated code", "committedDate": "2020-12-10T13:40:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4MjQwNw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540182407", "bodyText": "jmh now uses jmh_generated instead of generated.", "author": "ijuma", "createdAt": "2020-12-10T13:49:13Z", "path": "gradle/spotbugs-exclude.xml", "diffHunk": "@@ -237,19 +237,8 @@ For a detailed description of spotbugs bug categories, see https://spotbugs.read\n     </Match>\n \n     <Match>\n-        <!-- Suppress some minor warnings about machine-generated code for\n-             benchmarking. -->\n-        <Or>\n-            <Package name=\"org.apache.kafka.jmh.cache.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.common.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.record.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.partition.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.producer.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.fetchsession.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.fetcher.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.server.generated\"/>\n-            <Package name=\"org.apache.kafka.jmh.consumer.generated\"/>\n-        </Or>\n+        <!-- Suppress some minor warnings about machine-generated code for benchmarking. -->\n+        <Package name=\"~org\\.apache\\.kafka\\.jmh\\..*\\.jmh_generated\"/>", "originalCommit": "8e52198d80925a06a9532f4c9d04d781de70c079", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MDQ0MQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540360441", "bodyText": "How about:\n\"It's good practice to check profiler output for microbenchmarks in order to verify that they represent application behavior and measure what you expect to measure. Some example pitfalls include the use of expensive mocks or accidental inclusion of test setup code in the benchmarked code.\"", "author": "lbradstreet", "createdAt": "2020-12-10T17:31:10Z", "path": "jmh-benchmarks/README.md", "diffHunk": "@@ -1,10 +1,69 @@\n-### JMH-Benchmark module\n+### JMH-Benchmarks module\n \n This module contains benchmarks written using [JMH](https://openjdk.java.net/projects/code-tools/jmh/) from OpenJDK.\n Writing correct micro-benchmarks in Java (or another JVM language) is difficult and there are many non-obvious pitfalls (many\n due to compiler optimizations). JMH is a framework for running and analyzing benchmarks (micro or macro) written in Java (or\n another JVM language).\n \n+### Running benchmarks\n+\n+If you want to set specific JMH flags or only run certain benchmarks, passing arguments via\n+gradle tasks is cumbersome. These are simplified by the provided `jmh.sh` script.\n+\n+The default behavior is to run all benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh\n+    \n+Pass a pattern or name after the command to select the benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh LRUCacheBenchmark\n+\n+Check which benchmarks that match the provided pattern:\n+\n+    ./jmh-benchmarks/jmh.sh -l LRUCacheBenchmark\n+\n+Run a specific test and override the number of forks, iterations and warm-up iteration to `2`:\n+\n+    ./jmh-benchmarks/jmh.sh -f 2 -i 2 -wi 2 LRUCacheBenchmark\n+\n+Run a specific test with async and GC profilers on Linux and flame graph output:\n+\n+    ./jmh-benchmarks/jmh.sh -prof gc -prof async:libPath=/path/to/libasyncProfiler.so\\;output=flamegraph LRUCacheBenchmark\n+\n+The following sections cover async profiler and GC profilers in more detail.\n+\n+### Using JMH with async profiler\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.", "originalCommit": "8e52198d80925a06a9532f4c9d04d781de70c079", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3Mjc1Mw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540372753", "bodyText": "Will add.", "author": "ijuma", "createdAt": "2020-12-10T17:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MDQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MTY4Mw==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540361683", "bodyText": "Could we include a short section here about what should be put into a PR that has been benchmarked?\nI'm thinking:\n\nBenchmark comparisons for the code before and after the change.\n-prof gc results.\nAn example async profile from at least one run.", "author": "lbradstreet", "createdAt": "2020-12-10T17:32:58Z", "path": "jmh-benchmarks/README.md", "diffHunk": "@@ -1,10 +1,69 @@\n-### JMH-Benchmark module\n+### JMH-Benchmarks module\n \n This module contains benchmarks written using [JMH](https://openjdk.java.net/projects/code-tools/jmh/) from OpenJDK.\n Writing correct micro-benchmarks in Java (or another JVM language) is difficult and there are many non-obvious pitfalls (many\n due to compiler optimizations). JMH is a framework for running and analyzing benchmarks (micro or macro) written in Java (or\n another JVM language).\n \n+### Running benchmarks\n+\n+If you want to set specific JMH flags or only run certain benchmarks, passing arguments via\n+gradle tasks is cumbersome. These are simplified by the provided `jmh.sh` script.\n+\n+The default behavior is to run all benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh\n+    \n+Pass a pattern or name after the command to select the benchmarks:\n+\n+    ./jmh-benchmarks/jmh.sh LRUCacheBenchmark\n+\n+Check which benchmarks that match the provided pattern:\n+\n+    ./jmh-benchmarks/jmh.sh -l LRUCacheBenchmark\n+\n+Run a specific test and override the number of forks, iterations and warm-up iteration to `2`:\n+\n+    ./jmh-benchmarks/jmh.sh -f 2 -i 2 -wi 2 LRUCacheBenchmark\n+\n+Run a specific test with async and GC profilers on Linux and flame graph output:\n+\n+    ./jmh-benchmarks/jmh.sh -prof gc -prof async:libPath=/path/to/libasyncProfiler.so\\;output=flamegraph LRUCacheBenchmark\n+\n+The following sections cover async profiler and GC profilers in more detail.\n+\n+### Using JMH with async profiler\n+\n+It's good practice to check profiler output for microbenchmarks in order to verify that they are valid.\n+JMH includes [async-profiler](https://github.com/jvm-profiling-tools/async-profiler) integration that makes this easy:\n+\n+    ./jmh-benchmarks/jmh.sh -prof async:libPath=/path/to/libasyncProfiler.so\n+\n+With flame graph output (the semicolon is escaped to ensure it is not treated as a command separator):\n+\n+    ./jmh-benchmarks/jmh.sh -prof async:libPath=/path/to/libasyncProfiler.so\\;output=flamegraph\n+\n+A number of arguments can be passed to configure async profiler, run the following for a description:\n+\n+    ./jmh-benchmarks/jmh.sh -prof async:help\n+\n+### Using JMH GC profiler\n+\n+It's good practice to run your benchmark with `-prof gc` to measure its allocation rate:\n+\n+    ./jmh-benchmarks/jmh.sh -prof gc\n+\n+Of particular importance is the `norm` alloc rates, which measure the allocations per operation rather than allocations\n+per second which can increase when you have make your code faster.\n+\n+### Running JMH outside of gradle\n+\n+The JMH benchmarks can be run outside of gradle as you would with any executable jar file:\n+\n+    java -jar <kafka-repo-dir>/jmh-benchmarks/build/libs/kafka-jmh-benchmarks-all.jar -f2 LRUCacheBenchmark\n+\n+### Writing benchmarks", "originalCommit": "8e52198d80925a06a9532f4c9d04d781de70c079", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3MzQ0NQ==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540373445", "bodyText": "Good idea. We should also link from the contributor docs.", "author": "ijuma", "createdAt": "2020-12-10T17:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYzMTYxMA==", "url": "https://github.com/apache/kafka/pull/9129#discussion_r540631610", "bodyText": "I will do this in a separate PR since it's a bit unrelated to the original goal of this PR and it may take a few iterations to get right.", "author": "ijuma", "createdAt": "2020-12-11T01:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MTY4Mw=="}], "type": "inlineReview"}, {"oid": "0f5cd4d92a82f350454360fd22ad3b1d5858826f", "url": "https://github.com/apache/kafka/commit/0f5cd4d92a82f350454360fd22ad3b1d5858826f", "message": "Tweak \"profiler good practice\" text", "committedDate": "2020-12-11T01:53:09Z", "type": "commit"}]}