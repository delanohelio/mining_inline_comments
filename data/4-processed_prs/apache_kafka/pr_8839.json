{"pr_number": 8839, "pr_title": "MINOR: Documentation for KIP-585", "pr_createdAt": "2020-06-09T10:35:23Z", "pr_url": "https://github.com/apache/kafka/pull/8839", "timeline": [{"oid": "fa31ab81fceeff01846ca631b45e6b80bae14cf2", "url": "https://github.com/apache/kafka/commit/fa31ab81fceeff01846ca631b45e6b80bae14cf2", "message": "Add PredicateDoc for generating predicate docs\n\nFollow the style of TransformationDoc, but fix the header depth mismatch.\nAvoid generating HTML ids based purely on the config name since there\nare very likely to conflict (e.g. #name). Instead allow passing a function\nwhich can be used to generate an id from a config key.", "committedDate": "2020-06-09T10:02:24Z", "type": "commit"}, {"oid": "081c941be0c871f41ac0103ad8bb02571d02ddfa", "url": "https://github.com/apache/kafka/commit/081c941be0c871f41ac0103ad8bb02571d02ddfa", "message": "KIP-585: Add documentation for predicates", "committedDate": "2020-06-09T10:32:24Z", "type": "commit"}, {"oid": "593b07d0642bbcbb8b1c39bf1b94787c45aea22d", "url": "https://github.com/apache/kafka/commit/593b07d0642bbcbb8b1c39bf1b94787c45aea22d", "message": "Fix", "committedDate": "2020-06-09T11:06:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNzUwMQ==", "url": "https://github.com/apache/kafka/pull/8839#discussion_r439227501", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <p>Transformations can be configured with prediates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <b>Filter</b> transformation predicates can be used to selectively filter out certain messages.</p>\n          \n          \n            \n                <p>Transformations can be configured with predicates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <b>Filter</b> transformation predicates can be used to selectively filter out certain messages.</p>", "author": "kkonstantine", "createdAt": "2020-06-12T06:18:37Z", "path": "docs/connect.html", "diffHunk": "@@ -180,13 +182,80 @@ <h4><a id=\"connect_transforms\" href=\"#connect_transforms\">Transformations</a></h\n         <li>SetSchemaMetadata - modify the schema name or version</li>\n         <li>TimestampRouter - Modify the topic of a record based on original topic and timestamp. Useful when using a sink that needs to write to different tables or indexes based on timestamps</li>\n         <li>RegexRouter - modify the topic of a record based on original topic, replacement string and a regular expression</li>\n+        <li>Filter - Removes messages from all further processing. This is used with a <a href=\"#connect_predicates\">predicate</a> to selectively filter certain messages.</li>\n     </ul>\n \n     <p>Details on how to configure each transformation are listed below:</p>\n \n \n     <!--#include virtual=\"generated/connect_transforms.html\" -->\n \n+\n+    <h5><a id=\"connect_predicates\" href=\"#connect_predicates\">Predicates</a></h5>\n+\n+    <p>Transformations can be configured with prediates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <b>Filter</b> transformation predicates can be used to selectively filter out certain messages.</p>", "originalCommit": "593b07d0642bbcbb8b1c39bf1b94787c45aea22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyODE1Ng==", "url": "https://github.com/apache/kafka/pull/8839#discussion_r439228156", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <p>To do this we need to first to filter out the records destined for the topic 'foo'. The Filter transformation removes records from further processing, and can use the TopicNameMatches predicate to apply the transformation only to records in topics which match a certain regular expression. TopicNameMatches's only configuration property is <code>pattern</code> which is a Java regular expression for matching against the topic name. The configuration would look like this:</p>\n          \n          \n            \n                <p>To do this we need first to filter out the records destined for the topic 'foo'. The Filter transformation removes records from further processing, and can use the TopicNameMatches predicate to apply the transformation only to records in topics which match a certain regular expression. TopicNameMatches's only configuration property is <code>pattern</code> which is a Java regular expression for matching against the topic name. The configuration would look like this:</p>", "author": "kkonstantine", "createdAt": "2020-06-12T06:20:36Z", "path": "docs/connect.html", "diffHunk": "@@ -180,13 +182,80 @@ <h4><a id=\"connect_transforms\" href=\"#connect_transforms\">Transformations</a></h\n         <li>SetSchemaMetadata - modify the schema name or version</li>\n         <li>TimestampRouter - Modify the topic of a record based on original topic and timestamp. Useful when using a sink that needs to write to different tables or indexes based on timestamps</li>\n         <li>RegexRouter - modify the topic of a record based on original topic, replacement string and a regular expression</li>\n+        <li>Filter - Removes messages from all further processing. This is used with a <a href=\"#connect_predicates\">predicate</a> to selectively filter certain messages.</li>\n     </ul>\n \n     <p>Details on how to configure each transformation are listed below:</p>\n \n \n     <!--#include virtual=\"generated/connect_transforms.html\" -->\n \n+\n+    <h5><a id=\"connect_predicates\" href=\"#connect_predicates\">Predicates</a></h5>\n+\n+    <p>Transformations can be configured with prediates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <b>Filter</b> transformation predicates can be used to selectively filter out certain messages.</p>\n+\n+    <p>Predicates are specified in the connector configuration.</p>\n+\n+    <ul>\n+        <li><code>predicates</code> - Set of aliases for the predicates to be applied to some of the transformations.</li>\n+        <li><code>predicates.$alias.type</code> - Fully qualified class name for the predicate.</li>\n+        <li><code>predicates.$alias.$predicateSpecificConfig</code> - Configuration properties for the predicate.</li>\n+    </ul>\n+\n+    <p>All transformations have the implicit config properties <code>predicate</code> and <code>negate</code>. A predicular predicate is associated with a transformation by setting the transformation's <code>predicate</code> config to the predicate's alias. The predicate's value can be reversed using the <code>negate</code> configuration property.</p>\n+\n+    <p>For example, suppose you have a source connector which produces messages to many different topics and you want to:</p>\n+    <ul>\n+        <li>filter out the messages in the 'foo' topic entirely</li>\n+        <li>apply the ExtractField transformation with the field name 'other_field' to records in all topics <i>except</i> the topic 'bar'</li>\n+    </ul>\n+\n+    <p>To do this we need to first to filter out the records destined for the topic 'foo'. The Filter transformation removes records from further processing, and can use the TopicNameMatches predicate to apply the transformation only to records in topics which match a certain regular expression. TopicNameMatches's only configuration property is <code>pattern</code> which is a Java regular expression for matching against the topic name. The configuration would look like this:</p>", "originalCommit": "593b07d0642bbcbb8b1c39bf1b94787c45aea22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMDE1NQ==", "url": "https://github.com/apache/kafka/pull/8839#discussion_r439230155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <li><code>RecordIsTombstone</code> - matches tombstone records, that is, those will a null value.</li>\n          \n          \n            \n                    <li><code>RecordIsTombstone</code> - matches tombstone records, that is records with a null value.</li>", "author": "kkonstantine", "createdAt": "2020-06-12T06:26:20Z", "path": "docs/connect.html", "diffHunk": "@@ -180,13 +182,80 @@ <h4><a id=\"connect_transforms\" href=\"#connect_transforms\">Transformations</a></h\n         <li>SetSchemaMetadata - modify the schema name or version</li>\n         <li>TimestampRouter - Modify the topic of a record based on original topic and timestamp. Useful when using a sink that needs to write to different tables or indexes based on timestamps</li>\n         <li>RegexRouter - modify the topic of a record based on original topic, replacement string and a regular expression</li>\n+        <li>Filter - Removes messages from all further processing. This is used with a <a href=\"#connect_predicates\">predicate</a> to selectively filter certain messages.</li>\n     </ul>\n \n     <p>Details on how to configure each transformation are listed below:</p>\n \n \n     <!--#include virtual=\"generated/connect_transforms.html\" -->\n \n+\n+    <h5><a id=\"connect_predicates\" href=\"#connect_predicates\">Predicates</a></h5>\n+\n+    <p>Transformations can be configured with prediates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <b>Filter</b> transformation predicates can be used to selectively filter out certain messages.</p>\n+\n+    <p>Predicates are specified in the connector configuration.</p>\n+\n+    <ul>\n+        <li><code>predicates</code> - Set of aliases for the predicates to be applied to some of the transformations.</li>\n+        <li><code>predicates.$alias.type</code> - Fully qualified class name for the predicate.</li>\n+        <li><code>predicates.$alias.$predicateSpecificConfig</code> - Configuration properties for the predicate.</li>\n+    </ul>\n+\n+    <p>All transformations have the implicit config properties <code>predicate</code> and <code>negate</code>. A predicular predicate is associated with a transformation by setting the transformation's <code>predicate</code> config to the predicate's alias. The predicate's value can be reversed using the <code>negate</code> configuration property.</p>\n+\n+    <p>For example, suppose you have a source connector which produces messages to many different topics and you want to:</p>\n+    <ul>\n+        <li>filter out the messages in the 'foo' topic entirely</li>\n+        <li>apply the ExtractField transformation with the field name 'other_field' to records in all topics <i>except</i> the topic 'bar'</li>\n+    </ul>\n+\n+    <p>To do this we need to first to filter out the records destined for the topic 'foo'. The Filter transformation removes records from further processing, and can use the TopicNameMatches predicate to apply the transformation only to records in topics which match a certain regular expression. TopicNameMatches's only configuration property is <code>pattern</code> which is a Java regular expression for matching against the topic name. The configuration would look like this:</p>\n+\n+    <pre class=\"brush: text;\">\n+        transforms=Filter\n+        transforms.Filter.type=org.apache.kafka.connect.transforms.Filter\n+        transforms.Filter.predicate=IsFoo\n+\n+        predicates=IsFoo\n+        predicates.IsFoo.type=org.apache.kafka.connect.predicates.TopicNameMatches\n+        predicates.IsFoo.pattern=foo\n+    </pre>\n+        \n+    <p>Next we need to apply ExtractField only when the topic name of the record is not 'bar'. We can't just use TopicNameMatches directly, because that would apply the transformation to matching topic names, not topic names which do <i>not</i> match. The transformation's implicit <code>negate</code> config properties allows us to invert the set of records which a predicate matches. Adding the configuration for this to the previous example we arrive at:</p>\n+\n+    <pre class=\"brush: text;\">\n+        transforms=Filter,Extract\n+        transforms.Filter.type=org.apache.kafka.connect.transforms.Filter\n+        transforms.Filter.predicate=IsFoo\n+\n+        transforms.Extract.type=org.apache.kafka.connect.transforms.ExtractField$Key\n+        transforms.Extract.field=other_field\n+        transforms.Extract.predicate=IsBar\n+        transforms.Extract.negate=true\n+\n+        predicates=IsFoo,IsBar\n+        predicates.IsFoo.type=org.apache.kafka.connect.predicates.TopicNameMatches\n+        predicates.IsFoo.pattern=foo\n+\n+        predicates.IsBar.type=org.apache.kafka.connect.predicates.TopicNameMatches\n+        predicates.IsBar.pattern=bar\n+    </pre>\n+\n+    <p>Kafka Connect includes the following predicates:</p>\n+\n+    <ul>\n+        <li><code>TopicNameMatches</code> - matches records in a topic with a name matching a particular Java regular expression.</li>\n+        <li><code>HasHeaderKey</code> - matches records which have a header with the given key.</li>\n+        <li><code>RecordIsTombstone</code> - matches tombstone records, that is, those will a null value.</li>", "originalCommit": "593b07d0642bbcbb8b1c39bf1b94787c45aea22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "70d44cb2d701be9bef5c96d282a7232f1f205826", "url": "https://github.com/apache/kafka/commit/70d44cb2d701be9bef5c96d282a7232f1f205826", "message": "Apply suggestions from code review\n\nCo-authored-by: Konstantine Karantasis <konstantine@confluent.io>", "committedDate": "2020-06-12T07:39:11Z", "type": "commit"}]}