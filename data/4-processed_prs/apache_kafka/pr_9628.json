{"pr_number": 9628, "pr_title": "KAFKA-10747: Implement APIs for altering and describing IP connection rate quotas", "pr_createdAt": "2020-11-20T07:34:54Z", "pr_url": "https://github.com/apache/kafka/pull/9628", "timeline": [{"oid": "296330b879b3458fd10c780cf10f3ce3a3d0e932", "url": "https://github.com/apache/kafka/commit/296330b879b3458fd10c780cf10f3ce3a3d0e932", "message": "Alter and describe IP entity with client quota API", "committedDate": "2020-11-30T17:59:02Z", "type": "commit"}, {"oid": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "url": "https://github.com/apache/kafka/commit/cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "message": "Adds IP entity to config command", "committedDate": "2020-11-30T18:04:21Z", "type": "commit"}, {"oid": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "url": "https://github.com/apache/kafka/commit/cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "message": "Adds IP entity to config command", "committedDate": "2020-11-30T18:04:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwOTE1Mw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r532909153", "bodyText": "Consider making lower-case for consistency, but otherwise not a big issue, as I see that's how it was proposed in the KIP.", "author": "bdbyrne", "createdAt": "2020-11-30T21:17:42Z", "path": "clients/src/main/java/org/apache/kafka/common/quota/ClientQuotaEntity.java", "diffHunk": "@@ -32,6 +32,7 @@\n      */\n     public static final String USER = \"user\";\n     public static final String CLIENT_ID = \"client-id\";\n+    public static final String IP = \"IP\";", "originalCommit": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwMDQzMQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r533600431", "bodyText": "I have no objection to editing the KIP to changing this (and other uses of IP) to lower case, I just made it upper case because the original iteration of IP quotas in KIP-612 had IP in upper-case.\n@apovzner @dajac for any thoughts on upper vs lower.\nFWIW, the kafka-configs help output is better ordered when IP is in lower-case due to how it sorts flags.", "author": "splett2", "createdAt": "2020-12-01T17:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwOTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxODE5Mw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534218193", "bodyText": "I would also make it lower-case for consistency.", "author": "dajac", "createdAt": "2020-12-02T14:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwOTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU3MDQ0NA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534570444", "bodyText": "as I mentioned in my other comment, agreed with using lower-case.", "author": "apovzner", "createdAt": "2020-12-03T00:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwOTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxMjY4Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r532912686", "bodyText": "May want to provide a little more detail in the response", "author": "bdbyrne", "createdAt": "2020-11-30T21:23:53Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -833,45 +835,76 @@ class AdminManager(val config: KafkaConfig,\n   def describeClientQuotas(filter: ClientQuotaFilter): Map[ClientQuotaEntity, Map[String, Double]] = {\n     var userComponent: Option[ClientQuotaFilterComponent] = None\n     var clientIdComponent: Option[ClientQuotaFilterComponent] = None\n+    var ipComponent: Option[ClientQuotaFilterComponent] = None\n     filter.components.forEach { component =>\n       component.entityType match {\n         case ClientQuotaEntity.USER =>\n           if (userComponent.isDefined)\n-            throw new InvalidRequestException(s\"Duplicate user filter component entity type\");\n+            throw new InvalidRequestException(s\"Duplicate user filter component entity type\")\n           userComponent = Some(component)\n         case ClientQuotaEntity.CLIENT_ID =>\n           if (clientIdComponent.isDefined)\n-            throw new InvalidRequestException(s\"Duplicate client filter component entity type\");\n+            throw new InvalidRequestException(s\"Duplicate client filter component entity type\")\n           clientIdComponent = Some(component)\n+        case ClientQuotaEntity.IP =>\n+          if (ipComponent.isDefined)\n+            throw new InvalidRequestException(s\"Duplicate ip filter component entity type\")\n+          ipComponent = Some(component)\n         case \"\" =>\n           throw new InvalidRequestException(s\"Unexpected empty filter component entity type\")\n         case et =>\n           // Supplying other entity types is not yet supported.\n           throw new UnsupportedVersionException(s\"Custom entity type '${et}' not supported\")\n       }\n     }\n-    handleDescribeClientQuotas(userComponent, clientIdComponent, filter.strict)\n+    if ((userComponent.isDefined || clientIdComponent.isDefined) && ipComponent.isDefined)\n+      throw new InvalidRequestException(s\"Invalid entity filter component combination\")", "originalCommit": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNTAyMw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r532915023", "bodyText": "nit: indenting", "author": "bdbyrne", "createdAt": "2020-11-30T21:28:13Z", "path": "core/src/test/scala/unit/kafka/utils/TestUtils.scala", "diffHunk": "@@ -1529,6 +1530,16 @@ object TestUtils extends Logging {\n     adminClient.incrementalAlterConfigs(configs)\n   }\n \n+  def alterClientQuotas(adminClient: Admin, request: Map[ClientQuotaEntity, Map[String, Option[Double]]]): AlterClientQuotasResult = {\n+    val entries = request.map { case (entity, alter) =>\n+      val ops = alter.map { case (key, value) =>\n+        new ClientQuotaAlteration.Op(key, value.map(Double.box).getOrElse(null))\n+      }.asJavaCollection\n+        new ClientQuotaAlteration(entity, ops)", "originalCommit": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNzU0Mg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r532917542", "bodyText": "May want to rename (generalize) since this now includes IP", "author": "bdbyrne", "createdAt": "2020-11-30T21:33:22Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -807,23 +807,25 @@ class AdminManager(val config: KafkaConfig,\n       case name => Sanitizer.desanitize(name)\n     }\n \n-  private def entityToSanitizedUserClientId(entity: ClientQuotaEntity): (Option[String], Option[String]) = {\n+  private def entityToSanitizedUserClientId(entity: ClientQuotaEntity): (Option[String], Option[String], Option[String]) = {", "originalCommit": "cf888a9ac80f85ecb924cd41372c6f67a4d328d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cdd2364e2c538de77ab28d8da54a5f333a128f2c", "url": "https://github.com/apache/kafka/commit/cdd2364e2c538de77ab28d8da54a5f333a128f2c", "message": "Address feedback, fix test", "committedDate": "2020-12-01T18:18:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4NzQ4Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534287486", "bodyText": "Should we also provide a better error message if the user mixes up IP and user/clientId?", "author": "dajac", "createdAt": "2020-12-02T16:05:41Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -920,32 +954,49 @@ class AdminManager(val config: KafkaConfig,\n         !name.isDefined || !strict\n     }\n \n-    def fromProps(props: Map[String, String]): Map[String, Double] = {\n-      props.map { case (key, value) =>\n-        val doubleValue = try value.toDouble catch {\n-          case _: NumberFormatException =>\n-            throw new IllegalStateException(s\"Unexpected client quota configuration value: $key -> $value\")\n-        }\n-        key -> doubleValue\n-      }\n-    }\n-\n-    (userEntries ++ clientIdEntries ++ bothEntries).map { case ((u, c), p) =>\n+    (userEntries ++ clientIdEntries ++ bothEntries).flatMap { case ((u, c), p) =>\n       val quotaProps = p.asScala.filter { case (key, _) => QuotaConfigs.isQuotaConfig(key) }\n       if (quotaProps.nonEmpty && matches(userComponent, u) && matches(clientIdComponent, c))\n         Some(userClientIdToEntity(u, c) -> fromProps(quotaProps))\n       else\n         None\n-    }.flatten.toMap\n+    }.toMap\n+  }\n+\n+  def handleDescribeIpQuotas(ipComponent: Option[ClientQuotaFilterComponent], strict: Boolean): Map[ClientQuotaEntity, Map[String, Double]] = {\n+    val ip = ipComponent.flatMap(c => toOption(c.`match`))\n+    val exactIp = wantExact(ipComponent)\n+    val allIps = ipComponent.exists(_.`match` == null) || (ipComponent.isEmpty && !strict)\n+    val ipEntries = if (exactIp)\n+      Map(Some(ip.get) -> adminZkClient.fetchEntityConfig(ConfigType.Ip, sanitized(ip)))\n+    else if (allIps)\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.Ip).map { case (name, props) =>\n+        Some(desanitizeEntityName(name)) -> props\n+      }\n+    else\n+      Map.empty\n+\n+    def ipToQuotaEntity(ip: Option[String]): ClientQuotaEntity = {\n+      new ClientQuotaEntity(ip.map(ipName => ClientQuotaEntity.IP -> ipName).toMap.asJava)\n+    }\n+\n+    ipEntries.flatMap { case (ip, props) =>\n+      val ipQuotaProps = props.asScala.filter { case (key, _) => DynamicConfig.Ip.names.contains(key) }\n+      if (ipQuotaProps.nonEmpty)\n+        Some(ipToQuotaEntity(ip) -> fromProps(ipQuotaProps))\n+      else\n+        None\n+    }\n   }\n \n   def alterClientQuotas(entries: Seq[ClientQuotaAlteration], validateOnly: Boolean): Map[ClientQuotaEntity, ApiError] = {\n     def alterEntityQuotas(entity: ClientQuotaEntity, ops: Iterable[ClientQuotaAlteration.Op]): Unit = {\n-      val (path, configType, configKeys) = entityToSanitizedUserClientId(entity) match {\n-        case (Some(user), Some(clientId)) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (Some(user), None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (None, Some(clientId)) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n-        case _ => throw new InvalidRequestException(\"Invalid empty client quota entity\")\n+      val (path, configType, configKeys) = parseAndSanitizeQuotaEntity(entity) match {\n+        case (Some(user), Some(clientId), None) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (Some(user), None, None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (None, Some(clientId), None) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n+        case (None, None, Some(ip)) => (ip, ConfigType.Ip, DynamicConfig.Ip.configKeys)\n+        case _ => throw new InvalidRequestException(\"Invalid client quota entity\")", "originalCommit": "cdd2364e2c538de77ab28d8da54a5f333a128f2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5NjQ0NQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534296445", "bodyText": "I am not sure to understand why you have removed flatten here. Could you elaborate a bit on this please?", "author": "dajac", "createdAt": "2020-12-02T16:17:09Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -920,32 +954,49 @@ class AdminManager(val config: KafkaConfig,\n         !name.isDefined || !strict\n     }\n \n-    def fromProps(props: Map[String, String]): Map[String, Double] = {\n-      props.map { case (key, value) =>\n-        val doubleValue = try value.toDouble catch {\n-          case _: NumberFormatException =>\n-            throw new IllegalStateException(s\"Unexpected client quota configuration value: $key -> $value\")\n-        }\n-        key -> doubleValue\n-      }\n-    }\n-\n-    (userEntries ++ clientIdEntries ++ bothEntries).map { case ((u, c), p) =>\n+    (userEntries ++ clientIdEntries ++ bothEntries).flatMap { case ((u, c), p) =>\n       val quotaProps = p.asScala.filter { case (key, _) => QuotaConfigs.isQuotaConfig(key) }\n       if (quotaProps.nonEmpty && matches(userComponent, u) && matches(clientIdComponent, c))\n         Some(userClientIdToEntity(u, c) -> fromProps(quotaProps))\n       else\n         None\n-    }.flatten.toMap\n+    }.toMap", "originalCommit": "cdd2364e2c538de77ab28d8da54a5f333a128f2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NDUxMA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534494510", "bodyText": "this was just a coding style change, from calling entries.map(...).flatten() => entries.flatMap()", "author": "splett2", "createdAt": "2020-12-02T21:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5NjQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4ODAyNw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r535388027", "bodyText": "Ah. I missed the flatMap. That makes sense, thanks.", "author": "dajac", "createdAt": "2020-12-03T16:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5NjQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwODkzNQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534308935", "bodyText": "--IP-defaults looks pretty bad. I think that we should definitely use lower-case.", "author": "dajac", "createdAt": "2020-12-02T16:32:47Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -56,11 +56,12 @@ import scala.collection._\n  *                          --entity-type users --entity-name <user-principal> --entity-type clients --entity-name <client-id>\n  *     <li> broker: --broker <broker-id> OR --entity-type brokers --entity-name <broker-id>\n  *     <li> broker-logger: --broker-logger <broker-id> OR --entity-type broker-loggers --entity-name <broker-id>\n+ *     <li> ip: --IP <ip> OR --entity-type IPs --entity-name <ip>\n  * </ul>\n- * --entity-type <users|clients|brokers> --entity-default may be specified in place of --entity-type <users|clients|brokers> --entity-name <entityName>\n- * when describing or altering default configuration for users, clients, or brokers, respectively.\n- * Alternatively, --user-defaults, --client-defaults, or --broker-defaults may be specified in place of\n- * --entity-type <users|clients|brokers> --entity-default, respectively.\n+ * --entity-type <users|clients|brokers|IPs> --entity-default may be specified in place of --entity-type <users|clients|brokers|IPs> --entity-name <entityName>\n+ * when describing or altering default configuration for users, clients, brokers, or IPs, respectively.\n+ * Alternatively, --user-defaults, --client-defaults, --broker-defaults, or --IP-defaults may be specified in place of", "originalCommit": "cdd2364e2c538de77ab28d8da54a5f333a128f2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5Njk0Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534496946", "bodyText": "sounds good. In this case, do we want to change all mentions of IP to lower-case? including entity type/ZK path.", "author": "splett2", "createdAt": "2020-12-02T21:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwODkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1ODQwNw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r534558407", "bodyText": "yes, agreed about --IP-defaults looking bad.\nThe main reason I originally proposed upper case \"IP\" in the KIP is because ips as in --entity-type ips does not seem very recognizable as plural for IP (but that could be just me), i.e., not very user friendly. But if we do --entity-type IPs and then --ip-defaults, I think that would cause more issues later because people would assume it's consistent and use wrong case.\nOk, I am convinced that we lower-case is better, since there are more advantages to this vs. upper-case.", "author": "apovzner", "createdAt": "2020-12-02T23:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwODkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NzUwNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r535387504", "bodyText": "@splett2 Isn't the ZK path already lower-case?", "author": "dajac", "createdAt": "2020-12-03T16:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwODkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5Nzk2Mg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r535397962", "bodyText": "@dajac\nit was originally lower-case in #9386\nafter reading the KIP, i realized it was described as being upper case, e.g.\nDefault quota for <IPs> will be stored in Zookeeper at /config/IPs/<default>\nQuota for a specific IP address for which quota override is defined will be stored in Zookeeper at /config/IPs/<ip-address>\n\nand changed it to upper in this PR with the change in\ncore/src/main/scala/kafka/server/DynamicConfigManager.scala", "author": "splett2", "createdAt": "2020-12-03T16:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwODkzNQ=="}], "type": "inlineReview"}, {"oid": "1d5d69aa7f18ca931feb7d50bb30881b7b7a6f57", "url": "https://github.com/apache/kafka/commit/1d5d69aa7f18ca931feb7d50bb30881b7b7a6f57", "message": "more verbose error message", "committedDate": "2020-12-03T00:10:38Z", "type": "commit"}, {"oid": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "url": "https://github.com/apache/kafka/commit/f9e14cc25e5f8003e108202d09c90cf20d8ab179", "message": "IP => ip", "committedDate": "2020-12-03T21:25:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyOTA0Mg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r535829042", "bodyText": "TestUtils.alterClientQuotas called before adminClient.close can throw an exception. Admin extends AutoCloseable, so you can use try-with-resources.", "author": "apovzner", "createdAt": "2020-12-04T04:33:44Z", "path": "core/src/test/scala/integration/kafka/network/DynamicConnectionQuotaTest.scala", "diffHunk": "@@ -259,13 +264,19 @@ class DynamicConnectionQuotaTest extends BaseRequestTest {\n   }\n \n   private def updateIpConnectionRate(ip: Option[String], updatedRate: Int): Unit = {\n-    adminZkClient.changeIpConfig(ip.getOrElse(ConfigEntityName.Default),\n-      CoreUtils.propsWith(DynamicConfig.Ip.IpConnectionRateOverrideProp, updatedRate.toString))\n+    val initialConnectionCount = connectionCount\n+    val adminClient = createAdminClient()", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1MjUxMw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536152513", "bodyText": "I second this.", "author": "dajac", "createdAt": "2020-12-04T14:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyOTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgzMDY5MA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r535830690", "bodyText": "super tiny nit: verifyCommand name makes the code a bit confusing since the command is expected to fail. What about verifyCommandFails or verifyFails?", "author": "apovzner", "createdAt": "2020-12-04T04:39:28Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -472,6 +512,134 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     EasyMock.reset(alterResult, describeResult)\n   }\n \n+  @Test\n+  def shouldNotAlterNonQuotaIpConfigsUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a connection quota\n+    // for ip entities\n+    val node = new Node(1, \"localhost\", 9092)\n+    val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node)\n+\n+    def verifyCommand(entityType: String, alterOpts: String*): Unit = {\n+      val opts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--entity-type\", entityType, \"--entity-name\", \"admin\",\n+        \"--alter\") ++ alterOpts)\n+      val e = intercept[IllegalArgumentException] {\n+        ConfigCommand.alterConfig(mockAdminClient, opts)\n+      }\n+      assertTrue(s\"Unexpected exception: $e\", e.getMessage.contains(\"some_config\"))\n+    }\n+\n+    verifyCommand(\"ips\", \"--add-config\", \"connection_creation_rate=10000,some_config=10\")", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3MDU3Mg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536170572", "bodyText": "I do agree. It took me a while to grasp it. Moreover, the very same verifyCommand is defined in other places. I wonder if we could consolidate them into one. What do you think?", "author": "dajac", "createdAt": "2020-12-04T15:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgzMDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNDc4Mw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536134783", "bodyText": "nit: Could we add ip in the list as well?", "author": "dajac", "createdAt": "2020-12-04T14:23:49Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -864,11 +885,21 @@ object ConfigCommand extends Config {\n         }\n       }\n \n+      if (hasEntityName && entityTypeVals.contains(ConfigType.Ip)) {\n+        Seq(entityName, ip).filter(options.has(_)).map(options.valueOf(_)).foreach { ipAddress =>\n+          if (!Utils.validHostPattern(ipAddress))\n+            throw new IllegalArgumentException(s\"The entity name for ${entityTypeVals.head} must be a valid IP, but it is: $ipAddress\")\n+        }\n+      }\n+\n       if (options.has(describeOpt) && entityTypeVals.contains(BrokerLoggerConfigType) && !hasEntityName)\n         throw new IllegalArgumentException(s\"an entity name must be specified with --describe of ${entityTypeVals.mkString(\",\")}\")\n \n       if (options.has(alterOpt)) {\n-        if (entityTypeVals.contains(ConfigType.User) || entityTypeVals.contains(ConfigType.Client) || entityTypeVals.contains(ConfigType.Broker)) {\n+        if (entityTypeVals.contains(ConfigType.User) ||\n+            entityTypeVals.contains(ConfigType.Client) ||\n+            entityTypeVals.contains(ConfigType.Broker) ||\n+            entityTypeVals.contains(ConfigType.Ip)) {\n           if (!hasEntityName && !hasEntityDefault)\n             throw new IllegalArgumentException(\"an entity-name or default entity must be specified with --alter of users, clients or brokers\")", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MDMyNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536140324", "bodyText": "It seems that we should validate the provided ip somewhere here. I just tried with the following command:\n./bin/kafka-configs.sh --bootstrap-server localhost:9092 --alter --entity-type ips --entity-name ip --add-config  connection_creation_rate=10\n\nThe command completes but then the broker fails while applying the configuration:\n[2020-12-04 15:31:01,951] ERROR error processing change notification {\"version\":2,\"entity_path\":\"ips/ip\"} from /config/changes/config_change_0000000001 (kafka.common.ZkNodeChangeNotificationListener)\njava.lang.IllegalArgumentException: Unable to resolve address ip\n\tat kafka.server.IpConfigHandler.processConfigChanges(ConfigHandler.scala:199)\n\tat kafka.server.DynamicConfigManager$ConfigChangedNotificationHandler$.processEntityConfigChangeVersion2(DynamicConfigManager.scala:151)\n\tat kafka.server.DynamicConfigManager$ConfigChangedNotificationHandler$.$anonfun$processNotification$1(DynamicConfigManager.scala:105)\n\tat kafka.server.DynamicConfigManager$ConfigChangedNotificationHandler$.processNotification(DynamicConfigManager.scala:96)\n\tat kafka.common.ZkNodeChangeNotificationListener.$anonfun$processNotification$1(ZkNodeChangeNotificationListener.scala:106)\n\tat kafka.common.ZkNodeChangeNotificationListener.processNotification(ZkNodeChangeNotificationListener.scala:106)\n\tat kafka.common.ZkNodeChangeNotificationListener.$anonfun$processNotifications$2(ZkNodeChangeNotificationListener.scala:90)\n\tat kafka.common.ZkNodeChangeNotificationListener.$anonfun$processNotifications$2$adapted(ZkNodeChangeNotificationListener.scala:87)\n\tat scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)\n\tat scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)\n\tat scala.collection.AbstractIterable.foreach(Iterable.scala:919)\n\tat kafka.common.ZkNodeChangeNotificationListener.kafka$common$ZkNodeChangeNotificationListener$$processNotifications(ZkNodeChangeNotificationListener.scala:87)\n\tat kafka.common.ZkNodeChangeNotificationListener$ChangeNotification.process(ZkNodeChangeNotificationListener.scala:120)\n\tat kafka.common.ZkNodeChangeNotificationListener$ChangeEventProcessThread.doWork(ZkNodeChangeNotificationListener.scala:146)\n\tat kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:96)\n\nIt would be good to cover this in the tests, both for the command and the api.\nThis is also true with:\n./bin/kafka-configs.sh --zookeeper localhost:2181 --alter --ip ip --add-config connection_creation_rate=2", "author": "dajac", "createdAt": "2020-12-04T14:31:40Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -920,32 +954,51 @@ class AdminManager(val config: KafkaConfig,\n         !name.isDefined || !strict\n     }\n \n-    def fromProps(props: Map[String, String]): Map[String, Double] = {\n-      props.map { case (key, value) =>\n-        val doubleValue = try value.toDouble catch {\n-          case _: NumberFormatException =>\n-            throw new IllegalStateException(s\"Unexpected client quota configuration value: $key -> $value\")\n-        }\n-        key -> doubleValue\n-      }\n-    }\n-\n-    (userEntries ++ clientIdEntries ++ bothEntries).map { case ((u, c), p) =>\n+    (userEntries ++ clientIdEntries ++ bothEntries).flatMap { case ((u, c), p) =>\n       val quotaProps = p.asScala.filter { case (key, _) => QuotaConfigs.isQuotaConfig(key) }\n       if (quotaProps.nonEmpty && matches(userComponent, u) && matches(clientIdComponent, c))\n         Some(userClientIdToEntity(u, c) -> fromProps(quotaProps))\n       else\n         None\n-    }.flatten.toMap\n+    }.toMap\n+  }\n+\n+  def handleDescribeIpQuotas(ipComponent: Option[ClientQuotaFilterComponent], strict: Boolean): Map[ClientQuotaEntity, Map[String, Double]] = {\n+    val ip = ipComponent.flatMap(c => toOption(c.`match`))\n+    val exactIp = wantExact(ipComponent)\n+    val allIps = ipComponent.exists(_.`match` == null) || (ipComponent.isEmpty && !strict)\n+    val ipEntries = if (exactIp)\n+      Map(Some(ip.get) -> adminZkClient.fetchEntityConfig(ConfigType.Ip, sanitized(ip)))\n+    else if (allIps)\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.Ip).map { case (name, props) =>\n+        Some(desanitizeEntityName(name)) -> props\n+      }\n+    else\n+      Map.empty\n+\n+    def ipToQuotaEntity(ip: Option[String]): ClientQuotaEntity = {\n+      new ClientQuotaEntity(ip.map(ipName => ClientQuotaEntity.IP -> ipName).toMap.asJava)\n+    }\n+\n+    ipEntries.flatMap { case (ip, props) =>\n+      val ipQuotaProps = props.asScala.filter { case (key, _) => DynamicConfig.Ip.names.contains(key) }\n+      if (ipQuotaProps.nonEmpty)\n+        Some(ipToQuotaEntity(ip) -> fromProps(ipQuotaProps))\n+      else\n+        None\n+    }\n   }\n \n   def alterClientQuotas(entries: Seq[ClientQuotaAlteration], validateOnly: Boolean): Map[ClientQuotaEntity, ApiError] = {\n     def alterEntityQuotas(entity: ClientQuotaEntity, ops: Iterable[ClientQuotaAlteration.Op]): Unit = {\n-      val (path, configType, configKeys) = entityToSanitizedUserClientId(entity) match {\n-        case (Some(user), Some(clientId)) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (Some(user), None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (None, Some(clientId)) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n-        case _ => throw new InvalidRequestException(\"Invalid empty client quota entity\")\n+      val (path, configType, configKeys) = parseAndSanitizeQuotaEntity(entity) match {", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NzE1Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536147156", "bodyText": "It would be good to add these two flags in the KIP as well for completeness.", "author": "dajac", "createdAt": "2020-12-04T14:41:39Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -778,6 +793,10 @@ object ConfigCommand extends Config {\n     val brokerLogger = parser.accepts(\"broker-logger\", \"The broker's ID for its logger config.\")\n       .withRequiredArg\n       .ofType(classOf[String])\n+    val ipDefaults = parser.accepts(\"ip-defaults\", \"The config defaults for all IPs.\")\n+    val ip = parser.accepts(\"ip\", \"The IP address.\")", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzODQwNQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536238405", "bodyText": "will do, along with the change to lower", "author": "splett2", "createdAt": "2020-12-04T16:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NzE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0NTA1OA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r537945058", "bodyText": "done. while I was updating the KIP, i noticed that the previous config documentation was inconsistent with existing configs.\nDefault connection rate quotas for an IP address can be configured by omitting entity name.\nbin/kafka-configs  --bootstrap-server localhost:9091 --alter --add-config 'connection_creation_rate=100' --entity-type IPs\n\nThis isn't the case for any of the existing configs, you get an error:\nan entity-name or default entity must be specified with --alter of users, clients, brokers\nso I also updated the KIP for default IP to specify --entity-default.", "author": "splett2", "createdAt": "2020-12-08T00:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1NzgwNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536157804", "bodyText": "I think that we should validate that ipAddress is actually an IP. validHostPattern only ensure that it is a valid host name.", "author": "dajac", "createdAt": "2020-12-04T14:56:38Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -864,11 +885,21 @@ object ConfigCommand extends Config {\n         }\n       }\n \n+      if (hasEntityName && entityTypeVals.contains(ConfigType.Ip)) {\n+        Seq(entityName, ip).filter(options.has(_)).map(options.valueOf(_)).foreach { ipAddress =>\n+          if (!Utils.validHostPattern(ipAddress))", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTMzNw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536391337", "bodyText": "it looks like max.connections.per.ip permits hosts in addition to IPs.\n    val invalidAddresses = maxConnectionsPerIpOverrides.keys.filterNot(address => Utils.validHostPattern(address))\n    if (!invalidAddresses.isEmpty)\n      throw new IllegalArgumentException(s\"${KafkaConfig.MaxConnectionsPerIpOverridesProp} contains invalid addresses : ${invalidAddresses.mkString(\",\")}\")\n\nDo you think we should prefer consistency with the existing IP quota prop (e.g., permit any resolvable host address) or go for more strict enforcement (only IPs permitted)?", "author": "splett2", "createdAt": "2020-12-04T21:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1NzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxNTUwNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r537615504", "bodyText": "I think that we also permit hosts in our case as InetAddress.getByName resolves names that are not IP addresses. The issue is that Utils.validHostPattern is just a regex so it does not validate much.\nmax.connections.per.ip is validated in two phases. The code that you outlines is from the KafkaConfig. I suppose that we do a lightweight verification there in order to avoid doing any DNS resolution while parsing the config. This is later complemented in the socket server.\n  private[network] def updateMaxConnectionsPerIpOverride(overrideQuotas: Map[String, Int]): Unit = {\n    maxConnectionsPerIpOverrides = overrideQuotas.map { case (host, count) => (InetAddress.getByName(host), count) }\n  }\n\nIn our case, it is important to remain consistent everywhere.", "author": "dajac", "createdAt": "2020-12-07T15:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1NzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1OTE2MQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536159161", "bodyText": "nit: We can probably remove (_) in filter and map.", "author": "dajac", "createdAt": "2020-12-04T14:58:27Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -864,11 +885,21 @@ object ConfigCommand extends Config {\n         }\n       }\n \n+      if (hasEntityName && entityTypeVals.contains(ConfigType.Ip)) {\n+        Seq(entityName, ip).filter(options.has(_)).map(options.valueOf(_)).foreach { ipAddress =>", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MDg0Mw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536250843", "bodyText": "unexpectedly, I get a compile error if I remove (_) in map.\n[Error]~/kafka/core/src/main/scala/kafka/admin/ConfigCommand.scala:889: type mismatch;\n found   : [V](x$1: joptsimple.OptionSpec[V]): V <and> (x$1: String): Object\n required: joptsimple.ArgumentAcceptingOptionSpec[String] => ?\n\nI will keep it as is for both cases to avoid confusion, e.g. why do we use a function reference in filter, but not map", "author": "splett2", "createdAt": "2020-12-04T17:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1OTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2MjA2MA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536162060", "bodyText": "nit: Shouldn't we use (Some(_), Some(_), Some(_)) here in order to be really accurate? As it is, the first two could be anything. That works because it is after all the others but I would prefer to be explicit if possible.", "author": "dajac", "createdAt": "2020-12-04T15:02:32Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -920,32 +954,51 @@ class AdminManager(val config: KafkaConfig,\n         !name.isDefined || !strict\n     }\n \n-    def fromProps(props: Map[String, String]): Map[String, Double] = {\n-      props.map { case (key, value) =>\n-        val doubleValue = try value.toDouble catch {\n-          case _: NumberFormatException =>\n-            throw new IllegalStateException(s\"Unexpected client quota configuration value: $key -> $value\")\n-        }\n-        key -> doubleValue\n-      }\n-    }\n-\n-    (userEntries ++ clientIdEntries ++ bothEntries).map { case ((u, c), p) =>\n+    (userEntries ++ clientIdEntries ++ bothEntries).flatMap { case ((u, c), p) =>\n       val quotaProps = p.asScala.filter { case (key, _) => QuotaConfigs.isQuotaConfig(key) }\n       if (quotaProps.nonEmpty && matches(userComponent, u) && matches(clientIdComponent, c))\n         Some(userClientIdToEntity(u, c) -> fromProps(quotaProps))\n       else\n         None\n-    }.flatten.toMap\n+    }.toMap\n+  }\n+\n+  def handleDescribeIpQuotas(ipComponent: Option[ClientQuotaFilterComponent], strict: Boolean): Map[ClientQuotaEntity, Map[String, Double]] = {\n+    val ip = ipComponent.flatMap(c => toOption(c.`match`))\n+    val exactIp = wantExact(ipComponent)\n+    val allIps = ipComponent.exists(_.`match` == null) || (ipComponent.isEmpty && !strict)\n+    val ipEntries = if (exactIp)\n+      Map(Some(ip.get) -> adminZkClient.fetchEntityConfig(ConfigType.Ip, sanitized(ip)))\n+    else if (allIps)\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.Ip).map { case (name, props) =>\n+        Some(desanitizeEntityName(name)) -> props\n+      }\n+    else\n+      Map.empty\n+\n+    def ipToQuotaEntity(ip: Option[String]): ClientQuotaEntity = {\n+      new ClientQuotaEntity(ip.map(ipName => ClientQuotaEntity.IP -> ipName).toMap.asJava)\n+    }\n+\n+    ipEntries.flatMap { case (ip, props) =>\n+      val ipQuotaProps = props.asScala.filter { case (key, _) => DynamicConfig.Ip.names.contains(key) }\n+      if (ipQuotaProps.nonEmpty)\n+        Some(ipToQuotaEntity(ip) -> fromProps(ipQuotaProps))\n+      else\n+        None\n+    }\n   }\n \n   def alterClientQuotas(entries: Seq[ClientQuotaAlteration], validateOnly: Boolean): Map[ClientQuotaEntity, ApiError] = {\n     def alterEntityQuotas(entity: ClientQuotaEntity, ops: Iterable[ClientQuotaAlteration.Op]): Unit = {\n-      val (path, configType, configKeys) = entityToSanitizedUserClientId(entity) match {\n-        case (Some(user), Some(clientId)) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (Some(user), None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (None, Some(clientId)) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n-        case _ => throw new InvalidRequestException(\"Invalid empty client quota entity\")\n+      val (path, configType, configKeys) = parseAndSanitizeQuotaEntity(entity) match {\n+        case (Some(user), Some(clientId), None) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (Some(user), None, None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (None, Some(clientId), None) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n+        case (None, None, Some(ip)) => (ip, ConfigType.Ip, DynamicConfig.Ip.configKeys)\n+        case (_, _, Some(_)) => throw new InvalidRequestException(s\"Invalid quota entity combination, \" +", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0MDQxNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536240414", "bodyText": "i used (_, _, Some(_)) for this case, because we want to throw the more verbose exception in all of these cases:\n(Some(_), None, Some(_)) => specifying a user and IP, but no client\n(None, Some, Some) => specifying client and IP, but no user\n(Some, Some, Some) => specifying client, user and IP\nbasically any time there is a client OR user specified along with IP. I felt like adding all three cases would be pretty verbose, so I relied on the ordering of the cases instead.", "author": "splett2", "createdAt": "2020-12-04T16:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2MjA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxNTkyMA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r537615920", "bodyText": "Thanks for the explanation. That makes sense.", "author": "dajac", "createdAt": "2020-12-07T15:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2MjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2ODA1OA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536168058", "bodyText": "nit: Indentation seems wrong here.", "author": "dajac", "createdAt": "2020-12-04T15:11:17Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -398,19 +418,39 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     ConfigCommand.alterConfigWithZk(null, createOpts, new TestAdminZkClient(zkClient))\n   }\n \n-  def testShouldAddClientConfig(user: Option[String], clientId: Option[String]): Unit = {\n-    def toValues(entityName: Option[String], entityType: String, command: String):\n-        (Array[String], Option[String], Option[ClientQuotaFilterComponent]) = {\n-      entityName match {\n-        case Some(null) =>\n-          (Array(\"--entity-type\", command, \"--entity-default\"), Some(null),\n-            Some(ClientQuotaFilterComponent.ofDefaultEntity(entityType)))\n-        case Some(name) =>\n-          (Array(\"--entity-type\", command, \"--entity-name\", name), Some(name),\n-            Some(ClientQuotaFilterComponent.ofEntity(entityType, name)))\n-        case None => (Array.empty, None, None)\n+  @Test\n+  def shouldAddIpConfigsUsingZookeeper(): Unit = {\n+    val createOpts = new ConfigCommandOptions(Array(\"--zookeeper\", zkConnect,\n+      \"--entity-name\", \"1.2.3.4\",\n+      \"--entity-type\", \"ips\",\n+      \"--alter\",\n+      \"--add-config\", \"a=b,c=d\"))\n+\n+    class TestAdminZkClient(zkClient: KafkaZkClient) extends AdminZkClient(zkClient) {\n+      override def changeIpConfig(ip: String, configChange: Properties): Unit = {\n+        assertEquals(\"1.2.3.4\", ip)\n+        assertEquals(\"b\", configChange.get(\"a\"))\n+        assertEquals(\"d\", configChange.get(\"c\"))\n       }\n     }\n+\n+    ConfigCommand.alterConfigWithZk(null, createOpts, new TestAdminZkClient(zkClient))\n+  }\n+\n+  private def toValues(entityName: Option[String], entityType: String, command: String):\n+  (Array[String], Option[String], Option[ClientQuotaFilterComponent]) = {", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2OTgwNQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536169805", "bodyText": "Actually, I believe that the command should fail due to admin which is not valid IP. It may be better to use a valid IP address here as you want to tests the configs.", "author": "dajac", "createdAt": "2020-12-04T15:13:44Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -472,6 +512,134 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     EasyMock.reset(alterResult, describeResult)\n   }\n \n+  @Test\n+  def shouldNotAlterNonQuotaIpConfigsUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a connection quota\n+    // for ip entities\n+    val node = new Node(1, \"localhost\", 9092)\n+    val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node)\n+\n+    def verifyCommand(entityType: String, alterOpts: String*): Unit = {\n+      val opts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--entity-type\", entityType, \"--entity-name\", \"admin\",", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4MDQxOA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536180418", "bodyText": "Have you considered using a real mock instead of doing this? Is there a reason not to? It seems to be that it would be more appropriate.", "author": "dajac", "createdAt": "2020-12-04T15:28:10Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -472,6 +512,134 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     EasyMock.reset(alterResult, describeResult)\n   }\n \n+  @Test\n+  def shouldNotAlterNonQuotaIpConfigsUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a connection quota\n+    // for ip entities\n+    val node = new Node(1, \"localhost\", 9092)\n+    val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node)\n+\n+    def verifyCommand(entityType: String, alterOpts: String*): Unit = {\n+      val opts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--entity-type\", entityType, \"--entity-name\", \"admin\",\n+        \"--alter\") ++ alterOpts)\n+      val e = intercept[IllegalArgumentException] {\n+        ConfigCommand.alterConfig(mockAdminClient, opts)\n+      }\n+      assertTrue(s\"Unexpected exception: $e\", e.getMessage.contains(\"some_config\"))\n+    }\n+\n+    verifyCommand(\"ips\", \"--add-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--add-config\", \"some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"some_config=10\")\n+  }\n+\n+  @Test\n+  def testDescribeIpConfigs(): Unit = {\n+    def testShouldDescribeIpConfig(ip: Option[String]): Unit = {\n+      val entityType = ClientQuotaEntity.IP\n+      val (ipArgs, filterComponent) = ip match {\n+        case Some(null) => (Array(\"--entity-default\"), ClientQuotaFilterComponent.ofDefaultEntity(entityType))\n+        case Some(addr) => (Array(\"--entity-name\", addr), ClientQuotaFilterComponent.ofEntity(entityType, addr))\n+        case None => (Array.empty[String], ClientQuotaFilterComponent.ofEntityType(entityType))\n+      }\n+\n+      val describeOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--describe\", \"--entity-type\", \"ips\") ++ ipArgs)\n+\n+      val expectedFilter = ClientQuotaFilter.containsOnly(List(filterComponent).asJava)\n+\n+      var describedConfigs = false\n+      val describeFuture = new KafkaFutureImpl[util.Map[ClientQuotaEntity, util.Map[String, java.lang.Double]]]\n+      describeFuture.complete(Map.empty[ClientQuotaEntity, util.Map[String, java.lang.Double]].asJava)\n+      val describeResult: DescribeClientQuotasResult = EasyMock.createNiceMock(classOf[DescribeClientQuotasResult])\n+      EasyMock.expect(describeResult.entities()).andReturn(describeFuture)\n+\n+      val node = new Node(1, \"localhost\", 9092)\n+      val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node) {\n+        override def describeClientQuotas(filter: ClientQuotaFilter, options: DescribeClientQuotasOptions): DescribeClientQuotasResult = {\n+          assertTrue(filter.strict)\n+          assertEquals(expectedFilter, filter)\n+          describedConfigs = true\n+          describeResult\n+        }\n+      }", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NzU5NQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536257595", "bodyText": "hmm, good point. I did this because it's what a similar quotas config command test did, but you're right that a real mock would be more appropriate here.", "author": "splett2", "createdAt": "2020-12-04T17:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4MDQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNzE4MA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r537937180", "bodyText": "I took an attempt at this, and realized that the reason we use MockAdminClient is because ClientQuotaFilter and ClientQuotaAlteration take Collection in their constructors.\nIf we used a real mock, it would make the tests unnecessarily brittle, since we'd have to match the collection type used in the ConfigCommand implementation.", "author": "splett2", "createdAt": "2020-12-08T00:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4MDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4MTQ5Mw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536181493", "bodyText": "ditto", "author": "dajac", "createdAt": "2020-12-04T15:29:39Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -472,6 +512,134 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     EasyMock.reset(alterResult, describeResult)\n   }\n \n+  @Test\n+  def shouldNotAlterNonQuotaIpConfigsUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a connection quota\n+    // for ip entities\n+    val node = new Node(1, \"localhost\", 9092)\n+    val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node)\n+\n+    def verifyCommand(entityType: String, alterOpts: String*): Unit = {\n+      val opts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--entity-type\", entityType, \"--entity-name\", \"admin\",\n+        \"--alter\") ++ alterOpts)\n+      val e = intercept[IllegalArgumentException] {\n+        ConfigCommand.alterConfig(mockAdminClient, opts)\n+      }\n+      assertTrue(s\"Unexpected exception: $e\", e.getMessage.contains(\"some_config\"))\n+    }\n+\n+    verifyCommand(\"ips\", \"--add-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--add-config\", \"some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"some_config=10\")\n+  }\n+\n+  @Test\n+  def testDescribeIpConfigs(): Unit = {\n+    def testShouldDescribeIpConfig(ip: Option[String]): Unit = {\n+      val entityType = ClientQuotaEntity.IP\n+      val (ipArgs, filterComponent) = ip match {\n+        case Some(null) => (Array(\"--entity-default\"), ClientQuotaFilterComponent.ofDefaultEntity(entityType))\n+        case Some(addr) => (Array(\"--entity-name\", addr), ClientQuotaFilterComponent.ofEntity(entityType, addr))\n+        case None => (Array.empty[String], ClientQuotaFilterComponent.ofEntityType(entityType))\n+      }\n+\n+      val describeOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--describe\", \"--entity-type\", \"ips\") ++ ipArgs)\n+\n+      val expectedFilter = ClientQuotaFilter.containsOnly(List(filterComponent).asJava)\n+\n+      var describedConfigs = false\n+      val describeFuture = new KafkaFutureImpl[util.Map[ClientQuotaEntity, util.Map[String, java.lang.Double]]]\n+      describeFuture.complete(Map.empty[ClientQuotaEntity, util.Map[String, java.lang.Double]].asJava)\n+      val describeResult: DescribeClientQuotasResult = EasyMock.createNiceMock(classOf[DescribeClientQuotasResult])\n+      EasyMock.expect(describeResult.entities()).andReturn(describeFuture)\n+\n+      val node = new Node(1, \"localhost\", 9092)\n+      val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node) {\n+        override def describeClientQuotas(filter: ClientQuotaFilter, options: DescribeClientQuotasOptions): DescribeClientQuotasResult = {\n+          assertTrue(filter.strict)\n+          assertEquals(expectedFilter, filter)\n+          describedConfigs = true\n+          describeResult\n+        }\n+      }\n+      EasyMock.replay(describeResult)\n+      ConfigCommand.describeConfig(mockAdminClient, describeOpts)\n+      assertTrue(describedConfigs)\n+      EasyMock.reset(describeResult)\n+    }\n+\n+    testShouldDescribeIpConfig(Some(\"1.2.3.4\"))\n+    testShouldDescribeIpConfig(Some(null))\n+    testShouldDescribeIpConfig(None)\n+  }\n+\n+  @Test\n+  def testAlterIpConfig(): Unit = {\n+    def testShouldAlterIpConfig(ip: Option[String], remove: Boolean): Unit = {\n+      val (ipArgs, ipEntity, ipComponent) = toValues(ip, ClientQuotaEntity.IP, \"ips\")\n+      val alterOpts = if (remove)\n+        Array(\"--delete-config\", \"connection_creation_rate\")\n+      else\n+        Array(\"--add-config\", \"connection_creation_rate=100\")\n+      val createOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--alter\") ++ ipArgs ++ alterOpts)\n+\n+      // Explicitly populate a HashMap to ensure nulls are recorded properly.\n+      val entityMap = new java.util.HashMap[String, String]\n+      ipEntity.foreach(u => entityMap.put(ClientQuotaEntity.IP, u))\n+      val entity = new ClientQuotaEntity(entityMap)\n+\n+      var describedConfigs = false\n+      val describeFuture = new KafkaFutureImpl[util.Map[ClientQuotaEntity, util.Map[String, java.lang.Double]]]\n+      describeFuture.complete(Map(entity -> Map(\"connection_creation_rate\" -> Double.box(50.0)).asJava).asJava)\n+      val describeResult: DescribeClientQuotasResult = EasyMock.createNiceMock(classOf[DescribeClientQuotasResult])\n+      EasyMock.expect(describeResult.entities()).andReturn(describeFuture)\n+\n+      var alteredConfigs = false\n+      val alterFuture = new KafkaFutureImpl[Void]\n+      alterFuture.complete(null)\n+      val alterResult: AlterClientQuotasResult = EasyMock.createNiceMock(classOf[AlterClientQuotasResult])\n+      EasyMock.expect(alterResult.all()).andReturn(alterFuture)\n+\n+      val node = new Node(1, \"localhost\", 9092)\n+      val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node) {", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4MjE2Nw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536182167", "bodyText": "We must add tests with invalid IPs.", "author": "dajac", "createdAt": "2020-12-04T15:30:34Z", "path": "core/src/test/scala/unit/kafka/server/ClientQuotasRequestTest.scala", "diffHunk": "@@ -187,6 +190,59 @@ class ClientQuotasRequestTest extends BaseRequestTest {\n     ))\n   }\n \n+  @Test\n+  def testAlterIpQuotasRequest(): Unit = {", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4NTUwOQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536185509", "bodyText": "nit: I feel like this inner method is quite large and may merit to be extracted. It feels a bit weird when the inner method is way larger than the actual body of the method. I guess that it is a matter of taste but I believe that the code would be more readable. I leave this up to you.", "author": "dajac", "createdAt": "2020-12-04T15:35:31Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -472,6 +512,134 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     EasyMock.reset(alterResult, describeResult)\n   }\n \n+  @Test\n+  def shouldNotAlterNonQuotaIpConfigsUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a connection quota\n+    // for ip entities\n+    val node = new Node(1, \"localhost\", 9092)\n+    val mockAdminClient = new MockAdminClient(util.Collections.singletonList(node), node)\n+\n+    def verifyCommand(entityType: String, alterOpts: String*): Unit = {\n+      val opts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n+        \"--entity-type\", entityType, \"--entity-name\", \"admin\",\n+        \"--alter\") ++ alterOpts)\n+      val e = intercept[IllegalArgumentException] {\n+        ConfigCommand.alterConfig(mockAdminClient, opts)\n+      }\n+      assertTrue(s\"Unexpected exception: $e\", e.getMessage.contains(\"some_config\"))\n+    }\n+\n+    verifyCommand(\"ips\", \"--add-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--add-config\", \"some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"connection_creation_rate=10000,some_config=10\")\n+    verifyCommand(\"ips\", \"--delete-config\", \"some_config=10\")\n+  }\n+\n+  @Test\n+  def testDescribeIpConfigs(): Unit = {\n+    def testShouldDescribeIpConfig(ip: Option[String]): Unit = {", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNzYwMw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r537937603", "bodyText": "done. refactored the method to be more generic as well, to reduce some code duplication with an existing test.", "author": "splett2", "createdAt": "2020-12-08T00:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4NTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4NjkzNg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536186936", "bodyText": "This is not related to your PR but I wonder if it would be possible to replace this sleep by retry or waitUntilTrue. Thoughts?", "author": "dajac", "createdAt": "2020-12-04T15:37:36Z", "path": "core/src/test/scala/unit/kafka/server/ClientQuotasRequestTest.scala", "diffHunk": "@@ -236,13 +310,22 @@ class ClientQuotasRequestTest extends BaseRequestTest {\n     (Some(\"user-3\"), None, 58.58),\n     (Some(null), None, 59.59),\n     (None, Some(\"client-id-2\"), 60.60)\n-  ).map { case (u, c, v) => (toEntity(u, c), v) }\n+  ).map { case (u, c, v) => (toClientEntity(u, c), v) }\n+\n+  private val matchIpEntities = List(\n+    (Some(\"1.2.3.4\"), 10.0),\n+    (Some(\"2.3.4.5\"), 20.0)\n+  ).map { case (ip, quota) => (toIpEntity(ip), quota)}\n \n   private def setupDescribeClientQuotasMatchTest() = {\n-    val result = alterClientQuotas(matchEntities.map { case (e, v) =>\n-      (e -> Map((RequestPercentageProp, Some(v))))\n-    }.toMap, validateOnly = false)\n-    matchEntities.foreach(e => result.get(e._1).get.get(10, TimeUnit.SECONDS))\n+    val userClientQuotas = matchUserClientEntities.map { case (e, v) =>\n+      e -> Map((RequestPercentageProp, Some(v)))\n+    }.toMap\n+    val ipQuotas = matchIpEntities.map { case (e, v) =>\n+      e -> Map((IpConnectionRateProp, Some(v)))\n+    }.toMap\n+    val result = alterClientQuotas(userClientQuotas ++ ipQuotas, validateOnly = false)\n+    (matchUserClientEntities ++ matchIpEntities).foreach(e => result(e._1).get(10, TimeUnit.SECONDS))\n \n     // Allow time for watch callbacks to be triggered.\n     Thread.sleep(500)", "originalCommit": "f9e14cc25e5f8003e108202d09c90cf20d8ab179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0MTU5Nw==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r536241597", "bodyText": "makes sense, will do.\nActually, taking a closer look, there is no need for the Thread.sleep() call. None of the tests that use the match setup rely on ZK watches to trigger. I'll just remove the call to Thread.sleep() instead.", "author": "splett2", "createdAt": "2020-12-04T16:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4NjkzNg=="}], "type": "inlineReview"}, {"oid": "a59b1c850b0577d64aab5cd7286f29ce205d97fd", "url": "https://github.com/apache/kafka/commit/a59b1c850b0577d64aab5cd7286f29ce205d97fd", "message": "address feedback, refactor ConfigCommandTest", "committedDate": "2020-12-07T23:00:41Z", "type": "commit"}, {"oid": "6bee345cb763c303215fcd5fe073ba7ca65f95fa", "url": "https://github.com/apache/kafka/commit/6bee345cb763c303215fcd5fe073ba7ca65f95fa", "message": "More thorough verification of IP entity input", "committedDate": "2020-12-08T00:19:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ3NTM3Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r538475376", "bodyText": "It is a little weird to throw InvalidRequestException here because there is not request involved. Users of AdminZkClient may not expect this. I think that it would be better to throw a IllegalArgumentException. Then in the AdminManager#alterClientQuotas, we can catch it and transform it into InvalidRequestException by copying the internal message.", "author": "dajac", "createdAt": "2020-12-08T15:07:11Z", "path": "core/src/main/scala/kafka/zk/AdminZkClient.scala", "diffHunk": "@@ -394,8 +393,7 @@ class AdminZkClient(zkClient: KafkaZkClient) extends Logging {\n    * @param configs properties to validate for the IP\n    */\n   def validateIpConfig(ip: String, configs: Properties): Unit = {\n-    if (ip != ConfigEntityName.Default && !Utils.validHostPattern(ip))\n-      throw new AdminOperationException(s\"IP $ip is not a valid address.\")\n+    DynamicConfig.Ip.validateIpOrHost(ip)", "originalCommit": "6bee345cb763c303215fcd5fe073ba7ca65f95fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ3NzI0NA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r538477244", "bodyText": "ditto here. It is a bit weird to have an InvalidRequestException thrown here.", "author": "dajac", "createdAt": "2020-12-08T15:08:49Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -864,13 +885,20 @@ object ConfigCommand extends Config {\n         }\n       }\n \n+      if (hasEntityName && entityTypeVals.contains(ConfigType.Ip)) {\n+        Seq(entityName, ip).filter(options.has(_)).map(options.valueOf(_)).foreach(DynamicConfig.Ip.validateIpOrHost)", "originalCommit": "6bee345cb763c303215fcd5fe073ba7ca65f95fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ3ODY0Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r538478646", "bodyText": "I wonder if this step is really necessary as InetAddress.getByName also ensures that the hostname is valid. What do you think?", "author": "dajac", "createdAt": "2020-12-08T15:10:00Z", "path": "core/src/main/scala/kafka/server/DynamicConfig.scala", "diffHunk": "@@ -141,6 +144,18 @@ object DynamicConfig {\n     def names = ipConfigs.names\n \n     def validate(props: Properties) = DynamicConfig.validate(ipConfigs, props, customPropsAllowed = false)\n+\n+    def validateIpOrHost(ip: String): Unit = {\n+      if (ip != ConfigEntityName.Default) {\n+        if (!Utils.validHostPattern(ip))\n+          throw new InvalidRequestException(s\"$ip is not a valid hostname\")", "originalCommit": "6bee345cb763c303215fcd5fe073ba7ca65f95fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ3ODk0Ng==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r538478946", "bodyText": "nit: _ :UnknownHostException => _: UnknownHostException", "author": "dajac", "createdAt": "2020-12-08T15:10:17Z", "path": "core/src/main/scala/kafka/server/DynamicConfig.scala", "diffHunk": "@@ -141,6 +144,18 @@ object DynamicConfig {\n     def names = ipConfigs.names\n \n     def validate(props: Properties) = DynamicConfig.validate(ipConfigs, props, customPropsAllowed = false)\n+\n+    def validateIpOrHost(ip: String): Unit = {\n+      if (ip != ConfigEntityName.Default) {\n+        if (!Utils.validHostPattern(ip))\n+          throw new InvalidRequestException(s\"$ip is not a valid hostname\")\n+        try {\n+          InetAddress.getByName(ip)\n+        } catch {\n+          case _ :UnknownHostException => throw new InvalidRequestException(s\"$ip is not a valid IP or resolvable hostname\")", "originalCommit": "6bee345cb763c303215fcd5fe073ba7ca65f95fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b0ec2a3ca79dc8da5908c41afc4ef87d2288d84", "url": "https://github.com/apache/kafka/commit/1b0ec2a3ca79dc8da5908c41afc4ef87d2288d84", "message": "address feedback", "committedDate": "2020-12-08T16:39:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzNjE0MQ==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r539136141", "bodyText": "For my understanding, have you chosen to do the validation here to ensure that requests with validateOnly = true are fully validated?\nInitially, I thought that we could just catch the IllegalArgumentException here \n  \n    \n      kafka/core/src/main/scala/kafka/server/AdminManager.scala\n    \n    \n         Line 1043\n      in\n      1b0ec2a\n    \n    \n    \n    \n\n        \n          \n           } catch { \n        \n    \n  \n\n. Doing the conversion here seems reasonable as well. Alternatively, we could also change validateIpOrHost to return a boolean and let the caller decides which exception to throw.", "author": "dajac", "createdAt": "2020-12-09T09:16:20Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -920,32 +954,57 @@ class AdminManager(val config: KafkaConfig,\n         !name.isDefined || !strict\n     }\n \n-    def fromProps(props: Map[String, String]): Map[String, Double] = {\n-      props.map { case (key, value) =>\n-        val doubleValue = try value.toDouble catch {\n-          case _: NumberFormatException =>\n-            throw new IllegalStateException(s\"Unexpected client quota configuration value: $key -> $value\")\n-        }\n-        key -> doubleValue\n-      }\n-    }\n-\n-    (userEntries ++ clientIdEntries ++ bothEntries).map { case ((u, c), p) =>\n+    (userEntries ++ clientIdEntries ++ bothEntries).flatMap { case ((u, c), p) =>\n       val quotaProps = p.asScala.filter { case (key, _) => QuotaConfigs.isQuotaConfig(key) }\n       if (quotaProps.nonEmpty && matches(userComponent, u) && matches(clientIdComponent, c))\n         Some(userClientIdToEntity(u, c) -> fromProps(quotaProps))\n       else\n         None\n-    }.flatten.toMap\n+    }.toMap\n+  }\n+\n+  def handleDescribeIpQuotas(ipComponent: Option[ClientQuotaFilterComponent], strict: Boolean): Map[ClientQuotaEntity, Map[String, Double]] = {\n+    val ip = ipComponent.flatMap(c => toOption(c.`match`))\n+    val exactIp = wantExact(ipComponent)\n+    val allIps = ipComponent.exists(_.`match` == null) || (ipComponent.isEmpty && !strict)\n+    val ipEntries = if (exactIp)\n+      Map(Some(ip.get) -> adminZkClient.fetchEntityConfig(ConfigType.Ip, sanitized(ip)))\n+    else if (allIps)\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.Ip).map { case (name, props) =>\n+        Some(desanitizeEntityName(name)) -> props\n+      }\n+    else\n+      Map.empty\n+\n+    def ipToQuotaEntity(ip: Option[String]): ClientQuotaEntity = {\n+      new ClientQuotaEntity(ip.map(ipName => ClientQuotaEntity.IP -> ipName).toMap.asJava)\n+    }\n+\n+    ipEntries.flatMap { case (ip, props) =>\n+      val ipQuotaProps = props.asScala.filter { case (key, _) => DynamicConfig.Ip.names.contains(key) }\n+      if (ipQuotaProps.nonEmpty)\n+        Some(ipToQuotaEntity(ip) -> fromProps(ipQuotaProps))\n+      else\n+        None\n+    }\n   }\n \n   def alterClientQuotas(entries: Seq[ClientQuotaAlteration], validateOnly: Boolean): Map[ClientQuotaEntity, ApiError] = {\n     def alterEntityQuotas(entity: ClientQuotaEntity, ops: Iterable[ClientQuotaAlteration.Op]): Unit = {\n-      val (path, configType, configKeys) = entityToSanitizedUserClientId(entity) match {\n-        case (Some(user), Some(clientId)) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (Some(user), None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n-        case (None, Some(clientId)) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n-        case _ => throw new InvalidRequestException(\"Invalid empty client quota entity\")\n+      val (path, configType, configKeys) = parseAndSanitizeQuotaEntity(entity) match {\n+        case (Some(user), Some(clientId), None) => (user + \"/clients/\" + clientId, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (Some(user), None, None) => (user, ConfigType.User, DynamicConfig.User.configKeys)\n+        case (None, Some(clientId), None) => (clientId, ConfigType.Client, DynamicConfig.Client.configKeys)\n+        case (None, None, Some(ip)) =>\n+          try {\n+            DynamicConfig.Ip.validateIpOrHost(ip)\n+          } catch {\n+            case e: IllegalArgumentException => throw new InvalidRequestException(e.getMessage)\n+          }", "originalCommit": "1b0ec2a3ca79dc8da5908c41afc4ef87d2288d84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NTYwMg==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r539455602", "bodyText": "@dajac\nyes, I thought that catching in that block would work, but after taking a closer look, it seems like entity validation is only done when altering, so we wouldn't hit validation in the validateOnly = true case.\nI think changing validateIpOrHost to return a boolean is reasonable. I originally wanted to have it throw exception instead of boolean since we had two validation steps (validHostPattern and then resolvable IP), but since we simplified that code block to only do host resolution, it makes more sense to have it just return a boolean.", "author": "splett2", "createdAt": "2020-12-09T16:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzNjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzODAwNA==", "url": "https://github.com/apache/kafka/pull/9628#discussion_r539138004", "bodyText": "For these three tests, would it make sense to also verify that the error message? InvalidRequestException are thrown all over the place so we may get one but not for the expected cause. Your last commit suggests that you got caught by this already, is it? 1b0ec2a#diff-f02b619b5cd14e83f7e21dbe211b3f88336f825e1ee5c630fee32b8a0fbe3d20R294", "author": "dajac", "createdAt": "2020-12-09T09:18:55Z", "path": "core/src/test/scala/unit/kafka/server/ClientQuotasRequestTest.scala", "diffHunk": "@@ -223,8 +279,34 @@ class ClientQuotasRequestTest extends BaseRequestTest {\n     alterEntityQuotas(entity, Map((ProducerByteRateProp -> Some(10000.5))), validateOnly = true)\n   }\n \n+  @Test\n+  def testAlterClientQuotasInvalidEntityCombination(): Unit = {", "originalCommit": "1b0ec2a3ca79dc8da5908c41afc4ef87d2288d84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a781ee70fd166c1e0773da21112a2dcd721b658a", "url": "https://github.com/apache/kafka/commit/a781ee70fd166c1e0773da21112a2dcd721b658a", "message": "address feedback", "committedDate": "2020-12-09T17:21:55Z", "type": "commit"}]}