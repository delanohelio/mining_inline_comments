{"pr_number": 9430, "pr_title": "KAFKA-5235: GetOffsetShell: support for multiple topics and consumer configuration override", "pr_createdAt": "2020-10-14T06:52:59Z", "pr_url": "https://github.com/apache/kafka/pull/9430", "timeline": [{"oid": "512461ec3b43a4381cf0e07cad799d5e6e396ed6", "url": "https://github.com/apache/kafka/commit/512461ec3b43a4381cf0e07cad799d5e6e396ed6", "message": "KAFKA-5235: Unit tests for GetOffsetShell", "committedDate": "2020-11-19T10:31:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE1ODY2MA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558158660", "bodyText": "Is having empty string as default necessary? It shows as (default: ) in the description which looks weird.", "author": "dajac", "createdAt": "2021-01-15T09:53:12Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -33,15 +35,26 @@ object GetOffsetShell {\n \n   def main(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionOpt = parser.accepts(\"topic-partitions\", \"Comma separated list of topic-partition specifications to get the offsets for, with the format of topic:partition. The 'topic' part can be a regex or may be omitted to only specify the partitions, and query all authorized topics.\" +\n+                                            \" The 'partition' part can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions of the specified topic.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic:partition,...,topic:partition\")\n+                           .ofType(classOf[String])\n+                           .defaultsTo(\"\")", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY2Nzk3OQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563667979", "bodyText": "Not at all, thank you for catching this", "author": "urbandan", "createdAt": "2021-01-25T11:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE1ODY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2NDU5OQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558164599", "bodyText": "We should replace $topicPartitionOpt by --topic-partitions in order to remain consistent with the other descriptions. $topicPartitionOpt generates [topic-partitions] in the description.", "author": "dajac", "createdAt": "2021-01-15T09:56:56Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -33,15 +35,26 @@ object GetOffsetShell {\n \n   def main(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionOpt = parser.accepts(\"topic-partitions\", \"Comma separated list of topic-partition specifications to get the offsets for, with the format of topic:partition. The 'topic' part can be a regex or may be omitted to only specify the partitions, and query all authorized topics.\" +\n+                                            \" The 'partition' part can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions of the specified topic.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic:partition,...,topic:partition\")\n+                           .ofType(classOf[String])\n+                           .defaultsTo(\"\")\n+    val topicOpt = parser.accepts(\"topic\", s\"The topic to get the offsets for. It also accepts a regular expression. If not present, all authorized topics are queried. Ignored if $topicPartitionOpt is present.\")", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY2OTM5OQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563669399", "bodyText": "Thanks, fixed it", "author": "urbandan", "createdAt": "2021-01-25T11:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2NDU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2NDg2NA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558164864", "bodyText": "ditto", "author": "dajac", "createdAt": "2021-01-15T09:57:04Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -33,15 +35,26 @@ object GetOffsetShell {\n \n   def main(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionOpt = parser.accepts(\"topic-partitions\", \"Comma separated list of topic-partition specifications to get the offsets for, with the format of topic:partition. The 'topic' part can be a regex or may be omitted to only specify the partitions, and query all authorized topics.\" +\n+                                            \" The 'partition' part can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions of the specified topic.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic:partition,...,topic:partition\")\n+                           .ofType(classOf[String])\n+                           .defaultsTo(\"\")\n+    val topicOpt = parser.accepts(\"topic\", s\"The topic to get the offsets for. It also accepts a regular expression. If not present, all authorized topics are queried. Ignored if $topicPartitionOpt is present.\")\n                            .withRequiredArg\n                            .describedAs(\"topic\")\n                            .ofType(classOf[String])\n-    val partitionOpt = parser.accepts(\"partitions\", \"comma separated list of partition ids. If not specified, it will find offsets for all partitions\")\n+    val partitionOpt = parser.accepts(\"partitions\", s\"Comma separated list of partition ids to get the offsets for. If not present, all partitions of the authorized topics are queried. Ignored if $topicPartitionOpt is present.\")", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3MDEzNg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558170136", "bodyText": "How about Property file containing configs to be passed to Consumer Client. to remain inline with description of that field used by other command line tools?", "author": "dajac", "createdAt": "2021-01-15T10:00:09Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -51,28 +64,30 @@ object GetOffsetShell {\n                            .describedAs(\"timestamp/-1(latest)/-2(earliest)\")\n                            .ofType(classOf[java.lang.Long])\n                            .defaultsTo(-1L)\n-    parser.accepts(\"offsets\", \"DEPRECATED AND IGNORED: number of offsets returned\")\n-                           .withRequiredArg\n-                           .describedAs(\"count\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1)\n-    parser.accepts(\"max-wait-ms\", \"DEPRECATED AND IGNORED: The max amount of time each fetch request waits.\")\n+    val commandConfigOpt = parser.accepts(\"command-config\", s\"Consumer config properties file.\")", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3ODU1NA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558178554", "bodyText": "Should we also verify combination of arguments that are not valid? I am thinking about --topic-partitions vs --topic and --partitions. That would be better than silently ignoring.", "author": "dajac", "createdAt": "2021-01-15T10:05:31Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -51,28 +64,30 @@ object GetOffsetShell {\n                            .describedAs(\"timestamp/-1(latest)/-2(earliest)\")\n                            .ofType(classOf[java.lang.Long])\n                            .defaultsTo(-1L)\n-    parser.accepts(\"offsets\", \"DEPRECATED AND IGNORED: number of offsets returned\")\n-                           .withRequiredArg\n-                           .describedAs(\"count\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1)\n-    parser.accepts(\"max-wait-ms\", \"DEPRECATED AND IGNORED: The max amount of time each fetch request waits.\")\n+    val commandConfigOpt = parser.accepts(\"command-config\", s\"Consumer config properties file.\")\n                            .withRequiredArg\n-                           .describedAs(\"ms\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1000)\n+                           .describedAs(\"config file\")\n+                           .ofType(classOf[String])\n+    val excludeInternalTopicsOpt = parser.accepts(\"exclude-internal-topics\", s\"By default, internal topics are included. If specified, internal topics are excluded.\")\n \n-   if (args.length == 0)\n-      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic offsets.\")\n+    if (args.length == 0)", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY2OTg5NQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563669895", "bodyText": "I agree, good catch", "author": "urbandan", "createdAt": "2021-01-25T12:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3ODU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE5NTIxNw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558195217", "bodyText": "nit: We usually structure blocks as follow:\nruleSpecs.map { ruleSpec => \n  ...\n}\n\nWe can avoid the parenthesis.", "author": "dajac", "createdAt": "2021-01-15T10:17:28Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxMzk1NQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558213955", "bodyText": "Let's try to remain inline with https://cwiki.apache.org/confluence/display/KAFKA/KIP-629%3A+Use+racially+neutral+terms+in+our+codebase. We should name the variable includeList.", "author": "dajac", "createdAt": "2021-01-15T10:30:50Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {\n+      val parts = ruleSpec.split(\":\")\n+      if (parts.length == 1) {\n+        val whitelist = IncludeList(parts(0))", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MDQ0Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563670443", "bodyText": "Thanks for the catch", "author": "urbandan", "createdAt": "2021-01-25T12:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxMzk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxNjQ3Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558216473", "bodyText": "Should we handle the case where it is not a number and provide a meaning full error to the user?", "author": "dajac", "createdAt": "2021-01-15T10:32:57Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {\n+      val parts = ruleSpec.split(\":\")\n+      if (parts.length == 1) {\n+        val whitelist = IncludeList(parts(0))\n+        tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics)\n+      } else if (parts.length == 2) {\n+        val partitionFilter = createPartitionFilter(parts(1))\n+\n+        if (parts(0).trim().isEmpty) {\n+          tp: PartitionInfo => partitionFilter.apply(tp.partition)\n+        } else {\n+          val whitelist = IncludeList(parts(0))\n+          tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics) && partitionFilter.apply(tp.partition)\n+        }\n+      } else {\n+        throw new IllegalArgumentException(s\"Invalid topic-partition rule: $ruleSpec\")\n+      }\n+    })\n+\n+    tp => rules.exists(rule => rule.apply(tp))\n+  }\n+\n+  /**\n+   * Creates a partition filter based on a single id or a range.\n+   * Expected format:\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n+   */\n+  private def createPartitionFilter(spec: String): Int => Boolean = {\n+    if (spec.indexOf('-') != -1) {\n+      val rangeParts = spec.split(\"-\", -1)\n+      if(rangeParts.length != 2 || rangeParts(0).isEmpty && rangeParts(1).isEmpty) {\n+        throw new IllegalArgumentException(s\"Invalid range specification: $spec\")\n+      }\n+\n+      if(rangeParts(0).isEmpty) {\n+        val max = rangeParts(1).toInt\n+        partition: Int => partition < max\n+      } else if(rangeParts(1).isEmpty) {\n+        val min = rangeParts(0).toInt\n+        partition: Int => partition >= min\n+      } else {\n+        val min = rangeParts(0).toInt\n+        val max = rangeParts(1).toInt\n+\n+        if (min > max) {\n+          throw new IllegalArgumentException(s\"Range lower bound cannot be greater than upper bound: $spec\")\n+        }\n+\n+        partition: Int => partition >= min && partition < max\n+      }\n+    } else {\n+      val number = spec.toInt", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3Mjc2NA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563672764", "bodyText": "You are right, should be handled, fixed it", "author": "urbandan", "createdAt": "2021-01-25T12:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxNjQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyMDkzNA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558220934", "bodyText": "nit: A space is missing after if. There are couple of similar cases below.", "author": "dajac", "createdAt": "2021-01-15T10:38:38Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {\n+      val parts = ruleSpec.split(\":\")\n+      if (parts.length == 1) {\n+        val whitelist = IncludeList(parts(0))\n+        tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics)\n+      } else if (parts.length == 2) {\n+        val partitionFilter = createPartitionFilter(parts(1))\n+\n+        if (parts(0).trim().isEmpty) {\n+          tp: PartitionInfo => partitionFilter.apply(tp.partition)\n+        } else {\n+          val whitelist = IncludeList(parts(0))\n+          tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics) && partitionFilter.apply(tp.partition)\n+        }\n+      } else {\n+        throw new IllegalArgumentException(s\"Invalid topic-partition rule: $ruleSpec\")\n+      }\n+    })\n+\n+    tp => rules.exists(rule => rule.apply(tp))\n+  }\n+\n+  /**\n+   * Creates a partition filter based on a single id or a range.\n+   * Expected format:\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n+   */\n+  private def createPartitionFilter(spec: String): Int => Boolean = {\n+    if (spec.indexOf('-') != -1) {\n+      val rangeParts = spec.split(\"-\", -1)\n+      if(rangeParts.length != 2 || rangeParts(0).isEmpty && rangeParts(1).isEmpty) {", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTUwMw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558225503", "bodyText": "Could we simplify this block to something like the following?\nval topicFilter = IncludeList(topicOpt.getOrElse(\".*\"))\nt => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics)) && (partitionIds.isEmpty || partitionIds.contains(t.partition))", "author": "dajac", "createdAt": "2021-01-15T10:47:06Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {\n+      val parts = ruleSpec.split(\":\")\n+      if (parts.length == 1) {\n+        val whitelist = IncludeList(parts(0))\n+        tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics)\n+      } else if (parts.length == 2) {\n+        val partitionFilter = createPartitionFilter(parts(1))\n+\n+        if (parts(0).trim().isEmpty) {\n+          tp: PartitionInfo => partitionFilter.apply(tp.partition)\n+        } else {\n+          val whitelist = IncludeList(parts(0))\n+          tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics) && partitionFilter.apply(tp.partition)\n+        }\n+      } else {\n+        throw new IllegalArgumentException(s\"Invalid topic-partition rule: $ruleSpec\")\n+      }\n+    })\n+\n+    tp => rules.exists(rule => rule.apply(tp))\n+  }\n+\n+  /**\n+   * Creates a partition filter based on a single id or a range.\n+   * Expected format:\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n+   */\n+  private def createPartitionFilter(spec: String): Int => Boolean = {\n+    if (spec.indexOf('-') != -1) {\n+      val rangeParts = spec.split(\"-\", -1)\n+      if(rangeParts.length != 2 || rangeParts(0).isEmpty && rangeParts(1).isEmpty) {\n+        throw new IllegalArgumentException(s\"Invalid range specification: $spec\")\n+      }\n+\n+      if(rangeParts(0).isEmpty) {\n+        val max = rangeParts(1).toInt\n+        partition: Int => partition < max\n+      } else if(rangeParts(1).isEmpty) {\n+        val min = rangeParts(0).toInt\n+        partition: Int => partition >= min\n+      } else {\n+        val min = rangeParts(0).toInt\n+        val max = rangeParts(1).toInt\n+\n+        if (min > max) {\n+          throw new IllegalArgumentException(s\"Range lower bound cannot be greater than upper bound: $spec\")\n+        }\n+\n+        partition: Int => partition >= min && partition < max\n+      }\n+    } else {\n+      val number = spec.toInt\n+      partition: Int => partition == number\n+    }\n   }\n \n+  /**\n+   * Creates a topic-partition filter based on a topic pattern and a set of partition ids.\n+   */\n+  private def createTopicPartitionFilterWithTopicAndPartitionPattern(topicOpt: Option[String], excludeInternalTopics: Boolean, partitionIds: Set[Int]): Option[PartitionInfo => Boolean] = {\n+    topicOpt match {\n+      case Some(topic) =>\n+        val topicsFilter = IncludeList(topic)\n+        if(partitionIds.isEmpty)\n+          Some(t => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics))\n+        else\n+          Some(t => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics) && partitionIds.contains(t.partition))\n+      case None =>\n+        if(excludeInternalTopics) {\n+          if(partitionIds.isEmpty)\n+            Some(t => !Topic.isInternal(t.topic))\n+          else\n+            Some(t => !Topic.isInternal(t.topic) && partitionIds.contains(t.partition))\n+        } else {\n+          if(partitionIds.isEmpty)\n+            None\n+          else\n+            Some(t => partitionIds.contains(t.partition))\n+        }\n+    }", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3Mzg4MQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563673881", "bodyText": "I was mostly focusing on avoiding unnecessary filtering, but you are right, it shouldn't be an issue, your code is much cleaner", "author": "urbandan", "createdAt": "2021-01-25T12:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NzIxOQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558287219", "bodyText": "This block of code is identical to the one use at L132. Could we extract the predicate in a function and use it in both cases?", "author": "dajac", "createdAt": "2021-01-15T12:53:23Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDIwMg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563674202", "bodyText": "Removed unnecessary sorting, no duplication", "author": "urbandan", "createdAt": "2021-01-25T12:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NzQzOA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558287438", "bodyText": "Do we really need to sort the partitions here? What are the benefits?", "author": "dajac", "createdAt": "2021-01-15T12:53:48Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -89,33 +104,40 @@ object GetOffsetShell {\n     }\n     val listOffsetsTimestamp = options.valueOf(timeOpt).longValue\n \n-    val config = new Properties\n+    val topicPartitionFilter = if (options.has(topicPartitionOpt)) {\n+      Some(createTopicPartitionFilterWithPatternList(options.valueOf(topicPartitionOpt), excludeInternalTopics))\n+    } else {\n+      createTopicPartitionFilterWithTopicAndPartitionPattern(\n+        if (options.has(topicOpt)) Some(options.valueOf(topicOpt)) else None,\n+        excludeInternalTopics,\n+        partitionIdsRequested\n+      )\n+    }\n+\n+    val config = if (options.has(commandConfigOpt))\n+      Utils.loadProps(options.valueOf(commandConfigOpt))\n+    else\n+      new Properties\n     config.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n     config.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, clientId)\n     val consumer = new KafkaConsumer(config, new ByteArrayDeserializer, new ByteArrayDeserializer)\n \n-    val partitionInfos = listPartitionInfos(consumer, topic, partitionIdsRequested) match {\n-      case None =>\n-        System.err.println(s\"Topic $topic does not exist\")\n-        Exit.exit(1)\n-      case Some(p) if p.isEmpty =>\n-        if (partitionIdsRequested.isEmpty)\n-          System.err.println(s\"Topic $topic has 0 partitions\")\n-        else\n-          System.err.println(s\"Topic $topic does not have any of the requested partitions ${partitionIdsRequested.mkString(\",\")}\")\n-        Exit.exit(1)\n-      case Some(p) => p\n-    }\n+    val partitionInfos = listPartitionInfos(consumer, topicPartitionFilter)\n \n-    if (partitionIdsRequested.nonEmpty) {\n-      (partitionIdsRequested -- partitionInfos.map(_.partition)).foreach { partitionId =>\n-        System.err.println(s\"Error: partition $partitionId does not exist\")\n-      }\n+    if (partitionInfos.isEmpty) {\n+      System.err.println(s\"Could not match any topic-partitions with the specified filters\")\n+      Exit.exit(1)\n     }\n \n-    val topicPartitions = partitionInfos.sortBy(_.partition).flatMap { p =>\n+    val topicPartitions = partitionInfos.sortWith((tp1, tp2) => {", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDM5Nw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563674397", "bodyText": "No point, good catch", "author": "urbandan", "createdAt": "2021-01-25T12:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NzQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4OTc0Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558289743", "bodyText": "It might be worth doing the filtering in the flatMap directly. It would avoid having the construct the full list and to filter it afterwards. What do you think?", "author": "dajac", "createdAt": "2021-01-15T12:58:07Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +154,119 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n \n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  private def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map(ruleSpec => {\n+      val parts = ruleSpec.split(\":\")\n+      if (parts.length == 1) {\n+        val whitelist = IncludeList(parts(0))\n+        tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics)\n+      } else if (parts.length == 2) {\n+        val partitionFilter = createPartitionFilter(parts(1))\n+\n+        if (parts(0).trim().isEmpty) {\n+          tp: PartitionInfo => partitionFilter.apply(tp.partition)\n+        } else {\n+          val whitelist = IncludeList(parts(0))\n+          tp: PartitionInfo => whitelist.isTopicAllowed(tp.topic, excludeInternalTopics) && partitionFilter.apply(tp.partition)\n+        }\n+      } else {\n+        throw new IllegalArgumentException(s\"Invalid topic-partition rule: $ruleSpec\")\n+      }\n+    })\n+\n+    tp => rules.exists(rule => rule.apply(tp))\n+  }\n+\n+  /**\n+   * Creates a partition filter based on a single id or a range.\n+   * Expected format:\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n+   */\n+  private def createPartitionFilter(spec: String): Int => Boolean = {\n+    if (spec.indexOf('-') != -1) {\n+      val rangeParts = spec.split(\"-\", -1)\n+      if(rangeParts.length != 2 || rangeParts(0).isEmpty && rangeParts(1).isEmpty) {\n+        throw new IllegalArgumentException(s\"Invalid range specification: $spec\")\n+      }\n+\n+      if(rangeParts(0).isEmpty) {\n+        val max = rangeParts(1).toInt\n+        partition: Int => partition < max\n+      } else if(rangeParts(1).isEmpty) {\n+        val min = rangeParts(0).toInt\n+        partition: Int => partition >= min\n+      } else {\n+        val min = rangeParts(0).toInt\n+        val max = rangeParts(1).toInt\n+\n+        if (min > max) {\n+          throw new IllegalArgumentException(s\"Range lower bound cannot be greater than upper bound: $spec\")\n+        }\n+\n+        partition: Int => partition >= min && partition < max\n+      }\n+    } else {\n+      val number = spec.toInt\n+      partition: Int => partition == number\n+    }\n   }\n \n+  /**\n+   * Creates a topic-partition filter based on a topic pattern and a set of partition ids.\n+   */\n+  private def createTopicPartitionFilterWithTopicAndPartitionPattern(topicOpt: Option[String], excludeInternalTopics: Boolean, partitionIds: Set[Int]): Option[PartitionInfo => Boolean] = {\n+    topicOpt match {\n+      case Some(topic) =>\n+        val topicsFilter = IncludeList(topic)\n+        if(partitionIds.isEmpty)\n+          Some(t => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics))\n+        else\n+          Some(t => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics) && partitionIds.contains(t.partition))\n+      case None =>\n+        if(excludeInternalTopics) {\n+          if(partitionIds.isEmpty)\n+            Some(t => !Topic.isInternal(t.topic))\n+          else\n+            Some(t => !Topic.isInternal(t.topic) && partitionIds.contains(t.partition))\n+        } else {\n+          if(partitionIds.isEmpty)\n+            None\n+          else\n+            Some(t => partitionIds.contains(t.partition))\n+        }\n+    }\n+  }\n+\n+  /**\n+   * Return the partition infos. Filter them with topicPartitionFilter if specified.\n+   */\n+  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topicPartitionFilter: Option[PartitionInfo => Boolean]): Seq[PartitionInfo] = {\n+    val topicListUnfiltered = consumer.listTopics.asScala.values.flatMap { tp => tp.asScala }", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDU3Ng==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563674576", "bodyText": "I agree, fixed it", "author": "urbandan", "createdAt": "2021-01-25T12:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4OTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI5NDY2Nw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558294667", "bodyText": "nit: map(tp => { => map { tp =>", "author": "dajac", "createdAt": "2021-01-15T13:07:49Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+  private val topicPattern = Pattern.compile(\"test.*\")\n+\n+  override def generateConfigs: collection.Seq[KafkaConfig] = TestUtils.createBrokerConfigs(1, zkConnect)\n+    .map(p => {", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI5NTM3OQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558295379", "bodyText": "It would be better to use assertEquals as well as it outputs the values when the test fails. The same applies to all the test it seems.", "author": "dajac", "createdAt": "2021-01-15T13:09:00Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+  private val topicPattern = Pattern.compile(\"test.*\")\n+\n+  override def generateConfigs: collection.Seq[KafkaConfig] = TestUtils.createBrokerConfigs(1, zkConnect)\n+    .map(p => {\n+      p.put(KafkaConfig.OffsetsTopicPartitionsProp, offsetTopicPartitionCount)\n+      p\n+    }).map(KafkaConfig.fromProps)\n+\n+  @Before\n+  def createTopicAndConsume(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => createTopic(topicName(i), i))\n+\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n+    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.GROUP_ID_CONFIG, \"GetOffsetShellTest\")\n+\n+    // Send X messages to each partition of topicX\n+    val producer = new KafkaProducer[String, String](props)\n+    Range(1, topicCount + 1).foreach(i => Range(0, i*i)\n+      .foreach(msgCount => producer.send(new ProducerRecord[String, String](topicName(i), msgCount % i, null, \"val\" + msgCount))))\n+    producer.close()\n+\n+    // Consume so consumer offsets topic is created\n+    val consumer = new KafkaConsumer[String, String](props)\n+    consumer.subscribe(topicPattern)\n+    consumer.poll(Duration.ofMillis(1000))\n+    consumer.commitSync()\n+    consumer.close()\n+  }\n+\n+  @Test\n+  def testNoFilterOptions(): Unit = {\n+    val offsets = executeAndParse(Array())\n+    assertTrue(expectedOffsets() sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NTI1MQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563675251", "bodyText": "Completely agree, fixed it", "author": "urbandan", "createdAt": "2021-01-25T12:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI5NTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMTcxMw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558301713", "bodyText": "I am not sure to understand why you filter the offsets with !isConsumerOffsetTopicPartition. In this case, we expect --exclude-internal-topics to already do this, no?\nIn general, if --exclude-internal-topics is not set, we should verify that internal topics are there as well. I wouldn't filter them out from the result set.", "author": "dajac", "createdAt": "2021-01-15T13:21:03Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+  private val topicPattern = Pattern.compile(\"test.*\")\n+\n+  override def generateConfigs: collection.Seq[KafkaConfig] = TestUtils.createBrokerConfigs(1, zkConnect)\n+    .map(p => {\n+      p.put(KafkaConfig.OffsetsTopicPartitionsProp, offsetTopicPartitionCount)\n+      p\n+    }).map(KafkaConfig.fromProps)\n+\n+  @Before\n+  def createTopicAndConsume(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => createTopic(topicName(i), i))\n+\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n+    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.GROUP_ID_CONFIG, \"GetOffsetShellTest\")\n+\n+    // Send X messages to each partition of topicX\n+    val producer = new KafkaProducer[String, String](props)\n+    Range(1, topicCount + 1).foreach(i => Range(0, i*i)\n+      .foreach(msgCount => producer.send(new ProducerRecord[String, String](topicName(i), msgCount % i, null, \"val\" + msgCount))))\n+    producer.close()\n+\n+    // Consume so consumer offsets topic is created\n+    val consumer = new KafkaConsumer[String, String](props)\n+    consumer.subscribe(topicPattern)\n+    consumer.poll(Duration.ofMillis(1000))\n+    consumer.commitSync()\n+    consumer.close()\n+  }\n+\n+  @Test\n+  def testNoFilterOptions(): Unit = {\n+    val offsets = executeAndParse(Array())\n+    assertTrue(expectedOffsets() sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))\n+    assertEquals(offsetTopicPartitionCount, offsets.count(isConsumerOffsetTopicPartition))\n+  }\n+\n+  @Test\n+  def testInternalExcluded(): Unit = {\n+    val offsets = executeAndParse(Array(\"--exclude-internal-topics\"))\n+    assertTrue(expectedOffsets() sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY4MzQzNw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563683437", "bodyText": "I wasn't sure if I should define any expectations on the end offsets of the internal topic, that's why I was testing it separately.\nBut I think you are right, so I refactored the code to handle all topics uniformly", "author": "urbandan", "createdAt": "2021-01-25T12:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMTcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMjM3Mg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558302372", "bodyText": "nit: r => r._2 <= 1 is quite hard to read. It might be better to deconstruct the record so we can name the variable partition.", "author": "dajac", "createdAt": "2021-01-15T13:22:17Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+  private val topicPattern = Pattern.compile(\"test.*\")\n+\n+  override def generateConfigs: collection.Seq[KafkaConfig] = TestUtils.createBrokerConfigs(1, zkConnect)\n+    .map(p => {\n+      p.put(KafkaConfig.OffsetsTopicPartitionsProp, offsetTopicPartitionCount)\n+      p\n+    }).map(KafkaConfig.fromProps)\n+\n+  @Before\n+  def createTopicAndConsume(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => createTopic(topicName(i), i))\n+\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n+    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, classOf[StringDeserializer])\n+    props.put(ConsumerConfig.GROUP_ID_CONFIG, \"GetOffsetShellTest\")\n+\n+    // Send X messages to each partition of topicX\n+    val producer = new KafkaProducer[String, String](props)\n+    Range(1, topicCount + 1).foreach(i => Range(0, i*i)\n+      .foreach(msgCount => producer.send(new ProducerRecord[String, String](topicName(i), msgCount % i, null, \"val\" + msgCount))))\n+    producer.close()\n+\n+    // Consume so consumer offsets topic is created\n+    val consumer = new KafkaConsumer[String, String](props)\n+    consumer.subscribe(topicPattern)\n+    consumer.poll(Duration.ofMillis(1000))\n+    consumer.commitSync()\n+    consumer.close()\n+  }\n+\n+  @Test\n+  def testNoFilterOptions(): Unit = {\n+    val offsets = executeAndParse(Array())\n+    assertTrue(expectedOffsets() sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))\n+    assertEquals(offsetTopicPartitionCount, offsets.count(isConsumerOffsetTopicPartition))\n+  }\n+\n+  @Test\n+  def testInternalExcluded(): Unit = {\n+    val offsets = executeAndParse(Array(\"--exclude-internal-topics\"))\n+    assertTrue(expectedOffsets() sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))\n+    assertEquals(0, offsets.count(isConsumerOffsetTopicPartition))\n+  }\n+\n+  @Test\n+  def testTopicNameArg(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => {\n+      val offsets = executeAndParse(Array(\"--topic\", topicName(i)))\n+      assertTrue(\"Offset output did not match for \" + topicName(i), expectedOffsetsForTopic(i) sameElements offsets)\n+    })\n+  }\n+\n+  @Test\n+  def testTopicPatternArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--topic\", \"topic.*\"))\n+    assertTrue(expectedOffsets() sameElements offsets)\n+  }\n+\n+  @Test\n+  def testPartitionsArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--partitions\", \"0,1\"))\n+    assertTrue(expectedOffsets().filter(r => r._2 <= 1) sameElements offsets.filter(r => !isConsumerOffsetTopicPartition(r)))", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMjk4Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558302983", "bodyText": "It would be great if we could add few tests to verify the mutually exclusive arguments. We should also add unit tests to verify the parsing of the specs. We could make the relevant package private so we can access them from here.", "author": "dajac", "createdAt": "2021-01-15T13:23:23Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNzY4NA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563837684", "bodyText": "Agree, added coverage for the arguments and the filter parsing as well", "author": "urbandan", "createdAt": "2021-01-25T16:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMjk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMzUxNQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r558303515", "bodyText": "Is test.* correct? It seems that topics are named topic....", "author": "dajac", "createdAt": "2021-01-15T13:24:23Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,194 @@\n+package kafka.tools\n+\n+import java.time.Duration\n+import java.util.Properties\n+import java.util.regex.Pattern\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.{StringDeserializer, StringSerializer}\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+  private val topicPattern = Pattern.compile(\"test.*\")", "originalCommit": "7c3fee195e9245287f1db02e41d6afcb772911d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY4Mzk0Nw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r563683947", "bodyText": "Was used by the dummy consumer, removed", "author": "urbandan", "createdAt": "2021-01-25T12:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwMzUxNQ=="}], "type": "inlineReview"}, {"oid": "a9f7eaf2bc576dd61d2247c545b7a6aadf1dbfbc", "url": "https://github.com/apache/kafka/commit/a9f7eaf2bc576dd61d2247c545b7a6aadf1dbfbc", "message": "KAFKA-5235: Addressed review comments", "committedDate": "2021-01-26T07:34:25Z", "type": "forcePushed"}, {"oid": "446a9bf18538db20a759d9704bd31b614d4ae291", "url": "https://github.com/apache/kafka/commit/446a9bf18538db20a759d9704bd31b614d4ae291", "message": "KAFKA-5235: Addressed review comments", "committedDate": "2021-01-26T08:08:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTA4ODI0MA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r565088240", "bodyText": "How about moving the computation of partitionIdsRequested to L112? It does not make sense to do all of this if options.has(topicPartitionsOpt).", "author": "dajac", "createdAt": "2021-01-27T07:42:35Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -33,49 +34,65 @@ object GetOffsetShell {\n \n   def main(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionsOpt = parser.accepts(\"topic-partitions\", \"Comma separated list of topic-partition specifications to get the offsets for, with the format of topic:partition. The 'topic' part can be a regex or may be omitted to only specify the partitions, and query all authorized topics.\" +\n+                                            \" The 'partition' part can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions of the specified topic.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic:partition,...,topic:partition\")\n+                           .ofType(classOf[String])\n+    val topicOpt = parser.accepts(\"topic\", s\"The topic to get the offsets for. It also accepts a regular expression. If not present, all authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"topic\")\n                            .ofType(classOf[String])\n-    val partitionOpt = parser.accepts(\"partitions\", \"comma separated list of partition ids. If not specified, it will find offsets for all partitions\")\n+    val partitionsOpt = parser.accepts(\"partitions\", s\"Comma separated list of partition ids to get the offsets for. If not present, all partitions of the authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"partition ids\")\n                            .ofType(classOf[String])\n-                           .defaultsTo(\"\")\n-    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently commited record timestamp is given.]\")\n+    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently committed record timestamp is given.]\")\n                            .withRequiredArg\n                            .describedAs(\"timestamp/-1(latest)/-2(earliest)\")\n                            .ofType(classOf[java.lang.Long])\n                            .defaultsTo(-1L)\n-    parser.accepts(\"offsets\", \"DEPRECATED AND IGNORED: number of offsets returned\")\n-                           .withRequiredArg\n-                           .describedAs(\"count\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1)\n-    parser.accepts(\"max-wait-ms\", \"DEPRECATED AND IGNORED: The max amount of time each fetch request waits.\")\n+    val commandConfigOpt = parser.accepts(\"command-config\", s\"Property file containing configs to be passed to Consumer Client.\")\n                            .withRequiredArg\n-                           .describedAs(\"ms\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1000)\n+                           .describedAs(\"config file\")\n+                           .ofType(classOf[String])\n+    val excludeInternalTopicsOpt = parser.accepts(\"exclude-internal-topics\", s\"By default, internal topics are included. If specified, internal topics are excluded.\")\n \n-   if (args.length == 0)\n-      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic offsets.\")\n+    if (args.length == 0)\n+      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic-partition offsets.\")\n \n     val options = parser.parse(args : _*)\n \n-    CommandLineUtils.checkRequiredArgs(parser, options, brokerListOpt, topicOpt)\n+    val effectiveBrokerListOpt = if (options.has(bootstrapServerOpt))\n+      bootstrapServerOpt\n+    else\n+      brokerListOpt\n+\n+    CommandLineUtils.checkRequiredArgs(parser, options, effectiveBrokerListOpt)\n \n     val clientId = \"GetOffsetShell\"\n-    val brokerList = options.valueOf(brokerListOpt)\n+    val brokerList = options.valueOf(effectiveBrokerListOpt)\n+\n     ToolsUtils.validatePortOrDie(parser, brokerList)\n-    val topic = options.valueOf(topicOpt)\n+    val excludeInternalTopics = options.has(excludeInternalTopicsOpt)\n+\n+    if (options.has(topicPartitionsOpt) && (options.has(topicOpt) || options.has(partitionsOpt))) {\n+      System.err.println(s\"--topic-partitions cannot be used with --topic or --partitions\")\n+      Exit.exit(1)\n+    }\n+\n     val partitionIdsRequested: Set[Int] = {", "originalCommit": "446a9bf18538db20a759d9704bd31b614d4ae291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ5NDU4Ng==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r569494586", "bodyText": "Good catch, thank you", "author": "urbandan", "createdAt": "2021-02-03T15:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTA4ODI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTA5NjM5Mg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r565096392", "bodyText": "I am not fan of using Exit.exit all over the places. I know that it was already like this before but I do wonder if we could improve this by throwing exceptions instead and by catching them in the main. I think that this would require to strip down the main function a bit.\nAnother reason for this is that the new code throws IllegalArgumentException in few places but I don't think that we catch them anywhere, do we? What do you think?", "author": "dajac", "createdAt": "2021-01-27T07:58:39Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -89,33 +106,34 @@ object GetOffsetShell {\n     }\n     val listOffsetsTimestamp = options.valueOf(timeOpt).longValue\n \n-    val config = new Properties\n+    val topicPartitionFilter = if (options.has(topicPartitionsOpt)) {\n+      createTopicPartitionFilterWithPatternList(options.valueOf(topicPartitionsOpt), excludeInternalTopics)\n+    } else {\n+      createTopicPartitionFilterWithTopicAndPartitionPattern(\n+        if (options.has(topicOpt)) Some(options.valueOf(topicOpt)) else None,\n+        excludeInternalTopics,\n+        partitionIdsRequested\n+      )\n+    }\n+\n+    val config = if (options.has(commandConfigOpt))\n+      Utils.loadProps(options.valueOf(commandConfigOpt))\n+    else\n+      new Properties\n     config.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n     config.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, clientId)\n     val consumer = new KafkaConsumer(config, new ByteArrayDeserializer, new ByteArrayDeserializer)\n \n-    val partitionInfos = listPartitionInfos(consumer, topic, partitionIdsRequested) match {\n-      case None =>\n-        System.err.println(s\"Topic $topic does not exist\")\n-        Exit.exit(1)\n-      case Some(p) if p.isEmpty =>\n-        if (partitionIdsRequested.isEmpty)\n-          System.err.println(s\"Topic $topic has 0 partitions\")\n-        else\n-          System.err.println(s\"Topic $topic does not have any of the requested partitions ${partitionIdsRequested.mkString(\",\")}\")\n-        Exit.exit(1)\n-      case Some(p) => p\n-    }\n+    val partitionInfos = listPartitionInfos(consumer, topicPartitionFilter)\n \n-    if (partitionIdsRequested.nonEmpty) {\n-      (partitionIdsRequested -- partitionInfos.map(_.partition)).foreach { partitionId =>\n-        System.err.println(s\"Error: partition $partitionId does not exist\")\n-      }\n+    if (partitionInfos.isEmpty) {\n+      System.err.println(s\"Could not match any topic-partitions with the specified filters\")\n+      Exit.exit(1)", "originalCommit": "446a9bf18538db20a759d9704bd31b614d4ae291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ5NjUxMg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r569496512", "bodyText": "Overall, I agree. Removed the exit calls, but left other util calls possibly invoking exit.", "author": "urbandan", "createdAt": "2021-02-03T15:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTA5NjM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTEwMjEzMQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r565102131", "bodyText": "I just learnt that we can actually compare TopicPartition with the following comparator in Scala:\n  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n    (a.topic(), a.partition()) < (b.topic(), b.partition())\n  }\n\nand do partitionOffsets.toSeq.sortWith(compareTopicPartitions).foreach { .... This makes the code a bit more readable.", "author": "dajac", "createdAt": "2021-01-27T08:09:31Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +150,104 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {", "originalCommit": "446a9bf18538db20a759d9704bd31b614d4ae291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ5NjY2MQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r569496661", "bodyText": "Thanks, refactored it", "author": "urbandan", "createdAt": "2021-02-03T15:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTEwMjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTExNzg2Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r565117863", "bodyText": "Out of curiosity, did you consider using a regex to parse the rule spec? It seems to me that something like this  ([^:]*):([0-9]*)(?:-([0-9]*))? could work and could directly extract all the required parts. I haven't tested it. That could reduce the code while making the grammar of the rule spec more explicit.", "author": "dajac", "createdAt": "2021-01-27T08:36:27Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +150,104 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => {\n+      val topicComp = tp1._1.topic.compareTo(tp2._1.topic)\n+      if (topicComp == 0)\n+        tp1._1.partition < tp2._1.partition\n+      else\n+        topicComp < 0\n+    }).foreach { case (tp, offset) =>\n+      println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  /**\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n+   */\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec =>", "originalCommit": "446a9bf18538db20a759d9704bd31b614d4ae291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ5NzUxMA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r569497510", "bodyText": "I personally prefer not using regex, but I see your point - switched to regex usage.", "author": "urbandan", "createdAt": "2021-02-03T15:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTExNzg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTEyMDI1Nw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r565120257", "bodyText": "nit: .map(line => { -> .map { line =>", "author": "dajac", "createdAt": "2021-01-27T08:40:17Z", "path": "core/src/test/scala/kafka/tools/GetOffsetShellTest.scala", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.tools\n+\n+import java.util.Properties\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.{Exit, Logging, TestUtils}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.producer.{KafkaProducer, ProducerConfig, ProducerRecord}\n+import org.apache.kafka.common.serialization.StringSerializer\n+import org.junit.Assert.assertEquals\n+import org.junit.{Before, Test}\n+\n+class GetOffsetShellTest extends KafkaServerTestHarness with Logging {\n+  private val topicCount = 4\n+  private val offsetTopicPartitionCount = 4\n+\n+  override def generateConfigs: collection.Seq[KafkaConfig] = TestUtils.createBrokerConfigs(1, zkConnect)\n+    .map { p =>\n+      p.put(KafkaConfig.OffsetsTopicPartitionsProp, Int.box(offsetTopicPartitionCount))\n+      p\n+    }.map(KafkaConfig.fromProps)\n+\n+  @Before\n+  def createTestAndInternalTopics(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => createTopic(topicName(i), i))\n+\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n+    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])\n+\n+    // Send X messages to each partition of topicX\n+    val producer = new KafkaProducer[String, String](props)\n+    Range(1, topicCount + 1).foreach(i => Range(0, i*i)\n+      .foreach(msgCount => producer.send(new ProducerRecord[String, String](topicName(i), msgCount % i, null, \"val\" + msgCount))))\n+    producer.close()\n+\n+    TestUtils.createOffsetsTopic(zkClient, servers)\n+  }\n+\n+  @Test\n+  def testNoFilterOptions(): Unit = {\n+    val offsets = executeAndParse(Array())\n+    assertEquals(expectedOffsetsWithInternal(), offsets)\n+  }\n+\n+  @Test\n+  def testInternalExcluded(): Unit = {\n+    val offsets = executeAndParse(Array(\"--exclude-internal-topics\"))\n+    assertEquals(expectedTestTopicOffsets(), offsets)\n+  }\n+\n+  @Test\n+  def testTopicNameArg(): Unit = {\n+    Range(1, topicCount + 1).foreach(i => {\n+      val offsets = executeAndParse(Array(\"--topic\", topicName(i)))\n+      assertEquals(\"Offset output did not match for \" + topicName(i), expectedOffsetsForTopic(i), offsets)\n+    })\n+  }\n+\n+  @Test\n+  def testTopicPatternArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--topic\", \"topic.*\"))\n+    assertEquals(expectedTestTopicOffsets(), offsets)\n+  }\n+\n+  @Test\n+  def testPartitionsArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--partitions\", \"0,1\"))\n+    assertEquals(expectedOffsetsWithInternal().filter { case (_, partition, _) => partition <= 1 }, offsets)\n+  }\n+\n+  @Test\n+  def testTopicPatternArgWithPartitionsArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--topic\", \"topic.*\", \"--partitions\", \"0,1\"))\n+    assertEquals(expectedTestTopicOffsets().filter { case (_, partition, _) => partition <= 1 }, offsets)\n+  }\n+\n+  @Test\n+  def testTopicPartitionsArg(): Unit = {\n+    val offsets = executeAndParse(Array(\"--topic-partitions\", \"topic1:0,topic2:1,topic(3|4):2,__.*:3\"))\n+    assertEquals(\n+      List(\n+        (\"__consumer_offsets\", 3, Some(0)),\n+        (\"topic1\", 0, Some(1)),\n+        (\"topic2\", 1, Some(2)),\n+        (\"topic3\", 2, Some(3)),\n+        (\"topic4\", 2, Some(4))\n+      ),\n+      offsets\n+    )\n+  }\n+\n+  @Test\n+  def testTopicPartitionsArgWithInternalExcluded(): Unit = {\n+    val offsets = executeAndParse(Array(\"--topic-partitions\",\n+      \"topic1:0,topic2:1,topic(3|4):2,__.*:3\", \"--exclude-internal-topics\"))\n+    assertEquals(\n+      List(\n+        (\"topic1\", 0, Some(1)),\n+        (\"topic2\", 1, Some(2)),\n+        (\"topic3\", 2, Some(3)),\n+        (\"topic4\", 2, Some(4))\n+      ),\n+      offsets\n+    )\n+  }\n+\n+  @Test\n+  def testTopicPartitionsNotFoundForNonExistentTopic(): Unit = {\n+    assertExitCodeIsOne(Array(\"--topic\", \"some_nonexistent_topic\"))\n+  }\n+\n+  @Test\n+  def testTopicPartitionsNotFoundForExcludedInternalTopic(): Unit = {\n+    assertExitCodeIsOne(Array(\"--topic\", \"some_nonexistent_topic:*\"))\n+  }\n+\n+  @Test\n+  def testTopicPartitionsNotFoundForNonMatchingTopicPartitionPattern(): Unit = {\n+    assertExitCodeIsOne(Array(\"--topic-partitions\", \"__consumer_offsets\", \"--exclude-internal-topics\"))\n+  }\n+\n+  @Test\n+  def testTopicPartitionsFlagWithTopicFlagCauseExit(): Unit = {\n+    assertExitCodeIsOne(Array(\"--topic-partitions\", \"__consumer_offsets\", \"--topic\", \"topic1\"))\n+  }\n+\n+  @Test\n+  def testTopicPartitionsFlagWithPartitionsFlagCauseExit(): Unit = {\n+    assertExitCodeIsOne(Array(\"--topic-partitions\", \"__consumer_offsets\", \"--partitions\", \"0\"))\n+  }\n+\n+  private def expectedOffsetsWithInternal(): List[(String, Int, Option[Long])] = {\n+    Range(0, offsetTopicPartitionCount).map(i => (\"__consumer_offsets\", i, Some(0L))).toList ++ expectedTestTopicOffsets()\n+  }\n+\n+  private def expectedTestTopicOffsets(): List[(String, Int, Option[Long])] = {\n+    Range(1, topicCount + 1).flatMap(i => expectedOffsetsForTopic(i)).toList\n+  }\n+\n+  private def expectedOffsetsForTopic(i: Int): List[(String, Int, Option[Long])] = {\n+    val name = topicName(i)\n+    Range(0, i).map(p => (name, p, Some(i.toLong))).toList\n+  }\n+\n+  private def topicName(i: Int): String = \"topic\" + i\n+\n+  private def assertExitCodeIsOne(args: Array[String]): Unit = {\n+    var exitStatus: Option[Int] = None\n+    Exit.setExitProcedure { (status, _) =>\n+      exitStatus = Some(status)\n+      throw new RuntimeException\n+    }\n+\n+    try {\n+      GetOffsetShell.main(addBootstrapServer(args))\n+    } catch {\n+      case e: RuntimeException =>\n+    } finally {\n+      Exit.resetExitProcedure()\n+    }\n+\n+    assertEquals(Some(1), exitStatus)\n+  }\n+\n+  private def executeAndParse(args: Array[String]): List[(String, Int, Option[Long])] = {\n+    val output = executeAndGrabOutput(args)\n+    output.split(System.lineSeparator())\n+      .map(_.split(\":\"))\n+      .filter(_.length >= 2)\n+      .map(line => {", "originalCommit": "446a9bf18538db20a759d9704bd31b614d4ae291", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d5b6f5e0561344ff7bea0dd0e09adcb7f895748f", "url": "https://github.com/apache/kafka/commit/d5b6f5e0561344ff7bea0dd0e09adcb7f895748f", "message": "KAFKA-5235: Rebase, switched pattern parsing to regex, removed explicit exits", "committedDate": "2021-02-03T15:04:44Z", "type": "forcePushed"}, {"oid": "2b1cc08f973759074521bdbeeabc626e283fdd77", "url": "https://github.com/apache/kafka/commit/2b1cc08f973759074521bdbeeabc626e283fdd77", "message": "KAFKA-5235: Rebase, switched pattern parsing to regex, removed explicit exits", "committedDate": "2021-02-08T07:54:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0Nzk0NQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572047945", "bodyText": "It seems that we need to print out something here for the user. The default exit procedure doesn't do anything with the provided message. Take a look at the other commands to see how we handle this.", "author": "dajac", "createdAt": "2021-02-08T13:31:59Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,131 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val topicPartitionPattern = Pattern.compile( \"([^:,]*)(?::([0-9]*)(?:-([0-9]*))?)?\")\n \n   def main(args: Array[String]): Unit = {\n+    try {\n+      fetchOffsets(args)\n+    } catch {\n+      case e: Exception => Exit.exit(1, Some(e.getMessage))", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjY2NzA3Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572667073", "bodyText": "Thanks, good catch", "author": "urbandan", "createdAt": "2021-02-09T08:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0Nzk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0ODM3OA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572048378", "bodyText": "nit: sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)) -> sortWith(compareTopicPartitions)", "author": "dajac", "createdAt": "2021-02-08T13:32:33Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjY2NjMzNw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572666337", "bodyText": "The current compareTopicPartitions method expects TopicPartitions, but we have tuples in the collection.\nShould I change compareTopicPartitions to expect tuples?", "author": "urbandan", "createdAt": "2021-02-09T08:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0ODM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE5NDczNQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573194735", "bodyText": "No, that's fine as it is then. I missed this.", "author": "dajac", "createdAt": "2021-02-09T19:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0ODM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0ODg4MA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572048880", "bodyText": "I don't think that matcher.groupCount() == 0 is necessary. My understanding is that it will never be 0 as we have groups defined in the regex.", "author": "dajac", "createdAt": "2021-02-08T13:33:24Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjY2NzM2Mg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572667362", "bodyText": "True, good catch", "author": "urbandan", "createdAt": "2021-02-09T08:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0ODg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA0OTc4NA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572049784", "bodyText": "It seems that checking matcher.groupCount() >= 2 is not necessary. Groups will be null anyway if they are not filled.", "author": "dajac", "createdAt": "2021-02-08T13:34:41Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    val topicPattern = wrapNullOrEmpty(matcher.group(1))\n+    val lowerRange = if (matcher.groupCount() >= 2) wrapNullOrEmpty(matcher.group(2)) else None", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NDQ5Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572054493", "bodyText": "I think that we could further simplify this by differentiating the range case from the single partition case in the regex directly. We could for instance use the following regex: \"([^:,]*)(?::(?:([0-9]*)|(?:([0-9]*)-([0-9]*))))?\".\nIt allows to do something like this for the processing:\n    val matcher = topicPartitionPattern.matcher(ruleSpec)\n    if (!matcher.matches())\n      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n\n    def group(group: Int): Option[String] = {\n      Option(matcher.group(group)).filter(s => s != null && s.nonEmpty)\n    }\n\n    val topicFilter = IncludeList(group(1).getOrElse(\".*\"))\n    val partitionFilter = group(2).map(_.toInt) match {\n      case Some(partition) =>\n        (p: Int) => p == partition\n      case None =>\n        val lowerRange = group(3).map(_.toInt).getOrElse(0)\n        val upperRange = group(4).map(_.toInt).getOrElse(Int.MaxValue)\n        (p: Int) => p >= lowerRange && p < upperRange\n    }\n\nBasically, if no single partition is provided, we use a range with 0 and Int.MaxValue as defaults.", "author": "dajac", "createdAt": "2021-02-08T13:41:12Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    val topicPattern = wrapNullOrEmpty(matcher.group(1))\n+    val lowerRange = if (matcher.groupCount() >= 2) wrapNullOrEmpty(matcher.group(2)) else None\n+    val upperRangeSection = if (matcher.groupCount() >= 3) matcher.group(3) else null\n+    val upperRange = wrapNullOrEmpty(upperRangeSection)\n+    val isRange = upperRangeSection != null\n+\n+    val includeList = IncludeList(topicPattern.getOrElse(\".*\"))\n+\n+    val partitionFilter: Int => Boolean = if (lowerRange.isEmpty && upperRange.isEmpty) {\n+      _ => true\n+    } else if (lowerRange.isEmpty) {\n+      val upperBound = upperRange.get.toInt\n+      p => p < upperBound\n+    } else if (upperRange.isEmpty) {\n+      val lowerBound = lowerRange.get.toInt\n+      if (isRange) {\n+        p => p >= lowerBound\n+      }\n+      else {\n+        p => p == lowerBound\n+      }\n+    } else {\n+      val upperBound = upperRange.get.toInt\n+      val lowerBound = lowerRange.get.toInt\n+      p => p >= lowerBound && p < upperBound\n+    }", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjY2OTkyNQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572669925", "bodyText": "Thank you, changed implementation to this", "author": "urbandan", "createdAt": "2021-02-09T08:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NDQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NTQ5MQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572055491", "bodyText": "Not related to your changes but it seems that we never close the consumer. It would be great if we could do it.", "author": "dajac", "createdAt": "2021-02-08T13:42:42Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,131 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val topicPartitionPattern = Pattern.compile( \"([^:,]*)(?::([0-9]*)(?:-([0-9]*))?)?\")\n \n   def main(args: Array[String]): Unit = {\n+    try {\n+      fetchOffsets(args)\n+    } catch {\n+      case e: Exception => Exit.exit(1, Some(e.getMessage))\n+    }\n+  }\n+\n+  private def fetchOffsets(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionsOpt = parser.accepts(\"topic-partitions\", s\"Comma separated list of topic-partition patterns to get the offsets for, with the format of '$topicPartitionPattern'.\" +\n+                                            \" The first group is an optional regex for the topic name, if omitted, it matches any topic name.\" +\n+                                            \" The section after ':' describes a 'partition' pattern, which can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic1:1,topic2:0-3,topic3,topic4:5-,topic5:-3\")\n+                           .ofType(classOf[String])\n+    val topicOpt = parser.accepts(\"topic\", s\"The topic to get the offsets for. It also accepts a regular expression. If not present, all authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"topic\")\n                            .ofType(classOf[String])\n-    val partitionOpt = parser.accepts(\"partitions\", \"comma separated list of partition ids. If not specified, it will find offsets for all partitions\")\n+    val partitionsOpt = parser.accepts(\"partitions\", s\"Comma separated list of partition ids to get the offsets for. If not present, all partitions of the authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"partition ids\")\n                            .ofType(classOf[String])\n-                           .defaultsTo(\"\")\n-    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently commited record timestamp is given.]\")\n+    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently committed record timestamp is given.]\")\n                            .withRequiredArg\n                            .describedAs(\"timestamp/-1(latest)/-2(earliest)\")\n                            .ofType(classOf[java.lang.Long])\n                            .defaultsTo(-1L)\n-    parser.accepts(\"offsets\", \"DEPRECATED AND IGNORED: number of offsets returned\")\n-                           .withRequiredArg\n-                           .describedAs(\"count\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1)\n-    parser.accepts(\"max-wait-ms\", \"DEPRECATED AND IGNORED: The max amount of time each fetch request waits.\")\n+    val commandConfigOpt = parser.accepts(\"command-config\", s\"Property file containing configs to be passed to Consumer Client.\")\n                            .withRequiredArg\n-                           .describedAs(\"ms\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1000)\n+                           .describedAs(\"config file\")\n+                           .ofType(classOf[String])\n+    val excludeInternalTopicsOpt = parser.accepts(\"exclude-internal-topics\", s\"By default, internal topics are included. If specified, internal topics are excluded.\")\n \n-   if (args.length == 0)\n-      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic offsets.\")\n+    if (args.length == 0)\n+      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic-partition offsets.\")\n \n     val options = parser.parse(args : _*)\n \n-    CommandLineUtils.checkRequiredArgs(parser, options, brokerListOpt, topicOpt)\n+    val effectiveBrokerListOpt = if (options.has(bootstrapServerOpt))\n+      bootstrapServerOpt\n+    else\n+      brokerListOpt\n+\n+    CommandLineUtils.checkRequiredArgs(parser, options, effectiveBrokerListOpt)\n \n     val clientId = \"GetOffsetShell\"\n-    val brokerList = options.valueOf(brokerListOpt)\n+    val brokerList = options.valueOf(effectiveBrokerListOpt)\n+\n     ToolsUtils.validatePortOrDie(parser, brokerList)\n-    val topic = options.valueOf(topicOpt)\n-    val partitionIdsRequested: Set[Int] = {\n-      val partitionsString = options.valueOf(partitionOpt)\n-      if (partitionsString.isEmpty)\n-        Set.empty\n-      else\n-        partitionsString.split(\",\").map { partitionString =>\n-          try partitionString.toInt\n-          catch {\n-            case _: NumberFormatException =>\n-              System.err.println(s\"--partitions expects a comma separated list of numeric partition ids, but received: $partitionsString\")\n-              Exit.exit(1)\n-          }\n-        }.toSet\n+    val excludeInternalTopics = options.has(excludeInternalTopicsOpt)\n+\n+    if (options.has(topicPartitionsOpt) && (options.has(topicOpt) || options.has(partitionsOpt))) {\n+      throw new IllegalArgumentException(\"--topic-partitions cannot be used with --topic or --partitions\")\n     }\n+\n     val listOffsetsTimestamp = options.valueOf(timeOpt).longValue\n \n-    val config = new Properties\n+    val topicPartitionFilter = if (options.has(topicPartitionsOpt)) {\n+      createTopicPartitionFilterWithPatternList(options.valueOf(topicPartitionsOpt), excludeInternalTopics)\n+    } else {\n+      val partitionIdsRequested: Set[Int] = {\n+        val partitionsString = options.valueOf(partitionsOpt)\n+        if (partitionsString == null || partitionsString.isEmpty)\n+          Set.empty\n+        else\n+          partitionsString.split(\",\").map { partitionString =>\n+            try partitionString.toInt\n+            catch {\n+              case _: NumberFormatException =>\n+                throw new IllegalArgumentException(s\"--partitions expects a comma separated list of numeric \" +\n+                  s\"partition ids, but received: $partitionsString\")\n+            }\n+          }.toSet\n+      }\n+\n+      createTopicPartitionFilterWithTopicAndPartitionPattern(\n+        if (options.has(topicOpt)) Some(options.valueOf(topicOpt)) else None,\n+        excludeInternalTopics,\n+        partitionIdsRequested\n+      )\n+    }\n+\n+    val config = if (options.has(commandConfigOpt))\n+      Utils.loadProps(options.valueOf(commandConfigOpt))\n+    else\n+      new Properties\n     config.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList)\n     config.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, clientId)\n     val consumer = new KafkaConsumer(config, new ByteArrayDeserializer, new ByteArrayDeserializer)", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIwMTQ3MA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573201470", "bodyText": "Could we address this one as well? We could add a try/finally.", "author": "dajac", "createdAt": "2021-02-09T20:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NTQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY2MTQzMg==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573661432", "bodyText": "Sorry, missed this one, fixed it", "author": "urbandan", "createdAt": "2021-02-10T11:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NTQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NjQ5NQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572056495", "bodyText": "nit: We tend to use parenthesis instead of curly braces when the lambda is on a single line.", "author": "dajac", "createdAt": "2021-02-08T13:44:12Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1NzI1MA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572057250", "bodyText": "The null instead of the None is quite subtile. I did not see it at first. See my comment which suggest to push more to the regex.", "author": "dajac", "createdAt": "2021-02-08T13:45:20Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    val topicPattern = wrapNullOrEmpty(matcher.group(1))\n+    val lowerRange = if (matcher.groupCount() >= 2) wrapNullOrEmpty(matcher.group(2)) else None\n+    val upperRangeSection = if (matcher.groupCount() >= 3) matcher.group(3) else null", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1Nzk0OA==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572057948", "bodyText": "nit: The parenthesis after topic and partition could be omitted. It seems that we could call partitionFilter directly without the apply.", "author": "dajac", "createdAt": "2021-02-08T13:46:12Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    val topicPattern = wrapNullOrEmpty(matcher.group(1))\n+    val lowerRange = if (matcher.groupCount() >= 2) wrapNullOrEmpty(matcher.group(2)) else None\n+    val upperRangeSection = if (matcher.groupCount() >= 3) matcher.group(3) else null\n+    val upperRange = wrapNullOrEmpty(upperRangeSection)\n+    val isRange = upperRangeSection != null\n+\n+    val includeList = IncludeList(topicPattern.getOrElse(\".*\"))\n+\n+    val partitionFilter: Int => Boolean = if (lowerRange.isEmpty && upperRange.isEmpty) {\n+      _ => true\n+    } else if (lowerRange.isEmpty) {\n+      val upperBound = upperRange.get.toInt\n+      p => p < upperBound\n+    } else if (upperRange.isEmpty) {\n+      val lowerBound = lowerRange.get.toInt\n+      if (isRange) {\n+        p => p >= lowerBound\n+      }\n+      else {\n+        p => p == lowerBound\n+      }\n+    } else {\n+      val upperBound = upperRange.get.toInt\n+      val lowerBound = lowerRange.get.toInt\n+      p => p >= lowerBound && p < upperBound\n+    }\n+\n+    tp => includeList.isTopicAllowed(tp.topic(), excludeInternalTopics) && partitionFilter.apply(tp.partition())", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA1ODc3Nw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572058777", "bodyText": "nit: We should use parenthesis here instead of curly braces. filter(topicPartitionFilter) might even work directly as well.", "author": "dajac", "createdAt": "2021-02-08T13:47:20Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +161,85 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n-    else\n-      Some(partitionInfos.filter(p => partitionIds.contains(p.partition)))\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists(rule => rule.apply(tp))\n   }\n \n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    def wrapNullOrEmpty(s: String): Option[String] = {\n+      if (s == null || s.isEmpty)\n+        None\n+      else\n+        Some(s)\n+    }\n+\n+    val matcher = topicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches() || matcher.groupCount() == 0)\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    val topicPattern = wrapNullOrEmpty(matcher.group(1))\n+    val lowerRange = if (matcher.groupCount() >= 2) wrapNullOrEmpty(matcher.group(2)) else None\n+    val upperRangeSection = if (matcher.groupCount() >= 3) matcher.group(3) else null\n+    val upperRange = wrapNullOrEmpty(upperRangeSection)\n+    val isRange = upperRangeSection != null\n+\n+    val includeList = IncludeList(topicPattern.getOrElse(\".*\"))\n+\n+    val partitionFilter: Int => Boolean = if (lowerRange.isEmpty && upperRange.isEmpty) {\n+      _ => true\n+    } else if (lowerRange.isEmpty) {\n+      val upperBound = upperRange.get.toInt\n+      p => p < upperBound\n+    } else if (upperRange.isEmpty) {\n+      val lowerBound = lowerRange.get.toInt\n+      if (isRange) {\n+        p => p >= lowerBound\n+      }\n+      else {\n+        p => p == lowerBound\n+      }\n+    } else {\n+      val upperBound = upperRange.get.toInt\n+      val lowerBound = lowerRange.get.toInt\n+      p => p >= lowerBound && p < upperBound\n+    }\n+\n+    tp => includeList.isTopicAllowed(tp.topic(), excludeInternalTopics) && partitionFilter.apply(tp.partition())\n+  }\n+\n+  /**\n+   * Creates a topic-partition filter based on a topic pattern and a set of partition ids.\n+   */\n+  def createTopicPartitionFilterWithTopicAndPartitionPattern(topicOpt: Option[String], excludeInternalTopics: Boolean, partitionIds: Set[Int]): PartitionInfo => Boolean = {\n+    val topicsFilter = IncludeList(topicOpt.getOrElse(\".*\"))\n+    t => topicsFilter.isTopicAllowed(t.topic, excludeInternalTopics) && (partitionIds.isEmpty || partitionIds.contains(t.partition))\n+  }\n+\n+  /**\n+   * Return the partition infos. Filter them with topicPartitionFilter.\n+   */\n+  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topicPartitionFilter: PartitionInfo => Boolean): Seq[PartitionInfo] = {\n+    consumer.listTopics.asScala.values.flatMap { partitions =>\n+      partitions.asScala.filter { tp => topicPartitionFilter.apply(tp) }", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA2MjMyNw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572062327", "bodyText": "nit: We usually capitalize the first letter of constant in Scala.", "author": "dajac", "createdAt": "2021-02-08T13:52:27Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,131 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val topicPartitionPattern = Pattern.compile( \"([^:,]*)(?::([0-9]*)(?:-([0-9]*))?)?\")", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA2NDI4OQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572064289", "bodyText": "nit: Should we consider moving this block in an method?", "author": "dajac", "createdAt": "2021-02-08T13:55:19Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,131 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val topicPartitionPattern = Pattern.compile( \"([^:,]*)(?::([0-9]*)(?:-([0-9]*))?)?\")\n \n   def main(args: Array[String]): Unit = {\n+    try {\n+      fetchOffsets(args)\n+    } catch {\n+      case e: Exception => Exit.exit(1, Some(e.getMessage))\n+    }\n+  }\n+\n+  private def fetchOffsets(args: Array[String]): Unit = {\n     val parser = new OptionParser(false)\n-    val brokerListOpt = parser.accepts(\"broker-list\", \"REQUIRED: The list of hostname and port of the server to connect to.\")\n+    val brokerListOpt = parser.accepts(\"broker-list\", \"DEPRECATED, use --bootstrap-server instead; ignored if --bootstrap-server is specified. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n                            .withRequiredArg\n-                           .describedAs(\"hostname:port,...,hostname:port\")\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n                            .ofType(classOf[String])\n-    val topicOpt = parser.accepts(\"topic\", \"REQUIRED: The topic to get offset from.\")\n+    val bootstrapServerOpt = parser.accepts(\"bootstrap-server\", \"REQUIRED. The server(s) to connect to in the form HOST1:PORT1,HOST2:PORT2.\")\n+                           .requiredUnless(\"broker-list\")\n+                           .withRequiredArg\n+                           .describedAs(\"HOST1:PORT1,...,HOST3:PORT3\")\n+                           .ofType(classOf[String])\n+    val topicPartitionsOpt = parser.accepts(\"topic-partitions\", s\"Comma separated list of topic-partition patterns to get the offsets for, with the format of '$topicPartitionPattern'.\" +\n+                                            \" The first group is an optional regex for the topic name, if omitted, it matches any topic name.\" +\n+                                            \" The section after ':' describes a 'partition' pattern, which can be: a number, a range in the format of 'NUMBER-NUMBER' (lower inclusive, upper exclusive), an inclusive lower bound in the format of 'NUMBER-', an exclusive upper bound in the format of '-NUMBER' or may be omitted to accept all partitions.\")\n+                           .withRequiredArg\n+                           .describedAs(\"topic1:1,topic2:0-3,topic3,topic4:5-,topic5:-3\")\n+                           .ofType(classOf[String])\n+    val topicOpt = parser.accepts(\"topic\", s\"The topic to get the offsets for. It also accepts a regular expression. If not present, all authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"topic\")\n                            .ofType(classOf[String])\n-    val partitionOpt = parser.accepts(\"partitions\", \"comma separated list of partition ids. If not specified, it will find offsets for all partitions\")\n+    val partitionsOpt = parser.accepts(\"partitions\", s\"Comma separated list of partition ids to get the offsets for. If not present, all partitions of the authorized topics are queried. Cannot be used if --topic-partitions is present.\")\n                            .withRequiredArg\n                            .describedAs(\"partition ids\")\n                            .ofType(classOf[String])\n-                           .defaultsTo(\"\")\n-    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently commited record timestamp is given.]\")\n+    val timeOpt = parser.accepts(\"time\", \"timestamp of the offsets before that. [Note: No offset is returned, if the timestamp greater than recently committed record timestamp is given.]\")\n                            .withRequiredArg\n                            .describedAs(\"timestamp/-1(latest)/-2(earliest)\")\n                            .ofType(classOf[java.lang.Long])\n                            .defaultsTo(-1L)\n-    parser.accepts(\"offsets\", \"DEPRECATED AND IGNORED: number of offsets returned\")\n-                           .withRequiredArg\n-                           .describedAs(\"count\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1)\n-    parser.accepts(\"max-wait-ms\", \"DEPRECATED AND IGNORED: The max amount of time each fetch request waits.\")\n+    val commandConfigOpt = parser.accepts(\"command-config\", s\"Property file containing configs to be passed to Consumer Client.\")\n                            .withRequiredArg\n-                           .describedAs(\"ms\")\n-                           .ofType(classOf[java.lang.Integer])\n-                           .defaultsTo(1000)\n+                           .describedAs(\"config file\")\n+                           .ofType(classOf[String])\n+    val excludeInternalTopicsOpt = parser.accepts(\"exclude-internal-topics\", s\"By default, internal topics are included. If specified, internal topics are excluded.\")\n \n-   if (args.length == 0)\n-      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic offsets.\")\n+    if (args.length == 0)\n+      CommandLineUtils.printUsageAndDie(parser, \"An interactive shell for getting topic-partition offsets.\")\n \n     val options = parser.parse(args : _*)\n \n-    CommandLineUtils.checkRequiredArgs(parser, options, brokerListOpt, topicOpt)\n+    val effectiveBrokerListOpt = if (options.has(bootstrapServerOpt))\n+      bootstrapServerOpt\n+    else\n+      brokerListOpt\n+\n+    CommandLineUtils.checkRequiredArgs(parser, options, effectiveBrokerListOpt)\n \n     val clientId = \"GetOffsetShell\"\n-    val brokerList = options.valueOf(brokerListOpt)\n+    val brokerList = options.valueOf(effectiveBrokerListOpt)\n+\n     ToolsUtils.validatePortOrDie(parser, brokerList)\n-    val topic = options.valueOf(topicOpt)\n-    val partitionIdsRequested: Set[Int] = {\n-      val partitionsString = options.valueOf(partitionOpt)\n-      if (partitionsString.isEmpty)\n-        Set.empty\n-      else\n-        partitionsString.split(\",\").map { partitionString =>\n-          try partitionString.toInt\n-          catch {\n-            case _: NumberFormatException =>\n-              System.err.println(s\"--partitions expects a comma separated list of numeric partition ids, but received: $partitionsString\")\n-              Exit.exit(1)\n-          }\n-        }.toSet\n+    val excludeInternalTopics = options.has(excludeInternalTopicsOpt)\n+\n+    if (options.has(topicPartitionsOpt) && (options.has(topicOpt) || options.has(partitionsOpt))) {\n+      throw new IllegalArgumentException(\"--topic-partitions cannot be used with --topic or --partitions\")\n     }\n+\n     val listOffsetsTimestamp = options.valueOf(timeOpt).longValue\n \n-    val config = new Properties\n+    val topicPartitionFilter = if (options.has(topicPartitionsOpt)) {\n+      createTopicPartitionFilterWithPatternList(options.valueOf(topicPartitionsOpt), excludeInternalTopics)\n+    } else {\n+      val partitionIdsRequested: Set[Int] = {\n+        val partitionsString = options.valueOf(partitionsOpt)\n+        if (partitionsString == null || partitionsString.isEmpty)\n+          Set.empty\n+        else\n+          partitionsString.split(\",\").map { partitionString =>\n+            try partitionString.toInt\n+            catch {\n+              case _: NumberFormatException =>\n+                throw new IllegalArgumentException(s\"--partitions expects a comma separated list of numeric \" +\n+                  s\"partition ids, but received: $partitionsString\")\n+            }\n+          }.toSet", "originalCommit": "2b1cc08f973759074521bdbeeabc626e283fdd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjY3MjgzMQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r572672831", "bodyText": "I agree, more readable", "author": "urbandan", "createdAt": "2021-02-09T08:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjA2NDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE4ODQxNw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573188417", "bodyText": "nit: The space before \" could be removed.", "author": "dajac", "createdAt": "2021-02-09T19:47:24Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,120 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val TopicPartitionPattern = Pattern.compile( \"([^:,]*)(?::(?:([0-9]*)|(?:([0-9]*)-([0-9]*))))?\")", "originalCommit": "8e69e1dc50566e19afd9a62b47976552a5c6f9d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE5Mjg4MQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573192881", "bodyText": "We could use println here to be consistent with the other command line tools. Moreover, you need to use curly braces around e.getMessage: s\"Error: ${e.getMessage}\".", "author": "dajac", "createdAt": "2021-02-09T19:54:44Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -20,102 +20,120 @@ package kafka.tools\n \n import java.util.Properties\n import joptsimple._\n-import kafka.utils.{CommandLineUtils, Exit, ToolsUtils}\n+import kafka.utils.{CommandLineUtils, Exit, IncludeList, ToolsUtils}\n import org.apache.kafka.clients.consumer.{ConsumerConfig, KafkaConsumer}\n import org.apache.kafka.common.requests.ListOffsetsRequest\n import org.apache.kafka.common.{PartitionInfo, TopicPartition}\n import org.apache.kafka.common.serialization.ByteArrayDeserializer\n+import org.apache.kafka.common.utils.Utils\n \n+import java.util.regex.Pattern\n import scala.jdk.CollectionConverters._\n import scala.collection.Seq\n+import scala.math.Ordering.Implicits.infixOrderingOps\n \n object GetOffsetShell {\n+  private val TopicPartitionPattern = Pattern.compile( \"([^:,]*)(?::(?:([0-9]*)|(?:([0-9]*)-([0-9]*))))?\")\n \n   def main(args: Array[String]): Unit = {\n+    try {\n+      fetchOffsets(args)\n+    } catch {\n+      case e: Exception =>\n+        System.err.println(s\"Error occurred: $e.getMessage\")", "originalCommit": "8e69e1dc50566e19afd9a62b47976552a5c6f9d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE5NTU0Mw==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573195543", "bodyText": ".map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) } => .map(ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics)) - We usually don't use curly braces when the lambda is on one line.", "author": "dajac", "createdAt": "2021-02-09T19:58:44Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +150,79 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }", "originalCommit": "8e69e1dc50566e19afd9a62b47976552a5c6f9d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE5NTgwMQ==", "url": "https://github.com/apache/kafka/pull/9430#discussion_r573195801", "bodyText": "tp.partition() => tp.partition", "author": "dajac", "createdAt": "2021-02-09T19:59:06Z", "path": "core/src/main/scala/kafka/tools/GetOffsetShell.scala", "diffHunk": "@@ -132,23 +150,79 @@ object GetOffsetShell {\n         }\n     }\n \n-    partitionOffsets.toArray.sortBy { case (tp, _) => tp.partition }.foreach { case (tp, offset) =>\n-      println(s\"$topic:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n+    partitionOffsets.toSeq.sortWith((tp1, tp2) => compareTopicPartitions(tp1._1, tp2._1)).foreach {\n+      case (tp, offset) => println(s\"${tp.topic}:${tp.partition}:${Option(offset).getOrElse(\"\")}\")\n     }\n+  }\n \n+  def compareTopicPartitions(a: TopicPartition, b: TopicPartition): Boolean = {\n+    (a.topic(), a.partition()) < (b.topic(), b.partition())\n   }\n \n   /**\n-   * Return the partition infos for `topic`. If the topic does not exist, `None` is returned.\n+   * Creates a topic-partition filter based on a list of patterns.\n+   * Expected format:\n+   * List: TopicPartitionPattern(, TopicPartitionPattern)*\n+   * TopicPartitionPattern: TopicPattern(:PartitionPattern)? | :PartitionPattern\n+   * TopicPattern: REGEX\n+   * PartitionPattern: NUMBER | NUMBER-(NUMBER)? | -NUMBER\n    */\n-  private def listPartitionInfos(consumer: KafkaConsumer[_, _], topic: String, partitionIds: Set[Int]): Option[Seq[PartitionInfo]] = {\n-    val partitionInfos = consumer.listTopics.asScala.filter { case (k, _) => k == topic }.values.flatMap(_.asScala).toBuffer\n-    if (partitionInfos.isEmpty)\n-      None\n-    else if (partitionIds.isEmpty)\n-      Some(partitionInfos)\n+  def createTopicPartitionFilterWithPatternList(topicPartitions: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val ruleSpecs = topicPartitions.split(\",\")\n+    val rules = ruleSpecs.map { ruleSpec => parseRuleSpec(ruleSpec, excludeInternalTopics) }\n+    tp => rules.exists { rule => rule.apply(tp) }\n+  }\n+\n+  def parseRuleSpec(ruleSpec: String, excludeInternalTopics: Boolean): PartitionInfo => Boolean = {\n+    val matcher = TopicPartitionPattern.matcher(ruleSpec)\n+    if (!matcher.matches())\n+      throw new IllegalArgumentException(s\"Invalid rule specification: $ruleSpec\")\n+\n+    def group(group: Int): Option[String] = {\n+      Option(matcher.group(group)).filter(s => s != null && s.nonEmpty)\n+    }\n+\n+    val topicFilter = IncludeList(group(1).getOrElse(\".*\"))\n+    val partitionFilter = group(2).map(_.toInt) match {\n+      case Some(partition) =>\n+        (p: Int) => p == partition\n+      case None =>\n+        val lowerRange = group(3).map(_.toInt).getOrElse(0)\n+        val upperRange = group(4).map(_.toInt).getOrElse(Int.MaxValue)\n+        (p: Int) => p >= lowerRange && p < upperRange\n+    }\n+\n+    tp => topicFilter.isTopicAllowed(tp.topic, excludeInternalTopics) && partitionFilter(tp.partition())", "originalCommit": "8e69e1dc50566e19afd9a62b47976552a5c6f9d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d3d81152effc827a35e1fe5914664602b78488ef", "url": "https://github.com/apache/kafka/commit/d3d81152effc827a35e1fe5914664602b78488ef", "message": "KAFKA-5235: Cleanup based on review", "committedDate": "2021-02-10T11:49:08Z", "type": "forcePushed"}, {"oid": "7b989e430969273298329640a98ae3c0fd4de815", "url": "https://github.com/apache/kafka/commit/7b989e430969273298329640a98ae3c0fd4de815", "message": "KAFKA-5235: GetOffsetShell: support for multiple topics and consumer configuration override\n\nImplements KIP-635", "committedDate": "2021-02-10T12:14:19Z", "type": "commit"}, {"oid": "0ae1a7580cea131bcccbd939a058a05451e073ae", "url": "https://github.com/apache/kafka/commit/0ae1a7580cea131bcccbd939a058a05451e073ae", "message": "KAFKA-5235: Added .bat for windows, usage now mentions that only authorized topics are scanned", "committedDate": "2021-02-10T12:14:19Z", "type": "commit"}, {"oid": "fed78f70588afc06bbb77396fa77f237258828b2", "url": "https://github.com/apache/kafka/commit/fed78f70588afc06bbb77396fa77f237258828b2", "message": "KAFKA-5235: Deprecated --broker-list argument, introduced --boostrap-servre", "committedDate": "2021-02-10T12:14:19Z", "type": "commit"}, {"oid": "e7d2f2b3ab1c41602731185807b919789e1cb2df", "url": "https://github.com/apache/kafka/commit/e7d2f2b3ab1c41602731185807b919789e1cb2df", "message": "KAFKA-5235: Unit tests for GetOffsetShell", "committedDate": "2021-02-10T12:14:19Z", "type": "commit"}, {"oid": "12901068ff5200c8e8f2d840bbd25373784c6738", "url": "https://github.com/apache/kafka/commit/12901068ff5200c8e8f2d840bbd25373784c6738", "message": "KAFKA-5235: Addressed review comments", "committedDate": "2021-02-10T12:14:19Z", "type": "commit"}, {"oid": "6a9c6648951d9fd5c5bebc4d9c3ca2a0034bb610", "url": "https://github.com/apache/kafka/commit/6a9c6648951d9fd5c5bebc4d9c3ca2a0034bb610", "message": "KAFKA-5235: Rebase, switched pattern parsing to regex, removed explicit exits", "committedDate": "2021-02-10T12:14:20Z", "type": "commit"}, {"oid": "324810b00b9e14636ae9399fa7fe468b6dc50d00", "url": "https://github.com/apache/kafka/commit/324810b00b9e14636ae9399fa7fe468b6dc50d00", "message": "KAFKA-5235: Cleanup based on review", "committedDate": "2021-02-10T12:14:20Z", "type": "forcePushed"}, {"oid": "fabd539f30737ba7c6d163a7a58519e4d94d732a", "url": "https://github.com/apache/kafka/commit/fabd539f30737ba7c6d163a7a58519e4d94d732a", "message": "KAFKA-5235: Cleanup based on review", "committedDate": "2021-02-10T14:12:12Z", "type": "commit"}, {"oid": "fabd539f30737ba7c6d163a7a58519e4d94d732a", "url": "https://github.com/apache/kafka/commit/fabd539f30737ba7c6d163a7a58519e4d94d732a", "message": "KAFKA-5235: Cleanup based on review", "committedDate": "2021-02-10T14:12:12Z", "type": "forcePushed"}]}