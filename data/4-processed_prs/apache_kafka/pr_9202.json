{"pr_number": 9202, "pr_title": "KAFKA-10401: Fix the currentStateTimeStamp doesn't get set correctly", "pr_createdAt": "2020-08-20T04:28:02Z", "pr_url": "https://github.com/apache/kafka/pull/9202", "timeline": [{"oid": "fd8787a3df279ebd5e802008700b1c41a65f60ec", "url": "https://github.com/apache/kafka/commit/fd8787a3df279ebd5e802008700b1c41a65f60ec", "message": "KAFKA-10401: Fix the currentStateTimeStamp doesn't get set in GROUP_METADATA_VALUE_SCHEMA_V3", "committedDate": "2020-08-20T04:22:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjUxNg==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475046516", "bodyText": "We should use an if/else here, no point in using pattern matching.", "author": "ijuma", "createdAt": "2020-08-22T04:53:45Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,16 +1401,17 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1\n \n-      if (version >= 0 && version <= 3) {\n+      if (0 to maxVersion contains version) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n         val currentStateTimestamp: Option[Long] = version match {", "originalCommit": "fd8787a3df279ebd5e802008700b1c41a65f60ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1MjU4Mg==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475352582", "bodyText": "Nice catch! Yes, it's better to use if/else.", "author": "showuon", "createdAt": "2020-08-24T05:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjU0OA==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475046548", "bodyText": "I'd keep the old code and simply change the second clause to use maxVersion.", "author": "ijuma", "createdAt": "2020-08-22T04:54:16Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,16 +1401,17 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1\n \n-      if (version >= 0 && version <= 3) {\n+      if (0 to maxVersion contains version) {", "originalCommit": "fd8787a3df279ebd5e802008700b1c41a65f60ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae5ae323f159afc9bb384252e45bef640531ea94", "url": "https://github.com/apache/kafka/commit/ae5ae323f159afc9bb384252e45bef640531ea94", "message": "KAFKA-10401: address reviewer's comment to refactor codes and add test", "committedDate": "2020-08-24T05:33:27Z", "type": "commit"}, {"oid": "ae5ae323f159afc9bb384252e45bef640531ea94", "url": "https://github.com/apache/kafka/commit/ae5ae323f159afc9bb384252e45bef640531ea94", "message": "KAFKA-10401: address reviewer's comment to refactor codes and add test", "committedDate": "2020-08-24T05:33:27Z", "type": "forcePushed"}, {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289", "url": "https://github.com/apache/kafka/commit/468505e65be60f0e3d2ce71ebe3af50966026289", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-10401", "committedDate": "2020-09-03T08:42:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MjU5MQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485652591", "bodyText": "We should add a constant in GroupMetadataManager for this, maybe call it CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION for consistency with the other two similar fields.", "author": "ijuma", "createdAt": "2020-09-09T14:23:01Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,24 +1401,20 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1OTA5Ng==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486159096", "bodyText": "Good suggestion! Updated.", "author": "showuon", "createdAt": "2020-09-10T08:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MjU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MzAxOQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485653019", "bodyText": "Nit: un-supported -> unsupported.", "author": "ijuma", "createdAt": "2020-09-09T14:23:35Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MzE5MQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485653191", "bodyText": "Nit: unsupportedVersion.", "author": "ijuma", "createdAt": "2020-09-09T14:23:48Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NTI0Mg==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485655242", "bodyText": "Nit: TS -> Timestamp for clarity. Also, Version -> Versions.", "author": "ijuma", "createdAt": "2020-09-09T14:26:21Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unSupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unSupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTSForAllGroupMetadataVersion(): Unit = {", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjI1OQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485656259", "bodyText": "This fails without the change, right?", "author": "ijuma", "createdAt": "2020-09-09T14:27:41Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unSupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unSupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTSForAllGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.get)", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2MTQyOA==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486161428", "bodyText": "Correct! Also, after your question, I tried and found the message when test failed will be:\nkafka.coordinator.group.GroupMetadataManagerTest > testCurrentStateTimestampForAllGroupMetadataVersions FAILED\n    java.util.NoSuchElementException: None.get\n\nIt's not clear and not helpful for debugging. So I added failed message and use getOrElse(-1) to get an unexpected timestamp when none. Now, the failed message will be:\nkafka.coordinator.group.GroupMetadataManagerTest > testCurrentStateTimestampForAllGroupMetadataVersions FAILED\n    java.lang.AssertionError: the apiVersion 2.3-IV0 doesn't set the currentStateTimestamp correctly. expected:<1599726297785> but was:<-1>\n\nIt'll be more clear to show which version cause this error and what error it is.", "author": "showuon", "createdAt": "2020-09-10T08:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjkxNQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485656915", "bodyText": "Is this test related to the change or a gap you identified? It's fine if it's the latter, just trying to understand.", "author": "ijuma", "createdAt": "2020-09-09T14:28:30Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {", "originalCommit": "468505e65be60f0e3d2ce71ebe3af50966026289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2MjYzNw==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486162637", "bodyText": "This test doesn't relate to the change. I just like to add missing tests for what I saw. :)", "author": "showuon", "createdAt": "2020-09-10T08:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjkxNQ=="}], "type": "inlineReview"}, {"oid": "f01aaa643840c871d613c9e0af538b79519f2667", "url": "https://github.com/apache/kafka/commit/f01aaa643840c871d613c9e0af538b79519f2667", "message": "KAFKA-10401: address reviewer's comments to refactor the codes", "committedDate": "2020-09-10T08:26:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2MjgxNw==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490262817", "bodyText": "This would be more robust if we did something like:\nGROUP_VALUE_SCHEMAS.keySet.max\nOr something along those lines.", "author": "ijuma", "createdAt": "2020-09-17T13:51:41Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1139,6 +1139,7 @@ object GroupMetadataManager {\n \n   private val CURRENT_OFFSET_KEY_SCHEMA = schemaForKey(CURRENT_OFFSET_KEY_SCHEMA_VERSION)\n   private val CURRENT_GROUP_KEY_SCHEMA = schemaForKey(CURRENT_GROUP_KEY_SCHEMA_VERSION)\n+  private val CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION = GROUP_VALUE_SCHEMAS.size - 1", "originalCommit": "f01aaa643840c871d613c9e0af538b79519f2667", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MzE0OA==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490283148", "bodyText": "good suggestion! Thanks.", "author": "showuon", "createdAt": "2020-09-17T14:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2MjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2Mzk2NQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490263965", "bodyText": "I think it would be better to have the expected side be Some(time.milliseconds()), then you don't need the getOrElse on the actual side.", "author": "ijuma", "createdAt": "2020-09-17T13:53:13Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,44 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unsupportedVersion = Short.MinValue\n+\n+    // put the unsupported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unsupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unsupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTimestampForAllGroupMetadataVersions(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(s\"the apiVersion $apiVersion doesn't set the currentStateTimestamp correctly.\",\n+          time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.getOrElse(-1))", "originalCommit": "f01aaa643840c871d613c9e0af538b79519f2667", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MzE4MA==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490283180", "bodyText": "Good suggestion! Thanks.", "author": "showuon", "createdAt": "2020-09-17T14:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2Mzk2NQ=="}], "type": "inlineReview"}, {"oid": "97fe0a53d450d103e25dae0669c3ac803d7afe40", "url": "https://github.com/apache/kafka/commit/97fe0a53d450d103e25dae0669c3ac803d7afe40", "message": "KAFKA-10401: address reviewer's comment to use keySet.max to be more robust", "committedDate": "2020-09-17T14:15:28Z", "type": "commit"}, {"oid": "85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b", "url": "https://github.com/apache/kafka/commit/85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-10401", "committedDate": "2020-09-18T01:16:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r491240953", "bodyText": "I wonder if the version check is necessary. Is the presence of the field enough?", "author": "hachikuji", "createdAt": "2020-09-19T00:08:45Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1402,23 +1403,18 @@ object GroupMetadataManager {\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n \n-      if (version >= 0 && version <= 3) {\n+      if (version >= 0 && version <= CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n-        val currentStateTimestamp: Option[Long] = version match {\n-          case version if version == 2 =>\n-            if (value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {\n-              val timestamp = value.getLong(CURRENT_STATE_TIMESTAMP_KEY)\n-              if (timestamp == -1) None else Some(timestamp)\n-            } else\n-              None\n-          case _ =>\n-            None\n-        }\n+        val currentStateTimestamp: Option[Long] =\n+          if (version >= 2 && value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {", "originalCommit": "85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwODU0Mg==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r491908542", "bodyText": "@hachikuji , well, you're right, the CURRENT_STATE_TIMESTAMP_KEY field only set in version >= 2... in normal cases. I'm not sure if there's possibility that there will be version 0 or 1 containing the CURRENT_STATE_TIMESTAMP_KEY field situation. In my opinion, I think the check is OK and make it more robust, and most importantly, it's a simple check, not too many overhead to the resource. What do you think?", "author": "showuon", "createdAt": "2020-09-21T09:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwMzU1NQ==", "url": "https://github.com/apache/kafka/pull/9202#discussion_r492203555", "bodyText": "No strong opinion. I'm ok leaving the check.", "author": "hachikuji", "createdAt": "2020-09-21T16:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw=="}], "type": "inlineReview"}]}