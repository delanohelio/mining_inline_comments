{"pr_number": 8218, "pr_title": "KAFKA-9441: Unify committing within TaskManager", "pr_createdAt": "2020-03-04T03:10:26Z", "pr_url": "https://github.com/apache/kafka/pull/8218", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzUwMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387427500", "bodyText": "This is not really relevant for this PR, but we need to add it for KIP-447 eventually, thus I just include it in this PR.", "author": "mjsax", "createdAt": "2020-03-04T03:11:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java", "diffHunk": "@@ -275,6 +277,18 @@\n     @SuppressWarnings(\"WeakerAccess\")\n     public static final String UPGRADE_FROM_23 = \"2.3\";\n \n+    /**\n+     * Config value for parameter {@link #UPGRADE_FROM_CONFIG \"upgrade.from\"} for upgrading an application from version {@code 2.4.x}.\n+     */\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final String UPGRADE_FROM_24 = \"2.4\";\n+\n+    /**\n+     * Config value for parameter {@link #UPGRADE_FROM_CONFIG \"upgrade.from\"} for upgrading an application from version {@code 2.5.x}.\n+     */\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final String UPGRADE_FROM_25 = \"2.5\";\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzYzOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387427638", "bodyText": "We moved this to TaskManager", "author": "mjsax", "createdAt": "2020-03-04T03:12:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordCollector.java", "diffHunk": "@@ -45,8 +44,6 @@\n                      final Serializer<V> valueSerializer,\n                      final StreamPartitioner<? super K, ? super V> partitioner);\n \n-    void commit(final Map<TopicPartition, OffsetAndMetadata> offsets);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyOTg1NA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391829854", "bodyText": "Please see my other comment above --- I think it is cleaner to just call foreach(active-task) task.recordCollector.commit inside the task-manager; and inside RecordCollectorImpl we check that eosEnabled is always true, otherwise illegal-state thrown.\nIn the next PR where we have the thread-producer, we could then only create a single recordCollector object that is shared among all active tasks and wraps the thread-producer, and then the caller taskManager code then can just get one active task and call its record-collector's commit function knowing that is sufficient to actually commit for all tasks since everyone is using the same record-collector.\nWDYT?", "author": "guozhangwang", "createdAt": "2020-03-12T19:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjkzNA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393336934", "bodyText": "After syncing offline about this, I think I'm convinced now that moving this logic into TaskManager is better.", "author": "guozhangwang", "createdAt": "2020-03-16T22:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzgyMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387427823", "bodyText": "On suspend() and prepareCommit() we don't commit yet, but return the offsets that need to be committed", "author": "mjsax", "createdAt": "2020-03-04T03:12:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -102,8 +103,9 @@ public void completeRestoration() {\n     }\n \n     @Override\n-    public void suspend() {\n+    public Map<TopicPartition, OffsetAndMetadata> suspend() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyNzkxMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387427911", "bodyText": "We don't commit and thus don't throw any longer", "author": "mjsax", "createdAt": "2020-03-04T03:13:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -294,29 +296,24 @@ public void resume() {\n         }\n     }\n \n-    /**\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n-     */", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyODQxNg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387428416", "bodyText": "Frankly, not sure if this is correct any longer. What do we want to record with this sensor exactly? Flushing can be expensive and we might want to record it as part of committing -- but I am not sure.", "author": "mjsax", "createdAt": "2020-03-04T03:15:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -338,12 +335,14 @@ private void commitState() {\n         final long startNs = time.nanoseconds();\n \n         stateMgr.flush();\n-\n         recordCollector.flush();\n \n-        // we need to preserve the original partitions times before calling commit\n-        // because all partition times are reset to -1 during close\n+        commitSensor.record(time.nanoseconds() - startNs);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyODc4Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387428786", "bodyText": "I am not happy with this rewrite (but as I know that John did some changes in this class in another PR, I just did this hack her for now -- needs some cleanup after a rebase)", "author": "mjsax", "createdAt": "2020-03-04T03:17:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -59,9 +61,8 @@\n     private boolean transactionInFlight = false;\n     private boolean transactionInitialized = false;\n \n-    public StreamsProducer(final LogContext logContext,\n-                           final Producer<byte[], byte[]> producer) {\n-        this(logContext, producer, null, null);\n+    public StreamsProducer(final Producer<byte[], byte[]> producer) {\n+        this(null, producer, null, null);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyOTA2Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387429067", "bodyText": "We could also do a second loop over all tasks, after calling commit(..) below -- not sure if this is ok as-is?", "author": "mjsax", "createdAt": "2020-03-04T03:18:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -481,14 +486,16 @@ int commitAll() {\n         if (rebalanceInProgress) {\n             return -1;\n         } else {\n-            int commits = 0;\n+            final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n             for (final Task task : tasks.values()) {\n                 if (task.commitNeeded()) {\n-                    task.commit();\n-                    commits++;\n+                    consumedOffsetsAndMetadataPerTask.put(task.id(), task.prepareCommit());\n+                    task.markCommitted();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxOTQyMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388019423", "bodyText": "I would prefer a second loop to guarantee a consistent reflection on the task committed state.", "author": "abbccdda", "createdAt": "2020-03-05T00:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyOTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzMDU1Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387430556", "bodyText": "Moved both tests to TaskManagerTest", "author": "mjsax", "createdAt": "2020-03-04T03:25:43Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordCollectorTest.java", "diffHunk": "@@ -239,49 +231,6 @@ public void shouldPassThroughRecordHeaderToSerializer() {\n         }\n     }\n \n-    @Test\n-    public void shouldCommitViaConsumerIfEosDisabled() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzMDYzMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387430633", "bodyText": "move all 4 tests to TaskManagerTest", "author": "mjsax", "createdAt": "2020-03-04T03:26:02Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordCollectorTest.java", "diffHunk": "@@ -506,103 +445,12 @@ public void shouldThrowStreamsExceptionOnSubsequentCallIfFatalEvenWithContinueEx\n         assertThat(thrown.getMessage(), equalTo(\"Error encountered sending record to topic topic for task 0_0 due to:\\norg.apache.kafka.common.errors.AuthenticationException: KABOOM!\\nWritten offsets would not be recorded and no more records would be sent since this is a fatal error.\"));\n     }\n \n-    @Test\n-    public void shouldThrowTaskMigratedExceptionOnCommitFailed() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMDI1MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388030250", "bodyText": "Checkmark for proving the 6 tests are all migrated.", "author": "abbccdda", "createdAt": "2020-03-05T01:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzMDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NDAwMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387994001", "bodyText": "We need to allow committing in SUSPENDED state now as we first suspend all tasks and than commit. Cf. TaskManager#handleRevocation()", "author": "mjsax", "createdAt": "2020-03-04T23:23:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -294,29 +295,19 @@ public void resume() {\n         }\n     }\n \n-    /**\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n-     */\n     @Override\n-    public void commit() {\n+    public Map<TopicPartition, OffsetAndMetadata> prepareCommit() {\n         switch (state()) {\n             case RUNNING:\n             case RESTORING:\n-                commitState();\n-\n-                // this is an optimization for non-EOS only\n-                if (eosDisabled) {\n-                    stateMgr.checkpoint(checkpointableOffsets());\n-                }\n-\n-                log.info(\"Committed\");\n+            case SUSPENDED:", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NDI2OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387994269", "bodyText": "MInor improvement: we include writing the checkpoint and the caller can indicate if it should be written or not.", "author": "mjsax", "createdAt": "2020-03-04T23:23:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -334,16 +325,22 @@ public void commit() {\n      * @throws TaskMigratedException if committing offsets failed (non-EOS)\n      *                               or if the task producer got fenced (EOS)\n      */\n-    private void commitState() {\n+    private void commitState(final boolean writeCheckpoint) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NDY5Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387994697", "bodyText": "This issues was introduced in the PR that introduced StreamsProducer -- we forgot to close them. Fixing this on the side.", "author": "mjsax", "createdAt": "2020-03-04T23:25:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -409,6 +411,10 @@ public void close() {\n                 } catch (final Throwable e) {\n                     log.error(\"Failed to close producer due to the following error:\", e);\n                 }\n+            } else {\n+                for (final StreamsProducer streamsProducer : taskProducers.values()) {\n+                    streamsProducer.close();\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjUyMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388016523", "bodyText": "Sounds good, just mark that depending on John's fix, we probably don't need to handle this.", "author": "abbccdda", "createdAt": "2020-03-05T00:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NTA0NA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387995044", "bodyText": "We call closeClean below -- just fixing the comment here for now (\\cc @guozhangwang)\nNote that we don't commit offsets for this case any longer -- previously, committing offsets \"might\" have been done with closeClean() (even if I believe that the task would be marked as \"commitNeeded == false\"). We don't let the TaskManager commit offsets here, as it should not be required.", "author": "mjsax", "createdAt": "2020-03-04T23:26:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -138,7 +142,7 @@ void handleCorruption(final Map<TaskId, Set<TopicPartition>> taskWithChangelogs)\n             // this call is idempotent so even if the task is only CREATED we can still call it\n             changelogReader.remove(task.changelogPartitions());\n \n-            // mark corrupted partitions to not be checkpointed, and then close the task as dirty\n+            // mark corrupted partitions to not be checkpointed, and then close the task and revive the task", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NTg3NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387995875", "bodyText": "Similar to above: this issue was introduced in the StreamsProducer PR. We nee to close the producer when we remove it.", "author": "mjsax", "createdAt": "2020-03-04T23:28:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -194,7 +198,9 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                     // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n                     task.closeDirty();\n                 } finally {\n-                    taskProducers.remove(task.id());\n+                    if (taskProducers.containsKey(task.id())) {\n+                        taskProducers.remove(task.id()).close();\n+                    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMDgzNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388030837", "bodyText": "Probably need to change after rebase", "author": "abbccdda", "createdAt": "2020-03-05T01:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NTg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NTk2MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387995961", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-03-04T23:28:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -345,7 +352,9 @@ void handleLostAll() {\n                 cleanupTask(task);\n                 task.closeDirty();\n                 iterator.remove();\n-                taskProducers.remove(task.id());\n+                if (taskProducers.containsKey(task.id())) {\n+                    taskProducers.remove(task.id()).close();\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5NjEzMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387996132", "bodyText": "Not sure why we use an iterator here. Simplifying the code with a for-loop", "author": "mjsax", "createdAt": "2020-03-04T23:29:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -401,9 +410,12 @@ private void cleanupTask(final Task task) {\n \n     void shutdown(final boolean clean) {\n         final AtomicReference<RuntimeException> firstException = new AtomicReference<>(null);\n-        final Iterator<Task> iterator = tasks.values().iterator();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5Njc5Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387996797", "bodyText": "We need to commit explicitly in TTD now to mimic the TaskManger. Hence, we need access to the consumer and streamsProducer", "author": "mjsax", "createdAt": "2020-03-04T23:31:16Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -213,7 +214,9 @@\n     ProcessorTopology processorTopology;\n     ProcessorTopology globalTopology;\n \n+    private final MockConsumer<byte[], byte[]> consumer;\n     private final MockProducer<byte[], byte[]> producer;\n+    private final StreamsProducer streamsProducer;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyOTk1OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388029958", "bodyText": "Makes sense to me.", "author": "abbccdda", "createdAt": "2020-03-05T01:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5Njc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4MzU5MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387983590", "bodyText": "Did you already update the KIP for the new config?", "author": "abbccdda", "createdAt": "2020-03-04T22:54:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java", "diffHunk": "@@ -283,10 +297,26 @@\n \n     /**\n      * Config value for parameter {@link #PROCESSING_GUARANTEE_CONFIG \"processing.guarantee\"} for exactly-once processing guarantees.\n+     * <p>\n+     * Enabling exactly-once processing semantics requires broker version 0.11.0 or higher.\n+     * If you enable this feature, Kafka Streams will use a producer per task\n+     * (instead a producer per thread as for the {@link #AT_LEAST_ONCE} case).\n+     *\n+     * @see #EXACTLY_ONCE_BETA\n      */\n     @SuppressWarnings(\"WeakerAccess\")\n     public static final String EXACTLY_ONCE = \"exactly_once\";\n \n+    /**\n+     * Config value for parameter {@link #PROCESSING_GUARANTEE_CONFIG \"processing.guarantee\"} for exactly-once processing guarantees.\n+     * <p>\n+     * Enabling exactly-once (beta) requires broker version 2.5 or higher.\n+     * In contrast to {@link #EXACTLY_ONCE} Kafka Streams uses a producer per thread model,\n+     * similar to the {@link #AT_LEAST_ONCE} case.\n+     */\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final String EXACTLY_ONCE_BETA = \"exactly_once_beta\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NDI3MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r387984270", "bodyText": "What's the benefit of building this as a static helper?", "author": "abbccdda", "createdAt": "2020-03-04T22:56:19Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -707,6 +710,35 @@ public static String getSharedAdminClientId(final String clientId) {\n         return clientId + \"-admin\";\n     }\n \n+    static boolean eosAlphaEnabled(final StreamsConfig config) {\n+        return EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));\n+    }\n+\n+    public static boolean eosBetaEnabled(final StreamsConfig config) {\n+        return EXACTLY_ONCE_BETA.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));\n+    }\n+\n+    public static boolean eosEnabled(final StreamsConfig config) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MjEzMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r389052130", "bodyText": "We will need this later (ie follow up PR) and it reduced code duplication", "author": "mjsax", "createdAt": "2020-03-06T17:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NDI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTg1Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388015857", "bodyText": "Why do we start to suppress warnings?", "author": "abbccdda", "createdAt": "2020-03-05T00:33:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -504,8 +497,7 @@ public boolean isProcessable(final long wallClockTime) {\n      * @return true if this method processes a record, false if it does not process a record.\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MTU1MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r389051551", "bodyText": "We should have done this from the beginning on... (it's just a \"side fix\")", "author": "mjsax", "createdAt": "2020-03-06T17:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxODAxNQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388018015", "bodyText": "Add a comment describing the new return statement.", "author": "abbccdda", "createdAt": "2020-03-05T00:41:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -232,17 +232,16 @@ public void completeRestoration() {\n      *                               or if the task producer got fenced (EOS)\n      */\n     @Override\n-    public void suspend() {\n+    public Map<TopicPartition, OffsetAndMetadata> suspend() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxOTgyMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388019820", "bodyText": "In EOS beta, we should be able to send out a batch commit instead of individual ones?", "author": "abbccdda", "createdAt": "2020-03-05T00:47:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -500,17 +514,43 @@ int maybeCommitActiveTasksPerUserRequested() {\n         if (rebalanceInProgress) {\n             return -1;\n         } else {\n-            int commits = 0;\n+            final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n             for (final Task task : activeTaskIterable()) {\n                 if (task.commitRequested() && task.commitNeeded()) {\n-                    task.commit();\n-                    commits++;\n+                    consumedOffsetsAndMetadataPerTask.put(task.id(), task.prepareCommit());\n+                    task.markCommitted();\n                 }\n             }\n-            return commits;\n+            commit(consumedOffsetsAndMetadataPerTask);\n+\n+            return consumedOffsetsAndMetadataPerTask.size();\n         }\n     }\n \n+    private void commit(final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> offsetsPerTask) {\n+        if (eosEnabled) {\n+            for (final Map.Entry<TaskId, Map<TopicPartition, OffsetAndMetadata>> taskToCommit : offsetsPerTask.entrySet()) {\n+                taskProducers.get(taskToCommit.getKey()).commitTransaction(taskToCommit.getValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1Mjk1Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r389052956", "bodyText": "Correct. Unifying the commit logic as done is this PR allows us to do this in a follow up PR that actually enable producer per thread -- the whole purpose of this PR is to prepare/refactor for this.", "author": "mjsax", "createdAt": "2020-03-06T17:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxOTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyMjEzMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388022132", "bodyText": "I don't think we need to test assertFalse(task.commitNeeded() as its outcome is controlled by task.markCommitted. So we only need to do it once.", "author": "abbccdda", "createdAt": "2020-03-05T00:55:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -684,44 +686,47 @@ public void shouldRespectCommitNeeded() {\n         assertTrue(task.process(0L));\n         assertTrue(task.commitNeeded());\n \n-        task.commit();\n+        task.prepareCommit();\n+        assertTrue(task.commitNeeded());\n+\n+        task.markCommitted();\n         assertFalse(task.commitNeeded());\n \n         assertTrue(task.maybePunctuateStreamTime());\n         assertTrue(task.commitNeeded());\n \n-        task.commit();\n+        task.prepareCommit();\n+        assertTrue(task.commitNeeded());\n+\n+        task.markCommitted();\n         assertFalse(task.commitNeeded());\n \n         time.sleep(10);\n         assertTrue(task.maybePunctuateSystemTime());\n         assertTrue(task.commitNeeded());\n \n-        task.commit();\n+        task.prepareCommit();\n+        assertTrue(task.commitNeeded());\n+\n+        task.markCommitted();\n         assertFalse(task.commitNeeded());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyMjQxOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388022419", "bodyText": "Why do we no longer have the mock verification?", "author": "abbccdda", "createdAt": "2020-03-05T00:56:24Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -733,9 +738,9 @@ public void shouldCommitConsumerPositionIfRecordQueueIsEmpty() {\n \n         task.addRecords(partition1, singletonList(getConsumerRecord(partition1, 0L)));\n         task.process(0L);\n-        task.commit();\n+        final Map<TopicPartition, OffsetAndMetadata> offsetsAndMetadata = task.prepareCommit();\n \n-        verify(recordCollector);\n+        assertThat(offsetsAndMetadata, equalTo(mkMap(mkEntry(partition1, new OffsetAndMetadata(3L, encodeTimestamp(0L))))));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1NDY5NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r389054695", "bodyText": "We remove RecordCollector#commit() method in this PR and thus we remove the expected call to commit at the beginning of this test -- thus, there is nothing to be verified any longer and we don't call commit() with prepareCommit() any longer.", "author": "mjsax", "createdAt": "2020-03-06T17:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyMjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyNjY5MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388026690", "bodyText": "Should we do expectLastCall here?", "author": "abbccdda", "createdAt": "2020-03-05T01:11:22Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -441,10 +458,54 @@ public void shouldCommitActiveAndStandbyTasks() {\n     }\n \n     @Test\n+    public void shouldCommitViaConsumerIfEosDisabled() {\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+        task01.setCommitNeeded();\n+        taskManager.tasks().put(taskId01, task01);\n+\n+        consumer.commitSync(new HashMap<>());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyODY2NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388028665", "bodyText": "We should also verify the thrown cause", "author": "abbccdda", "createdAt": "2020-03-05T01:18:20Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -812,7 +877,79 @@ public void closeClean() {\n         assertThat(thrown.getCause().getMessage(), equalTo(null));\n     }\n \n+    @Test\n+    public void shouldThrowTaskMigratedExceptionOnCommitFailed() {\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+        task01.setCommitNeeded();\n+        taskManager.tasks().put(taskId01, task01);\n+\n+        consumer.commitSync(new HashMap<>());\n+        expectLastCall().andThrow(new CommitFailedException());\n+        replay(consumer);\n+\n+        final TaskMigratedException thrown = assertThrows(\n+            TaskMigratedException.class,\n+            () -> taskManager.commitAll()\n+        );\n+\n+        assertThat(thrown.getMessage(), equalTo(\"Consumer committing offsets failed, indicating the corresponding thread is no longer part of the group; it means all tasks belonging to this thread should be migrated.\"));\n+    }\n+\n+    @Test\n+    public void shouldThrowStreamsExceptionOnCommitTimeout() {\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+        task01.setCommitNeeded();\n+        taskManager.tasks().put(taskId01, task01);\n+\n+        consumer.commitSync(new HashMap<>());\n+        expectLastCall().andThrow(new TimeoutException());\n+        replay(consumer);\n+\n+        final StreamsException thrown = assertThrows(\n+            StreamsException.class,\n+            () -> taskManager.commitAll()\n+        );\n+\n+        assertThat(thrown.getMessage(), equalTo(\"Timed out while committing offsets via consumer\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyODgyMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388028820", "bodyText": "Same here, for verifying the thrown cause", "author": "abbccdda", "createdAt": "2020-03-05T01:18:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -812,7 +877,79 @@ public void closeClean() {\n         assertThat(thrown.getCause().getMessage(), equalTo(null));\n     }\n \n+    @Test\n+    public void shouldThrowTaskMigratedExceptionOnCommitFailed() {\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+        task01.setCommitNeeded();\n+        taskManager.tasks().put(taskId01, task01);\n+\n+        consumer.commitSync(new HashMap<>());\n+        expectLastCall().andThrow(new CommitFailedException());\n+        replay(consumer);\n+\n+        final TaskMigratedException thrown = assertThrows(\n+            TaskMigratedException.class,\n+            () -> taskManager.commitAll()\n+        );\n+\n+        assertThat(thrown.getMessage(), equalTo(\"Consumer committing offsets failed, indicating the corresponding thread is no longer part of the group; it means all tasks belonging to this thread should be migrated.\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxNzE1Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393917156", "bodyText": "This is a meta comment: since we moved the commit logic out of the tasks into task-manager already, we should add the check that:\n\ninside the task manager, if the commit failed with fatal errors, the corresponding follow-up steps (postCommit, suspend, closeClean) should be skipped, and the exception is thrown out of the task-manager to thread\nif commit failed with fenced errors, follow-up steps are also skipped (tasks state should be un-changed) and the task-migration exception is thrown out of the task-manager.", "author": "guozhangwang", "createdAt": "2020-03-17T19:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyODgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyOTE2NA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388029164", "bodyText": "What's the reasoning her for only wrapping the consumer offset commit case here, not for EOS case?", "author": "abbccdda", "createdAt": "2020-03-05T01:20:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -500,17 +514,43 @@ int maybeCommitActiveTasksPerUserRequested() {\n         if (rebalanceInProgress) {\n             return -1;\n         } else {\n-            int commits = 0;\n+            final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n             for (final Task task : activeTaskIterable()) {\n                 if (task.commitRequested() && task.commitNeeded()) {\n-                    task.commit();\n-                    commits++;\n+                    consumedOffsetsAndMetadataPerTask.put(task.id(), task.prepareCommit());\n+                    task.markCommitted();\n                 }\n             }\n-            return commits;\n+            commit(consumedOffsetsAndMetadataPerTask);\n+\n+            return consumedOffsetsAndMetadataPerTask.size();\n         }\n     }\n \n+    private void commit(final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> offsetsPerTask) {\n+        if (eosEnabled) {\n+            for (final Map.Entry<TaskId, Map<TopicPartition, OffsetAndMetadata>> taskToCommit : offsetsPerTask.entrySet()) {\n+                taskProducers.get(taskToCommit.getKey()).commitTransaction(taskToCommit.getValue());\n+            }\n+        } else {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MzU5OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r389053599", "bodyText": "You mean exception handling? For the producer all exception handling is done within StreamsProducer (note that threadProducer above is a StreamsProducer, not a KafkaProducer)", "author": "mjsax", "createdAt": "2020-03-06T17:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyOTE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0NDcyOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391244729", "bodyText": "\ud83d\udc4d", "author": "abbccdda", "createdAt": "2020-03-11T20:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyOTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyOTQ3MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r388029471", "bodyText": "Always feels better for one less parameter :)", "author": "abbccdda", "createdAt": "2020-03-05T01:21:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/KeyValueStoreTestDriver.java", "diffHunk": "@@ -200,8 +200,7 @@ private KeyValueStoreTestDriver(final StateSerdes<K, V> serdes) {\n         final RecordCollector recordCollector = new RecordCollectorImpl(\n             logContext,\n             new TaskId(0, 0),\n-            consumer,\n-            new StreamsProducer(logContext, producer),\n+            new StreamsProducer(producer),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjIxMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390712211", "bodyText": "This is an open question: we don't want to remove this sensor however it was unclear to me how to handle this metric after we split \"task committing\" into three steps (prepareCommit; taskManager#commit; postCommit).", "author": "mjsax", "createdAt": "2020-03-11T02:20:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -92,7 +92,6 @@\n     private final Sensor closeTaskSensor;\n     private final Sensor processLatencySensor;\n     private final Sensor punctuateLatencySensor;\n-    private final Sensor commitSensor;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2MTkyOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391261929", "bodyText": "Should we attempt to add more fine-grained metrics for 3 stages then?", "author": "abbccdda", "createdAt": "2020-03-11T20:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODUzMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391338530", "bodyText": "Frankly, I have no good idea atm... Also, if we change metrics, we need to update the KIP and it's getting more complicated. If possible, I would prefer to not change any metric, but not sure if it is possible...", "author": "mjsax", "createdAt": "2020-03-12T00:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzODcwNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391838707", "bodyText": "I actually think that we can remove this DEBUG-level per-task commit metrics, since we already have the INFO-level per-thread commit metric and this one does not provide much more additional information?", "author": "guozhangwang", "createdAt": "2020-03-12T19:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjU3MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390712571", "bodyText": "Simplification to avoid passing in eosEnabled and reducing constructor parameter list -- we just piggy back on the application.id that shall be null for non-eos.", "author": "mjsax", "createdAt": "2020-03-11T02:22:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -58,25 +58,24 @@\n     private boolean transactionInitialized = false;\n \n     public StreamsProducer(final Producer<byte[], byte[]> producer,\n-                           final boolean eosEnabled,\n-                           final LogContext logContext,\n-                           final String applicationId) {\n-        log = logContext.logger(getClass());\n+                           final String applicationId,\n+                           final LogContext logContext) {\n+        log = Objects.requireNonNull(logContext, \"logContext cannot be null\").logger(getClass());\n         logPrefix = logContext.logPrefix().trim();\n \n         this.producer = Objects.requireNonNull(producer, \"producer cannot be null\");\n         this.applicationId = applicationId;\n-        this.eosEnabled = eosEnabled;\n+        this.eosEnabled = applicationId != null;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2MjgwOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391162808", "bodyText": "It seems a bit roundabout to have to remember we should send a null application.id as the constructor argument to indicate that eos is enabled. What's wrong with saying \"eos is enabled\" when you want eos to be enabled?", "author": "vvcephei", "createdAt": "2020-03-11T18:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMjI0Mg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391812242", "bodyText": "Subjectively I'd +1 that adding one more parameter to avoid piggy-backing on the applicationId is better.", "author": "guozhangwang", "createdAt": "2020-03-12T18:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk5MzQxMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391993410", "bodyText": "It's a personal preference I guess. But seems you don't like it. Will revert it.", "author": "mjsax", "createdAt": "2020-03-13T02:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjY2NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390712665", "bodyText": "Avoid redundant logging.", "author": "mjsax", "createdAt": "2020-03-11T02:22:35Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -58,25 +58,24 @@\n     private boolean transactionInitialized = false;\n \n     public StreamsProducer(final Producer<byte[], byte[]> producer,\n-                           final boolean eosEnabled,\n-                           final LogContext logContext,\n-                           final String applicationId) {\n-        log = logContext.logger(getClass());\n+                           final String applicationId,\n+                           final LogContext logContext) {\n+        log = Objects.requireNonNull(logContext, \"logContext cannot be null\").logger(getClass());\n         logPrefix = logContext.logPrefix().trim();\n \n         this.producer = Objects.requireNonNull(producer, \"producer cannot be null\");\n         this.applicationId = applicationId;\n-        this.eosEnabled = eosEnabled;\n+        this.eosEnabled = applicationId != null;\n     }\n \n     private String formatException(final String message) {\n-        return message + \" [\" + logPrefix + \", \" + (eosEnabled ? \"eos\" : \"alo\") + \"]\";\n+        return message + \" [\" + logPrefix + \"]\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjc3MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390712770", "bodyText": "Side cleanup: All those method can actually be package private.", "author": "mjsax", "createdAt": "2020-03-11T02:23:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -58,25 +58,24 @@\n     private boolean transactionInitialized = false;\n \n     public StreamsProducer(final Producer<byte[], byte[]> producer,\n-                           final boolean eosEnabled,\n-                           final LogContext logContext,\n-                           final String applicationId) {\n-        log = logContext.logger(getClass());\n+                           final String applicationId,\n+                           final LogContext logContext) {\n+        log = Objects.requireNonNull(logContext, \"logContext cannot be null\").logger(getClass());\n         logPrefix = logContext.logPrefix().trim();\n \n         this.producer = Objects.requireNonNull(producer, \"producer cannot be null\");\n         this.applicationId = applicationId;\n-        this.eosEnabled = eosEnabled;\n+        this.eosEnabled = applicationId != null;\n     }\n \n     private String formatException(final String message) {\n-        return message + \" [\" + logPrefix + \", \" + (eosEnabled ? \"eos\" : \"alo\") + \"]\";\n+        return message + \" [\" + logPrefix + \"]\";\n     }\n \n     /**\n      * @throws IllegalStateException if EOS is disabled\n      */\n-    public void initTransaction() {\n+    void initTransaction() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjk3MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390712971", "bodyText": "Removing this state -- this is an open question if I did this correctly. \\cc @vvcephei", "author": "mjsax", "createdAt": "2020-03-11T02:23:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -71,7 +72,6 @@\n         RESTORING(2, 3, 4),    // 1\n         RUNNING(3, 4),         // 2\n         SUSPENDED(1, 4),       // 3\n-        CLOSING(4, 5),         // 4, we allow CLOSING to transit to itself to make close idempotent", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDAyNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390714027", "bodyText": "After we addressed the question how we want to do metrics, we can update this tests", "author": "mjsax", "createdAt": "2020-03-11T02:27:59Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -385,30 +387,30 @@ public void shouldConstructMetricsWithBuiltInMetricsVersionLatest() {\n     private void testMetrics(final String builtInMetricsVersion) {\n         task = createStatelessTask(createConfig(false, \"100\"), builtInMetricsVersion);\n \n-        assertNotNull(getMetric(\n-            \"commit\",\n-            \"%s-latency-avg\",\n-            task.id().toString(),\n-            builtInMetricsVersion\n-        ));\n-        assertNotNull(getMetric(\n-            \"commit\",\n-            \"%s-latency-max\",\n-            task.id().toString(),\n-            builtInMetricsVersion\n-        ));\n-        assertNotNull(getMetric(\n-            \"commit\",\n-            \"%s-rate\",\n-            task.id().toString(),\n-            builtInMetricsVersion\n-        ));\n-        assertNotNull(getMetric(\n-            \"commit\",\n-            \"%s-total\",\n-            task.id().toString(),\n-            builtInMetricsVersion\n-        ));\n+//        assertNotNull(getMetric(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDQ4OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390714488", "bodyText": "Because we make app method in StreamsProducer package private but need access to commit() we add TestDriverProducer to get access.", "author": "mjsax", "createdAt": "2020-03-11T02:29:59Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -213,7 +214,9 @@\n     ProcessorTopology processorTopology;\n     ProcessorTopology globalTopology;\n \n+    private final MockConsumer<byte[], byte[]> consumer;\n     private final MockProducer<byte[], byte[]> producer;\n+    private final TestDriverProducer testDriverProducer;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDc0MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390714741", "bodyText": "Just added to give public access to commitTransaction() to TTD (it's more elegant than making StreamsProducer#commitTransaction public IMHO)", "author": "mjsax", "createdAt": "2020-03-11T02:31:09Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/processor/internals/TestDriverProducer.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.clients.producer.Producer;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.errors.ProducerFencedException;\n+import org.apache.kafka.common.utils.LogContext;\n+\n+import java.util.Map;\n+\n+public class TestDriverProducer extends StreamsProducer {\n+\n+    public TestDriverProducer(final Producer<byte[], byte[]> producer,\n+                              final String applicationId,\n+                              final LogContext logContext) {\n+        super(producer, applicationId, logContext);\n+    }\n+\n+    public void commitTransaction(final Map<TopicPartition, OffsetAndMetadata> offsets) throws ProducerFencedException {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkxMTUzMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393911532", "bodyText": "Why making commitTransaction is less elegant? I thought that was fine since StreamsProducer is inside the internals package anyways? In fact, in TTD we have access to InternalTopologyBuilder accessing it functions (we used to also have a wrapper of InternalTopologyBuilder which we removed later) so I thought that was the agreed pattern.", "author": "guozhangwang", "createdAt": "2020-03-17T19:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2ODg0Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393968843", "bodyText": "It's obviously subjective -- personally, even if something is internal, we should not just declare stuff as public but try to keep it to a minimum to follow the idea of encapsulation (not always possible). If you want me to remove this class and make the method public I can do it in a follow up PR. Not sure if we have an agreed pattern, though.", "author": "mjsax", "createdAt": "2020-03-17T21:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3OTA0MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393979041", "bodyText": "Cool, in that sense let's just keep it then -- do not add it in one PR and remove it immediately in the next.", "author": "guozhangwang", "createdAt": "2020-03-17T21:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDc0MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNzQwOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r390727409", "bodyText": "nit: we could log thread-id here for easier log search.", "author": "abbccdda", "createdAt": "2020-03-11T03:27:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -80,32 +80,42 @@ private static String getTaskProducerClientId(final String threadClientId, final\n                       final KafkaClientSupplier clientSupplier,\n                       final String threadId,\n                       final Logger log) {\n-        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n         this.builder = builder;\n         this.config = config;\n         this.streamsMetrics = streamsMetrics;\n         this.stateDirectory = stateDirectory;\n         this.storeChangelogReader = storeChangelogReader;\n+        this.cache = cache;\n         this.time = time;\n+        this.clientSupplier = clientSupplier;\n+        this.threadId = threadId;\n         this.log = log;\n \n+        createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n+        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+\n         if (EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG))) {\n             threadProducer = null;\n             taskProducers = new HashMap<>();\n         } else {\n+            log.info(\"Creating thread producer client\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNzc4Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391337786", "bodyText": "The threadId is already added to the log prefix when the log object is created in StreamsThread", "author": "mjsax", "createdAt": "2020-03-12T00:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzMzc3Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391233773", "bodyText": "Could we internalize this state check inside the task to simplify the logic here?", "author": "abbccdda", "createdAt": "2020-03-11T20:05:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -182,30 +193,49 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                 cleanupTask(task);\n \n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDQzNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391344437", "bodyText": "prepareCloseClean() already does a state check and returns emptyMap if state is CREATED.\nThe point of this check is, that we don't add anything to the consumedOffsetsAndMetadataPerTask map -- this is important for the corner case for which all tasks are in state CREATED and thus no transaction was initialized. For this case we cannot call producer.addOffsetsToTranscation() and must skip this step entirely. Note, that we have a corresponding check below to not call commitOffsetsOrTransaction if the map is empty.", "author": "mjsax", "createdAt": "2020-03-12T00:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzMzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NTQzOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393385438", "bodyText": "See my other comments: we should not commit in CREATED, RESTORING and SUSPENDED state, and it's better just to let the prepareXX function to indicate if there's anything to commit based on its state internally than letting task-manager to branch on the task state -- more specifically, here the prepareClose call should not return the map of checkpoints but the map of partition -> partition-timestamps (if empty it means nothing to commit), since the checkpoint map are not needed at task-manager at all and post commit, if the offsets should be empty it would still be empty.", "author": "guozhangwang", "createdAt": "2020-03-17T00:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzMzc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNDI0OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391234248", "bodyText": "Similarly here, this state check could be internalized.", "author": "abbccdda", "createdAt": "2020-03-11T20:05:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -320,13 +363,27 @@ boolean tryToCompleteRestoration() {\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n+        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                task.suspend();\n+                task.prepareSuspend();\n+                if (task.state() != CREATED) {\n+                    consumedOffsetsAndMetadataPerTask.put(task.id(), task.committableOffsetsAndMetadata());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzOTA2Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393339067", "bodyText": "I think we should just let the prepareXX function to return the map of partitions -> partition-timestamp to indicate if it should be included in the map of committing offsets, so that we do not need to leak the state into task-manager here. Also we only need to call mainConsumer.position once for all tasks -- please see my other comment above.\nAlso: we should not try to commit state if we are in RESTORING but only flushing store and writing checkpoints (I think this is already the behavior in trunk), since the partitions are paused from the main-consumer before restoration is done --- maybe it is partly causing some unit test flakiness.", "author": "guozhangwang", "createdAt": "2020-03-16T22:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNDI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNjUwOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391236509", "bodyText": "nit: let's order the functions as\nprepareCloseClean\ncloseClean\nprepareCloseDirty\ncloseDirty", "author": "abbccdda", "createdAt": "2020-03-11T20:07:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -123,35 +123,41 @@ public boolean isValidTransition(final State newState) {\n     boolean commitNeeded();\n \n     /**\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void commit();\n+    void prepareCommit();\n+\n+    void postCommit();\n \n     /**\n      * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void suspend();\n+    void prepareSuspend();\n \n+    void suspend();\n     /**\n+     *\n      * @throws StreamsException fatal error, should close the thread\n      */\n     void resume();\n \n     /**\n-     * Close a task that we still own. Commit all progress and close the task gracefully.\n+     * Close a task that we still own and prepare it for committing\n      * Throws an exception if this couldn't be done.\n      *\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void closeClean();\n+    Map<TopicPartition, Long> prepareCloseClean();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNzA3OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391237078", "bodyText": "Prepare to uncleanly close a task that we may not own.", "author": "abbccdda", "createdAt": "2020-03-11T20:08:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -123,35 +123,41 @@ public boolean isValidTransition(final State newState) {\n     boolean commitNeeded();\n \n     /**\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void commit();\n+    void prepareCommit();\n+\n+    void postCommit();\n \n     /**\n      * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void suspend();\n+    void prepareSuspend();\n \n+    void suspend();\n     /**\n+     *\n      * @throws StreamsException fatal error, should close the thread\n      */\n     void resume();\n \n     /**\n-     * Close a task that we still own. Commit all progress and close the task gracefully.\n+     * Close a task that we still own and prepare it for committing\n      * Throws an exception if this couldn't be done.\n      *\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void closeClean();\n+    Map<TopicPartition, Long> prepareCloseClean();\n \n     /**\n      * Close a task that we may not own. Discard any uncommitted progress and close the task.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MTUyOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391241528", "bodyText": "Having a prepareCloseDirty makes the calling of closeDirty a bit cumbersome as we always need to call prepareCloseDirty first. To simplify or just do a reminder, I have two suggestions:\n\nInternally create a task state called PREPARE_CLOSE or just a boolean like closeDirtyPrepared as the state check, so that closeDirty will throw illegal state if the flag is false\nFollowing #1, instead of throw, if we don't see the prepareClose is being called, the closeDirty will invoke prepareCloseDirty first internally.", "author": "abbccdda", "createdAt": "2020-03-11T20:13:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -144,6 +149,7 @@ void handleCorruption(final Map<TaskId, Collection<TopicPartition>> taskWithChan\n             final Collection<TopicPartition> corruptedPartitions = entry.getValue();\n             task.markChangelogAsCorrupted(corruptedPartitions);\n \n+            task.prepareCloseDirty();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mjk2Mg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391342962", "bodyText": "I actually had a similar though, but was not sure if it's worth it. Would like to hear from @guozhangwang @vvcephei what they think?\nIf we do this, we might want to do it for \"commit\" and \"suspend\", too. For suspend() adding a state SUSPEND_PREPARED is not helpful as suspend() does different things depending on the previous state. (For commit and close an additional state would work). For consistency reasons, an internal flag might be better though.\nNot sure ate if calling \"prepare\" automatically would actually be correct for all cases?", "author": "mjsax", "createdAt": "2020-03-12T00:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4NDMwOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392784308", "bodyText": "We can address this in a follow up PR.", "author": "mjsax", "createdAt": "2020-03-16T05:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NTQ1NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393195455", "bodyText": "Yea, a TODO is also ok.", "author": "abbccdda", "createdAt": "2020-03-16T17:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NDI2Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393384266", "bodyText": "For the next PR: I think we can save prepareClose (or more accurately, merge prepareClose and close together again) if we make a state diagram change that only suspended state can transit to closed state, i.e. at task-manager level whenever we want to close a task we call its suspend function first, which would, depending on its state, be a no-op, or flushing, or closing topology etc, and then after that the task is always in SUSPENDED state, and then we call \"commit\" if necessary, and then we call close (a minor thing is that today when the state is in SUSPENDED we would omit committing inside task, and we need to lift this restriction; and also the transition actions to transit to SUSPENDED need to rely on the clean flag, hence we need suspend(clean-flag)).\nAND we can further merge prepareSuspend and suspend as well by just making the checkpointing logic as part of post-commit instead of post-suspend, since as I mentioned above you only have three cases:\n\ndo not need to checkpoint: if you are in CREATED.\ncheckpoint written and consumed offsets: if you are in RUNNING, in which you need to commit offsets as well.\ncheckpoint only store offsets: if you are in RESTORING, and in which case you do not need to commit offsets.\n\nIn fact, if we are not in the RUNNING state yet, the consumedOffsets as well as recordCollector#offsets() are always going to be empty, so it is always safe to call stateMgr.checkpoint(checkpointableOffsets()) and not condition on the state and call stateMgr.checkpoint(emptySet()).\nAnd if we now allow committing in SUSPENDED state as part of closing (i.e. suspend -> commit -> close), similar rules apply: if we are suspending from a RESTORING state, then in postCommit while we ``stateMgr.checkpoint(checkpointableOffsets())thecheckpointableOffsets` would always be empty; if we are suspending from a RUNNING state it would contain some offsets.", "author": "guozhangwang", "createdAt": "2020-03-17T00:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzkxMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391243910", "bodyText": "@guozhangwang For my own education, why we do and here instead of just checking commitRequested?", "author": "abbccdda", "createdAt": "2020-03-11T20:17:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -555,14 +653,46 @@ int maybeCommitActiveTasksPerUserRequested() {\n         if (rebalanceInProgress) {\n             return -1;\n         } else {\n-            int commits = 0;\n+            final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n             for (final Task task : activeTaskIterable()) {\n                 if (task.commitRequested() && task.commitNeeded()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTk4Mg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391345982", "bodyText": "To avoid the overhead to commit offset that are already committed, ie, the previous commit committed offset 5 and now we would commit offset 5 again.", "author": "mjsax", "createdAt": "2020-03-12T00:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4Nzg0MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393387840", "bodyText": "\"as above\" :)", "author": "guozhangwang", "createdAt": "2020-03-17T00:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQxODAxMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393418010", "bodyText": "Within maybeCommitActiveTasksPerUserRequested we know that we are in state RUNNING and thus, no need to check what committableOffsetsAndMetadata() returns but we can \"blindly\" commit.", "author": "mjsax", "createdAt": "2020-03-17T02:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2MDI0Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391260243", "bodyText": "Comment here for no better place: Standby task always returns an empty committableOffsetsAndMetadata, then why do we still need to check commitNeeded for it? Shouldn't it always set to false?", "author": "abbccdda", "createdAt": "2020-03-11T20:50:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -115,48 +121,45 @@ public void resume() {\n      * 1. flush store\n      * 2. write checkpoint file\n      *\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n     @Override\n-    public void commit() {\n-        switch (state()) {\n-            case RUNNING:\n-                stateMgr.flush();\n-\n-                // since there's no written offsets we can checkpoint with empty map,\n-                // and the state current offset would be used to checkpoint\n-                stateMgr.checkpoint(Collections.emptyMap());\n-\n-                offsetSnapshotSinceLastCommit = new HashMap<>(stateMgr.changelogOffsets());\n-\n-                log.info(\"Committed\");\n-                break;\n-\n-            case CLOSING:\n-                // do nothing and also not throw\n-                log.trace(\"Skip committing since task is closing\");\n-\n-                break;\n-\n-            default:\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while committing standby task \" + id);\n+    public void prepareCommit() {\n+        if (state() == State.RUNNING) {\n+            stateMgr.flush();\n+            log.info(\"Task ready for committing\");\n+        } else {\n+            throw new IllegalStateException(\"Illegal state \" + state() + \" while preparing standby task \" + id + \" for committing \");\n+        }\n+    }\n \n+    @Override", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODIzOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391338238", "bodyText": "Not sure if I can follow. We don't check commitNeeded in postCommit()? Can you elaborate?", "author": "mjsax", "createdAt": "2020-03-12T00:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2MDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2MTE1OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391261158", "bodyText": "logContext  is not used.", "author": "abbccdda", "createdAt": "2020-03-11T20:52:34Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -80,32 +80,42 @@ private static String getTaskProducerClientId(final String threadClientId, final\n                       final KafkaClientSupplier clientSupplier,\n                       final String threadId,\n                       final Logger log) {\n-        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n         this.builder = builder;\n         this.config = config;\n         this.streamsMetrics = streamsMetrics;\n         this.stateDirectory = stateDirectory;\n         this.storeChangelogReader = storeChangelogReader;\n+        this.cache = cache;\n         this.time = time;\n+        this.clientSupplier = clientSupplier;\n+        this.threadId = threadId;\n         this.log = log;\n \n+        createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n+        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+\n         if (EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG))) {\n             threadProducer = null;\n             taskProducers = new HashMap<>();\n         } else {\n+            log.info(\"Creating thread producer client\");\n+\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n-            log.info(\"Creating thread producer client\");\n+\n+            final String logPrefix = String.format(\"stream-thread [%s] \", Thread.currentThread().getName());\n+            final LogContext logContext = new LogContext(logPrefix);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0ODU4Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391348586", "bodyText": "Good catch.", "author": "mjsax", "createdAt": "2020-03-12T00:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2MTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NTcxMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391265711", "bodyText": "Could we add a @return for this method? Also we should comment about the different indications when we return an empty map vs null.", "author": "abbccdda", "createdAt": "2020-03-11T21:01:37Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -410,54 +410,88 @@ public void closeDirty() {\n      * @throws TaskMigratedException if committing offsets failed (non-EOS)\n      *                               or if the task producer got fenced (EOS)\n      */\n-    private void close(final boolean clean) {\n+    private Map<TopicPartition, Long> prepareClose(final boolean clean) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzOTIxMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391339213", "bodyText": "Why do we need to document this in the method JavaDoc? It's an internal method? Internal comment outdate quickly if code is changed and comments are not updated accordingly (what happens 99% of the time). Hence, I would prefer to limit comments if possible. In doubt, we should document at Task level anyway.", "author": "mjsax", "createdAt": "2020-03-12T00:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NTcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MDQzOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391340439", "bodyText": "@guozhangwang I am actually wondering about point (5) -- why do we need to checkpoint the state manager if we wipe out the store later anyway for the unclean EOS case?", "author": "mjsax", "createdAt": "2020-03-12T00:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NTcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MzAyMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393373023", "bodyText": "Yes we are unnecessarily checkpointing here --- the reason is that EOS flag was original striped out of task and only processor-state-manager knows about it; now since we get this EOS flag back to task (sigh.. :) we can add this additional check.", "author": "guozhangwang", "createdAt": "2020-03-16T23:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NzEwOQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391267109", "bodyText": "Remove if", "author": "abbccdda", "createdAt": "2020-03-11T21:04:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -410,54 +410,88 @@ public void closeDirty() {\n      * @throws TaskMigratedException if committing offsets failed (non-EOS)\n      *                               or if the task producer got fenced (EOS)\n      */\n-    private void close(final boolean clean) {\n+    private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n+        final Map<TopicPartition, Long> checkpoint;\n+\n         if (state() == State.CREATED) {\n             // the task is created and not initialized, just re-write the checkpoint file\n-            executeAndMaybeSwallow(clean, () -> {\n-                stateMgr.checkpoint(Collections.emptyMap());\n-            }, \"state manager checkpoint\", log);\n-\n-            transitionTo(State.CLOSING);\n+            checkpoint = Collections.emptyMap();\n         } else if (state() == State.RUNNING) {\n             closeTopology(clean);\n \n             if (clean) {\n-                commitState();\n-                // whenever we have successfully committed state, it is safe to checkpoint\n-                // the state as well no matter if EOS is enabled or not\n-                stateMgr.checkpoint(checkpointableOffsets());\n+                stateMgr.flush();\n+                recordCollector.flush();\n+                checkpoint = checkpointableOffsets();\n             } else {\n+                checkpoint = null; // `null` indicates to not write a checkpoint\n                 executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n             }\n-\n-            transitionTo(State.CLOSING);\n         } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, () -> {\n-                stateMgr.flush();\n-                stateMgr.checkpoint(Collections.emptyMap());\n-            }, \"state manager flush and checkpoint\", log);\n-\n-            transitionTo(State.CLOSING);\n+            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+            checkpoint = Collections.emptyMap();\n         } else if (state() == State.SUSPENDED) {\n-            // do not need to commit / checkpoint, since when suspending we've already committed the state\n-            transitionTo(State.CLOSING);\n+            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4Njk4OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391286988", "bodyText": "I feel a bit weird here as we don't need prepareCloseClean anymore. This API usage is a little complicated upon when we should do it and we don't.", "author": "abbccdda", "createdAt": "2020-03-11T21:47:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -182,30 +193,49 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                 cleanupTask(task);\n \n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {\n+                        consumedOffsetsAndMetadataPerTask.put(task.id(), task.committableOffsetsAndMetadata());\n+                    }\n                 } catch (final RuntimeException e) {\n                     final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n                     log.error(uncleanMessage, e);\n                     taskCloseExceptions.put(task.id(), e);\n                     // We've already recorded the exception (which is the point of clean).\n                     // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n-                    task.closeDirty();\n-                } finally {\n-                    if (task.isActive()) {\n-                        try {\n-                            activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(task.id());\n-                        } catch (final RuntimeException e) {\n-                            final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n-                            log.error(uncleanMessage, e);\n-                            taskCloseExceptions.putIfAbsent(task.id(), e);\n-                        }\n-                    }\n+                    task.prepareCloseDirty();\n+                    dirtyTasks.add(task);\n                 }\n \n                 iterator.remove();\n             }\n         }\n \n+        if (!consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        }\n+\n+        for (final Map.Entry<Task, Map<TopicPartition, Long>> taskAndCheckpoint : checkpointPerTask.entrySet()) {\n+            final Task task = taskAndCheckpoint.getKey();\n+            try {\n+                task.closeClean(checkpointPerTask.get(task));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDg2Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391344863", "bodyText": "We need to call prepareCloseClean (as done in L196 above) before we call commitOffsetsOrTransaction (L215 above).", "author": "mjsax", "createdAt": "2020-03-12T00:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4Njk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4NzEzMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391287132", "bodyText": "Similarly for closeDirty and prepareCloseDirty", "author": "abbccdda", "createdAt": "2020-03-11T21:47:37Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -182,30 +193,49 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                 cleanupTask(task);\n \n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {\n+                        consumedOffsetsAndMetadataPerTask.put(task.id(), task.committableOffsetsAndMetadata());\n+                    }\n                 } catch (final RuntimeException e) {\n                     final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n                     log.error(uncleanMessage, e);\n                     taskCloseExceptions.put(task.id(), e);\n                     // We've already recorded the exception (which is the point of clean).\n                     // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n-                    task.closeDirty();\n-                } finally {\n-                    if (task.isActive()) {\n-                        try {\n-                            activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(task.id());\n-                        } catch (final RuntimeException e) {\n-                            final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n-                            log.error(uncleanMessage, e);\n-                            taskCloseExceptions.putIfAbsent(task.id(), e);\n-                        }\n-                    }\n+                    task.prepareCloseDirty();\n+                    dirtyTasks.add(task);\n                 }\n \n                 iterator.remove();\n             }\n         }\n \n+        if (!consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        }\n+\n+        for (final Map.Entry<Task, Map<TopicPartition, Long>> taskAndCheckpoint : checkpointPerTask.entrySet()) {\n+            final Task task = taskAndCheckpoint.getKey();\n+            try {\n+                task.closeClean(checkpointPerTask.get(task));\n+            } catch (final RuntimeException e) {\n+                final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n+                log.error(uncleanMessage, e);\n+                taskCloseExceptions.put(task.id(), e);\n+                // We've already recorded the exception (which is the point of clean).\n+                // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n+                task.closeDirty();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDkzNg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391344936", "bodyText": "Some comment as above.", "author": "mjsax", "createdAt": "2020-03-12T00:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4NzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTc4Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391289786", "bodyText": "nit; 228 - 229 could be merged.", "author": "abbccdda", "createdAt": "2020-03-11T21:54:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StandbyTaskTest.java", "diffHunk": "@@ -222,7 +225,8 @@ public void shouldDoNothingWithCreatedStateOnClose() {\n         final MetricName metricName = setupCloseTaskMetric();\n \n         task = createStandbyTask();\n-        task.closeClean();\n+        final Map<TopicPartition, Long> checkpoint = task.prepareCloseClean();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NjI4NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391346285", "bodyText": "I think it's easier to read if it's split.", "author": "mjsax", "createdAt": "2020-03-12T00:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MTEwMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391291102", "bodyText": "Also the above step #4 is no longer correct, the commit is done on TaskManager now.", "author": "abbccdda", "createdAt": "2020-03-11T21:57:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -410,54 +410,88 @@ public void closeDirty() {\n      * @throws TaskMigratedException if committing offsets failed (non-EOS)\n      *                               or if the task producer got fenced (EOS)\n      */\n-    private void close(final boolean clean) {\n+    private Map<TopicPartition, Long> prepareClose(final boolean clean) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzOTQ2Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391339463", "bodyText": "You see -- that is may point from above... The code should be written in a way that explains itself... Updating comments always slips...", "author": "mjsax", "createdAt": "2020-03-12T00:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MDM4MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393180380", "bodyText": "I couldn't fully follow this idea, just playing devil advocates here, if we think meta code comments actually hinder the readability of internal class, why not just remove all the internal function meta comments, as they would get outdated anyway? For me the return type comment is still valuable for understandability. If the comment gets outdated, we should just update it. cc @guozhangwang if the idea here makes sense, or we could get a consensus on what needs to be done in internal class comments, and what's not.", "author": "abbccdda", "createdAt": "2020-03-16T17:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NDQ2Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393374466", "bodyText": "I would suggest not restricting ourselves to some specific rules about comments :) Personally I tried to avoid the one line comment explaining one line code type of comments inside a function since it should be obvious, rather I'd add some comments for a block or several blocks if I fear it maybe hard to read by itself. I think you guys should just make your best judgement here.\nAnd for internal functions, I agree that we do not necessarily need to write java-docs, and this one, for example, I wrote the java-doc as part of the tech debt cleanup just to remind what operations MUST be considered here inside closing / suspending etc so that later on when we change the function itself by other contributors, they would use it as a reference to check if they mistakenly missed some steps or re-ordered some steps. However if we are going to split this function into multiple, instead of just re-structuring the function as a whole, then although I have my preference I'd leave to you guys if you want to add the javadoc for both pre/post of you feel now it is too obvious to bother :)", "author": "guozhangwang", "createdAt": "2020-03-16T23:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5NTIyMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391295221", "bodyText": "Do we need to keep a task once it is failed to clean close? Why couldn't we just close it dirty immediately after we see the exception?", "author": "abbccdda", "createdAt": "2020-03-11T22:08:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -432,24 +490,54 @@ private void cleanupTask(final Task task) {\n \n     void shutdown(final boolean clean) {\n         final AtomicReference<RuntimeException> firstException = new AtomicReference<>(null);\n-        final Iterator<Task> iterator = tasks.values().iterator();\n-        while (iterator.hasNext()) {\n-            final Task task = iterator.next();\n+\n+        final Map<Task, Map<TopicPartition, Long>> checkpointPerTask = new HashMap<>();\n+        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n+        final Set<Task> dirtyTasks = new HashSet<>();\n+\n+        for (final Task task : tasks.values()) {\n             cleanupTask(task);\n \n             if (clean) {\n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {\n+                        consumedOffsetsAndMetadataPerTask.put(task.id(), task.committableOffsetsAndMetadata());\n+                    }\n                 } catch (final TaskMigratedException e) {\n                     // just ignore the exception as it doesn't matter during shutdown\n-                    task.closeDirty();\n+                    task.prepareCloseDirty();\n+                    dirtyTasks.add(task);\n                 } catch (final RuntimeException e) {\n                     firstException.compareAndSet(null, e);\n-                    task.closeDirty();\n+                    task.prepareCloseDirty();\n+                    dirtyTasks.add(task);\n                 }\n             } else {\n+                task.prepareCloseDirty();\n+                dirtyTasks.add(task);\n+            }\n+        }\n+\n+        if (clean && !consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        }\n+\n+        for (final Map.Entry<Task, Map<TopicPartition, Long>> taskAndCheckpoint : checkpointPerTask.entrySet()) {\n+            final Task task = taskAndCheckpoint.getKey();\n+            try {\n+                task.closeClean(checkpointPerTask.get(task));\n+            } catch (final RuntimeException e) {\n+                firstException.compareAndSet(null, e);\n                 task.closeDirty();\n             }\n+        }\n+\n+        for (final Task task : dirtyTasks) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MTI0Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391361243", "bodyText": "Good idea!", "author": "mjsax", "createdAt": "2020-03-12T01:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5NTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5Njg5NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391296895", "bodyText": "Why do we need to move these tests?", "author": "abbccdda", "createdAt": "2020-03-11T22:11:16Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -88,44 +88,11 @@ public void before() {\n         eosStreamsProducer.initTransaction();\n     }\n \n-    @Test", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NzExNA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391347114", "bodyText": "I try to keep \"order\" and group test methods to keep an overview if test coverage is complete.\n// generic tests\n    // functional\n    // exception handling\n// non-EOS tests\n    // functional\n    // exception handling\n// EOS tests\n    // functional\n    // exception handling", "author": "mjsax", "createdAt": "2020-03-12T00:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5Njg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5ODc4NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391298785", "bodyText": "Looks like we lack test coverage for TimeoutException and KafkaException cases", "author": "abbccdda", "createdAt": "2020-03-11T22:13:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -364,11 +365,8 @@ private void commitState() {\n             final long partitionTime = partitionTimes.get(partition);\n             consumedOffsetsAndMetadata.put(partition, new OffsetAndMetadata(offset, encodeTimestamp(partitionTime)));\n         }\n-        recordCollector.commit(consumedOffsetsAndMetadata);\n \n-        commitNeeded = false;\n-        commitRequested = false;\n-        commitSensor.record(time.nanoseconds() - startNs);\n+        return consumedOffsetsAndMetadata;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODcxMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391338712", "bodyText": "Yeah, this PR does not yet add all required test...", "author": "mjsax", "createdAt": "2020-03-12T00:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5ODc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4Mzg1OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392783859", "bodyText": "Covered via shouldCommitNextOffsetFromQueueIfAvailable and shouldCommitConsumerPositionIfRecordQueueIsEmpty", "author": "mjsax", "createdAt": "2020-03-16T05:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5ODc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMTY3OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391301678", "bodyText": "We don't have unit test coverage for this exception case", "author": "abbccdda", "createdAt": "2020-03-11T22:17:34Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -247,6 +277,19 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n         changelogReader.transitToRestoreActive();\n     }\n \n+    private void cleanUpTaskProducer(final Task task,\n+                                     final Map<TaskId, RuntimeException> taskCloseExceptions) {\n+        if (task.isActive()) {\n+            try {\n+                activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(task.id());\n+            } catch (final RuntimeException e) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5NDkxMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392794910", "bodyText": "Added test shouldThrowWhenHandlingClosingTasksOnProducerCloseError", "author": "mjsax", "createdAt": "2020-03-16T05:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMjIyNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391302227", "bodyText": "We lack unit test coverage for this case", "author": "abbccdda", "createdAt": "2020-03-11T22:18:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -182,30 +193,49 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n                 cleanupTask(task);\n \n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {\n+                        consumedOffsetsAndMetadataPerTask.put(task.id(), task.committableOffsetsAndMetadata());\n+                    }\n                 } catch (final RuntimeException e) {\n                     final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n                     log.error(uncleanMessage, e);\n                     taskCloseExceptions.put(task.id(), e);\n                     // We've already recorded the exception (which is the point of clean).\n                     // Now, we should go ahead and complete the close because a half-closed task is no good to anyone.\n-                    task.closeDirty();\n-                } finally {\n-                    if (task.isActive()) {\n-                        try {\n-                            activeTaskCreator.closeAndRemoveTaskProducerIfNeeded(task.id());\n-                        } catch (final RuntimeException e) {\n-                            final String uncleanMessage = String.format(\"Failed to close task %s cleanly. Attempting to close remaining tasks before re-throwing:\", task.id());\n-                            log.error(uncleanMessage, e);\n-                            taskCloseExceptions.putIfAbsent(task.id(), e);\n-                        }\n-                    }\n+                    task.prepareCloseDirty();\n+                    dirtyTasks.add(task);\n                 }\n \n                 iterator.remove();\n             }\n         }\n \n+        if (!consumedOffsetsAndMetadataPerTask.isEmpty()) {\n+            commitOffsetsOrTransaction(consumedOffsetsAndMetadataPerTask);\n+        }\n+\n+        for (final Map.Entry<Task, Map<TopicPartition, Long>> taskAndCheckpoint : checkpointPerTask.entrySet()) {\n+            final Task task = taskAndCheckpoint.getKey();\n+            try {\n+                task.closeClean(checkpointPerTask.get(task));\n+            } catch (final RuntimeException e) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDk2Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391344967", "bodyText": "I know...", "author": "mjsax", "createdAt": "2020-03-12T00:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMzcxMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391303712", "bodyText": "Could we verify the assignment stack and lost stack separately, by doing handleAssignment verify first before calling handleLost", "author": "abbccdda", "createdAt": "2020-03-11T22:20:40Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -212,23 +227,24 @@ public void shouldCloseActiveTasksWhenHandlingLostTasks() {\n         final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n         final Task task01 = new StateMachineTask(taskId01, taskId01Partitions, false);\n \n+        // `handleAssignment`", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0ODEwMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391348100", "bodyText": "Not sure if I can follow? The comments just mark which setup calls belongs to which test call, nothing more. All setup is done upfront before we call the actually methods under test.", "author": "mjsax", "createdAt": "2020-03-12T00:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwOTc5MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391809790", "bodyText": "nit: add a check that taskId exists in taskProducers to make sure we do not return null.", "author": "guozhangwang", "createdAt": "2020-03-12T18:22:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -80,32 +80,42 @@ private static String getTaskProducerClientId(final String threadClientId, final\n                       final KafkaClientSupplier clientSupplier,\n                       final String threadId,\n                       final Logger log) {\n-        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n         this.builder = builder;\n         this.config = config;\n         this.streamsMetrics = streamsMetrics;\n         this.stateDirectory = stateDirectory;\n         this.storeChangelogReader = storeChangelogReader;\n+        this.cache = cache;\n         this.time = time;\n+        this.clientSupplier = clientSupplier;\n+        this.threadId = threadId;\n         this.log = log;\n \n+        createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n+        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+\n         if (EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG))) {\n             threadProducer = null;\n             taskProducers = new HashMap<>();\n         } else {\n+            log.info(\"Creating thread producer client\");\n+\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n-            log.info(\"Creating thread producer client\");\n+\n+            final String logPrefix = String.format(\"stream-thread [%s] \", Thread.currentThread().getName());\n+            final LogContext logContext = new LogContext(logPrefix);\n+\n             threadProducer = clientSupplier.getProducer(producerConfigs);\n             taskProducers = Collections.emptyMap();\n         }\n+    }\n \n-\n-        this.cache = cache;\n-        this.threadId = threadId;\n-        this.clientSupplier = clientSupplier;\n-\n-        createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n+    StreamsProducer streamsProducerForTask(final TaskId taskId) {\n+        if (threadProducer != null) {\n+            throw new IllegalStateException(\"Producer per thread is used\");\n+        }\n+        return taskProducers.get(taskId);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyOTQ3Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391829473", "bodyText": "Actually on a second thought, I'm wondering if the following inside TaskManager is cleaner:\nfor (task <- taskManager.activeTasks)\n    task.recordCollector().commit(taskToCommit.getTask(task.id);\n\nInstead of:\nactiveTaskCreator.streamsProducerForTask(taskToCommit.getKey()).commitTransaction(taskToCommit.getValue());\n\nMy gut feeling is that it is cleaner to not access the task creator for its created stream-producers (and hence here we need to change the task-producer map to streamsProducers), but just access each task's record collector and call its commit --- today we already have a StreamTask#recordCollector method.", "author": "guozhangwang", "createdAt": "2020-03-12T18:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwOTc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NDUwOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391974508", "bodyText": "I think it's unclean to let the RecordCollector commit (note that this PR removes RecordCollector not at side refactoring but on purpose) -- to me the RecordCollector has the responsibility to bridge the gap between the runtime code (that is typed), and the Producer that uses <byte[],byte[]> (ie, it serialized the data and manages errors from send) -- why would a collector know anything about committing (for which it also needs a handle to the consumer)?\nAbout accessing the ActiveTaskCreator: we could also expose the StreamsProducer via the RecordCollector though (or directly via the task)? That would be cleaner I guess.", "author": "mjsax", "createdAt": "2020-03-13T00:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwOTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzODA3OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r391838078", "bodyText": "This is a meta comment: I think we can consolidate prepareCommit and prepareClose and prepareSuspend here by introducing the clean parameters to the function, since their logic are very similar (for the part that they diffs a bit, it can be pushed to post logic), and on task-manager during commit:\n\nfor each task -> task.prepareCommit(true)\ncommit\nfor each task -> task.postCommit(true)\n\nDuring close:\nif (clean)\n1) for each task -> task.prepareCommit(true)\n2) commit()\n3) for each task -> task.postCommit(true)\nelse\n1) for each task -> task.prepareCommit(false)\n// do not commit\n3) for each task -> task.postCommit(false)\n4) tasks.close(flag)\nAnd the same for suspension.", "author": "guozhangwang", "createdAt": "2020-03-12T19:16:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -115,48 +121,45 @@ public void resume() {\n      * 1. flush store\n      * 2. write checkpoint file\n      *\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n     @Override\n-    public void commit() {\n-        switch (state()) {\n-            case RUNNING:\n-                stateMgr.flush();\n-\n-                // since there's no written offsets we can checkpoint with empty map,\n-                // and the state current offset would be used to checkpoint\n-                stateMgr.checkpoint(Collections.emptyMap());\n-\n-                offsetSnapshotSinceLastCommit = new HashMap<>(stateMgr.changelogOffsets());\n-\n-                log.info(\"Committed\");\n-                break;\n-\n-            case CLOSING:\n-                // do nothing and also not throw\n-                log.trace(\"Skip committing since task is closing\");\n-\n-                break;\n-\n-            default:\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while committing standby task \" + id);\n+    public void prepareCommit() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4MzI0OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392783249", "bodyText": "Will do this in a follow up PR.", "author": "mjsax", "createdAt": "2020-03-16T04:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzODA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzOTIxMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393339213", "bodyText": "SG.\nI think in this PR we still can do the change to let prepareXX to return the map of partitions -> partition-timestamp to indicate whether this task should be included in committing.", "author": "guozhangwang", "createdAt": "2020-03-16T22:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzODA3OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAxNzk1NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392017955", "bodyText": "This is not introduced in this PR, but: while thinking about it, I realized for RESTORING state we do not need to rely on eosDisabled to checkpoint, in fact we can always checkpoint during RESTORING here.", "author": "guozhangwang", "createdAt": "2020-03-13T03:50:05Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -293,18 +302,31 @@ public void resume() {\n         }\n     }\n \n-    /**\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n-     */\n     @Override\n-    public void commit() {\n+    public void prepareCommit() {\n+        switch (state()) {\n+            case RUNNING:\n+            case RESTORING:\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepared task for committing\");\n+\n+                break;\n+\n+            default:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while preparing active task \" + id + \" for committing\");\n+        }\n+    }\n+\n+    @Override\n+    public void postCommit() {\n         switch (state()) {\n             case RUNNING:\n             case RESTORING:\n-                commitState();\n+                commitNeeded = false;\n+                commitRequested = false;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4MzQxNQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r392783415", "bodyText": "Ack", "author": "mjsax", "createdAt": "2020-03-16T05:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAxNzk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzOTU3NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393139575", "bodyText": "Do we have unit test to check the checkpoint status after postCommit()?", "author": "abbccdda", "createdAt": "2020-03-16T16:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAxNzk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MDgyNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393350827", "bodyText": "Yes, shouldRespectCommitNeeded() check this already.", "author": "mjsax", "createdAt": "2020-03-16T22:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAxNzk1NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzMjU1OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393132558", "bodyText": "We need a unit test for this function.", "author": "abbccdda", "createdAt": "2020-03-16T16:00:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -80,32 +80,44 @@ private static String getTaskProducerClientId(final String threadClientId, final\n                       final KafkaClientSupplier clientSupplier,\n                       final String threadId,\n                       final Logger log) {\n-        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n         this.builder = builder;\n         this.config = config;\n         this.streamsMetrics = streamsMetrics;\n         this.stateDirectory = stateDirectory;\n         this.storeChangelogReader = storeChangelogReader;\n+        this.cache = cache;\n         this.time = time;\n+        this.clientSupplier = clientSupplier;\n+        this.threadId = threadId;\n         this.log = log;\n \n+        createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n+        applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+\n         if (EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG))) {\n             threadProducer = null;\n             taskProducers = new HashMap<>();\n         } else {\n+            log.info(\"Creating thread producer client\");\n+\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n-            log.info(\"Creating thread producer client\");\n+\n             threadProducer = clientSupplier.getProducer(producerConfigs);\n             taskProducers = Collections.emptyMap();\n         }\n+    }\n \n+    StreamsProducer streamsProducerForTask(final TaskId taskId) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjE2MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393336160", "bodyText": "For the next PR (all other comments with this tag means no changes required for this PR): my understanding is that we would make the thread-producer also a StreamsProducer instead of a KafkaProducer which would be used to commitTransaction under eosBeta, is that right?", "author": "guozhangwang", "createdAt": "2020-03-16T22:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzMjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4OTU4Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393389583", "bodyText": "Correct. For eos-beta there will be one StreamsProducer that is shared over all tasks.", "author": "mjsax", "createdAt": "2020-03-17T00:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzMjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzNjU5NQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393136595", "bodyText": "we could just do one log in front: log.info(\"Prepare suspending {}\", state());", "author": "abbccdda", "createdAt": "2020-03-16T16:06:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -231,27 +228,40 @@ public void completeRestoration() {\n      *                               or if the task producer got fenced (EOS)\n      */\n     @Override\n-    public void suspend() {\n-        if (state() == State.CREATED || state() == State.CLOSING || state() == State.SUSPENDED) {\n+    public void prepareSuspend() {\n+        if (state() == State.CREATED || state() == State.SUSPENDED) {\n             // do nothing\n-            log.trace(\"Skip suspending since state is {}\", state());\n+            log.trace(\"Skip prepare suspending since state is {}\", state());\n         } else if (state() == State.RUNNING) {\n             closeTopology(true);\n \n-            commitState();\n-            // whenever we have successfully committed state during suspension, it is safe to checkpoint\n-            // the state as well no matter if EOS is enabled or not\n-            stateMgr.checkpoint(checkpointableOffsets());\n+            stateMgr.flush();\n+            recordCollector.flush();\n \n-            // we should also clear any buffered records of a task when suspending it\n+            log.info(\"Prepare suspending running\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MDUxNg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393350516", "bodyText": "Well, we log \"skip\" for state CREATED and we throw for invalid states. Note sure how to do this?", "author": "mjsax", "createdAt": "2020-03-16T22:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzNjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MzMxMA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393183310", "bodyText": "nit: { could be reduced.", "author": "abbccdda", "createdAt": "2020-03-16T17:11:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -400,65 +422,88 @@ public void closeDirty() {\n      *  1. first close topology to make sure all cached records in the topology are processed\n      *  2. then flush the state, send any left changelog records\n      *  3. then flush the record collector\n-     *  4. then commit the record collector -- for EOS this is the synchronization barrier\n-     *  5. then checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed\n-     *  6. then if we are closing on EOS and dirty, wipe out the state store directory\n-     *  7. finally release the state manager lock\n      * </pre>\n      *\n-     * @param clean    shut down cleanly (ie, incl. flush and commit) if {@code true} --\n+     * @param clean    shut down cleanly (ie, incl. flush) if {@code true} --\n      *                 otherwise, just close open resources\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n+     * @throws TaskMigratedException if the task producer got fenced (EOS)\n      */\n-    private void close(final boolean clean) {\n+    private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n+        final Map<TopicPartition, Long> checkpoint;\n+\n         if (state() == State.CREATED) {\n             // the task is created and not initialized, just re-write the checkpoint file\n-            executeAndMaybeSwallow(clean, () -> {\n-                stateMgr.checkpoint(Collections.emptyMap());\n-            }, \"state manager checkpoint\", log);\n-\n-            transitionTo(State.CLOSING);\n+            checkpoint = Collections.emptyMap();\n         } else if (state() == State.RUNNING) {\n             closeTopology(clean);\n \n             if (clean) {\n-                commitState();\n-                // whenever we have successfully committed state, it is safe to checkpoint\n-                // the state as well no matter if EOS is enabled or not\n-                stateMgr.checkpoint(checkpointableOffsets());\n+                stateMgr.flush();\n+                recordCollector.flush();\n+                checkpoint = checkpointableOffsets();\n             } else {\n+                checkpoint = null; // `null` indicates to not write a checkpoint\n                 executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n             }\n-\n-            transitionTo(State.CLOSING);\n         } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, () -> {\n-                stateMgr.flush();\n-                stateMgr.checkpoint(Collections.emptyMap());\n-            }, \"state manager flush and checkpoint\", log);\n-\n-            transitionTo(State.CLOSING);\n+            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+            checkpoint = Collections.emptyMap();\n         } else if (state() == State.SUSPENDED) {\n-            // do not need to commit / checkpoint, since when suspending we've already committed the state\n-            transitionTo(State.CLOSING);\n+            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n+            checkpoint = null; // `null` indicates to not write a checkpoint\n+        } else {\n+            throw new IllegalStateException(\"Illegal state \" + state() + \" while prepare closing active task \" + id);\n         }\n \n-        if (state() == State.CLOSING) {\n-            // if EOS is enabled, we wipe out the whole state store for unclean close\n-            // since they are invalid to use anymore\n-            final boolean wipeStateStore = !clean && !eosDisabled;\n+        return checkpoint;\n+    }\n \n-            // first close state manager (which is idempotent) then close the record collector (which could throw),\n-            // if the latter throws and we re-close dirty which would close the state manager again.\n-            executeAndMaybeSwallow(clean, () -> {\n-                StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        wipeStateStore, stateMgr, stateDirectory, TaskType.ACTIVE);\n-            }, \"state manager close\", log);\n+    /**\n+     * <pre>\n+     * the following order must be followed:\n+     *  1. checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed\n+     *  2. then if we are closing on EOS and dirty, wipe out the state store directory\n+     *  3. finally release the state manager lock\n+     * </pre>\n+     */\n+    private void close(final boolean clean,\n+                       final Map<TopicPartition, Long> checkpoint) {\n+        if (clean && checkpoint != null) {\n+            executeAndMaybeSwallow(clean, () -> stateMgr.checkpoint(checkpoint), \"state manager checkpoint\", log);\n+        }\n \n-            executeAndMaybeSwallow(clean, recordCollector::close, \"record collector close\", log);\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while closing active task \" + id);\n+        switch (state()) {\n+            case CREATED:\n+            case RUNNING:\n+            case RESTORING:\n+            case SUSPENDED:\n+                // if EOS is enabled, we wipe out the whole state store for unclean close\n+                // since they are invalid to use anymore\n+                final boolean wipeStateStore = !clean && !eosDisabled;\n+\n+                // first close state manager (which is idempotent) then close the record collector (which could throw),\n+                // if the latter throws and we re-close dirty which would close the state manager again.\n+                executeAndMaybeSwallow(\n+                    clean,\n+                    () -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjYxOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393336618", "bodyText": "nit: we can have a wrapped StreamsProducer#close / metrics, and then #kafkaProducer would be for testing-only.", "author": "guozhangwang", "createdAt": "2020-03-16T22:08:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -178,18 +194,18 @@ void closeThreadProducerIfNeeded() {\n             try {\n                 threadProducer.close();\n             } catch (final RuntimeException e) {\n-                throw new StreamsException(\"Thread Producer encounter unexpected error trying to close\", e);\n+                throw new StreamsException(\"Thread Producer encounter error trying to close\", e);\n             }\n         }\n     }\n \n     void closeAndRemoveTaskProducerIfNeeded(final TaskId id) {\n-        final Producer<byte[], byte[]> producer = taskProducers.remove(id);\n-        if (producer != null) {\n+        final StreamsProducer taskProducer = taskProducers.remove(id);\n+        if (taskProducer != null) {\n             try {\n-                producer.close();\n+                taskProducer.kafkaProducer().close();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4OTkwMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393389903", "bodyText": "We could, but the idea was that ActiveTaskCreator creates the producer via new KafkaProducer() and thus it should call KafkaProducer#close(), too, and not delegate it to StreamsProducer. Thoughts?", "author": "mjsax", "createdAt": "2020-03-17T01:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NTgxNQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393885815", "bodyText": "Hmm, I think moving forward we would create and maintain both the single thread-producer and task-producers as StreamsProducer objects right?", "author": "guozhangwang", "createdAt": "2020-03-17T18:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg5ODk5OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393898999", "bodyText": "SGTM", "author": "mjsax", "createdAt": "2020-03-17T18:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNjYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0MTk3Mg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393341972", "bodyText": "In either eos-alpha or eos-beta or non-eos, we can just loop over all the \"committable partitions\" and call mainConsumer#position once, so this function can be extracted out of the task as a per-task call.\nMore specifically, in the prepareXX calls, we know based on the state of the task and clean flag whether or not we should commit the source topic offsets for this task, so we can let the prepareXX function to return Map<TopicPartition, Long> partitionTimes encoding the extracted timestamps for each partition instead of void --- when we decided not to commit we return an empty map. And then inside TaskManager we just use the mainConsumer to call position once and then pass that to the commitOffsetsOrTransaction call.", "author": "guozhangwang", "createdAt": "2020-03-16T22:23:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -313,35 +334,23 @@ public void commit() {\n \n                 break;\n \n-            case CLOSING:\n-                // do nothing\n+            case RESTORING:\n+                commitNeeded = false;\n+                commitRequested = false;\n+\n+                stateMgr.checkpoint(checkpointableOffsets());\n+\n+                log.info(\"Committed\");\n+\n                 break;\n \n             default:\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while committing standby task \" + id);\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while post committing active task \" + id);\n         }\n     }\n \n-    /**\n-     * <pre>\n-     * the following order must be followed:\n-     *  1. flush the state, send any left changelog records\n-     *  2. then flush the record collector\n-     *  3. then commit the record collector -- for EOS this is the synchronization barrier\n-     * </pre>\n-     *\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n-     */\n-    private void commitState() {\n-        final long startNs = time.nanoseconds();\n-\n-        stateMgr.flush();\n-\n-        recordCollector.flush();\n-\n-        // we need to preserve the original partitions times before calling commit\n-        // because all partition times are reset to -1 during close\n+    @Override\n+    public Map<TopicPartition, OffsetAndMetadata> committableOffsetsAndMetadata() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NDYxMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393344611", "bodyText": "nit: we can do if / else if / else here still and move the closeTaskSensor.record(); / transitionTo(State.CLOSED); to avoid duplication.", "author": "guozhangwang", "createdAt": "2020-03-16T22:28:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -166,29 +169,70 @@ public void closeDirty() {\n      * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    private void close(final boolean clean) {\n+    private void prepareClose(final boolean clean) {\n         if (state() == State.CREATED) {\n             // the task is created and not initialized, do nothing\n-            transitionTo(State.CLOSING);\n-        } else {\n-            if (state() == State.RUNNING) {\n-                if (clean) {\n-                    commit();\n-                }\n+            return;\n+        }\n \n-                transitionTo(State.CLOSING);\n+        if (state() == State.RUNNING) {\n+            if (clean) {\n+                stateMgr.flush();\n             }\n+        } else {\n+            throw new IllegalStateException(\"Illegal state \" + state() + \" while closing standby task \" + id);\n+        }\n+    }\n+\n+    @Override\n+    public void closeClean(final Map<TopicPartition, Long> checkpoint) {\n+        Objects.requireNonNull(checkpoint);\n+        close(true, checkpoint);\n+\n+        log.info(\"Closed clean\");\n+    }\n+\n+    @Override\n+    public void closeDirty() {\n+        close(false, null);\n+\n+        log.info(\"Closed dirty\");\n+    }\n \n-            if (state() == State.CLOSING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        false, stateMgr, stateDirectory, TaskType.STANDBY);\n-                }, \"state manager close\", log);\n+    private void close(final boolean clean,\n+                       final Map<TopicPartition, Long> checkpoint) {\n+        if (state() == State.CREATED) {\n+            // the task is created and not initialized, do nothing\n+            closeTaskSensor.record();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5Mjg5OA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393392898", "bodyText": "Well, we can, but we get an empty \"than block\" what is weird:\nif (state() == State.CREATED) {\n  // empty\n} else if {\n...\n}", "author": "mjsax", "createdAt": "2020-03-17T01:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NDYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NzE3MA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393887170", "bodyText": "I'd say we can always log a debug there saying \"doing nothing in this function since we are in this state\" :) The main concern I had, is that if in the future we want to add more steps in addition to recording sensor etc, we may forget adding it in one place or the other. Removing duplicated code helps us to be less vulnerable.", "author": "guozhangwang", "createdAt": "2020-03-17T18:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NDYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NTAzNw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393345037", "bodyText": "Ditto here, I think if / else if / else is more readable.", "author": "guozhangwang", "createdAt": "2020-03-16T22:29:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -166,29 +169,70 @@ public void closeDirty() {\n      * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    private void close(final boolean clean) {\n+    private void prepareClose(final boolean clean) {\n         if (state() == State.CREATED) {\n             // the task is created and not initialized, do nothing\n-            transitionTo(State.CLOSING);\n-        } else {\n-            if (state() == State.RUNNING) {\n-                if (clean) {\n-                    commit();\n-                }\n+            return;\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MTc4MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393371781", "bodyText": "For the next PR: as I mentioned in the last commit I feel prepareSuspend and prepareClose can be consolidated with prepareCommit but in the next PR these logic would be changed again for eos-beta so maybe we cannot do that any more, so I'm fine with keeping as-is and we can revisit to see if we can really do this refactoring or not in the next PR when we did the eos-beta.", "author": "guozhangwang", "createdAt": "2020-03-16T23:47:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -231,27 +228,40 @@ public void completeRestoration() {\n      *                               or if the task producer got fenced (EOS)\n      */\n     @Override\n-    public void suspend() {\n-        if (state() == State.CREATED || state() == State.CLOSING || state() == State.SUSPENDED) {\n+    public void prepareSuspend() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzI1Ng==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393377256", "bodyText": "For the next PR: I see the reason I return the checkpoint is that we are now extracting the committing out of the task and I need to remember if we need to checkpoint and if yes which offsets after we've flushed and before we checkpoint, but since the state of the task would not change before / after the commit during close.\nMore specifically we only have three cases: 1) to not write checkpoint, 2) write checkpoints for written offsets (changelogs) only, 3) write checkpoint for written and consumed offsets. And no matter which case it is during the preClose, it would always be the same in the post, so why do we need to return it to task-manager, book-keep there, and then after commit to pass it back to tasks?", "author": "guozhangwang", "createdAt": "2020-03-17T00:07:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -400,65 +422,88 @@ public void closeDirty() {\n      *  1. first close topology to make sure all cached records in the topology are processed\n      *  2. then flush the state, send any left changelog records\n      *  3. then flush the record collector\n-     *  4. then commit the record collector -- for EOS this is the synchronization barrier\n-     *  5. then checkpoint the state manager -- even if we crash before this step, EOS is still guaranteed\n-     *  6. then if we are closing on EOS and dirty, wipe out the state store directory\n-     *  7. finally release the state manager lock\n      * </pre>\n      *\n-     * @param clean    shut down cleanly (ie, incl. flush and commit) if {@code true} --\n+     * @param clean    shut down cleanly (ie, incl. flush) if {@code true} --\n      *                 otherwise, just close open resources\n-     * @throws TaskMigratedException if committing offsets failed (non-EOS)\n-     *                               or if the task producer got fenced (EOS)\n+     * @throws TaskMigratedException if the task producer got fenced (EOS)\n      */\n-    private void close(final boolean clean) {\n+    private Map<TopicPartition, Long> prepareClose(final boolean clean) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5MjUxMQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393792511", "bodyText": "By next PR, you mean the one after we finish the EOS-beta commit feature right?", "author": "abbccdda", "createdAt": "2020-03-17T16:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NDM0Mw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393884343", "bodyText": "I mean the next PR when we add the EOS-beta feature --- please see the first comment I have with this tag.", "author": "guozhangwang", "createdAt": "2020-03-17T18:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODc3OQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393378779", "bodyText": "nit: we should emphasize that PrepareClose and close calls should be implemented idempotent since we may call it multiple times if a task close clean first and then fail and then close dirty.", "author": "guozhangwang", "createdAt": "2020-03-17T00:14:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -125,35 +125,41 @@ public boolean isValidTransition(final State newState) {\n     boolean commitNeeded();\n \n     /**\n-     * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void commit();\n+    void prepareCommit();\n+\n+    void postCommit();\n \n     /**\n      * @throws TaskMigratedException all the task has been migrated\n      * @throws StreamsException fatal error, should close the thread\n      */\n-    void suspend();\n+    void prepareSuspend();\n \n+    void suspend();\n     /**\n+     *\n      * @throws StreamsException fatal error, should close the thread\n      */\n     void resume();\n \n     /**\n-     * Close a task that we still own. Commit all progress and close the task gracefully.\n+     * Prepare to close a task that we still own and prepare it for committing", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NzQ5MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393387491", "bodyText": "Same here: not only CREATED, but also RESTORING and SUSPENDED tasks should not be included in consumedOffsetsAndMetadataPerTask and we should not let the task-manager to peek its state.", "author": "guozhangwang", "createdAt": "2020-03-17T00:50:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -497,24 +555,49 @@ private void cleanupTask(final Task task) {\n \n     void shutdown(final boolean clean) {\n         final AtomicReference<RuntimeException> firstException = new AtomicReference<>(null);\n-        final Iterator<Task> iterator = tasks.values().iterator();\n-        while (iterator.hasNext()) {\n-            final Task task = iterator.next();\n+\n+        final Map<Task, Map<TopicPartition, Long>> checkpointPerTask = new HashMap<>();\n+        final Map<TaskId, Map<TopicPartition, OffsetAndMetadata>> consumedOffsetsAndMetadataPerTask = new HashMap<>();\n+\n+        for (final Task task : tasks.values()) {\n             cleanupTask(task);\n \n             if (clean) {\n                 try {\n-                    task.closeClean();\n+                    checkpointPerTask.put(task, task.prepareCloseClean());\n+                    if (task.state() != CREATED) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNTczMg==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393905732", "bodyText": "Thanks for the cleanup!", "author": "guozhangwang", "createdAt": "2020-03-17T19:03:16Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/MetricsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,6 @@\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@SuppressWarnings(\"unchecked\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNjk3MQ==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393906971", "bodyText": "Why we have to transit to SUSPENDED before prepare-closing? Originally we want to check that CREATED state can still trigger close.", "author": "guozhangwang", "createdAt": "2020-03-17T19:05:38Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -264,7 +265,10 @@ public void shouldAttemptToDeleteStateDirectoryWhenCloseDirtyAndEosEnabled() thr\n         ctrl.replay();\n \n         task = createStatefulTask(createConfig(true, \"100\"), true, stateManager);\n-        task.transitionTo(Task.State.CLOSING);\n+        task.transitionTo(Task.State.RESTORING);\n+        task.transitionTo(Task.State.RUNNING);\n+        task.transitionTo(Task.State.SUSPENDED);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2MzcwOA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393963708", "bodyText": "Ack. We can remove this.", "author": "mjsax", "createdAt": "2020-03-17T20:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNjk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNzc1NA==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393907754", "bodyText": "Not introduced in this PR: could we add test checking CLOSED state should not commit as well?\nAlso checking SUSPENDED state close-call is no-op.", "author": "guozhangwang", "createdAt": "2020-03-17T19:07:06Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1292,7 +1275,14 @@ public void shouldThrowStreamsExceptionWhenFetchCommittedFailed() {\n     public void shouldThrowIfCommittingOnIllegalState() {\n         task = createStatelessTask(createConfig(false, \"100\"), StreamsConfig.METRICS_LATEST);\n \n-        assertThrows(IllegalStateException.class, task::commit);\n+        assertThrows(IllegalStateException.class, task::prepareCommit);\n+    }\n+\n+    @Test\n+    public void shouldThrowIfPostCommittingOnIllegalState() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NDcyMw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393964723", "bodyText": "Ack", "author": "mjsax", "createdAt": "2020-03-17T20:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNzc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NjA4Nw==", "url": "https://github.com/apache/kafka/pull/8218#discussion_r393966087", "bodyText": "Also checking SUSPENDED state close-call is no-op.\n\nBut in close() if state is suspended we might still wipe out the state store -- it's not a no-op", "author": "mjsax", "createdAt": "2020-03-17T20:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwNzc1NA=="}], "type": "inlineReview"}, {"oid": "b5de5b1250020bac04d4763cfe54d5ad78e2168e", "url": "https://github.com/apache/kafka/commit/b5de5b1250020bac04d4763cfe54d5ad78e2168e", "message": "KAFKA-9441: Unify committing within TaskManager", "committedDate": "2020-03-18T17:04:03Z", "type": "commit"}, {"oid": "20021441a3b69b3bc26b6608457fcb1fec779087", "url": "https://github.com/apache/kafka/commit/20021441a3b69b3bc26b6608457fcb1fec779087", "message": "Github comments", "committedDate": "2020-03-18T17:04:03Z", "type": "commit"}, {"oid": "a2f2c04daa41d692095cb20063b45a31850cc1cb", "url": "https://github.com/apache/kafka/commit/a2f2c04daa41d692095cb20063b45a31850cc1cb", "message": "Github comments", "committedDate": "2020-03-18T17:04:03Z", "type": "commit"}, {"oid": "45e5633f16c6305e5d645e36da3fa9917b53c8df", "url": "https://github.com/apache/kafka/commit/45e5633f16c6305e5d645e36da3fa9917b53c8df", "message": "Fix bug", "committedDate": "2020-03-18T17:04:03Z", "type": "commit"}, {"oid": "693b33d6f5365579c85f42d7a9663a2db491b711", "url": "https://github.com/apache/kafka/commit/693b33d6f5365579c85f42d7a9663a2db491b711", "message": "Github comments", "committedDate": "2020-03-18T17:04:03Z", "type": "commit"}, {"oid": "693b33d6f5365579c85f42d7a9663a2db491b711", "url": "https://github.com/apache/kafka/commit/693b33d6f5365579c85f42d7a9663a2db491b711", "message": "Github comments", "committedDate": "2020-03-18T17:04:03Z", "type": "forcePushed"}, {"oid": "4b03a487a518756f7c9acd1f3177b12b407867d5", "url": "https://github.com/apache/kafka/commit/4b03a487a518756f7c9acd1f3177b12b407867d5", "message": "Bug fix", "committedDate": "2020-03-19T08:48:44Z", "type": "commit"}]}