{"pr_number": 8892, "pr_title": "KAFKA-10068: verify assignment performance with large cluster", "pr_createdAt": "2020-06-18T02:15:22Z", "pr_url": "https://github.com/apache/kafka/pull/8892", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5Njk5MQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r442496991", "bodyText": "Can you just pass this as an argument to getPartitionInfos so that we can do all the initialization in the assignment instead of needing an initialization block? The fact that this field is used in another field initialization statement makes the initialization block kind of questionable, since you have to read the JVM spec to know if this block executes before or after the usage.\nAlternatively, maybe the prior code was actually better, because you can see exactly what data you're testing with, instead of having to go read another method to understand what getPartitioninfos(3, 3) might mean.", "author": "vvcephei", "createdAt": "2020-06-18T20:54:50Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -148,27 +150,35 @@\n     private final TopicPartition t3p2 = new TopicPartition(\"topic3\", 2);\n     private final TopicPartition t3p3 = new TopicPartition(\"topic3\", 3);\n \n-    private final List<PartitionInfo> infos = asList(\n-        new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 3, Node.noNode(), new Node[0], new Node[0])\n-    );\n-\n-    private final SubscriptionInfo defaultSubscriptionInfo = getInfo(UUID_1, EMPTY_TASKS, EMPTY_TASKS);\n+    private final List<PartitionInfo> partitionInfos = getPartitionInfos(3, 3);\n+    {\n+        partitionInfos.add(new PartitionInfo(\"topic3\", 3, Node.noNode(), new Node[0], new Node[0]));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NzYwOQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r442497609", "bodyText": "If there's a whole set of constants only used by one test, one might wonder whether that test shouldn't just be in its own class...", "author": "vvcephei", "createdAt": "2020-06-18T20:56:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -148,27 +150,35 @@\n     private final TopicPartition t3p2 = new TopicPartition(\"topic3\", 2);\n     private final TopicPartition t3p3 = new TopicPartition(\"topic3\", 3);\n \n-    private final List<PartitionInfo> infos = asList(\n-        new PartitionInfo(\"topic1\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic1\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic1\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic2\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 0, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 1, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 2, Node.noNode(), new Node[0], new Node[0]),\n-        new PartitionInfo(\"topic3\", 3, Node.noNode(), new Node[0], new Node[0])\n-    );\n-\n-    private final SubscriptionInfo defaultSubscriptionInfo = getInfo(UUID_1, EMPTY_TASKS, EMPTY_TASKS);\n+    private final List<PartitionInfo> partitionInfos = getPartitionInfos(3, 3);\n+    {\n+        partitionInfos.add(new PartitionInfo(\"topic3\", 3, Node.noNode(), new Node[0], new Node[0]));\n+    }\n \n     private final Cluster metadata = new Cluster(\n         \"cluster\",\n         Collections.singletonList(Node.noNode()),\n-        infos,\n+        partitionInfos,\n         emptySet(),\n-        emptySet());\n+        emptySet()\n+    );\n+\n+    /* Used by the scale test for large apps/clusters */\n+    private static final int NUM_TOPICS_XL = 10;\n+    private static final int NUM_PARTITIONS_PER_TOPIC_XL = 1_000;\n+    private static final int NUM_CONSUMERS_XL = 100;\n+    private static final List<String> TOPICS_LIST_XL = new ArrayList<>();\n+    private static final Map<TopicPartition, Long> CHANGELOG_END_OFFSETS_XL = new HashMap<>();\n+    private static final List<PartitionInfo> PARTITION_INFOS_XL = getPartitionInfos(NUM_TOPICS_XL, NUM_PARTITIONS_PER_TOPIC_XL);\n+    private static final Cluster CLUSTER_METADATA_XL = new Cluster(\n+        \"cluster\",\n+        Collections.singletonList(Node.noNode()),\n+        PARTITION_INFOS_XL,\n+        emptySet(),\n+        emptySet()\n+    );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2NzgyNQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r444067825", "bodyText": "prop: Could you please move this method closer to where it is used, i.e., around line 200?", "author": "cadonna", "createdAt": "2020-06-23T08:53:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1953,6 +1975,54 @@ public void shouldRequestCommittedOffsetsForPreexistingSourceChangelogs() {\n         EasyMock.verify(consumerClient);\n     }\n \n+    @Test(timeout = 30 * 1000)\n+    public void shouldCompleteLargeAssignmentInAReasonableAmountOfTime() {\n+        builder.addSource(null, \"source\", null, null, null, TOPICS_LIST_XL.toArray(new String[0]));\n+        builder.addProcessor(\"processor\", new MockProcessorSupplier(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {\n+            subscriptions.put(\"consumer-\" + i,\n+                              new Subscription(\n+                                  TOPICS_LIST_XL,\n+                                  getInfo(uuidForInt(i), EMPTY_TASKS, EMPTY_TASKS).encode())\n+            );\n+        }\n+        createMockTaskManager(EMPTY_TASKS, EMPTY_TASKS);\n+        createMockAdminClient(CHANGELOG_END_OFFSETS_XL);\n+        configurePartitionAssignorWith(singletonMap(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 3));\n+\n+        final Map<String, Assignment> assignments =\n+            partitionAssignor.assign(CLUSTER_METADATA_XL, new GroupSubscription(subscriptions)).groupAssignment();\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {\n+            final String consumer = \"consumer-\" + i;\n+            final Assignment assignment = assignments.get(consumer);\n+            final AssignmentInfo info = AssignmentInfo.decode(assignment.userData());\n+\n+            subscriptions.put(\"consumer-\" + i,\n+                              new Subscription(\n+                                  TOPICS_LIST_XL,\n+                                  getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),\n+                                  assignment.partitions())\n+            );\n+        }\n+\n+        final Map<String, Assignment> secondAssignments =\n+            partitionAssignor.assign(CLUSTER_METADATA_XL, new GroupSubscription(subscriptions)).groupAssignment();\n+    }\n+\n+    private static List<PartitionInfo> getPartitionInfos(final int numTopics, final int numPartitionsPerTopic) {\n+        final List<PartitionInfo> partitionInfos = new ArrayList<>();\n+        for (int t = 1; t <= numTopics; ++t) { // topic numbering starts from 1\n+            for (int p = 0; p < numPartitionsPerTopic; ++p) {\n+                partitionInfos.add(new PartitionInfo(\"topic\" + t, p, Node.noNode(), new Node[0], new Node[0]));\n+            }\n+        }\n+        return  partitionInfos;\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTAzNA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r444075034", "bodyText": "req: Could you please remove variable secondAssignments since it is never used?", "author": "cadonna", "createdAt": "2020-06-23T09:04:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1953,6 +1975,54 @@ public void shouldRequestCommittedOffsetsForPreexistingSourceChangelogs() {\n         EasyMock.verify(consumerClient);\n     }\n \n+    @Test(timeout = 30 * 1000)\n+    public void shouldCompleteLargeAssignmentInAReasonableAmountOfTime() {\n+        builder.addSource(null, \"source\", null, null, null, TOPICS_LIST_XL.toArray(new String[0]));\n+        builder.addProcessor(\"processor\", new MockProcessorSupplier(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {\n+            subscriptions.put(\"consumer-\" + i,\n+                              new Subscription(\n+                                  TOPICS_LIST_XL,\n+                                  getInfo(uuidForInt(i), EMPTY_TASKS, EMPTY_TASKS).encode())\n+            );\n+        }\n+        createMockTaskManager(EMPTY_TASKS, EMPTY_TASKS);\n+        createMockAdminClient(CHANGELOG_END_OFFSETS_XL);\n+        configurePartitionAssignorWith(singletonMap(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 3));\n+\n+        final Map<String, Assignment> assignments =\n+            partitionAssignor.assign(CLUSTER_METADATA_XL, new GroupSubscription(subscriptions)).groupAssignment();\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {\n+            final String consumer = \"consumer-\" + i;\n+            final Assignment assignment = assignments.get(consumer);\n+            final AssignmentInfo info = AssignmentInfo.decode(assignment.userData());\n+\n+            subscriptions.put(\"consumer-\" + i,\n+                              new Subscription(\n+                                  TOPICS_LIST_XL,\n+                                  getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),\n+                                  assignment.partitions())\n+            );\n+        }\n+\n+        final Map<String, Assignment> secondAssignments =", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3Njk1OQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r444076959", "bodyText": "prop:\nsubscriptions.put(\"consumer10\", new Subscription(singletonList(\"topic1\"), defaultSubscriptionInfo.encode()));", "author": "cadonna", "createdAt": "2020-06-23T09:08:08Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1932,10 +1954,10 @@ public void shouldRequestCommittedOffsetsForPreexistingSourceChangelogs() {\n         streamsBuilder.table(\"topic1\", Materialized.as(\"store\"));\n \n         subscriptions.put(\"consumer10\",\n-            new Subscription(\n-                singletonList(\"topic1\"),\n-                defaultSubscriptionInfo.encode()\n-            ));\n+                          new Subscription(\n+                              singletonList(\"topic1\"),\n+                              defaultSubscriptionInfo.encode()\n+                          ));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4OTM3OQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r444089379", "bodyText": "Q: I am wondering if it would be better to extract the two assignments to two scale tests, so that when one fails we immediately know whether the startup assignment or the intermediate assignment is slow.", "author": "cadonna", "createdAt": "2020-06-23T09:28:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1953,6 +1975,54 @@ public void shouldRequestCommittedOffsetsForPreexistingSourceChangelogs() {\n         EasyMock.verify(consumerClient);\n     }\n \n+    @Test(timeout = 30 * 1000)\n+    public void shouldCompleteLargeAssignmentInAReasonableAmountOfTime() {\n+        builder.addSource(null, \"source\", null, null, null, TOPICS_LIST_XL.toArray(new String[0]));\n+        builder.addProcessor(\"processor\", new MockProcessorSupplier(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {\n+            subscriptions.put(\"consumer-\" + i,\n+                              new Subscription(\n+                                  TOPICS_LIST_XL,\n+                                  getInfo(uuidForInt(i), EMPTY_TASKS, EMPTY_TASKS).encode())\n+            );\n+        }\n+        createMockTaskManager(EMPTY_TASKS, EMPTY_TASKS);\n+        createMockAdminClient(CHANGELOG_END_OFFSETS_XL);\n+        configurePartitionAssignorWith(singletonMap(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 3));\n+\n+        final Map<String, Assignment> assignments =\n+            partitionAssignor.assign(CLUSTER_METADATA_XL, new GroupSubscription(subscriptions)).groupAssignment();\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int i = 0; i < NUM_CONSUMERS_XL; ++i) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NzI0Ng==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487867246", "bodyText": "nit: You could inline this call on line 122", "author": "cadonna", "createdAt": "2020-09-14T12:19:54Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    private final Class<? extends TaskAssignor> taskAssignor;\n+\n+    @Parameterized.Parameters(name = \"task assignor = {0}\")\n+    public static Collection<Object[]> parameters() {\n+        return asList(\n+            new Object[]{StickyTaskAssignor.class},\n+            new Object[]{HighAvailabilityTaskAssignor.class},\n+            new Object[]{FallbackPriorTaskAssignor.class}\n+        );\n+    }\n+\n+    public StreamsAssignmentScaleTest(final Class<? extends TaskAssignor> taskAssignor) {\n+        this.taskAssignor = taskAssignor;\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargePartitionCount() {\n+        shouldCompleteLargeAssignmentInReasonableTime(3_000, 1, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargeNumConsumers() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 1_000, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyStandbys() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 100, 1, 50);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyThreadsPerClient() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 10, 1000, 1);\n+    }\n+\n+    private void shouldCompleteLargeAssignmentInReasonableTime(final int numPartitions,\n+                                                               final int numClients,\n+                                                               final int numThreadsPerClient,\n+                                                               final int numStandbys) {\n+        final List<String> topic = singletonList(\"topic\");\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+        final List<PartitionInfo> partitionInfos = getPartitionInfos(numPartitions);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MjYwNQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487872605", "bodyText": "Since you use string \"consumer\" also in the second assignment and it is important that the consumers have the same name, I would suggest to specify I constant for it.", "author": "cadonna", "createdAt": "2020-09-14T12:28:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    private final Class<? extends TaskAssignor> taskAssignor;\n+\n+    @Parameterized.Parameters(name = \"task assignor = {0}\")\n+    public static Collection<Object[]> parameters() {\n+        return asList(\n+            new Object[]{StickyTaskAssignor.class},\n+            new Object[]{HighAvailabilityTaskAssignor.class},\n+            new Object[]{FallbackPriorTaskAssignor.class}\n+        );\n+    }\n+\n+    public StreamsAssignmentScaleTest(final Class<? extends TaskAssignor> taskAssignor) {\n+        this.taskAssignor = taskAssignor;\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargePartitionCount() {\n+        shouldCompleteLargeAssignmentInReasonableTime(3_000, 1, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargeNumConsumers() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 1_000, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyStandbys() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 100, 1, 50);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyThreadsPerClient() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 10, 1000, 1);\n+    }\n+\n+    private void shouldCompleteLargeAssignmentInReasonableTime(final int numPartitions,\n+                                                               final int numClients,\n+                                                               final int numThreadsPerClient,\n+                                                               final int numStandbys) {\n+        final List<String> topic = singletonList(\"topic\");\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+        final List<PartitionInfo> partitionInfos = getPartitionInfos(numPartitions);\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andReturn(builder).anyTimes();\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(\"consumer-\" + client + \"-\" + i,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MTA5NA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487881094", "bodyText": "Why is this not .andStubReturn() too? For consistency, I would also use .andStubReturn() here.", "author": "cadonna", "createdAt": "2020-09-14T12:42:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    private final Class<? extends TaskAssignor> taskAssignor;\n+\n+    @Parameterized.Parameters(name = \"task assignor = {0}\")\n+    public static Collection<Object[]> parameters() {\n+        return asList(\n+            new Object[]{StickyTaskAssignor.class},\n+            new Object[]{HighAvailabilityTaskAssignor.class},\n+            new Object[]{FallbackPriorTaskAssignor.class}\n+        );\n+    }\n+\n+    public StreamsAssignmentScaleTest(final Class<? extends TaskAssignor> taskAssignor) {\n+        this.taskAssignor = taskAssignor;\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargePartitionCount() {\n+        shouldCompleteLargeAssignmentInReasonableTime(3_000, 1, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargeNumConsumers() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 1_000, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyStandbys() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 100, 1, 50);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyThreadsPerClient() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 10, 1000, 1);\n+    }\n+\n+    private void shouldCompleteLargeAssignmentInReasonableTime(final int numPartitions,\n+                                                               final int numClients,\n+                                                               final int numThreadsPerClient,\n+                                                               final int numStandbys) {\n+        final List<String> topic = singletonList(\"topic\");\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+        final List<PartitionInfo> partitionInfos = getPartitionInfos(numPartitions);\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andReturn(builder).anyTimes();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2NzU5NA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r488267594", "bodyText": "I copied this over from StreamsPartitionAssignorTest, I'll fix it over there too", "author": "ableegoldman", "createdAt": "2020-09-14T22:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4Mjg3NA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487882874", "bodyText": "I guess there is a took too too much. ;-)", "author": "cadonna", "createdAt": "2020-09-14T12:45:37Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    private final Class<? extends TaskAssignor> taskAssignor;\n+\n+    @Parameterized.Parameters(name = \"task assignor = {0}\")\n+    public static Collection<Object[]> parameters() {\n+        return asList(\n+            new Object[]{StickyTaskAssignor.class},\n+            new Object[]{HighAvailabilityTaskAssignor.class},\n+            new Object[]{FallbackPriorTaskAssignor.class}\n+        );\n+    }\n+\n+    public StreamsAssignmentScaleTest(final Class<? extends TaskAssignor> taskAssignor) {\n+        this.taskAssignor = taskAssignor;\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargePartitionCount() {\n+        shouldCompleteLargeAssignmentInReasonableTime(3_000, 1, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargeNumConsumers() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 1_000, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyStandbys() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 100, 1, 50);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyThreadsPerClient() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 10, 1000, 1);\n+    }\n+\n+    private void shouldCompleteLargeAssignmentInReasonableTime(final int numPartitions,\n+                                                               final int numClients,\n+                                                               final int numThreadsPerClient,\n+                                                               final int numStandbys) {\n+        final List<String> topic = singletonList(\"topic\");\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+        final List<PartitionInfo> partitionInfos = getPartitionInfos(numPartitions);\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andReturn(builder).anyTimes();\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(\"consumer-\" + client + \"-\" + i,\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n+                );\n+            }\n+        }\n+\n+        final long firstAssignmentStartMs = System.currentTimeMillis();\n+        final Map<String, Assignment> firstAssignments = partitionAssignor.assign(clusterMetadata, new GroupSubscription(subscriptions)).groupAssignment();\n+        final long firstAssignmentEndMs = System.currentTimeMillis();\n+\n+        final long firstAssignmentDuration = firstAssignmentEndMs - firstAssignmentStartMs;\n+        if (firstAssignmentDuration > MAX_ASSIGNMENT_DURATION) {\n+            throw new AssertionError(\"The first assignment took took too long to complete at \" + firstAssignmentDuration + \"ms.\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzA3Ng==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487883076", "bodyText": "I guess here too too.", "author": "cadonna", "createdAt": "2020-09-14T12:45:57Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    private final Class<? extends TaskAssignor> taskAssignor;\n+\n+    @Parameterized.Parameters(name = \"task assignor = {0}\")\n+    public static Collection<Object[]> parameters() {\n+        return asList(\n+            new Object[]{StickyTaskAssignor.class},\n+            new Object[]{HighAvailabilityTaskAssignor.class},\n+            new Object[]{FallbackPriorTaskAssignor.class}\n+        );\n+    }\n+\n+    public StreamsAssignmentScaleTest(final Class<? extends TaskAssignor> taskAssignor) {\n+        this.taskAssignor = taskAssignor;\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargePartitionCount() {\n+        shouldCompleteLargeAssignmentInReasonableTime(3_000, 1, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testLargeNumConsumers() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 1_000, 1, 1);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyStandbys() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 100, 1, 50);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testManyThreadsPerClient() {\n+        shouldCompleteLargeAssignmentInReasonableTime(1_000, 10, 1000, 1);\n+    }\n+\n+    private void shouldCompleteLargeAssignmentInReasonableTime(final int numPartitions,\n+                                                               final int numClients,\n+                                                               final int numThreadsPerClient,\n+                                                               final int numStandbys) {\n+        final List<String> topic = singletonList(\"topic\");\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+        final List<PartitionInfo> partitionInfos = getPartitionInfos(numPartitions);\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andReturn(builder).anyTimes();\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(\"consumer-\" + client + \"-\" + i,\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n+                );\n+            }\n+        }\n+\n+        final long firstAssignmentStartMs = System.currentTimeMillis();\n+        final Map<String, Assignment> firstAssignments = partitionAssignor.assign(clusterMetadata, new GroupSubscription(subscriptions)).groupAssignment();\n+        final long firstAssignmentEndMs = System.currentTimeMillis();\n+\n+        final long firstAssignmentDuration = firstAssignmentEndMs - firstAssignmentStartMs;\n+        if (firstAssignmentDuration > MAX_ASSIGNMENT_DURATION) {\n+            throw new AssertionError(\"The first assignment took took too long to complete at \" + firstAssignmentDuration + \"ms.\");\n+        } else {\n+            log.info(\"First assignment took {}ms.\", firstAssignmentDuration);\n+        }\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                final String consumer = \"consumer-\" + client + \"-\" + i;\n+                final Assignment assignment = firstAssignments.get(consumer);\n+                final AssignmentInfo info = AssignmentInfo.decode(assignment.userData());\n+\n+                subscriptions.put(consumer,\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),\n+                                      assignment.partitions())\n+                );\n+            }\n+        }\n+\n+        final long secondAssignmentStartMs = System.currentTimeMillis();\n+        final Map<String, Assignment> secondAssignments = partitionAssignor.assign(clusterMetadata, new GroupSubscription(subscriptions)).groupAssignment();\n+        final long secondAssignmentEndMs = System.currentTimeMillis();\n+        final long secondAssignmentDuration = secondAssignmentEndMs - secondAssignmentStartMs;\n+        if (secondAssignmentDuration > MAX_ASSIGNMENT_DURATION) {\n+            throw new AssertionError(\"The second assignment took took too long to complete at \" + secondAssignmentDuration + \"ms.\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzA3MQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r487903071", "bodyText": "I do not remember exactly whether intergration tests are defined by running an embedded Kafka or tests that have a runtime beyond a certain threshold. If the latter, I guess, you should tag this class as an integration test.\nAlso, I run the test on my machine locally and I got two failures due to time outs for FallbackPriorTaskAssignor, namely for testManyStandbys() and testLargePartitionCount(). Admittedly, at that time my machine was under high load, but I guess that could also happen on Jenkins. Should we use lower parameter values?", "author": "cadonna", "createdAt": "2020-09-14T13:16:01Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(value = Parameterized.class)\n+public class StreamsAssignmentScaleTest {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzNjA2Nw==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r488236067", "bodyText": "Thanks, the extra data points on the runtime are helpful. We should definitely give it a wide margin to avoid flakiness on Jenkins", "author": "ableegoldman", "createdAt": "2020-09-14T21:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzA3MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEwMTM3Nw==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r490101377", "bodyText": "Code style suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            subscriptions.put(getConsumerName(i, client),\n          \n          \n            \n                                              new Subscription(\n          \n          \n            \n                                                  topic,\n          \n          \n            \n                                                  getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n          \n          \n            \n                            );\n          \n          \n            \n                            subscriptions.put(\n          \n          \n            \n                                getConsumerName(i, client),\n          \n          \n            \n                                new Subscription(topic, getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n          \n          \n            \n                            );", "author": "cadonna", "createdAt": "2020-09-17T09:25:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({IntegrationTest.class})\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    /************ HighAvailabilityTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(6_000, 1, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 50, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    /************ StickyTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, StickyTaskAssignor.class);\n+    }\n+\n+    /************ FallbackPriorTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    private void completeLargeAssignment(final int numPartitions,\n+                                         final int numClients,\n+                                         final int numThreadsPerClient,\n+                                         final int numStandbys,\n+                                         final Class<? extends TaskAssignor> taskAssignor) {\n+        final List<String> topic = singletonList(\"topic\");\n+\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+\n+        final List<PartitionInfo> partitionInfos = new ArrayList<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            partitionInfos.add(new PartitionInfo(\"topic\", p, Node.noNode(), new Node[0], new Node[0]));\n+        }\n+\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andStubReturn(builder);\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(getConsumerName(i, client),\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n+                );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEwMjMxOA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r490102318", "bodyText": "Code style suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            subscriptions.put(consumer,\n          \n          \n            \n                                              new Subscription(\n          \n          \n            \n                                                  topic,\n          \n          \n            \n                                                  getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),\n          \n          \n            \n                                                  assignment.partitions())\n          \n          \n            \n                            );\n          \n          \n            \n                            subscriptions.put(\n          \n          \n            \n                                consumer,\n          \n          \n            \n                                new Subscription(\n          \n          \n            \n                                    topic, \n          \n          \n            \n                                    getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(), \n          \n          \n            \n                                    assignment.partitions()\n          \n          \n            \n                                )\n          \n          \n            \n                            );", "author": "cadonna", "createdAt": "2020-09-17T09:26:51Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({IntegrationTest.class})\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    /************ HighAvailabilityTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(6_000, 1, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 50, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    /************ StickyTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, StickyTaskAssignor.class);\n+    }\n+\n+    /************ FallbackPriorTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    private void completeLargeAssignment(final int numPartitions,\n+                                         final int numClients,\n+                                         final int numThreadsPerClient,\n+                                         final int numStandbys,\n+                                         final Class<? extends TaskAssignor> taskAssignor) {\n+        final List<String> topic = singletonList(\"topic\");\n+\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+\n+        final List<PartitionInfo> partitionInfos = new ArrayList<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            partitionInfos.add(new PartitionInfo(\"topic\", p, Node.noNode(), new Node[0], new Node[0]));\n+        }\n+\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andStubReturn(builder);\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(getConsumerName(i, client),\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n+                );\n+            }\n+        }\n+\n+        final long firstAssignmentStartMs = System.currentTimeMillis();\n+        final Map<String, Assignment> firstAssignments = partitionAssignor.assign(clusterMetadata, new GroupSubscription(subscriptions)).groupAssignment();\n+        final long firstAssignmentEndMs = System.currentTimeMillis();\n+\n+        final long firstAssignmentDuration = firstAssignmentEndMs - firstAssignmentStartMs;\n+        if (firstAssignmentDuration > MAX_ASSIGNMENT_DURATION) {\n+            throw new AssertionError(\"The first assignment took too long to complete at \" + firstAssignmentDuration + \"ms.\");\n+        } else {\n+            log.info(\"First assignment took {}ms.\", firstAssignmentDuration);\n+        }\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                final String consumer = getConsumerName(i, client);\n+                final Assignment assignment = firstAssignments.get(consumer);\n+                final AssignmentInfo info = AssignmentInfo.decode(assignment.userData());\n+\n+                subscriptions.put(consumer,\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),\n+                                      assignment.partitions())\n+                );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExMDI2Nw==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r490110267", "bodyText": "I get this warning when I run this test:\nWARN Unable to assign 1 of 1 standby tasks for task [0_0]. There is not enough available capacity ...\n\nSince to get this warning, the code needs to break the loop in assignStandbyReplicaTasks(), I think you should either:\n\nset the stand-bys to 0, or\nset the clients to 2\n\nOption 1 would not run the code in the loop at all. Option 2 would run all code in the loop until all stand-bys are assigned. I would prefer option 2, since option 2 runs more code in the test which is better for scale testing.\nSimilar is true for the corresponding tests for the other assignors.\nIMPORTANT: Before you fix this, you should read my comment on line 234, otherwise setting the number of clients to 2 will not work as expected for the second assignment.", "author": "cadonna", "createdAt": "2020-09-17T09:40:02Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({IntegrationTest.class})\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    /************ HighAvailabilityTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(6_000, 1, 1, 1, HighAvailabilityTaskAssignor.class);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzMDY4MA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r490130680", "bodyText": "This should be uuidForInt(client), otherwise in the second assignment you have as many clients as stream threads and each client does only have one stream thread.", "author": "cadonna", "createdAt": "2020-09-17T10:14:00Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsAssignmentScaleTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.EMPTY_TASKS;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.createMockAdminClientForAssignor;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.getInfo;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.uuidForInt;\n+import static org.easymock.EasyMock.expect;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.GroupSubscription;\n+import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsConfig.InternalConfig;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo;\n+import org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.StickyTaskAssignor;\n+import org.apache.kafka.streams.processor.internals.assignment.TaskAssignor;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.MockApiProcessorSupplier;\n+import org.apache.kafka.test.MockClientSupplier;\n+import org.apache.kafka.test.MockInternalTopicManager;\n+import org.apache.kafka.test.MockKeyValueStoreBuilder;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({IntegrationTest.class})\n+public class StreamsAssignmentScaleTest {\n+    final static long MAX_ASSIGNMENT_DURATION = 60 * 1000L; //each individual assignment should complete within 20s\n+    final static String APPLICATION_ID = \"streams-assignment-scale-test\";\n+\n+    private final Logger log = LoggerFactory.getLogger(StreamsAssignmentScaleTest.class);\n+\n+    /************ HighAvailabilityTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(6_000, 1, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 50, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testHighAvailabilityTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, HighAvailabilityTaskAssignor.class);\n+    }\n+\n+    /************ StickyTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, StickyTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testStickyTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, StickyTaskAssignor.class);\n+    }\n+\n+    /************ FallbackPriorTaskAssignor tests ************/\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargePartitionCount() {\n+        completeLargeAssignment(2_000, 1, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorLargeNumConsumers() {\n+        completeLargeAssignment(1_000, 1_000, 1, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyStandbys() {\n+        completeLargeAssignment(1_000, 100, 1, 20, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    @Test(timeout = 120 * 1000)\n+    public void testFallbackPriorTaskAssignorManyThreadsPerClient() {\n+        completeLargeAssignment(1_000, 10, 1000, 1, FallbackPriorTaskAssignor.class);\n+    }\n+\n+    private void completeLargeAssignment(final int numPartitions,\n+                                         final int numClients,\n+                                         final int numThreadsPerClient,\n+                                         final int numStandbys,\n+                                         final Class<? extends TaskAssignor> taskAssignor) {\n+        final List<String> topic = singletonList(\"topic\");\n+\n+        final Map<TopicPartition, Long> changelogEndOffsets = new HashMap<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            changelogEndOffsets.put(new TopicPartition(APPLICATION_ID + \"-store-changelog\", p), 100_000L);\n+        }\n+\n+        final List<PartitionInfo> partitionInfos = new ArrayList<>();\n+        for (int p = 0; p < numPartitions; ++p) {\n+            partitionInfos.add(new PartitionInfo(\"topic\", p, Node.noNode(), new Node[0], new Node[0]));\n+        }\n+\n+        final Cluster clusterMetadata = new Cluster(\n+            \"cluster\",\n+            Collections.singletonList(Node.noNode()),\n+            partitionInfos,\n+            emptySet(),\n+            emptySet()\n+        );\n+\n+        final InternalTopologyBuilder builder = new InternalTopologyBuilder();\n+        builder.addSource(null, \"source\", null, null, null, \"topic\");\n+        builder.addProcessor(\"processor\", new MockApiProcessorSupplier<>(), \"source\");\n+        builder.addStateStore(new MockKeyValueStoreBuilder(\"store\", false), \"processor\");\n+        builder.setApplicationId(APPLICATION_ID);\n+        builder.buildTopology();\n+\n+        final Consumer<byte[], byte[]> mainConsumer = EasyMock.createNiceMock(Consumer.class);\n+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);\n+        expect(taskManager.builder()).andStubReturn(builder);\n+        expect(taskManager.mainConsumer()).andStubReturn(mainConsumer);\n+        expect(mainConsumer.committed(new HashSet<>())).andStubReturn(Collections.emptyMap());\n+        final AdminClient adminClient = createMockAdminClientForAssignor(changelogEndOffsets);\n+\n+        final StreamsPartitionAssignor partitionAssignor = new StreamsPartitionAssignor();\n+\n+        final Map<String, Object> configMap = new HashMap<>();\n+        configMap.put(StreamsConfig.APPLICATION_ID_CONFIG, APPLICATION_ID);\n+        configMap.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:8080\");\n+        configMap.put(InternalConfig.TASK_MANAGER_FOR_PARTITION_ASSIGNOR, taskManager);\n+        configMap.put(InternalConfig.STREAMS_METADATA_STATE_FOR_PARTITION_ASSIGNOR, EasyMock.createNiceMock(StreamsMetadataState.class));\n+        configMap.put(InternalConfig.STREAMS_ADMIN_CLIENT, adminClient);\n+        configMap.put(InternalConfig.ASSIGNMENT_ERROR_CODE, new AtomicInteger());\n+        configMap.put(InternalConfig.NEXT_SCHEDULED_REBALANCE_MS, new AtomicLong(Long.MAX_VALUE));\n+        configMap.put(InternalConfig.TIME, new MockTime());\n+        configMap.put(InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, taskAssignor.getName());\n+        configMap.put(StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, numStandbys);\n+\n+        final MockInternalTopicManager mockInternalTopicManager = new MockInternalTopicManager(\n+            new MockTime(),\n+            new StreamsConfig(configMap),\n+            new MockClientSupplier().restoreConsumer,\n+            false\n+        );\n+        partitionAssignor.configure(configMap);\n+        EasyMock.replay(taskManager, adminClient, mainConsumer);\n+\n+        partitionAssignor.setInternalTopicManager(mockInternalTopicManager);\n+\n+        final Map<String, Subscription> subscriptions = new HashMap<>();\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                subscriptions.put(getConsumerName(i, client),\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(client), EMPTY_TASKS, EMPTY_TASKS).encode())\n+                );\n+            }\n+        }\n+\n+        final long firstAssignmentStartMs = System.currentTimeMillis();\n+        final Map<String, Assignment> firstAssignments = partitionAssignor.assign(clusterMetadata, new GroupSubscription(subscriptions)).groupAssignment();\n+        final long firstAssignmentEndMs = System.currentTimeMillis();\n+\n+        final long firstAssignmentDuration = firstAssignmentEndMs - firstAssignmentStartMs;\n+        if (firstAssignmentDuration > MAX_ASSIGNMENT_DURATION) {\n+            throw new AssertionError(\"The first assignment took too long to complete at \" + firstAssignmentDuration + \"ms.\");\n+        } else {\n+            log.info(\"First assignment took {}ms.\", firstAssignmentDuration);\n+        }\n+\n+        // Use the assignment to generate the subscriptions' prev task data for the next rebalance\n+        for (int client = 0; client < numClients; ++client) {\n+            for (int i = 0; i < numThreadsPerClient; ++i) {\n+                final String consumer = getConsumerName(i, client);\n+                final Assignment assignment = firstAssignments.get(consumer);\n+                final AssignmentInfo info = AssignmentInfo.decode(assignment.userData());\n+\n+                subscriptions.put(consumer,\n+                                  new Subscription(\n+                                      topic,\n+                                      getInfo(uuidForInt(i), new HashSet<>(info.activeTasks()), info.standbyTasks().keySet()).encode(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA4NzE1Mw==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r491087153", "bodyText": "Whoops,  good catch thanks", "author": "ableegoldman", "createdAt": "2020-09-18T17:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzMDY4MA=="}], "type": "inlineReview"}, {"oid": "11c1dc09ab3f592d76ab1271a329598b316d0971", "url": "https://github.com/apache/kafka/commit/11c1dc09ab3f592d76ab1271a329598b316d0971", "message": "add scale test", "committedDate": "2020-09-18T23:08:31Z", "type": "commit"}, {"oid": "a123ebcdd69981ae7bab50377acd3dc44b1a73ba", "url": "https://github.com/apache/kafka/commit/a123ebcdd69981ae7bab50377acd3dc44b1a73ba", "message": "refactor, add several tests with different parameters", "committedDate": "2020-09-18T23:08:31Z", "type": "commit"}, {"oid": "8707e5392a38f3049c36fc3cd228b2a99b81ce89", "url": "https://github.com/apache/kafka/commit/8707e5392a38f3049c36fc3cd228b2a99b81ce89", "message": "stub consumer offset fetch", "committedDate": "2020-09-18T23:08:31Z", "type": "commit"}, {"oid": "f0d93598d50025b30abd5bfa8c92e99d317ecb09", "url": "https://github.com/apache/kafka/commit/f0d93598d50025b30abd5bfa8c92e99d317ecb09", "message": "review comments, un-parametrize the tests for individual limits", "committedDate": "2020-09-18T23:08:31Z", "type": "commit"}, {"oid": "4ae509cb9f216707f30f7766bbaeed19293090dc", "url": "https://github.com/apache/kafka/commit/4ae509cb9f216707f30f7766bbaeed19293090dc", "message": "fix checkstyle", "committedDate": "2020-09-18T23:08:31Z", "type": "commit"}, {"oid": "9ef7207d407aa8031f6ad85609764ae5794144c2", "url": "https://github.com/apache/kafka/commit/9ef7207d407aa8031f6ad85609764ae5794144c2", "message": "review comments", "committedDate": "2020-09-18T23:08:32Z", "type": "commit"}, {"oid": "9ef7207d407aa8031f6ad85609764ae5794144c2", "url": "https://github.com/apache/kafka/commit/9ef7207d407aa8031f6ad85609764ae5794144c2", "message": "review comments", "committedDate": "2020-09-18T23:08:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjUyMg==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492302522", "bodyText": "Huh, I thought we fixed this a while ago. Why it it showing up in the diff right now?", "author": "vvcephei", "createdAt": "2020-09-21T19:41:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ClientState.java", "diffHunk": "@@ -288,17 +288,17 @@ public void computeTaskLags(final UUID uuid, final Map<TaskId, Long> allTaskEndO\n             final Long endOffsetSum = taskEntry.getValue();\n             final Long offsetSum = taskOffsetSums.getOrDefault(task, 0L);\n \n-            if (endOffsetSum < offsetSum) {\n+            if (offsetSum == Task.LATEST_OFFSET) {\n+                taskLagTotals.put(task, Task.LATEST_OFFSET);\n+            } else if (offsetSum == UNKNOWN_OFFSET_SUM) {\n+                taskLagTotals.put(task, UNKNOWN_OFFSET_SUM);\n+            } else if (endOffsetSum < offsetSum) {", "originalCommit": "9ef7207d407aa8031f6ad85609764ae5794144c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzIyMw==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492383223", "bodyText": "I don't know about fixing this before, but I found this while debugging these tests and fixed it on the side in this PR. To be fair, it wasn't hurting anything since we happen to put the right thing in the taskLagTotals map, but the warning logged was definitely incorrect.", "author": "ableegoldman", "createdAt": "2020-09-21T22:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzk3OQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492303979", "bodyText": "Why remove this? Do we need to instantiate this class now? (I only see static members still).", "author": "vvcephei", "createdAt": "2020-09-21T19:43:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/AssignmentTestUtils.java", "diffHunk": "@@ -77,13 +86,8 @@\n     public static final TaskId TASK_2_3 = new TaskId(2, 3);\n \n     public static final Set<TaskId> EMPTY_TASKS = emptySet();\n-    public static final List<TaskId> EMPTY_TASK_LIST = emptyList();\n-    public static final Map<TaskId, Long> EMPTY_TASK_OFFSET_SUMS = emptyMap();\n     public static final Map<TopicPartition, Long> EMPTY_CHANGELOG_END_OFFSETS = new HashMap<>();\n \n-    private AssignmentTestUtils() {}", "originalCommit": "9ef7207d407aa8031f6ad85609764ae5794144c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MjMzMg==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492382332", "bodyText": "Do we need to instantiate this class now\n\nNo...isn't that exactly the reason we don't need this?", "author": "ableegoldman", "createdAt": "2020-09-21T22:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzNjY4MA==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492436680", "bodyText": "Ah, note the private. The purpose of this constructor is to make it uninstantiable. I.e., it's \"self-documenting\" that it should only be a container for static members.", "author": "vvcephei", "createdAt": "2020-09-22T01:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0NzA0MQ==", "url": "https://github.com/apache/kafka/pull/8892#discussion_r492447041", "bodyText": "Ah yeah ok. I'll put it back", "author": "ableegoldman", "createdAt": "2020-09-22T02:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzk3OQ=="}], "type": "inlineReview"}, {"oid": "fc9dd1efa9585a3ce8d3bed551632776c50cd1be", "url": "https://github.com/apache/kafka/commit/fc9dd1efa9585a3ce8d3bed551632776c50cd1be", "message": "private constructor", "committedDate": "2020-09-22T02:42:43Z", "type": "commit"}]}